include "MarshalledAccessors.i.dfy"

abstract module Union{{count}}Marshalling(
{%- for n in range(0,count) %}
  CaseMarshalling{{n}}: Marshalling,
{%- endfor %}
  TagInt: NativePackedInt)
refines Marshalling {

  import TGM = IntegerMarshalling(TagInt)

  datatype UnmarshalledType =
{%- for n in range(0,count) %}
    | Case{{n}}(c{{n}}: CaseMarshalling{{n}}.UnmarshalledType)
{%- endfor %}

  datatype Config = Config(
{%- for n in range(0,count) %}
    elemCfg{{n}}: CaseMarshalling{{n}}.Config,
{%- endfor %}
    tgmCfg: TGM.Config)

  predicate validConfig(cfg: Config)
  {
    && TGM.validConfig(cfg.tgmCfg)
{%- for n in range(0,count) %}
    && CaseMarshalling{{n}}.validConfig(cfg.elemCfg{{n}})
{%- endfor %}
  }

  function method getTagEnd(): uint64
  {
    TagInt.Size() as uint64
  }

  predicate parsable(cfg: Config, data: mseq<byte>)
  {
    var tagEnd := getTagEnd() as int;
    && |data| >= tagEnd
    && TGM.parsable(cfg.tgmCfg, data[..tagEnd])
    && var tag := TGM.parse(cfg.tgmCfg, data[..tagEnd]);
{%- for n in range(0,count) %}
    {%- if n == 0 %}
    (if tag == 0 then CaseMarshalling0.parsable(cfg.elemCfg0, data[tagEnd..])
    {% elif n != count - 1 -%}
      else if tag == {{n}} then CaseMarshalling{{n}}.parsable(cfg.elemCfg{{n}}, data[tagEnd..])
    {% else -%}
        else CaseMarshalling{{n}}.parsable(cfg.elemCfg{{n}}, data[tagEnd..]))
    {% endif %}
{%- endfor %}
  }

  function parse(cfg: Config, data: mseq<byte>) : UnmarshalledType
  {
    var tagEnd := getTagEnd() as int;
    var tag := TGM.parse(cfg.tgmCfg, data[..tagEnd]);

{%- for n in range(0,count) %}
    {%- if n == 0 %}
    if tag == 0 then Case0(CaseMarshalling0.parse(cfg.elemCfg{{n}}, data[tagEnd..]))
    {% elif n != count - 1 -%}
      else if tag == {{n}} then Case{{n}}(CaseMarshalling{{n}}.parse(cfg.elemCfg{{n}}, data[tagEnd..]))
    {% else -%}
        else Case{{n}}(CaseMarshalling{{n}}.parse(cfg.elemCfg{{n}}, data[tagEnd..]))
    {% endif %}
{%- endfor %}
  }

  method TryParse(cfg: Config, data: mseq<byte>) returns (ovalue: Option<UnmarshalledType>)
  {
    var tagEnd := getTagEnd();

    if tagEnd > |data| as uint64 {
      return None;
    }

    var tag :- TGM.TryParse(cfg.tgmCfg, data[..tagEnd]);
    ovalue := None;

{%- for n in range(0,count) %}
    {%- if n == 0 %}
    if tag == 0 {
      var value :- CaseMarshalling{{n}}.TryParse(cfg.elemCfg{{n}}, data[tagEnd..]);
      ovalue := Some(Case{{n}}(value));
    {% elif n != count - 1 -%}
    } else if tag == {{n}} {
      var value :- CaseMarshalling{{n}}.TryParse(cfg.elemCfg{{n}}, data[tagEnd..]);
      ovalue := Some(Case{{n}}(value));
    {% else -%}
    } else {
      var value :- CaseMarshalling{{n}}.TryParse(cfg.elemCfg{{n}}, data[tagEnd..]);
      ovalue := Some(Case{{n}}(value));
    }
    {% endif %}
{%- endfor %}
  }

  method Parsable(cfg: Config, data: mseq<byte>) returns (p: bool)
  {
    var tagEnd := getTagEnd();

    if tagEnd > |data| as uint64 {
      return false;
    }

    var tagOvalue := TGM.TryParse(cfg.tgmCfg, data[..tagEnd]);
    
    if tagOvalue.None? {
      return false;
    }

    var tag := TGM.Int.toUint64(tagOvalue.value);
    var parsable := false;

{%- for n in range(0,count) %}
    {%- if n == 0 %}
    if tag == 0 {
      parsable := CaseMarshalling0.Parsable(cfg.elemCfg{{n}}, data[tagEnd..]);
    {% elif n != count - 1 -%}
    } else if tag == {{n}} {
      parsable := CaseMarshalling{{n}}.Parsable(cfg.elemCfg{{n}}, data[tagEnd..]);
    {% else -%}
    } else {
      parsable := CaseMarshalling{{n}}.Parsable(cfg.elemCfg{{n}}, data[tagEnd..]);
    }
    {% endif %}
{%- endfor %}

    return parsable;
  }

  method Parse(cfg: Config, data: mseq<byte>) returns (value: UnmarshalledType)
  {
    var tagEnd := getTagEnd();
    var tag := TGM.Parse(cfg.tgmCfg, data[..tagEnd]);
{%- for n in range(0,count) %}
    {%- if n == 0 %}
    if tag == 0 {
      var result := CaseMarshalling{{n}}.Parse(cfg.elemCfg{{n}}, data[tagEnd..]);
      return Case0(result);
    {% elif n != count - 1 -%}
    } else if tag == {{n}} {
      var result := CaseMarshalling{{n}}.Parse(cfg.elemCfg{{n}}, data[tagEnd..]);
      return Case{{n}}(result);
    {% else -%}
    } else {
      var result := CaseMarshalling{{n}}.Parse(cfg.elemCfg{{n}}, data[tagEnd..]);
      return Case{{n}}(result);
    }
    {% endif %}
{%- endfor %}
  }

  predicate marshallable(cfg: Config,  value: UnmarshalledType)
  {
    && TagInt.MinValue() <= 0 < {{count-1}} < TagInt.UpperBound()
    && match value {
{%- for n in range(0,count) %}
      case Case{{n}}(c{{n}}) => 
        (&& CaseMarshalling{{n}}.marshallable(cfg.elemCfg{{n}}, c{{n}})
        && getTagEnd() as nat + CaseMarshalling{{n}}.size(cfg.elemCfg{{n}}, c{{n}}) as nat < Uint64UpperBound())
{%- endfor %}
    }
  }

  function size(cfg: Config, value: UnmarshalledType) : uint64
  {
    var tagEnd := getTagEnd();
    match value {
{%- for n in range(0,count) %}
      case Case{{n}}(c{{n}}) => getTagEnd() + CaseMarshalling{{n}}.size(cfg.elemCfg{{n}}, c{{n}})
{%- endfor %}
    }
  }

  method Size(cfg: Config, value: UnmarshalledType) returns (sz: uint64)
  {
    sz := getTagEnd();
    match value {
{%- for n in range(0,count) %}
      case Case{{n}}(c{{n}}) => {
        var size := CaseMarshalling{{n}}.Size(cfg.elemCfg{{n}}, c{{n}});
        sz := sz + size;
      }
{%- endfor %}
    }
    return sz;
  }

  method Marshall(cfg: Config, value: UnmarshalledType, linear inout data: mseq<byte>, start: uint64) returns (end: uint64)
  {
    ghost var tagEnd : uint64 := getTagEnd();

    match value
    {%- for n in range(0,count) %}
    case Case{{n}}(c{{n}}) => {
      end := TGM.Marshall(cfg.tgmCfg, {{n}}, inout data, start);
      ghost var newdata1 :seq<byte>, end1 := data, end;
      end := CaseMarshalling{{n}}.Marshall(cfg.elemCfg{{n}}, c{{n}}, inout data, end);

      assert newdata1[start..end1] == data[start..end1];
      assert data[start..end][..tagEnd] == data[start..end1];
    }
    {%- endfor %}
  }
}