include "MarshalledAccessors.i.dfy"
include "../Base/sequences.i.dfy"

abstract module Tuple{{count}}Marshalling(
{%- for n in range(0,count) %}
  ElemMarshalling{{n}} : Marshalling,
{%- endfor %}
  BoundaryInt: NativePackedInt)
  refines Marshalling {

  import Sequences
  import opened Mathematics

  import BSM = IntegerSeqMarshalling(BoundaryInt)

  type Boundary = BoundaryInt.Integer
  type BoundaryTable = mseq<Boundary>

  type UnmarshalledType = (
{%- for n in range(0,count) %}
    {%- if n != count - 1 -%}
        ElemMarshalling{{n}}.UnmarshalledType, 
    {% else -%}
        ElemMarshalling{{n}}.UnmarshalledType)
    {% endif %}
{%- endfor %}

  datatype Config = Config(
{%- for n in range(0,count) %}
    elemCfg{{n}} : ElemMarshalling{{0}}.Config, 
{%- endfor %}
    bsmCfg: BSM.Config)

  const eltCount := {{count}};

  predicate validConfig(cfg: Config)
  {
{%- for n in range(0,count) %}
    && ElemMarshalling{{n}}.validConfig(cfg.elemCfg{{n}})
{%- endfor %}
    && BSM.validConfig(cfg.bsmCfg)
  }

  function sizeOfTable(): nat
  {
    (eltCount - 1) as nat * BoundaryInt.Size() as nat
  }
  
  predicate sizeOfTableBounded()
  {
    sizeOfTable() < Uint64UpperBound()
  }

  function method SizeOfTable() : (size: uint64)
    requires sizeOfTableBounded()
    ensures size as nat == sizeOfTable()
  {
    (eltCount - 1) as uint64 * BoundaryInt.Size()
  }

  predicate tableParsable(bsmCfg: BSM.Config, data: mseq<byte>)
  {
    && sizeOfTableBounded()
    && sizeOfTable() <= |data|
  }

  function parseTable(bsmCfg: BSM.Config, data: mseq<byte>): (table : mseq<Boundary>)
    requires tableParsable(bsmCfg, data)
    ensures table == BoundaryInt.unpack_Seq(data[..sizeOfTable()], eltCount - 1)
  {
    var tableData := data[.. sizeOfTable()];
    var table: mseq<Boundary> := BSM.parse(bsmCfg, tableData);
    BSM.parse_is_unpack_Seq(bsmCfg, tableData);
    assert BSM.length(bsmCfg, tableData) == |tableData| / BoundaryInt.Size() as nat;
    MulDivCancel((eltCount - 1) as nat, BoundaryInt.Size() as nat);
    table
  }

  predicate parsable(cfg: Config, data: mseq<byte>)
  {
    && tableParsable(cfg.bsmCfg, data)
    && var table := parseTable(cfg.bsmCfg, data);
{% for n in range(0,count) %}
    {% if n == 0 -%}
    && var bound0 := table[0];
    && sizeOfTable() <= bound0 <= |data|
    && ElemMarshalling0.parsable(cfg.elemCfg{{n}}, data[sizeOfTable()..bound0])
    {% elif n != count-1 -%}
    && var bound{{n}} := table[{{n}}];
    && bound{{n-1}} <= bound{{n}} <= |data|
    && ElemMarshalling{{n}}.parsable(cfg.elemCfg{{n}}, data[bound{{n-1}}..bound{{n}}])
    {% else -%}
    && ElemMarshalling{{n}}.parsable(cfg.elemCfg{{n}}, data[bound{{n-1}}..])
    {%- endif -%}
{% endfor %}
  }

  function parse(cfg: Config, data: mseq<byte>) : UnmarshalledType
  {
    var tableSize := sizeOfTable();
    var table :mseq<Boundary> := BSM.parse(cfg.bsmCfg, data[..tableSize]);
{% for n in range(0,count) %}
    {% if n == 0 -%}
    var bound0 := table[0];
    var elem0 := ElemMarshalling0.parse(cfg.elemCfg{{n}}, data[tableSize..bound0]);
    {% elif n != count-1 -%}
    var bound{{n}} := table[{{n}}];
    var elem{{n}} := ElemMarshalling{{n}}.parse(cfg.elemCfg{{n}}, data[bound{{n-1}}..bound{{n}}]);
    {% else -%}
    var elem{{n}} := ElemMarshalling{{n}}.parse(cfg.elemCfg{{n}}, data[bound{{n-1}}..]);
    {% endif -%}
{% endfor %}
    (
{%- for n in range(0,count) -%}
    {%- if n != count - 1 -%}
      elem{{n}},
    {% else -%}
      elem{{n}})
    {%- endif %}
{%- endfor %}
  }

  method TryParse(cfg: Config, data: mseq<byte>) returns (ovalue: Option<UnmarshalledType>)
  {
    var tableSize := SizeOfTable();

    if tableSize > |data| as uint64 {
      return None;
    }

    var table :- BSM.TryParse(cfg.bsmCfg, data[..tableSize]);
    assert table == parseTable(cfg.bsmCfg, data);

{% for n in range(0,count-1) %}
    var bound{{n}} := BoundaryInt.toUint64(table[{{n}}]);
{%- endfor %}

{% for n in range(0,count-1) %}
    {%- if n == 0 %}
    if bound0 > |data| as uint64 || bound0 < tableSize {
      return None;
    }
    {%- else %}
    if bound{{n}} > |data| as uint64 || bound{{n}} < bound{{n-1}} {
      return None;
    }
    {% endif %}
{% endfor -%}

{% for n in range(0,count) %}
    {%- if n == 0 %}
    var value0 :- ElemMarshalling0.TryParse(cfg.elemCfg0, data[tableSize..bound0]);
    {%- elif n != count - 1 %}
    var value{{n}} :- ElemMarshalling0.TryParse(cfg.elemCfg{{n}}, data[bound{{n-1}}..bound{{n}}]);
    {% else -%}
    var value{{n}} :- ElemMarshalling0.TryParse(cfg.elemCfg{{n}}, data[bound{{n-1}}..]);
    {% endif %}
{%- endfor %}
    return Some((
    {%- for n in range(0,count) -%}
    {%- if n != count - 1 -%}
      value{{n}},
    {% else -%}
      value{{n}}));
    {%- endif %}
    {%- endfor %}
  }

  method Parsable(cfg: Config, data: mseq<byte>) returns (p: bool)
  {
    var tableSize := SizeOfTable();

    if tableSize > |data| as uint64 {
      return false;
    }

    var tableOpt := BSM.TryParse(cfg.bsmCfg, data[..tableSize]);
    
    if tableOpt.None? {
      return false;
    }

    var table :mseq<Boundary> := tableOpt.value;
    assert table == parseTable(cfg.bsmCfg, data);

{% for n in range(0,count-1) %}
    var bound{{n}} := BoundaryInt.toUint64(table[{{n}}]);
{%- endfor %}

{% for n in range(0,count-1) %}
    {%- if n == 0 %}
    if bound0 > |data| as uint64 || bound0 < tableSize {
      return false;
    }
    {%- else %}
    if bound{{n}} > |data| as uint64 || bound{{n}} < bound{{n-1}} {
      return false;
    }
    {% endif %}
{% endfor -%}

{% for n in range(0,count) %}
    {%- if n == 0 %}
    var elemParsable0 := ElemMarshalling0.Parsable(cfg.elemCfg0, data[tableSize..bound0]);
    {%- elif n != count - 1 %}
    var elemParsable{{n}} := ElemMarshalling{{n}}.Parsable(cfg.elemCfg{{n}}, data[bound{{n-1}}..bound{{n}}]);
    {%- else %}
    var elemParsable{{n}} := ElemMarshalling{{n}}.Parsable(cfg.elemCfg{{n}}, data[bound{{n-1}}..]);
    {% endif %}
{%- endfor %}
    if {%+ for n in range(0,count) -%}
      || !elemParsable{{n}}
    {% endfor -%} {
      return false;
    }

    return true;
  }

  method Parse(cfg: Config, data: mseq<byte>) returns (value: UnmarshalledType)
  {
    var tableSize := SizeOfTable();
    var table :mseq<Boundary> := BSM.Parse(cfg.bsmCfg, data[..tableSize]);
    assert table == parseTable(cfg.bsmCfg, data);
{% for n in range(0,count-1) %}
    var bound{{n}} := BoundaryInt.toUint64(table[{{n}}]);
{%- endfor %}
{% for n in range(0,count) %}
    {%- if n == 0 %}
    var elem0 := ElemMarshalling0.Parse(cfg.elemCfg0, data[tableSize..bound0]);
    {%- elif n != count - 1 %}
    var elem{{n}} := ElemMarshalling{{n}}.Parse(cfg.elemCfg{{n}}, data[bound{{n-1}}..bound{{n}}]);
    {%- else %}
    var elem{{n}} := ElemMarshalling{{n}}.Parse(cfg.elemCfg{{n}}, data[bound{{n-1}}..]);
    {% endif %}
{%- endfor %}
    return (
    {%- for n in range(0,count) -%}
    {%- if n != count - 1 -%}
      elem{{n}},
    {% else -%}
      elem{{n}});
    {%- endif %}
    {%- endfor %}
  }

  predicate marshallable(cfg: Config, value: UnmarshalledType)
  {
    && var ({%- for n in range(0,count) -%}
    {%- if n != count - 1 -%}
      elem{{n}},
    {%- else -%}
      elem{{n}}) := value;
    {%- endif %}
    {%- endfor %}
{%- for n in range(0,count) %}
    && ElemMarshalling{{n}}.marshallable(cfg.elemCfg{{n}}, elem{{n}})
{%- endfor %}
{% for n in range(0,count) %}
    {%- if n == 0 %}
    && var tableSize := sizeOfTable();
    var size0 := ElemMarshalling0.size(cfg.elemCfg{{n}}, elem0) as nat;
    var bound0 := tableSize + size0;
    {%- else %}
    var size{{n}} := ElemMarshalling{{n}}.size(cfg.elemCfg{{n}}, elem{{n}}) as nat;
    var bound{{n}} := bound{{n-1}} + size{{n}};
    {% endif %}
{%- endfor %}
{%- for n in range(0,count) %}
    && BoundaryInt.MinValue() <= bound{{n}} < BoundaryInt.UpperBound()
{%- endfor %}
    && var table :mseq<Boundary> := [
{%- for n in range(0,count-1) -%}
    {%- if n != count-2 -%}
      bound{{n}},
    {% else -%}
      bound{{n}}];
    {%- endif %}
{%- endfor %}
    && BSM.marshallable(cfg.bsmCfg, table)
  }

  function size(cfg: Config, value: UnmarshalledType) : uint64
  {
    var ({%- for n in range(0,count) -%}
    {%- if n != count - 1 -%}
      elem{{n}},
    {%- else -%}
      elem{{n}}) := value;
    {%- endif %}
    {%- endfor %}
    var tableSize := SizeOfTable();
{%- for n in range(0,count) %}
    var size{{n}} := ElemMarshalling{{n}}.size(cfg.elemCfg{{n}}, elem{{n}});
{%- endfor %}

    tableSize+{% for n in range(0,count) -%}
  {%- if n != count - 1 -%}
      size{{n}}+ 
  {%- else -%}
      size{{n}}
  {%- endif %}
{%- endfor %}
  }

  method Size(cfg: Config, value: UnmarshalledType) returns (sz: uint64)
  {
    var ({%- for n in range(0,count) -%}
    {%- if n != count - 1 -%}
      elem{{n}},
    {%- else -%}
      elem{{n}}) := value;
    {%- endif %}
    {%- endfor %}
    var tableSize := SizeOfTable();
{%- for n in range(0,count) %}
    var size{{n}} := ElemMarshalling{{n}}.Size(cfg.elemCfg{{n}}, elem{{n}});
{%- endfor %}

    sz := tableSize+{% for n in range(0,count) -%}
  {%- if n != count - 1 -%}
      size{{n}}+ 
  {%- else -%}
      size{{n}};
  {%- endif %}
{%- endfor %}
  }

  method Marshall(cfg: Config, value: UnmarshalledType, linear inout data: mseq<byte>, start: uint64)
    returns (end: uint64)
  {
    var ({%- for n in range(0,count) -%}
    {%- if n != count - 1 -%}
      elem{{n}},
    {%- else -%}
      elem{{n}}) := value;
    {%- endif %}
    {%- endfor %}
{% for n in range(0,count-1) %}
    {%- if n == 0 %}
    var tableSize := SizeOfTable();
    var size0 := ElemMarshalling0.Size(cfg.elemCfg{{n}}, elem0);
    var bound0 := tableSize + size0;
    {%- else %}
    var size{{n}} := ElemMarshalling{{n}}.Size(cfg.elemCfg{{n}}, elem{{n}});
    var bound{{n}} := bound{{n-1}} + size{{n}};
    {% endif %}
{%- endfor %}
    var table :mseq<Boundary> := [
{%- for n in range(0,count-1) -%}
    {%- if n != count-2 -%}
      bound{{n}} as BoundaryInt.Integer,
    {% else -%}
      bound{{n}} as BoundaryInt.Integer];
    {%- endif %}
{%- endfor %}

    {% for n in range(0,count+1) -%}
    {% if n == 0 -%}
    end := BSM.Marshall(cfg.bsmCfg, table, inout data, start);
    ghost var newdata0 :seq<byte>, end0 := data, end;
    {% elif n != count -%}
    end := ElemMarshalling{{n-1}}.Marshall(cfg.elemCfg{{n-1}}, elem{{n-1}}, inout data, end);
    ghost var newdata{{n}} :seq<byte>, end{{n}} := data, end;
    {% else -%}
    end := ElemMarshalling{{n-1}}.Marshall(cfg.elemCfg{{n-1}}, elem{{n-1}}, inout data, end);
    {%- endif %}
{%- endfor %}

    assert data[start..end][..tableSize] == data[start..end0] == newdata0[start..end0];
    // assert BSM.parse(newdata[start..end0]) == table;
    
    assert data[start..end][tableSize..bound0] == data[end0..end1] == newdata1[end0..end1] by {
      Sequences.lemma_seq_slice_slice(data, start as int, end as int, tableSize as int, bound0 as int);
    }
    // assert ElemMarshalling0.parse(data[end0..end1]) == elem0;

{% for n in range(1,count-1) %}
    assert data[start..end][bound{{n-1}}..bound{{n}}] == data[end{{n}}..end{{n+1}}] == newdata{{n+1}}[end{{n}}..end{{n+1}}] by {
      Sequences.lemma_seq_slice_slice(data, start as int, end as int, bound{{n-1}} as int, bound{{n}} as int);
    }
    // assert ElemMarshalling{{n}}.parse(data[end{{n}}..end{{n+1}}]) == elem{{n}};
{%- endfor %}

    assert data[start..end][bound{{count-2}}..] == data[end{{count-1}}..end];
    // assert ElemMarshalling{{count-1}}.parse(data[end{{count-1}}..end]) == elem{{count-1}};
  }

  predicate boundGettable(cfg: Config, data: mseq<byte>, index: nat)
  {
    && validConfig(cfg)
    && index <= eltCount - 1

    && var tableSize := sizeOfTable();
    && tableSize <= |data|
    && var tableData := data[..tableSize];

    && (index != eltCount - 1 ==> BSM.gettable(cfg.bsmCfg, tableData, index))
    && (index != 0 ==> BSM.gettable(cfg.bsmCfg, tableData, index-1))
  }

  function getBounds(cfg: Config, data: mseq<byte>, index: nat) :(int, int)
    requires boundGettable(cfg, data, index)
  {
    var tableData := data[..sizeOfTable()];
    var start := if index == 0 then sizeOfTable() else BSM.getElt(cfg.bsmCfg, tableData, index - 1);
    var end := if index == eltCount-1 then |data| else BSM.getElt(cfg.bsmCfg, tableData, index);
    (start, end)
  }  

  predicate gettable(cfg: Config, data: mseq<byte>, index: nat)
  {
    && boundGettable(cfg, data, index)
    && var (start, end) := getBounds(cfg, data, index);
    && 0 <= start <= end <= |data|
  }

  method Gettable(cfg: Config, data: mseq<byte>, index: uint64)
    returns (g: bool)
    requires validConfig(cfg)
    requires index as nat < eltCount
    ensures g == gettable(cfg, data, index as nat)
  {
    var tableSize := SizeOfTable();
  
    if tableSize > |data| as uint64 {
      return false;
    }
    
    var tableData := data[..tableSize];

    if index != eltCount as uint64 - 1 {
      var startGettable := BSM.Gettable(cfg.bsmCfg, tableData, index);
      if !startGettable { return false; }
    }

    if index != 0 {
      var endGettable := BSM.Gettable(cfg.bsmCfg, tableData, index-1);
      if !endGettable { return false; }
    }

    var start := tableSize;

    if index != 0 {
      var istart := BSM.GetElt(cfg.bsmCfg, tableData, index - 1);
      start := BoundaryInt.toUint64(istart);
    }

    var end := |data| as uint64;

    if index != eltCount as uint64 - 1 {
      var iend := BSM.GetElt(cfg.bsmCfg, tableData, index);
      end := BoundaryInt.toUint64(iend);
    }

    g := 0 <= start <= end <= |data| as uint64;
  }

{% for n in range(0,count) %}
  method GetElem{{n}}(cfg: Config, data: mseq<byte>) returns (eslice: Slice)
    requires gettable(cfg, data, {{n}})

    ensures eslice.WF'(data)
    ensures parsable(cfg, data) ==> ElemMarshalling{{n}}.parsable(cfg.elemCfg{{n}}, eslice.I(data))
    ensures parsable(cfg, data) ==> parse(cfg, data).{{n}} == ElemMarshalling{{n}}.parse(cfg.elemCfg{{n}}, eslice.I(data))    
  {
    var tableSize := SizeOfTable();
  {% if n == 0 %}
    var bound0 := BSM.GetElt(cfg.bsmCfg, data[..tableSize], 0);
    eslice := Slice(tableSize, BoundaryInt.toUint64(bound0));
  }
  {% elif n != count-1 %}
    var bound{{n-1}} := BSM.GetElt(cfg.bsmCfg, data[..tableSize], {{n-1}});
    var bound{{n}} := BSM.GetElt(cfg.bsmCfg, data[..tableSize], {{n}});
    eslice := Slice(BoundaryInt.toUint64(bound{{n-1}}), BoundaryInt.toUint64(bound{{n}}));
    assert eslice.I(data) == data[bound{{n-1}}..bound{{n}}];
  }
  {% else %}
    var bound{{n-1}} := BSM.GetElt(cfg.bsmCfg, data[..tableSize], {{n-1}});
    eslice := Slice(BoundaryInt.toUint64(bound{{n-1}}), |data| as uint64);
    assert eslice.I(data) == data[bound{{n-1}}..];
  }
  {% endif -%}
{%- endfor %}

}