#![feature(prelude_import)]

#![allow(internal_features)]
#![feature(stmt_expr_attributes)]
#![feature(box_patterns)]
#![feature(negative_impls)]
#![feature(rustc_attrs)]
#![feature(unboxed_closures)]
#![feature(register_tool)]
#![feature(tuple_trait)]
#![feature(custom_inner_attributes)]
#![feature(try_trait_v2)]
#![register_tool(verus)]
#![register_tool(verifier)]
#[prelude_import]
use std::prelude::rust_2018::*;
#[macro_use]
extern crate std;
mod spec {
    pub mod Option_t {
        #[allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        #[verus::internal(verus_macro)]
        pub enum Option<T> { None, Some(T), }
        #[verus::internal(verus_macro)]
        #[cfg(verus_keep_ghost)]
        #[automatically_derived]
        impl<T> Option<T> {
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_None(&self) -> bool {
                ::builtin::is_variant(self, "None")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_Some(&self) -> bool {
                ::builtin::is_variant(self, "Some")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_Some_0(self) -> T {
                ::builtin::get_variant_field(self, "Some", "0")
            }
        }
    }
    pub mod FloatingSeq_t {
        use builtin_macros::*;
        use builtin::*;
        use vstd::{*, seq::*};
        use crate::spec::MapSpec_t::Version;
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct FloatingSeq<T> {
            pub start: nat,
            pub entries: Seq<T>,
        }
        #[verus::internal(verus_macro)]
        impl<T> FloatingSeq<T> {
            #[doc =
            " Returns a new FloatingSeq with active indices in the range [start, length). The entries"]
            #[doc =
            " in the active indices are populated using a caller-provided lambda, which should map"]
            #[doc =
            " active indices to the element that should populate that index."]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn new(start: nat, length: nat,
                f: ::builtin::FnSpec<(int,), T>) -> FloatingSeq<T> {
                ::builtin::recommends([(start).spec_le(length)]);
                FloatingSeq {
                    start: start,
                    entries: Seq::new(::builtin::spec_cast_integer::<_,
                                nat>(((length).spec_sub(start))),
                        ::builtin::closure_to_fn_spec(|i: int|
                                f((i).spec_add(start)))),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn len(self) -> int {
                (::builtin::spec_cast_integer::<_,
                                int>(self.start)).spec_add(self.entries.len())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn first_active_index(self) -> int {
                ::builtin::spec_cast_integer::<_, int>(self.start)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_active(self, i: int) -> bool {
                ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(self.start),
                            i), self.len()))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn get(self, i: int) -> T {
                ::builtin::recommends([self.is_active(i)]);
                self.entries.spec_index((i).spec_sub(::builtin::spec_cast_integer::<_,
                                int>(self.start)))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn spec_index(self, i: int) -> T {
                ::builtin::recommends([self.is_active(i)]);
                self.entries.spec_index((i).spec_sub(self.start))
            }
            #[doc =
            " Return a FloatingSeq containing the elements of this seq in the range"]
            #[doc =
            " [start, end_idx). (Note however for all FloatingSeq\'s we interpret all the"]
            #[doc =
            " empty indices [0, start) as \"occupied\"; they just represent forgotten"]
            #[doc = " values)."]
            #[doc =
            " i.e.: chop off all elements at index end_idx and beyond. (end_idx is"]
            #[doc =
            " in the \"absolute space\", FloatingSeq handles translation)."]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn get_prefix(self, end_idx: int) -> FloatingSeq<T> {
                ::builtin::recommends([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        end_idx), self.len()))]);
                if (end_idx).spec_le(self.start) {
                        FloatingSeq {
                            start: ::builtin::spec_cast_integer::<_, nat>(end_idx),
                            entries: ::vstd::seq::Seq::empty(),
                        }
                    } else {
                       FloatingSeq {
                           start: self.start,
                           entries: self.entries.subrange(::builtin::spec_literal_integer("0"),
                               (end_idx).spec_sub(self.start)),
                       }
                   }
            }
            #[doc =
            " Return a FloatingSeq containing the elements of this FloatingSeq in the range"]
            #[doc = " [newStart, self.len())."]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn get_suffix(self, newStart: int) -> FloatingSeq<T> {
                ::builtin::recommends([self.is_active(newStart) ||
                                ::builtin::spec_eq(newStart, self.len())]);
                FloatingSeq {
                    start: ::builtin::spec_cast_integer::<_, nat>(newStart),
                    entries: self.entries.subrange((newStart).spec_sub(self.start),
                        ::builtin::spec_cast_integer::<_, int>(self.entries.len())),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn append(self, elts: Seq<T>) -> FloatingSeq<T> {
                FloatingSeq {
                    start: self.start,
                    entries: (self.entries).spec_add(elts),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn last(self) -> T {
                ::builtin::recommends([(self.len()).spec_gt(::builtin::spec_literal_nat("0")),
                            self.is_active((self.len()).spec_sub(::builtin::spec_literal_nat("1")))]);
                self.spec_index((self.len()).spec_sub(::builtin::spec_literal_nat("1")))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn drop_last(self) -> FloatingSeq<T> {
                ::builtin::recommends([(self.len()).spec_gt(::builtin::spec_literal_nat("0"))]);
                self.get_prefix((self.len()).spec_sub(::builtin::spec_literal_nat("1")))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn extensionality(self, b: FloatingSeq<T>) {
                ::builtin::requires([::builtin::spec_eq(self.start, b.start),
                            ::builtin::spec_eq(self.len(), b.len()),
                            ::builtin::forall(|i|
                                    ::builtin::imply(self.is_active(i),
                                        ::builtin::spec_eq(self.spec_index(i), b.spec_index(i))))]);
                ::builtin::ensures([::builtin::spec_eq(self, b)]);
                {
                    ::builtin::assert_forall_by(|i|
                            {
                                ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                i), self.entries.len())));
                                ::builtin::ensures(::builtin::equal(self.entries.spec_index(i),
                                        b.entries.spec_index(i)));
                                ::builtin::assert_(::builtin::equal(b.spec_index(((self.start).spec_add(i))),
                                        b.entries.spec_index(i)));
                            });
                }
                ::builtin::assert_(::builtin::ext_equal(self.entries,
                        (b.entries)));
            }
        }
        #[verus::internal(verus_macro)]
        impl FloatingSeq<Version> {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn ext_equal(self, other: FloatingSeq<Version>) -> bool {
                ((::builtin::spec_eq(self.start, other.start)) &&
                            (::builtin::spec_eq(self.len(), other.len()))) &&
                    (::builtin::forall(|i|
                                ::builtin::imply(self.is_active(i),
                                    #[verus::internal(trigger)] self.spec_index(i).ext_equal(other.spec_index(i)))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn ext_equal_is_equality() {
                ::builtin::ensures([::builtin::forall(|a:
                                        FloatingSeq<Version>, b: FloatingSeq<Version>|
                                    ::builtin::spec_eq(a.ext_equal(b),
                                        (::builtin::spec_eq(a, b))))]);
                Version::ext_equal_is_equality();
                {
                    ::builtin::assert_forall_by(|s1: FloatingSeq<Version>,
                            s2: FloatingSeq<Version>|
                            {
                                ::builtin::requires(s1.ext_equal(s2));
                                ::builtin::ensures((::builtin::spec_eq(s1, s2)));
                                ::builtin::assert_(::builtin::forall(|i|
                                            ::builtin::imply(#[verus::internal(trigger)] s1.is_active(i),
                                                s1.spec_index(i).ext_equal(s2.spec_index(i)))));
                                s1.extensionality(s2);
                            });
                }
            }
        }
    }
    pub mod MapSpec_t {
        use builtin_macros::*;
        use builtin::*;
        use vstd::{*, map::*, set::*};
        use crate::spec::KeyType_t::*;
        use crate::spec::Messages_t::*;
        use crate::spec::FloatingSeq_t::*;
        use crate::spec::TotalKMMap_t::*;
        use state_machines_macros::state_machine;
        #[doc =
        " An Input represents a possible action that can be taken on an abstract"]
        #[doc =
        " MapSpec (i.e.: abstract key-value store), and contains the relevant"]
        #[doc = " arguments for performing that operation."]
        #[verus::internal(verus_macro)]
        pub enum Input {
            QueryInput {
                key: Key,
            },
            PutInput {
                key: Key,
                value: Value,
            },
            NoopInput,
        }
        #[verus::internal(verus_macro)]
        #[cfg(verus_keep_ghost)]
        #[automatically_derived]
        impl Input {
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_QueryInput(&self) -> bool {
                ::builtin::is_variant(self, "QueryInput")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_QueryInput_key(self) -> Key {
                ::builtin::get_variant_field(self, "QueryInput", "key")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_PutInput(&self) -> bool {
                ::builtin::is_variant(self, "PutInput")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_PutInput_key(self) -> Key {
                ::builtin::get_variant_field(self, "PutInput", "key")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_PutInput_value(self) -> Value {
                ::builtin::get_variant_field(self, "PutInput", "value")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_NoopInput(&self) -> bool {
                ::builtin::is_variant(self, "NoopInput")
            }
        }
        #[doc =
        " An Output represents the result from taking an Input action (and contains"]
        #[doc =
        " any relevant return arguments from performing the corresponding action)."]
        #[verus::internal(verus_macro)]
        pub enum Output {
            QueryOutput {
                value: Value,
            },
            PutOutput,
            NoopOutput,
        }
        #[verus::internal(verus_macro)]
        #[cfg(verus_keep_ghost)]
        #[automatically_derived]
        impl Output {
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_QueryOutput(&self) -> bool {
                ::builtin::is_variant(self, "QueryOutput")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_QueryOutput_value(self) -> Value {
                ::builtin::get_variant_field(self, "QueryOutput", "value")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_PutOutput(&self) -> bool {
                ::builtin::is_variant(self, "PutOutput")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_NoopOutput(&self) -> bool {
                ::builtin::is_variant(self, "NoopOutput")
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn my_init() -> MapSpec::State {
            MapSpec::State { kmmap: TotalKMMap::empty() }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn getInput(label: MapSpec::Label) -> Input {
            match label {
                MapSpec::Label::Query { input, output } => input,
                MapSpec::Label::Put { input, output } => input,
                MapSpec::Label::Noop { input, output } => input,
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn getOutput(label: MapSpec::Label) -> Output {
            match label {
                MapSpec::Label::Query { input, output } => output,
                MapSpec::Label::Put { input, output } => output,
                MapSpec::Label::Noop { input, output } => output,
            }
        }
        #[allow(unused_parens)]
        pub mod MapSpec {
            use super::*;
            #[verus::internal(verus_macro)]
            pub struct State {
                pub kmmap: TotalKMMap,
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Step {
                query(),
                put(),
                noop(),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Step {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_query(&self) -> bool {
                    ::builtin::is_variant(self, "query")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_put(&self) -> bool {
                    ::builtin::is_variant(self, "put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_noop(&self) -> bool {
                    ::builtin::is_variant(self, "noop")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Config { my_init_2(), dummy_to_use_type_params(State), }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Config {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_my_init_2(&self) -> bool {
                    ::builtin::is_variant(self, "my_init_2")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[verus::internal(verus_macro)]
            pub enum Label {
                Query {
                    input: Input,
                    output: Output,
                },
                Put {
                    input: Input,
                    output: Output,
                },
                Noop {
                    input: Input,
                    output: Output,
                },
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Label {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_Query(&self) -> bool {
                    ::builtin::is_variant(self, "Query")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_Query_input(self) -> Input {
                    ::builtin::get_variant_field(self, "Query", "input")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_Query_output(self) -> Output {
                    ::builtin::get_variant_field(self, "Query", "output")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_Put(&self) -> bool {
                    ::builtin::is_variant(self, "Put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_Put_input(self) -> Input {
                    ::builtin::get_variant_field(self, "Put", "input")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_Put_output(self) -> Output {
                    ::builtin::get_variant_field(self, "Put", "output")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_Noop(&self) -> bool {
                    ::builtin::is_variant(self, "Noop")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_Noop_input(self) -> Input {
                    ::builtin::get_variant_field(self, "Noop", "input")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_Noop_output(self) -> Output {
                    ::builtin::get_variant_field(self, "Noop", "output")
                }
            }
            pub mod show {
                use super::*;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn query(pre: super::State, post: super::State,
                    label: Label) {
                    ::builtin::requires(super::State::query(pre, post, label));
                    ::builtin::ensures(super::State::next(pre, post, label));
                }
                use bool as query;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn put(pre: super::State, post: super::State,
                    label: Label) {
                    ::builtin::requires(super::State::put(pre, post, label));
                    ::builtin::ensures(super::State::next(pre, post, label));
                }
                use bool as put;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn noop(pre: super::State, post: super::State,
                    label: Label) {
                    ::builtin::requires(super::State::noop(pre, post, label));
                    ::builtin::ensures(super::State::next(pre, post, label));
                }
                use bool as noop;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn my_init_2(post: super::State) {
                    ::builtin::requires(super::State::my_init_2(post));
                    ::builtin::ensures(super::State::init(post));
                }
                use bool as my_init_2;
            }
            pub mod take_step {
                use super::*;
            }
            #[verus::internal(verus_macro)]
            impl State {
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn my_init_2(post: Self) -> ::core::primitive::bool {
                    {
                        let update_tmp_kmmap: TotalKMMap = my_init().kmmap;

                        #[verifier::custom_err("cannot prove that final value of field `kmmap` has this updated value")]
                        (::builtin::equal(post.kmmap, update_tmp_kmmap))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn my_init_2_enabled() -> ::core::primitive::bool {
                    { true }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query(pre: Self, post: Self, label: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_kmmap: TotalKMMap = pre.kmmap;
                        (({
                                        let tmp_for_match_0 = label;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Query { input, output } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let (input, output) =
                                                        match tmp_for_match_0 {
                                                            Label::Query { input, output } => (input, output),
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    let tmp_for_match_1 = input;
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_1
                                                                    {
                                                                    Input::QueryInput { key } => true,
                                                                    _ => false,
                                                                }) &&
                                                            {
                                                                let key =
                                                                    match tmp_for_match_1 {
                                                                        Input::QueryInput { key } => key,
                                                                        _ => ::vstd::pervasive::arbitrary(),
                                                                    };
                                                                let tmp_for_match_2 = output;
                                                                (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_2
                                                                                {
                                                                                Output::QueryOutput { value } => true,
                                                                                _ => false,
                                                                            }) &&
                                                                        {
                                                                            let value =
                                                                                match tmp_for_match_2 {
                                                                                    Output::QueryOutput { value } => value,
                                                                                    _ => ::vstd::pervasive::arbitrary(),
                                                                                };

                                                                            #[verifier::custom_err("cannot prove this condition holds")]
                                                                            (::builtin::spec_eq(pre.kmmap.spec_index(key).get_Define_value(),
                                                                                    value))
                                                                        })
                                                            })
                                                })
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `kmmap` is preserved")] (::builtin::equal(post.kmmap,
                                            update_tmp_kmmap))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_strong(pre: Self, post: Self, label: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_kmmap: TotalKMMap = pre.kmmap;
                        (({
                                        let tmp_for_match_0 = label;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Query { input, output } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let (input, output) =
                                                        match tmp_for_match_0 {
                                                            Label::Query { input, output } => (input, output),
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    let tmp_for_match_1 = input;
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_1
                                                                    {
                                                                    Input::QueryInput { key } => true,
                                                                    _ => false,
                                                                }) &&
                                                            {
                                                                let key =
                                                                    match tmp_for_match_1 {
                                                                        Input::QueryInput { key } => key,
                                                                        _ => ::vstd::pervasive::arbitrary(),
                                                                    };
                                                                let tmp_for_match_2 = output;
                                                                (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_2
                                                                                {
                                                                                Output::QueryOutput { value } => true,
                                                                                _ => false,
                                                                            }) &&
                                                                        {
                                                                            let value =
                                                                                match tmp_for_match_2 {
                                                                                    Output::QueryOutput { value } => value,
                                                                                    _ => ::vstd::pervasive::arbitrary(),
                                                                                };

                                                                            #[verifier::custom_err("cannot prove this condition holds")]
                                                                            (::builtin::spec_eq(pre.kmmap.spec_index(key).get_Define_value(),
                                                                                    value))
                                                                        })
                                                            })
                                                })
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `kmmap` is preserved")] (::builtin::equal(post.kmmap,
                                            update_tmp_kmmap))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_enabled(pre: Self, label: Label)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = label;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Query { input, output } => true,
                                        _ => false,
                                    }) &&
                                {
                                    let (input, output) =
                                        match tmp_for_match_0 {
                                            Label::Query { input, output } => (input, output),
                                            _ => ::vstd::pervasive::arbitrary(),
                                        };
                                    let tmp_for_match_1 = input;
                                    (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_1
                                                    {
                                                    Input::QueryInput { key } => true,
                                                    _ => false,
                                                }) &&
                                            {
                                                let key =
                                                    match tmp_for_match_1 {
                                                        Input::QueryInput { key } => key,
                                                        _ => ::vstd::pervasive::arbitrary(),
                                                    };
                                                let tmp_for_match_2 = output;
                                                (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_2
                                                                {
                                                                Output::QueryOutput { value } => true,
                                                                _ => false,
                                                            }) &&
                                                        {
                                                            let value =
                                                                match tmp_for_match_2 {
                                                                    Output::QueryOutput { value } => value,
                                                                    _ => ::vstd::pervasive::arbitrary(),
                                                                };

                                                            #[verifier::custom_err("cannot prove this condition holds")]
                                                            (::builtin::spec_eq(pre.kmmap.spec_index(key).get_Define_value(),
                                                                    value))
                                                        })
                                            })
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put(pre: Self, post: Self, label: Label)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = label;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Put { input, output } => true,
                                        _ => false,
                                    }) &&
                                {
                                    let (input, output) =
                                        match tmp_for_match_0 {
                                            Label::Put { input, output } => (input, output),
                                            _ => ::vstd::pervasive::arbitrary(),
                                        };
                                    let tmp_for_match_1 = input;
                                    (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_1
                                                    {
                                                    Input::PutInput { key, value } => true,
                                                    _ => false,
                                                }) &&
                                            {
                                                let (key, value) =
                                                    match tmp_for_match_1 {
                                                        Input::PutInput { key, value } => (key, value),
                                                        _ => ::vstd::pervasive::arbitrary(),
                                                    };
                                                let tmp_for_match_2 = output;
                                                (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_2
                                                                {
                                                                Output::PutOutput => true,
                                                                _ => false,
                                                            }) &&
                                                        {
                                                            let update_tmp_kmmap: TotalKMMap =
                                                                pre.kmmap.insert(key, Message::Define { value });

                                                            #[verifier::custom_err("cannot prove that final value of field `kmmap` has this updated value")]
                                                            (::builtin::equal(post.kmmap, update_tmp_kmmap))
                                                        })
                                            })
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put_strong(pre: Self, post: Self, label: Label)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = label;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Put { input, output } => true,
                                        _ => false,
                                    }) &&
                                {
                                    let (input, output) =
                                        match tmp_for_match_0 {
                                            Label::Put { input, output } => (input, output),
                                            _ => ::vstd::pervasive::arbitrary(),
                                        };
                                    let tmp_for_match_1 = input;
                                    (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_1
                                                    {
                                                    Input::PutInput { key, value } => true,
                                                    _ => false,
                                                }) &&
                                            {
                                                let (key, value) =
                                                    match tmp_for_match_1 {
                                                        Input::PutInput { key, value } => (key, value),
                                                        _ => ::vstd::pervasive::arbitrary(),
                                                    };
                                                let tmp_for_match_2 = output;
                                                (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_2
                                                                {
                                                                Output::PutOutput => true,
                                                                _ => false,
                                                            }) &&
                                                        {
                                                            let update_tmp_kmmap: TotalKMMap =
                                                                pre.kmmap.insert(key, Message::Define { value });

                                                            #[verifier::custom_err("cannot prove that final value of field `kmmap` has this updated value")]
                                                            (::builtin::equal(post.kmmap, update_tmp_kmmap))
                                                        })
                                            })
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put_enabled(pre: Self, label: Label)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = label;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Put { input, output } => true,
                                        _ => false,
                                    }) &&
                                {
                                    let (input, output) =
                                        match tmp_for_match_0 {
                                            Label::Put { input, output } => (input, output),
                                            _ => ::vstd::pervasive::arbitrary(),
                                        };
                                    let tmp_for_match_1 = input;
                                    (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_1
                                                    {
                                                    Input::PutInput { key, value } => true,
                                                    _ => false,
                                                }) &&
                                            {
                                                let (key, value) =
                                                    match tmp_for_match_1 {
                                                        Input::PutInput { key, value } => (key, value),
                                                        _ => ::vstd::pervasive::arbitrary(),
                                                    };
                                                let tmp_for_match_2 = output;

                                                #[verifier::custom_err("cannot prove this condition holds")]
                                                (match tmp_for_match_2 {
                                                        Output::PutOutput => true,
                                                        _ => false,
                                                    })
                                            })
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn noop(pre: Self, post: Self, label: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_kmmap: TotalKMMap = pre.kmmap;
                        (({
                                        let tmp_for_match_0 = label;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Noop { input, output } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let (input, output) =
                                                        match tmp_for_match_0 {
                                                            Label::Noop { input, output } => (input, output),
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    let tmp_for_match_1 = input;
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_1
                                                                    {
                                                                    Input::NoopInput => true,
                                                                    _ => false,
                                                                }) &&
                                                            {
                                                                let tmp_for_match_2 = output;

                                                                #[verifier::custom_err("cannot prove this condition holds")]
                                                                (match tmp_for_match_2 {
                                                                        Output::NoopOutput => true,
                                                                        _ => false,
                                                                    })
                                                            })
                                                })
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `kmmap` is preserved")] (::builtin::equal(post.kmmap,
                                            update_tmp_kmmap))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn noop_strong(pre: Self, post: Self, label: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_kmmap: TotalKMMap = pre.kmmap;
                        (({
                                        let tmp_for_match_0 = label;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Noop { input, output } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let (input, output) =
                                                        match tmp_for_match_0 {
                                                            Label::Noop { input, output } => (input, output),
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    let tmp_for_match_1 = input;
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_1
                                                                    {
                                                                    Input::NoopInput => true,
                                                                    _ => false,
                                                                }) &&
                                                            {
                                                                let tmp_for_match_2 = output;

                                                                #[verifier::custom_err("cannot prove this condition holds")]
                                                                (match tmp_for_match_2 {
                                                                        Output::NoopOutput => true,
                                                                        _ => false,
                                                                    })
                                                            })
                                                })
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `kmmap` is preserved")] (::builtin::equal(post.kmmap,
                                            update_tmp_kmmap))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn noop_enabled(pre: Self, label: Label)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = label;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Noop { input, output } => true,
                                        _ => false,
                                    }) &&
                                {
                                    let (input, output) =
                                        match tmp_for_match_0 {
                                            Label::Noop { input, output } => (input, output),
                                            _ => ::vstd::pervasive::arbitrary(),
                                        };
                                    let tmp_for_match_1 = input;
                                    (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_1
                                                    {
                                                    Input::NoopInput => true,
                                                    _ => false,
                                                }) &&
                                            {
                                                let tmp_for_match_2 = output;

                                                #[verifier::custom_err("cannot prove this condition holds")]
                                                (match tmp_for_match_2 {
                                                        Output::NoopOutput => true,
                                                        _ => false,
                                                    })
                                            })
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_by(pre: State, post: State, label: Label,
                    step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::query() => Self::query(pre, post, label),
                        Step::put() => Self::put(pre, post, label),
                        Step::noop() => Self::noop(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next(pre: State, post: State, label: Label)
                    -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                            Self::next_by(pre, post, label, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_strong_by(pre: State, post: State, label: Label,
                    step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::query() => Self::query_strong(pre, post, label),
                        Step::put() => Self::put_strong(pre, post, label),
                        Step::noop() => Self::noop_strong(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_strong(pre: State, post: State, label: Label)
                    -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                            Self::next_strong_by(pre, post, label, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn init_by(post: State, step: Config)
                    -> ::core::primitive::bool {
                    match step {
                        Config::my_init_2() => Self::my_init_2(post),
                        Config::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn init(post: State) -> ::core::primitive::bool {
                    ::builtin::exists(|step: Config| Self::init_by(post, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::spec]
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                pub fn invariant(&self) -> ::core::primitive::bool { true }
            }
        }
        type ID = int;
        #[verus::internal(verus_macro)]
        pub struct Request {
            pub input: Input,
            pub id: ID,
        }
        #[verus::internal(verus_macro)]
        pub struct Reply {
            pub output: Output,
            pub id: ID,
        }
        #[doc =
        " PersistentState represents the actual state of the AsyncMap (wraps"]
        #[doc =
        " the true key-value store). Whenever an operation is executed the"]
        #[doc = " PersistentState is updated."]
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct PersistentState {
            pub appv: MapSpec::State,
        }
        #[verus::internal(verus_macro)]
        impl PersistentState {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn ext_equal(self, other: PersistentState) -> bool {
                self.appv.kmmap.ext_equal(other.appv.kmmap)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn ext_equal_is_equality() {
                ::builtin::ensures([::builtin::forall(|a: PersistentState,
                                    b: PersistentState|
                                    ::builtin::spec_eq(a.ext_equal(b),
                                        (::builtin::spec_eq(a, b))))]);
            }
        }
        #[doc =
        " EphemeralState captures the relevant async information we need to"]
        #[doc =
        " track whether operations violate linearizability (and thus enforce"]
        #[doc =
        " in our transitions that all operations are linearizable from the "]
        #[doc = " perspective of the client)."]
        #[doc = ""]
        #[doc =
        " We view our EphemeralState as a set of outstanding client requests"]
        #[doc =
        " that haven\'t been executed and a set of executed replies that have"]
        #[doc = " yet to be delivered to the client."]
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct EphemeralState {
            #[doc = " The set of received but not yet executed requests."]
            pub requests: Set<Request>,
            #[doc = " The set of executed but not yet delivered replies."]
            pub replies: Set<Reply>,
        }
        #[allow(unused_parens)]
        pub mod AsyncMap {
            use super::*;
            #[verus::internal(verus_macro)]
            pub struct State {
                pub persistent: PersistentState,
                pub ephemeral: EphemeralState,
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Step {
                request(),
                execute(MapSpec::Label, PersistentState),
                reply(),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Step {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_request(&self) -> bool {
                    ::builtin::is_variant(self, "request")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_execute(&self) -> bool {
                    ::builtin::is_variant(self, "execute")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_execute_0(self) -> MapSpec::Label {
                    ::builtin::get_variant_field(self, "execute", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_execute_1(self) -> PersistentState {
                    ::builtin::get_variant_field(self, "execute", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_reply(&self) -> bool {
                    ::builtin::is_variant(self, "reply")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Config { dummy_to_use_type_params(State), }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Config {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[verus::internal(verus_macro)]
            pub enum Label {

                #[doc =
                " Request transition is labeled with the requested operation."]
                RequestOp {
                    req: Request,
                },

                #[doc =
                " Execute transition is labeled with the requested operation that"]
                #[doc = " was executed and the produced reply."]
                ExecuteOp {
                    req: Request,
                    reply: Reply,
                },

                #[doc =
                " Reply transition is labeled with what reply is delivered."]
                ReplyOp {
                    reply: Reply,
                },
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Label {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_RequestOp(&self) -> bool {
                    ::builtin::is_variant(self, "RequestOp")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_RequestOp_req(self) -> Request {
                    ::builtin::get_variant_field(self, "RequestOp", "req")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_ExecuteOp(&self) -> bool {
                    ::builtin::is_variant(self, "ExecuteOp")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_ExecuteOp_req(self) -> Request {
                    ::builtin::get_variant_field(self, "ExecuteOp", "req")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_ExecuteOp_reply(self) -> Reply {
                    ::builtin::get_variant_field(self, "ExecuteOp", "reply")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_ReplyOp(&self) -> bool {
                    ::builtin::is_variant(self, "ReplyOp")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_ReplyOp_reply(self) -> Reply {
                    ::builtin::get_variant_field(self, "ReplyOp", "reply")
                }
            }
            pub mod show {
                use super::*;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn request(pre: super::State, post: super::State,
                    label: Label) {
                    ::builtin::requires(super::State::request(pre, post,
                            label));
                    ::builtin::ensures(super::State::next(pre, post, label));
                }
                use bool as request;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn execute(pre: super::State, post: super::State,
                    label: Label, map_label: MapSpec::Label,
                    post_persistent: PersistentState) {
                    ::builtin::requires(super::State::execute(pre, post, label,
                            map_label, post_persistent));
                    ::builtin::ensures(super::State::next(pre, post, label));
                }
                use bool as execute;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn reply(pre: super::State, post: super::State,
                    label: Label) {
                    ::builtin::requires(super::State::reply(pre, post, label));
                    ::builtin::ensures(super::State::next(pre, post, label));
                }
                use bool as reply;
            }
            pub mod take_step {
                use super::*;
            }
            #[verus::internal(verus_macro)]
            impl State {
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn request(pre: Self, post: Self, label: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: PersistentState = pre.persistent;
                        (({
                                        let tmp_for_match_0 = label;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::RequestOp { req } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let req =
                                                        match tmp_for_match_0 {
                                                            Label::RequestOp { req } => req,
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (!pre.ephemeral.requests.contains(req))
                                                            &&
                                                            {
                                                                let update_tmp_ephemeral: EphemeralState =
                                                                    EphemeralState {
                                                                        requests: pre.ephemeral.requests.insert(req),
                                                                        ..pre.ephemeral
                                                                    };

                                                                #[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")]
                                                                (::builtin::equal(post.ephemeral, update_tmp_ephemeral))
                                                            })
                                                })
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                            update_tmp_persistent))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn request_strong(pre: Self, post: Self, label: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: PersistentState = pre.persistent;
                        (({
                                        let tmp_for_match_0 = label;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::RequestOp { req } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let req =
                                                        match tmp_for_match_0 {
                                                            Label::RequestOp { req } => req,
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (!pre.ephemeral.requests.contains(req))
                                                            &&
                                                            {
                                                                let update_tmp_ephemeral: EphemeralState =
                                                                    EphemeralState {
                                                                        requests: pre.ephemeral.requests.insert(req),
                                                                        ..pre.ephemeral
                                                                    };

                                                                #[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")]
                                                                (::builtin::equal(post.ephemeral, update_tmp_ephemeral))
                                                            })
                                                })
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                            update_tmp_persistent))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn request_enabled(pre: Self, label: Label)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = label;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::RequestOp { req } => true,
                                        _ => false,
                                    }) &&
                                {
                                    let req =
                                        match tmp_for_match_0 {
                                            Label::RequestOp { req } => req,
                                            _ => ::vstd::pervasive::arbitrary(),
                                        };

                                    #[verifier::custom_err("cannot prove this condition holds")]
                                    (!pre.ephemeral.requests.contains(req))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn execute(pre: Self, post: Self, label: Label,
                    map_label: MapSpec::Label, post_persistent: PersistentState)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = label;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::ExecuteOp { req, reply } => true,
                                        _ => false,
                                    }) &&
                                {
                                    let (req, reply) =
                                        match tmp_for_match_0 {
                                            Label::ExecuteOp { req, reply } => (req, reply),
                                            _ => ::vstd::pervasive::arbitrary(),
                                        };
                                    (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(req.id,
                                                    reply.id)) &&
                                            (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.requests.contains(req))
                                                    &&
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (!pre.ephemeral.replies.contains(reply))
                                                            &&
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(getInput(map_label),
                                                                            req.input)) &&
                                                                    (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(getOutput(map_label),
                                                                                    reply.output)) &&
                                                                            (#[verifier::custom_err("cannot prove this condition holds")] (MapSpec::State::next(pre.persistent.appv,
                                                                                            post_persistent.appv, map_label)) &&
                                                                                    {
                                                                                        let update_tmp_persistent: PersistentState =
                                                                                            post_persistent;
                                                                                        let update_tmp_ephemeral: EphemeralState =
                                                                                            EphemeralState {
                                                                                                requests: pre.ephemeral.requests.remove(req),
                                                                                                replies: pre.ephemeral.replies.insert(reply),
                                                                                            };
                                                                                        (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                                                        update_tmp_ephemeral)) &&
                                                                                                #[verifier::custom_err("cannot prove that final value of field `persistent` has this updated value")] (::builtin::equal(post.persistent,
                                                                                                        update_tmp_persistent)))
                                                                                    }))))))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn execute_strong(pre: Self, post: Self, label: Label,
                    map_label: MapSpec::Label, post_persistent: PersistentState)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = label;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::ExecuteOp { req, reply } => true,
                                        _ => false,
                                    }) &&
                                {
                                    let (req, reply) =
                                        match tmp_for_match_0 {
                                            Label::ExecuteOp { req, reply } => (req, reply),
                                            _ => ::vstd::pervasive::arbitrary(),
                                        };
                                    (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(req.id,
                                                    reply.id)) &&
                                            (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.requests.contains(req))
                                                    &&
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (!pre.ephemeral.replies.contains(reply))
                                                            &&
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(getInput(map_label),
                                                                            req.input)) &&
                                                                    (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(getOutput(map_label),
                                                                                    reply.output)) &&
                                                                            (#[verifier::custom_err("cannot prove this condition holds")] (MapSpec::State::next(pre.persistent.appv,
                                                                                            post_persistent.appv, map_label)) &&
                                                                                    {
                                                                                        let update_tmp_persistent: PersistentState =
                                                                                            post_persistent;
                                                                                        let update_tmp_ephemeral: EphemeralState =
                                                                                            EphemeralState {
                                                                                                requests: pre.ephemeral.requests.remove(req),
                                                                                                replies: pre.ephemeral.replies.insert(reply),
                                                                                            };
                                                                                        (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                                                        update_tmp_ephemeral)) &&
                                                                                                #[verifier::custom_err("cannot prove that final value of field `persistent` has this updated value")] (::builtin::equal(post.persistent,
                                                                                                        update_tmp_persistent)))
                                                                                    }))))))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn execute_enabled(pre: Self, label: Label,
                    map_label: MapSpec::Label, post_persistent: PersistentState)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = label;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::ExecuteOp { req, reply } => true,
                                        _ => false,
                                    }) &&
                                {
                                    let (req, reply) =
                                        match tmp_for_match_0 {
                                            Label::ExecuteOp { req, reply } => (req, reply),
                                            _ => ::vstd::pervasive::arbitrary(),
                                        };
                                    (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(req.id,
                                                    reply.id)) &&
                                            (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.requests.contains(req))
                                                    &&
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (!pre.ephemeral.replies.contains(reply))
                                                            &&
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(getInput(map_label),
                                                                            req.input)) &&
                                                                    (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(getOutput(map_label),
                                                                                    reply.output)) &&
                                                                            #[verifier::custom_err("cannot prove this condition holds")] (MapSpec::State::next(pre.persistent.appv,
                                                                                    post_persistent.appv, map_label)))))))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn reply(pre: Self, post: Self, label: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: PersistentState = pre.persistent;
                        (({
                                        let tmp_for_match_0 = label;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::ReplyOp { reply } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let reply =
                                                        match tmp_for_match_0 {
                                                            Label::ReplyOp { reply } => reply,
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.replies.contains(reply))
                                                            &&
                                                            {
                                                                let update_tmp_ephemeral: EphemeralState =
                                                                    EphemeralState {
                                                                        replies: pre.ephemeral.replies.remove(reply),
                                                                        ..pre.ephemeral
                                                                    };

                                                                #[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")]
                                                                (::builtin::equal(post.ephemeral, update_tmp_ephemeral))
                                                            })
                                                })
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                            update_tmp_persistent))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn reply_strong(pre: Self, post: Self, label: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: PersistentState = pre.persistent;
                        (({
                                        let tmp_for_match_0 = label;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::ReplyOp { reply } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let reply =
                                                        match tmp_for_match_0 {
                                                            Label::ReplyOp { reply } => reply,
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.replies.contains(reply))
                                                            &&
                                                            {
                                                                let update_tmp_ephemeral: EphemeralState =
                                                                    EphemeralState {
                                                                        replies: pre.ephemeral.replies.remove(reply),
                                                                        ..pre.ephemeral
                                                                    };

                                                                #[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")]
                                                                (::builtin::equal(post.ephemeral, update_tmp_ephemeral))
                                                            })
                                                })
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                            update_tmp_persistent))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn reply_enabled(pre: Self, label: Label)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = label;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::ReplyOp { reply } => true,
                                        _ => false,
                                    }) &&
                                {
                                    let reply =
                                        match tmp_for_match_0 {
                                            Label::ReplyOp { reply } => reply,
                                            _ => ::vstd::pervasive::arbitrary(),
                                        };

                                    #[verifier::custom_err("cannot prove this condition holds")]
                                    (pre.ephemeral.replies.contains(reply))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_by(pre: State, post: State, label: Label,
                    step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::request() => Self::request(pre, post, label),
                        Step::execute(map_label, post_persistent) =>
                            Self::execute(pre, post, label, map_label, post_persistent),
                        Step::reply() => Self::reply(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next(pre: State, post: State, label: Label)
                    -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                            Self::next_by(pre, post, label, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_strong_by(pre: State, post: State, label: Label,
                    step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::request() => Self::request_strong(pre, post, label),
                        Step::execute(map_label, post_persistent) =>
                            Self::execute_strong(pre, post, label, map_label,
                                post_persistent),
                        Step::reply() => Self::reply_strong(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_strong(pre: State, post: State, label: Label)
                    -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                            Self::next_strong_by(pre, post, label, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn init_by(post: State, step: Config)
                    -> ::core::primitive::bool {
                    match step { Config::dummy_to_use_type_params(_) => false, }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn init(post: State) -> ::core::primitive::bool {
                    ::builtin::exists(|step: Config| Self::init_by(post, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::spec]
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                pub fn invariant(&self) -> ::core::primitive::bool { true }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn init_persistent_state() -> PersistentState {
                    PersistentState { appv: my_init() }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn init_ephemeral_state() -> EphemeralState {
                    EphemeralState {
                        requests: ::vstd::set::Set::empty(),
                        replies: ::vstd::set::Set::empty(),
                    }
                }
            }
        }
        type SyncReqId = nat;
        #[doc =
        " A Version is a snapshot of a map (its key-value pairs). Specifically it wraps"]
        #[doc = " a `MapSpec::State`."]
        #[verifier::ext_equal]
        pub type Version = PersistentState;
        #[allow(unused_parens)]
        pub mod CrashTolerantAsyncMap {
            use super::*;
            #[verus::internal(verus_macro)]
            pub struct State {
                pub versions: FloatingSeq<Version>,
                pub async_ephemeral: EphemeralState,
                pub sync_requests: Map<SyncReqId, nat>,
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Step {
                operate(FloatingSeq<Version>, EphemeralState),
                crash(),
                sync(int),
                req_sync(),
                reply_sync(),
                noop(),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Step {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_operate(&self) -> bool {
                    ::builtin::is_variant(self, "operate")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_operate_0(self) -> FloatingSeq<Version> {
                    ::builtin::get_variant_field(self, "operate", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_operate_1(self) -> EphemeralState {
                    ::builtin::get_variant_field(self, "operate", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_crash(&self) -> bool {
                    ::builtin::is_variant(self, "crash")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_sync(&self) -> bool {
                    ::builtin::is_variant(self, "sync")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_sync_0(self) -> int {
                    ::builtin::get_variant_field(self, "sync", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_req_sync(&self) -> bool {
                    ::builtin::is_variant(self, "req_sync")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_reply_sync(&self) -> bool {
                    ::builtin::is_variant(self, "reply_sync")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_noop(&self) -> bool {
                    ::builtin::is_variant(self, "noop")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Config { initialize(), dummy_to_use_type_params(State), }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Config {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_initialize(&self) -> bool {
                    ::builtin::is_variant(self, "initialize")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[verus::internal(verus_macro)]
            pub enum Label {
                OperateOp {
                    base_op: AsyncMap::Label,
                },
                CrashOp,
                SyncOp,
                ReqSyncOp {
                    sync_req_id: SyncReqId,
                },
                ReplySyncOp {
                    sync_req_id: SyncReqId,
                },
                Noop,
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Label {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_OperateOp(&self) -> bool {
                    ::builtin::is_variant(self, "OperateOp")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_OperateOp_base_op(self) -> AsyncMap::Label {
                    ::builtin::get_variant_field(self, "OperateOp", "base_op")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_CrashOp(&self) -> bool {
                    ::builtin::is_variant(self, "CrashOp")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_SyncOp(&self) -> bool {
                    ::builtin::is_variant(self, "SyncOp")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_ReqSyncOp(&self) -> bool {
                    ::builtin::is_variant(self, "ReqSyncOp")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_ReqSyncOp_sync_req_id(self) -> SyncReqId {
                    ::builtin::get_variant_field(self, "ReqSyncOp",
                        "sync_req_id")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_ReplySyncOp(&self) -> bool {
                    ::builtin::is_variant(self, "ReplySyncOp")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_ReplySyncOp_sync_req_id(self) -> SyncReqId {
                    ::builtin::get_variant_field(self, "ReplySyncOp",
                        "sync_req_id")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_Noop(&self) -> bool {
                    ::builtin::is_variant(self, "Noop")
                }
            }
            pub mod show {
                use super::*;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn operate(pre: super::State, post: super::State,
                    label: Label, new_versions: FloatingSeq<Version>,
                    new_async_ephemeral: EphemeralState) {
                    ::builtin::requires(super::State::operate(pre, post, label,
                            new_versions, new_async_ephemeral));
                    ::builtin::ensures(super::State::next(pre, post, label));
                }
                use bool as operate;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn crash(pre: super::State, post: super::State,
                    label: Label) {
                    ::builtin::requires(super::State::crash(pre, post, label));
                    ::builtin::ensures(super::State::next(pre, post, label));
                }
                use bool as crash;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn sync(pre: super::State, post: super::State,
                    label: Label, new_stable_index: int) {
                    ::builtin::requires(super::State::sync(pre, post, label,
                            new_stable_index));
                    ::builtin::ensures(super::State::next(pre, post, label));
                }
                use bool as sync;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn req_sync(pre: super::State, post: super::State,
                    label: Label) {
                    ::builtin::requires(super::State::req_sync(pre, post,
                            label));
                    ::builtin::ensures(super::State::next(pre, post, label));
                }
                use bool as req_sync;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn reply_sync(pre: super::State, post: super::State,
                    label: Label) {
                    ::builtin::requires(super::State::reply_sync(pre, post,
                            label));
                    ::builtin::ensures(super::State::next(pre, post, label));
                }
                use bool as reply_sync;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn noop(pre: super::State, post: super::State,
                    label: Label) {
                    ::builtin::requires(super::State::noop(pre, post, label));
                    ::builtin::ensures(super::State::next(pre, post, label));
                }
                use bool as noop;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn initialize(post: super::State) {
                    ::builtin::requires(super::State::initialize(post));
                    ::builtin::ensures(super::State::init(post));
                }
                use bool as initialize;
            }
            pub mod take_step {
                use super::*;
            }
            #[verus::internal(verus_macro)]
            impl State {
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn initialize(post: Self) -> ::core::primitive::bool {
                    {
                        let update_tmp_versions: FloatingSeq<Version> =
                            FloatingSeq::new(::builtin::spec_literal_integer("0"),
                                ::builtin::spec_literal_integer("1"),
                                ::builtin::closure_to_fn_spec(|i|
                                        AsyncMap::State::init_persistent_state()));
                        let update_tmp_async_ephemeral: EphemeralState =
                            AsyncMap::State::init_ephemeral_state();
                        let update_tmp_sync_requests: Map<SyncReqId, nat> =
                            Map::empty();
                        (#[verifier::custom_err("cannot prove that final value of field `sync_requests` has this updated value")] (::builtin::equal(post.sync_requests,
                                        update_tmp_sync_requests)) &&
                                (#[verifier::custom_err("cannot prove that final value of field `async_ephemeral` has this updated value")] (::builtin::equal(post.async_ephemeral,
                                                update_tmp_async_ephemeral)) &&
                                        #[verifier::custom_err("cannot prove that final value of field `versions` has this updated value")] (::builtin::equal(post.versions,
                                                update_tmp_versions))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn initialize_enabled() -> ::core::primitive::bool {
                    { true }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn operate(pre: Self, post: Self, label: Label,
                    new_versions: FloatingSeq<Version>,
                    new_async_ephemeral: EphemeralState)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_sync_requests: Map<SyncReqId, nat> =
                            pre.sync_requests;
                        (({
                                        let tmp_for_match_0 = label;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::OperateOp { base_op } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let base_op =
                                                        match tmp_for_match_0 {
                                                            Label::OperateOp { base_op } => base_op,
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (State::optionally_append_version(pre.versions,
                                                                    new_versions)) &&
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (AsyncMap::State::next(AsyncMap::State {
                                                                                persistent: pre.versions.last(),
                                                                                ephemeral: pre.async_ephemeral,
                                                                            },
                                                                            AsyncMap::State {
                                                                                persistent: new_versions.last(),
                                                                                ephemeral: new_async_ephemeral,
                                                                            }, base_op)) &&
                                                                    {
                                                                        let update_tmp_versions: FloatingSeq<Version> =
                                                                            new_versions;
                                                                        let update_tmp_async_ephemeral: EphemeralState =
                                                                            new_async_ephemeral;
                                                                        (#[verifier::custom_err("cannot prove that final value of field `async_ephemeral` has this updated value")] (::builtin::equal(post.async_ephemeral,
                                                                                        update_tmp_async_ephemeral)) &&
                                                                                #[verifier::custom_err("cannot prove that final value of field `versions` has this updated value")] (::builtin::equal(post.versions,
                                                                                        update_tmp_versions)))
                                                                    }))
                                                })
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `sync_requests` is preserved")] (::builtin::equal(post.sync_requests,
                                            update_tmp_sync_requests))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn operate_strong(pre: Self, post: Self, label: Label,
                    new_versions: FloatingSeq<Version>,
                    new_async_ephemeral: EphemeralState)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_sync_requests: Map<SyncReqId, nat> =
                            pre.sync_requests;
                        (({
                                        let tmp_for_match_0 = label;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::OperateOp { base_op } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let base_op =
                                                        match tmp_for_match_0 {
                                                            Label::OperateOp { base_op } => base_op,
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (State::optionally_append_version(pre.versions,
                                                                    new_versions)) &&
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (AsyncMap::State::next(AsyncMap::State {
                                                                                persistent: pre.versions.last(),
                                                                                ephemeral: pre.async_ephemeral,
                                                                            },
                                                                            AsyncMap::State {
                                                                                persistent: new_versions.last(),
                                                                                ephemeral: new_async_ephemeral,
                                                                            }, base_op)) &&
                                                                    {
                                                                        let update_tmp_versions: FloatingSeq<Version> =
                                                                            new_versions;
                                                                        let update_tmp_async_ephemeral: EphemeralState =
                                                                            new_async_ephemeral;
                                                                        (#[verifier::custom_err("cannot prove that final value of field `async_ephemeral` has this updated value")] (::builtin::equal(post.async_ephemeral,
                                                                                        update_tmp_async_ephemeral)) &&
                                                                                #[verifier::custom_err("cannot prove that final value of field `versions` has this updated value")] (::builtin::equal(post.versions,
                                                                                        update_tmp_versions)))
                                                                    }))
                                                })
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `sync_requests` is preserved")] (::builtin::equal(post.sync_requests,
                                            update_tmp_sync_requests))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn operate_enabled(pre: Self, label: Label,
                    new_versions: FloatingSeq<Version>,
                    new_async_ephemeral: EphemeralState)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = label;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::OperateOp { base_op } => true,
                                        _ => false,
                                    }) &&
                                {
                                    let base_op =
                                        match tmp_for_match_0 {
                                            Label::OperateOp { base_op } => base_op,
                                            _ => ::vstd::pervasive::arbitrary(),
                                        };
                                    (#[verifier::custom_err("cannot prove this condition holds")] (State::optionally_append_version(pre.versions,
                                                    new_versions)) &&
                                            #[verifier::custom_err("cannot prove this condition holds")] (AsyncMap::State::next(AsyncMap::State {
                                                        persistent: pre.versions.last(),
                                                        ephemeral: pre.async_ephemeral,
                                                    },
                                                    AsyncMap::State {
                                                        persistent: new_versions.last(),
                                                        ephemeral: new_async_ephemeral,
                                                    }, base_op)))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn crash(pre: Self, post: Self, label: Label)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = label;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::CrashOp => true,
                                        _ => false,
                                    }) &&
                                {
                                    let update_tmp_versions: FloatingSeq<Version> =
                                        pre.versions.get_prefix((pre.stable_index()).spec_add(::builtin::spec_literal_nat("1")));
                                    let update_tmp_async_ephemeral: EphemeralState =
                                        AsyncMap::State::init_ephemeral_state();
                                    let update_tmp_sync_requests: Map<SyncReqId, nat> =
                                        Map::empty();
                                    (#[verifier::custom_err("cannot prove that final value of field `sync_requests` has this updated value")] (::builtin::equal(post.sync_requests,
                                                    update_tmp_sync_requests)) &&
                                            (#[verifier::custom_err("cannot prove that final value of field `async_ephemeral` has this updated value")] (::builtin::equal(post.async_ephemeral,
                                                            update_tmp_async_ephemeral)) &&
                                                    #[verifier::custom_err("cannot prove that final value of field `versions` has this updated value")] (::builtin::equal(post.versions,
                                                            update_tmp_versions))))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn crash_strong(pre: Self, post: Self, label: Label)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = label;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::CrashOp => true,
                                        _ => false,
                                    }) &&
                                {
                                    let update_tmp_versions: FloatingSeq<Version> =
                                        pre.versions.get_prefix((pre.stable_index()).spec_add(::builtin::spec_literal_nat("1")));
                                    let update_tmp_async_ephemeral: EphemeralState =
                                        AsyncMap::State::init_ephemeral_state();
                                    let update_tmp_sync_requests: Map<SyncReqId, nat> =
                                        Map::empty();
                                    (#[verifier::custom_err("cannot prove that final value of field `sync_requests` has this updated value")] (::builtin::equal(post.sync_requests,
                                                    update_tmp_sync_requests)) &&
                                            (#[verifier::custom_err("cannot prove that final value of field `async_ephemeral` has this updated value")] (::builtin::equal(post.async_ephemeral,
                                                            update_tmp_async_ephemeral)) &&
                                                    #[verifier::custom_err("cannot prove that final value of field `versions` has this updated value")] (::builtin::equal(post.versions,
                                                            update_tmp_versions))))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn crash_enabled(pre: Self, label: Label)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = label;

                        #[verifier::custom_err("cannot prove this condition holds")]
                        (match tmp_for_match_0 {
                                Label::CrashOp => true,
                                _ => false,
                            })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn sync(pre: Self, post: Self, label: Label,
                    new_stable_index: int) -> ::core::primitive::bool {
                    {
                        let update_tmp_async_ephemeral: EphemeralState =
                            pre.async_ephemeral;
                        let update_tmp_sync_requests: Map<SyncReqId, nat> =
                            pre.sync_requests;
                        (({
                                        let tmp_for_match_0 = label;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::SyncOp => true,
                                                        _ => false,
                                                    }) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(pre.stable_index()),
                                                                        new_stable_index), pre.versions.len()))) &&
                                                        {
                                                            let update_tmp_versions: FloatingSeq<Version> =
                                                                pre.versions.get_suffix(new_stable_index);

                                                            #[verifier::custom_err("cannot prove that final value of field `versions` has this updated value")]
                                                            (::builtin::equal(post.versions, update_tmp_versions))
                                                        }))
                                    }) &&
                                ((#[verifier::custom_err("cannot prove that the field `sync_requests` is preserved")] (::builtin::equal(post.sync_requests,
                                                    update_tmp_sync_requests)) &&
                                            #[verifier::custom_err("cannot prove that the field `async_ephemeral` is preserved")] (::builtin::equal(post.async_ephemeral,
                                                    update_tmp_async_ephemeral)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn sync_strong(pre: Self, post: Self, label: Label,
                    new_stable_index: int) -> ::core::primitive::bool {
                    {
                        let update_tmp_async_ephemeral: EphemeralState =
                            pre.async_ephemeral;
                        let update_tmp_sync_requests: Map<SyncReqId, nat> =
                            pre.sync_requests;
                        (({
                                        let tmp_for_match_0 = label;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::SyncOp => true,
                                                        _ => false,
                                                    }) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(pre.stable_index()),
                                                                        new_stable_index), pre.versions.len()))) &&
                                                        {
                                                            let update_tmp_versions: FloatingSeq<Version> =
                                                                pre.versions.get_suffix(new_stable_index);

                                                            #[verifier::custom_err("cannot prove that final value of field `versions` has this updated value")]
                                                            (::builtin::equal(post.versions, update_tmp_versions))
                                                        }))
                                    }) &&
                                ((#[verifier::custom_err("cannot prove that the field `sync_requests` is preserved")] (::builtin::equal(post.sync_requests,
                                                    update_tmp_sync_requests)) &&
                                            #[verifier::custom_err("cannot prove that the field `async_ephemeral` is preserved")] (::builtin::equal(post.async_ephemeral,
                                                    update_tmp_async_ephemeral)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn sync_enabled(pre: Self, label: Label,
                    new_stable_index: int) -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = label;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::SyncOp => true,
                                        _ => false,
                                    }) &&
                                #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(pre.stable_index()),
                                                new_stable_index), pre.versions.len()))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn req_sync(pre: Self, post: Self, label: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_versions: FloatingSeq<Version> =
                            pre.versions;
                        let update_tmp_async_ephemeral: EphemeralState =
                            pre.async_ephemeral;
                        (({
                                        let tmp_for_match_0 = label;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::ReqSyncOp { sync_req_id } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let sync_req_id =
                                                        match tmp_for_match_0 {
                                                            Label::ReqSyncOp { sync_req_id } => sync_req_id,
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (!pre.sync_requests.dom().contains(sync_req_id))
                                                            &&
                                                            {
                                                                let update_tmp_sync_requests: Map<SyncReqId, nat> =
                                                                    pre.sync_requests.insert(sync_req_id,
                                                                        ::builtin::spec_cast_integer::<_,
                                                                                nat>(((pre.versions.len()).spec_sub(::builtin::spec_literal_nat("1")))));

                                                                #[verifier::custom_err("cannot prove that final value of field `sync_requests` has this updated value")]
                                                                (::builtin::equal(post.sync_requests,
                                                                        update_tmp_sync_requests))
                                                            })
                                                })
                                    }) &&
                                ((#[verifier::custom_err("cannot prove that the field `async_ephemeral` is preserved")] (::builtin::equal(post.async_ephemeral,
                                                    update_tmp_async_ephemeral)) &&
                                            #[verifier::custom_err("cannot prove that the field `versions` is preserved")] (::builtin::equal(post.versions,
                                                    update_tmp_versions)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn req_sync_strong(pre: Self, post: Self, label: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_versions: FloatingSeq<Version> =
                            pre.versions;
                        let update_tmp_async_ephemeral: EphemeralState =
                            pre.async_ephemeral;
                        (({
                                        let tmp_for_match_0 = label;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::ReqSyncOp { sync_req_id } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let sync_req_id =
                                                        match tmp_for_match_0 {
                                                            Label::ReqSyncOp { sync_req_id } => sync_req_id,
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (!pre.sync_requests.dom().contains(sync_req_id))
                                                            &&
                                                            {
                                                                let update_tmp_sync_requests: Map<SyncReqId, nat> =
                                                                    pre.sync_requests.insert(sync_req_id,
                                                                        ::builtin::spec_cast_integer::<_,
                                                                                nat>(((pre.versions.len()).spec_sub(::builtin::spec_literal_nat("1")))));

                                                                #[verifier::custom_err("cannot prove that final value of field `sync_requests` has this updated value")]
                                                                (::builtin::equal(post.sync_requests,
                                                                        update_tmp_sync_requests))
                                                            })
                                                })
                                    }) &&
                                ((#[verifier::custom_err("cannot prove that the field `async_ephemeral` is preserved")] (::builtin::equal(post.async_ephemeral,
                                                    update_tmp_async_ephemeral)) &&
                                            #[verifier::custom_err("cannot prove that the field `versions` is preserved")] (::builtin::equal(post.versions,
                                                    update_tmp_versions)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn req_sync_enabled(pre: Self, label: Label)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = label;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::ReqSyncOp { sync_req_id } => true,
                                        _ => false,
                                    }) &&
                                {
                                    let sync_req_id =
                                        match tmp_for_match_0 {
                                            Label::ReqSyncOp { sync_req_id } => sync_req_id,
                                            _ => ::vstd::pervasive::arbitrary(),
                                        };

                                    #[verifier::custom_err("cannot prove this condition holds")]
                                    (!pre.sync_requests.dom().contains(sync_req_id))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn reply_sync(pre: Self, post: Self, label: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_versions: FloatingSeq<Version> =
                            pre.versions;
                        let update_tmp_async_ephemeral: EphemeralState =
                            pre.async_ephemeral;
                        (({
                                        let tmp_for_match_0 = label;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::ReplySyncOp { sync_req_id } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let sync_req_id =
                                                        match tmp_for_match_0 {
                                                            Label::ReplySyncOp { sync_req_id } => sync_req_id,
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (pre.sync_requests.dom().contains(sync_req_id))
                                                            &&
                                                            (#[verifier::custom_err("cannot prove this condition holds")] ((pre.sync_requests.spec_index(sync_req_id)).spec_le(pre.stable_index()))
                                                                    &&
                                                                    {
                                                                        let update_tmp_sync_requests: Map<SyncReqId, nat> =
                                                                            pre.sync_requests.remove(sync_req_id);

                                                                        #[verifier::custom_err("cannot prove that final value of field `sync_requests` has this updated value")]
                                                                        (::builtin::equal(post.sync_requests,
                                                                                update_tmp_sync_requests))
                                                                    }))
                                                })
                                    }) &&
                                ((#[verifier::custom_err("cannot prove that the field `async_ephemeral` is preserved")] (::builtin::equal(post.async_ephemeral,
                                                    update_tmp_async_ephemeral)) &&
                                            #[verifier::custom_err("cannot prove that the field `versions` is preserved")] (::builtin::equal(post.versions,
                                                    update_tmp_versions)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn reply_sync_strong(pre: Self, post: Self, label: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_versions: FloatingSeq<Version> =
                            pre.versions;
                        let update_tmp_async_ephemeral: EphemeralState =
                            pre.async_ephemeral;
                        (({
                                        let tmp_for_match_0 = label;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::ReplySyncOp { sync_req_id } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let sync_req_id =
                                                        match tmp_for_match_0 {
                                                            Label::ReplySyncOp { sync_req_id } => sync_req_id,
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (pre.sync_requests.dom().contains(sync_req_id))
                                                            &&
                                                            (#[verifier::custom_err("cannot prove this condition holds")] ((pre.sync_requests.spec_index(sync_req_id)).spec_le(pre.stable_index()))
                                                                    &&
                                                                    {
                                                                        let update_tmp_sync_requests: Map<SyncReqId, nat> =
                                                                            pre.sync_requests.remove(sync_req_id);

                                                                        #[verifier::custom_err("cannot prove that final value of field `sync_requests` has this updated value")]
                                                                        (::builtin::equal(post.sync_requests,
                                                                                update_tmp_sync_requests))
                                                                    }))
                                                })
                                    }) &&
                                ((#[verifier::custom_err("cannot prove that the field `async_ephemeral` is preserved")] (::builtin::equal(post.async_ephemeral,
                                                    update_tmp_async_ephemeral)) &&
                                            #[verifier::custom_err("cannot prove that the field `versions` is preserved")] (::builtin::equal(post.versions,
                                                    update_tmp_versions)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn reply_sync_enabled(pre: Self, label: Label)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = label;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::ReplySyncOp { sync_req_id } => true,
                                        _ => false,
                                    }) &&
                                {
                                    let sync_req_id =
                                        match tmp_for_match_0 {
                                            Label::ReplySyncOp { sync_req_id } => sync_req_id,
                                            _ => ::vstd::pervasive::arbitrary(),
                                        };
                                    (#[verifier::custom_err("cannot prove this condition holds")] (pre.sync_requests.dom().contains(sync_req_id))
                                            &&
                                            #[verifier::custom_err("cannot prove this condition holds")] ((pre.sync_requests.spec_index(sync_req_id)).spec_le(pre.stable_index())))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn noop(pre: Self, post: Self, label: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_versions: FloatingSeq<Version> =
                            pre.versions;
                        let update_tmp_async_ephemeral: EphemeralState =
                            pre.async_ephemeral;
                        let update_tmp_sync_requests: Map<SyncReqId, nat> =
                            pre.sync_requests;
                        (({
                                        let tmp_for_match_0 = label;

                                        #[verifier::custom_err("cannot prove this condition holds")]
                                        (match tmp_for_match_0 { Label::Noop => true, _ => false, })
                                    }) &&
                                ((#[verifier::custom_err("cannot prove that the field `sync_requests` is preserved")] (::builtin::equal(post.sync_requests,
                                                    update_tmp_sync_requests)) &&
                                            (#[verifier::custom_err("cannot prove that the field `async_ephemeral` is preserved")] (::builtin::equal(post.async_ephemeral,
                                                            update_tmp_async_ephemeral)) &&
                                                    #[verifier::custom_err("cannot prove that the field `versions` is preserved")] (::builtin::equal(post.versions,
                                                            update_tmp_versions))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn noop_strong(pre: Self, post: Self, label: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_versions: FloatingSeq<Version> =
                            pre.versions;
                        let update_tmp_async_ephemeral: EphemeralState =
                            pre.async_ephemeral;
                        let update_tmp_sync_requests: Map<SyncReqId, nat> =
                            pre.sync_requests;
                        (({
                                        let tmp_for_match_0 = label;

                                        #[verifier::custom_err("cannot prove this condition holds")]
                                        (match tmp_for_match_0 { Label::Noop => true, _ => false, })
                                    }) &&
                                ((#[verifier::custom_err("cannot prove that the field `sync_requests` is preserved")] (::builtin::equal(post.sync_requests,
                                                    update_tmp_sync_requests)) &&
                                            (#[verifier::custom_err("cannot prove that the field `async_ephemeral` is preserved")] (::builtin::equal(post.async_ephemeral,
                                                            update_tmp_async_ephemeral)) &&
                                                    #[verifier::custom_err("cannot prove that the field `versions` is preserved")] (::builtin::equal(post.versions,
                                                            update_tmp_versions))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn noop_enabled(pre: Self, label: Label)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = label;

                        #[verifier::custom_err("cannot prove this condition holds")]
                        (match tmp_for_match_0 { Label::Noop => true, _ => false, })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_by(pre: State, post: State, label: Label,
                    step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::operate(new_versions, new_async_ephemeral) =>
                            Self::operate(pre, post, label, new_versions,
                                new_async_ephemeral),
                        Step::crash() => Self::crash(pre, post, label),
                        Step::sync(new_stable_index) =>
                            Self::sync(pre, post, label, new_stable_index),
                        Step::req_sync() => Self::req_sync(pre, post, label),
                        Step::reply_sync() => Self::reply_sync(pre, post, label),
                        Step::noop() => Self::noop(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next(pre: State, post: State, label: Label)
                    -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                            Self::next_by(pre, post, label, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_strong_by(pre: State, post: State, label: Label,
                    step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::operate(new_versions, new_async_ephemeral) =>
                            Self::operate_strong(pre, post, label, new_versions,
                                new_async_ephemeral),
                        Step::crash() => Self::crash_strong(pre, post, label),
                        Step::sync(new_stable_index) =>
                            Self::sync_strong(pre, post, label, new_stable_index),
                        Step::req_sync() => Self::req_sync_strong(pre, post, label),
                        Step::reply_sync() =>
                            Self::reply_sync_strong(pre, post, label),
                        Step::noop() => Self::noop_strong(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_strong(pre: State, post: State, label: Label)
                    -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                            Self::next_strong_by(pre, post, label, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn init_by(post: State, step: Config)
                    -> ::core::primitive::bool {
                    match step {
                        Config::initialize() => Self::initialize(post),
                        Config::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn init(post: State) -> ::core::primitive::bool {
                    ::builtin::exists(|step: Config| Self::init_by(post, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::spec]
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                pub fn invariant(&self) -> ::core::primitive::bool {
                    self.the_inv()
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn the_inv(self) -> bool {
                    ((::builtin::spec_literal_nat("0")).spec_lt(self.versions.len()))
                        &&
                        (self.versions.is_active((self.versions.len()).spec_sub(::builtin::spec_literal_nat("1"))))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::custom_req_err("could not show invariant `the_inv` on the `post` state")]
                #[verifier::external_body]
                #[verus::internal(verus_macro)]
                #[verifier::proof]
                fn lemma_msg_the_inv(s: State) {
                    ::builtin::requires(s.the_inv());
                    ::builtin::ensures(s.the_inv());
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn initialize_inductive(post: Self) {
                    ::builtin::requires(Self::initialize(post));
                    ::builtin::ensures(post.invariant());
                    {}
                    Self::lemma_msg_the_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn operate_inductive(pre: Self, post: Self, label: Label,
                    new_versions: FloatingSeq<Version>,
                    new_async_ephemeral: EphemeralState) {
                    ::builtin::requires(pre.invariant() &&
                            State::operate_strong(pre, post, label, new_versions,
                                new_async_ephemeral));
                    ::builtin::ensures(post.invariant());
                    {}
                    Self::lemma_msg_the_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn crash_inductive(pre: Self, post: Self, label: Label) {
                    ::builtin::requires(pre.invariant() &&
                            State::crash_strong(pre, post, label));
                    ::builtin::ensures(post.invariant());
                    {}
                    Self::lemma_msg_the_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn sync_inductive(pre: Self, post: Self, label: Label,
                    new_stable_index: int) {
                    ::builtin::requires(pre.invariant() &&
                            State::sync_strong(pre, post, label, new_stable_index));
                    ::builtin::ensures(post.invariant());
                    {}
                    Self::lemma_msg_the_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn req_sync_inductive(pre: Self, post: Self, label: Label) {
                    ::builtin::requires(pre.invariant() &&
                            State::req_sync_strong(pre, post, label));
                    ::builtin::ensures(post.invariant());
                    {}
                    Self::lemma_msg_the_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn reply_sync_inductive(pre: Self, post: Self, label: Label) {
                    ::builtin::requires(pre.invariant() &&
                            State::reply_sync_strong(pre, post, label));
                    ::builtin::ensures(post.invariant());
                    {}
                    Self::lemma_msg_the_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn noop_inductive(pre: Self, post: Self, label: Label) {
                    ::builtin::requires(pre.invariant() &&
                            State::noop_strong(pre, post, label));
                    ::builtin::ensures(post.invariant());
                    {}
                    Self::lemma_msg_the_inv(post);
                }
                #[doc =
                " Return the latest index in `self.versions` which is stable (i.e.: persistent across"]
                #[doc = " crashes)."]
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn stable_index(self) -> int {
                    self.versions.first_active_index()
                }
                #[doc =
                " Returns true iff versions_prime is one of the following:"]
                #[doc = " - Equal to versions."]
                #[doc =
                " - Equal to versions with a single version appended."]
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn optionally_append_version(versions:
                        FloatingSeq<Version>, versions_prime: FloatingSeq<Version>)
                    -> bool {
                    (((::builtin::spec_literal_nat("0")).spec_lt(versions_prime.len())
                                    &&
                                    ::builtin::spec_eq(versions_prime.drop_last(), versions)))
                        || (::builtin::spec_eq(versions_prime, versions))
                }
            }
        }
        fn main() {}
    }
    pub mod TotalKMMap_t {
        use builtin_macros::*;
        use vstd::prelude::*;
        use vstd::set_lib::*;
        use crate::spec::KeyType_t::*;
        use crate::spec::Messages_t::*;
        #[doc =
        " A TotalKMMap wraps a regular verus map. Maps Keys to Messages."]
        #[doc = " We use this to represent our abstract map state."]
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct TotalKMMap(pub Map<Key, Message>);
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn total_domain() -> Set<Key> {
            Set::new(::builtin::closure_to_fn_spec(|k: Key| true))
        }
        #[verus::internal(verus_macro)]
        impl TotalKMMap {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn empty() -> TotalKMMap {
                TotalKMMap(Map::new(::builtin::closure_to_fn_spec(|k: Key|
                                true),
                        ::builtin::closure_to_fn_spec(|k: Key| Message::empty())))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn spec_index(self, idx: Key) -> Message {
                ::builtin::recommends([self.wf()]);
                self.0.spec_index(idx)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn insert(self, key: Key, value: Message) -> Self {
                TotalKMMap(self.0.insert(key, value))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn dom(self) -> Set<Key> { self.0.dom() }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                ::builtin::spec_eq(self.dom(), total_domain())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn ext_equal(self, other: TotalKMMap) -> bool {
                ::builtin::ext_equal(self.0, other.0)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn ext_equal_is_equality(self, other: TotalKMMap) {
                ::builtin::requires([self.ext_equal(other)]);
                ::builtin::ensures([::builtin::spec_eq(self, other)]);
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn insert_lemma(self) {
                ::builtin::requires([self.wf()]);
                ::builtin::ensures([::builtin::forall(|k: Key, v: Message|
                                    #[verus::internal(auto_trigger)] (self.insert(k,
                                                v).wf()))]);
                {
                    ::builtin::assert_forall_by(|k: Key, v: Message|
                            {
                                ::builtin::ensures((#[verus::internal(trigger)] self.insert(k,
                                                v)).wf());
                                #[verifier::spec]
                                let s1 =
                                    ::vstd::set_lib::check_argument_is_set(self.insert(k,
                                                v).dom());
                                #[verifier::spec]
                                let s2 =
                                    ::vstd::set_lib::check_argument_is_set(total_domain());
                                ::builtin::assert_by(::builtin::equal(s1, s2),
                                    {
                                        ::builtin::assert_forall_by(|elem|
                                                {
                                                    ::builtin::ensures(::builtin::imply(s1.contains(elem),
                                                                s2.contains(elem)) &&
                                                            ::builtin::imply(s2.contains(elem), s1.contains(elem)));
                                                    { {} }
                                                });
                                        ::builtin::assert_(::builtin::ext_equal(s1, s2));
                                    });
                                ;
                            });
                }
            }
        }
    }
    pub mod Messages_t {
        #[allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        #[verus::internal(verus_macro)]
        pub struct Value(pub int);
        #[verus::internal(verus_macro)]
        pub struct Delta(pub int);
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn default_value() -> Value {
            Value(::builtin::spec_literal_integer("0"))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn nop_delta() -> Delta {
            Delta(::builtin::spec_literal_integer("0"))
        }
        #[doc =
        " Messages represent operations that can be performed to update/define the"]
        #[doc = " state of values in a map."]
        #[doc =
        " Messages can themselves be used as the values of a map as long as only \"Define\""]
        #[doc = " messages are stored (see TotalKMMap)."]
        #[verus::internal(verus_macro)]
        pub enum Message {

            #[doc =
            " A Define message represents setting a variable to the given value."]
            Define {
                value: Value,
            },

            #[doc =
            " An Update message represents updating a variable by the given delta."]
            Update {
                delta: Delta,
            },
        }
        #[verus::internal(verus_macro)]
        #[cfg(verus_keep_ghost)]
        #[automatically_derived]
        impl Message {
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_Define(&self) -> bool {
                ::builtin::is_variant(self, "Define")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_Define_value(self) -> Value {
                ::builtin::get_variant_field(self, "Define", "value")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_Update(&self) -> bool {
                ::builtin::is_variant(self, "Update")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_Update_delta(self) -> Delta {
                ::builtin::get_variant_field(self, "Update", "delta")
            }
        }
        #[verus::internal(verus_macro)]
        impl Message {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn combine_deltas(new: Delta, old: Delta) -> Delta {
                if ::builtin::spec_eq(new, nop_delta()) {
                        old
                    } else if ::builtin::spec_eq(old, nop_delta()) {
                       new
                   } else { new }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn apply_delta(delta: Delta, value: Value) -> Value { value }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn merge(self, new: Message) -> Message {
                match (self, new) {
                    (_, Message::Define { value: new_value }) => {
                        Message::Define { value: new_value }
                    }
                    (Message::Update { delta: old_delta }, Message::Update {
                        delta: new_delta }) => {
                        Message::Update {
                            delta: Self::combine_deltas(new_delta, old_delta),
                        }
                    }
                    (Message::Define { value }, Message::Update { delta }) => {
                        Message::Define { value: Self::apply_delta(delta, value) }
                    }
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn empty() -> Message {
                Message::Define { value: default_value() }
            }
        }
    }
    pub mod KeyType_t {
        #![allow(unused_imports)]
        use builtin_macros::*;
        use builtin::*;
        use vstd::prelude::*;
        use vstd::set_lib::*;
        #[doc =
        " A Key is a key in a B+-tree. Tuple style type makes it typecheck as its"]
        #[doc = " own type in Rust."]
        #[doc = " Keys in the real implementation are meant to be strings."]
        #[verus::internal(verus_macro)]
        pub struct Key(pub nat);
        #[doc =
        " An Element is a Be-tree pivot value. It is an enum type because we need a special"]
        #[doc =
        " value `Max` for representing a value larger than the largest key. `Max` is only used"]
        #[doc =
        " in the special case where the last bucket of a node has an unbounded upper bound."]
        #[doc = " "]
        #[doc =
        " We don\'t need a `Min` value, as the empty bytestring will represent the lowest possible"]
        #[doc =
        " value (and bucket lower bounds are inclusive). So we can use the empty bytestring as"]
        #[doc = " our lowest pivot if we want to represent all lower keys."]
        #[doc = " "]
        #[doc =
        " Elements are essentially just Keys with a special `Max` value, and thus the two types"]
        #[doc = " can be converted between each other."]
        #[verus::internal(verus_macro)]
        pub enum Element {

            #[doc =
            " Max is the max key in the domain. Only the last pivot of a Be-tree can"]
            #[doc =
            " be Max (in which case the last bucket has an unbounded upper bound)."]
            Max,
            Elem {
                e: nat,
            },
        }
        #[verus::internal(verus_macro)]
        #[cfg(verus_keep_ghost)]
        #[automatically_derived]
        impl Element {
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_Max(&self) -> bool {
                ::builtin::is_variant(self, "Max")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_Elem(&self) -> bool {
                ::builtin::is_variant(self, "Elem")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_Elem_e(self) -> nat {
                ::builtin::get_variant_field(self, "Elem", "e")
            }
        }
        #[doc = " Pre: elem is Element::Elem (and not `Max`)."]
        #[doc = " Returns the key corresponding to an Element::Elem."]
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn to_key(elem: Element) -> Key {
            ::builtin::recommends([elem.is_Elem()]);
            Key(elem.get_Elem_e())
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn to_element(key: Key) -> Element { Element::Elem { e: key.0 } }
        #[verus::internal(verus_macro)]
        impl Key {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn lte(a: Key, b: Key) -> bool { (a.0).spec_le(b.0) }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn lt(a: Key, b: Key) -> bool {
                (Key::lte(a, b)) && (!::builtin::spec_eq(a, b))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_strictly_sorted(run: Seq<Key>) -> bool {
                ::builtin::forall(|i: int, j: int|
                        ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            i), j), run.len())),
                            Key::lt(run.spec_index(i), run.spec_index(j))))
            }
            #[doc =
            " Returns the index of the largest element in `run` that\'s <= to the provided"]
            #[doc = " needle."]
            #[doc = " "]
            #[doc = " # Arguments"]
            #[doc = " "]
            #[doc = " * `run`: the sequence to search within."]
            #[doc = " * `needle`: the needle to search for."]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn largest_lte(run: Seq<Key>, needle: Key) -> int {
                ::builtin::decreases((run.len()));
                if ::builtin::spec_eq(run.len(),
                                ::builtin::spec_literal_nat("0")) ||
                            Key::lt(needle,
                                run.spec_index(::builtin::spec_literal_integer("0"))) {
                        (::builtin::spec_literal_nat("1")).spec_neg()
                    } else {
                       (::builtin::spec_literal_nat("1")).spec_add(Key::largest_lte(run.subrange(::builtin::spec_literal_integer("1"),
                                   ::builtin::spec_cast_integer::<_, int>(run.len())), needle))
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn largest_lt(run: Seq<Key>, needle: Key) -> int {
                ::builtin::decreases((run.len()));
                if ::builtin::spec_eq(run.len(),
                                ::builtin::spec_literal_nat("0")) ||
                            Key::lte(needle,
                                run.spec_index(::builtin::spec_literal_integer("0"))) {
                        (::builtin::spec_literal_nat("1")).spec_neg()
                    } else {
                       (::builtin::spec_literal_nat("1")).spec_add(Key::largest_lt(run.subrange(::builtin::spec_literal_integer("1"),
                                   ::builtin::spec_cast_integer::<_, int>(run.len())), needle))
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn map_pivoted_union<V>(left: Map<Key, V>, pivot: Key,
                right: Map<Key, V>) -> Map<Key, V> {
                let restricted_left =
                    left.restrict(Set::new(::builtin::closure_to_fn_spec(|key|
                                    Self::lt(key, pivot))));
                let restricted_right =
                    right.restrict(Set::new(::builtin::closure_to_fn_spec(|key|
                                    Self::lte(pivot, key))));
                restricted_left.union_prefer_right(restricted_right)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_sorted(run: Seq<Key>) -> bool {
                ::builtin::forall(|i: int, j: int|
                        ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            i), j), run.len())),
                            Key::lte(run.spec_index(i), run.spec_index(j))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn strictly_sorted_implies_sorted(run: Seq<Key>) {
                ::builtin::requires([Self::is_strictly_sorted(run)]);
                ::builtin::ensures([Self::is_sorted(run)]);
                {
                    ::builtin::assert_forall_by(|i: int, j: int|
                            {
                                ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                    i), j), run.len())));
                                ::builtin::ensures(Key::lte(run.spec_index(i),
                                        run.spec_index(j)));
                                if (i).spec_lt(j) {
                                        ::builtin::assert_(Key::lt(run.spec_index(i),
                                                run.spec_index(j)));
                                    }
                            });
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn lte_transitive_forall() {
                ::builtin::ensures([::builtin::forall(|a: Key, b: Key, c: Key|
                                    ::builtin::imply(Self::lte(a, b) && Self::lte(b, c),
                                        Self::lte(a, c)))]);
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn largest_lte_ensures(run: Seq<Key>, needle: Key, out: int) {
                ::builtin::requires([Key::is_sorted(run),
                            ::builtin::spec_eq(out, Key::largest_lte(run, needle))]);
                ::builtin::ensures([::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value((::builtin::spec_literal_nat("1")).spec_neg()),
                                        out), run.len())),
                            ::builtin::forall(|i|
                                    ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                    i), out)),
                                        Key::lte(#[verus::internal(trigger)] run.spec_index(i),
                                            needle))),
                            ::builtin::forall(|i|
                                    ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_lt(::builtin::spec_chained_value(out),
                                                    i), run.len())),
                                        Key::lt(needle,
                                            #[verus::internal(trigger)] run.spec_index(i)))),
                            ::builtin::imply(run.contains(needle),
                                (::builtin::spec_literal_nat("0")).spec_le(out) &&
                                    ::builtin::spec_eq(run.spec_index(out), needle))]);
                ::builtin::decreases((run.len()));
                ::builtin::assume_(false);
                Self::lte_transitive_forall();
                if !::builtin::spec_eq(run.len(),
                                    ::builtin::spec_literal_nat("0")) &&
                            !Key::lt(needle,
                                    run.spec_index(::builtin::spec_literal_integer("0"))) {
                        Self::largest_lte_ensures(run.subrange(::builtin::spec_literal_integer("1"),
                                ::builtin::spec_cast_integer::<_, int>(run.len())), needle,
                            (out).spec_sub(::builtin::spec_literal_nat("1")));
                    }
            }
        }
        #[verus::internal(verus_macro)]
        impl Element {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn lte(a: Element, b: Element) -> bool {
                (b.is_Max()) ||
                    ((a.is_Elem() && b.is_Elem() &&
                                Key::lte(to_key(a), to_key(b))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn lt(a: Element, b: Element) -> bool {
                (Element::lte(a, b)) && (!::builtin::spec_eq(a, b))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn lt_transitive(a: Element, b: Element, c: Element) {
                ::builtin::requires([Self::lt(a, b), Self::lt(b, c)]);
                ::builtin::ensures([Self::lt(a, c)]);
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn lt_transitive_forall() {
                ::builtin::ensures([::builtin::forall(|a: Element, b: Element,
                                    c: Element|
                                    ::builtin::imply(Self::lt(a, b) && Self::lt(b, c),
                                        Self::lt(a, c)))]);
                {
                    ::builtin::assert_forall_by(|a: Element, b: Element,
                            c: Element|
                            {
                                ::builtin::requires(Self::lt(a, b) && Self::lt(b, c));
                                ::builtin::ensures(Self::lt(a, c));
                                Self::lt_transitive(a, b, c);
                            });
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn lte_transitive(a: Element, b: Element, c: Element) {
                ::builtin::requires([Self::lte(a, b), Self::lte(b, c)]);
                ::builtin::ensures([Self::lte(a, c)]);
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn lte_transitive_forall() {
                ::builtin::ensures([::builtin::forall(|a: Element, b: Element,
                                    c: Element|
                                    ::builtin::imply(Self::lte(a, b) && Self::lte(b, c),
                                        Self::lte(a, c)))]);
                {
                    ::builtin::assert_forall_by(|a: Element, b: Element,
                            c: Element|
                            {
                                ::builtin::requires(Self::lte(a, b) && Self::lte(b, c));
                                ::builtin::ensures(Self::lte(a, c));
                                Self::lte_transitive(a, b, c);
                            });
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn min_elem() -> Element {
                Element::Elem { e: ::builtin::spec_literal_integer("0") }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_sorted(run: Seq<Element>) -> bool {
                ::builtin::forall(|i: int, j: int|
                        ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            i), j), run.len())),
                            Element::lte(run.spec_index(i), run.spec_index(j))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_strictly_sorted(run: Seq<Element>) -> bool {
                ::builtin::forall(|i: int, j: int|
                        ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            i), j), run.len())),
                            Element::lt(run.spec_index(i), run.spec_index(j))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn strictly_sorted_implies_sorted(run: Seq<Element>) {
                ::builtin::requires([Self::is_strictly_sorted(run)]);
                ::builtin::ensures([Self::is_sorted(run)]);
                {
                    ::builtin::assert_forall_by(|i: int, j: int|
                            {
                                ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                    i), j), run.len())));
                                ::builtin::ensures(Element::lte(run.spec_index(i),
                                        run.spec_index(j)));
                                if (i).spec_lt(j) {
                                        ::builtin::assert_(Element::lt(run.spec_index(i),
                                                run.spec_index(j)));
                                    }
                            });
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn largest_lte(run: Seq<Element>, needle: Element) -> int {
                ::builtin::decreases((run.len()));
                if ::builtin::spec_eq(run.len(),
                                ::builtin::spec_literal_nat("0")) ||
                            Element::lt(needle,
                                run.spec_index(::builtin::spec_literal_integer("0"))) {
                        (::builtin::spec_literal_nat("1")).spec_neg()
                    } else {
                       (::builtin::spec_literal_nat("1")).spec_add(Element::largest_lte(run.subrange(::builtin::spec_literal_integer("1"),
                                   ::builtin::spec_cast_integer::<_, int>(run.len())), needle))
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn largest_lte_lemma(run: Seq<Element>, needle: Element,
                out: int) {
                ::builtin::requires([Self::is_sorted(run),
                            ::builtin::spec_eq(out, Self::largest_lte(run, needle))]);
                ::builtin::ensures([::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value((::builtin::spec_literal_nat("1")).spec_neg()),
                                        out), run.len())),
                            ::builtin::forall(|i: int|
                                    #[verus::internal(auto_trigger)] (::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                        i), out)), Self::lte(run.spec_index(i), needle)))),
                            ::builtin::forall(|i: int|
                                    #[verus::internal(auto_trigger)] (::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_lt(::builtin::spec_chained_value(out),
                                                        i), run.len())), Self::lt(needle, run.spec_index(i))))),
                            ::builtin::imply(run.contains(needle),
                                (::builtin::spec_literal_nat("0")).spec_le(out) &&
                                    ::builtin::spec_eq(run.spec_index(out), needle))]);
                ::builtin::decreases((run.len()));
                Self::lte_transitive_forall();
                if ::builtin::spec_eq(run.len(),
                            ::builtin::spec_literal_nat("0"))
                        {} else if Element::lt(needle,
                           run.spec_index(::builtin::spec_literal_integer("0"))) {
                       if run.contains(needle) {
                               ::builtin::assert_(Element::lte(run.spec_index(::builtin::spec_literal_integer("0")),
                                       run.spec_index(run.index_of(needle))));
                               ::builtin::assert_(false);
                           }
                   } else {
                       let sub_run =
                           run.subrange(::builtin::spec_literal_integer("1"),
                               ::builtin::spec_cast_integer::<_, int>(run.len()));
                       Self::largest_lte_lemma(sub_run, needle,
                           (out).spec_sub(::builtin::spec_literal_nat("1")));
                       {
                           ::builtin::assert_forall_by(|i: int|
                                   {
                                       ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_lt(::builtin::spec_chained_value(out),
                                                       i), run.len())));
                                       ::builtin::ensures(#[verus::internal(trigger)] Self::lt(needle,
                                               run.spec_index(i)));
                                       ::builtin::assert_(::builtin::spec_eq(run.spec_index(i),
                                               sub_run.spec_index((i).spec_sub(::builtin::spec_literal_nat("1")))));
                                   });
                       }
                       if run.contains(needle) && !sub_run.contains(needle) {
                               let idx = run.index_of(needle);
                               if !::builtin::spec_eq(idx,
                                               ::builtin::spec_literal_nat("0")) {
                                       ::builtin::assert_(::builtin::spec_eq(sub_run.spec_index((idx).spec_sub(::builtin::spec_literal_nat("1"))),
                                               run.spec_index(idx)));
                                       ::builtin::assert_(false);
                                   }
                               ::builtin::assert_(::builtin::spec_eq(idx,
                                       ::builtin::spec_literal_nat("0")));
                               ::builtin::assert_(::builtin::spec_eq(run.spec_index(::builtin::spec_literal_integer("0")),
                                       needle));
                               if ::builtin::spec_eq(run.len(),
                                           ::builtin::spec_literal_nat("1")) {
                                       ::builtin::assert_(::builtin::spec_eq(out,
                                               ::builtin::spec_literal_nat("0")));
                                   } else {
                                      ::builtin::assert_(Element::lte(run.spec_index(::builtin::spec_literal_integer("0")),
                                              run.spec_index(::builtin::spec_literal_integer("1"))));
                                      ::builtin::assert_(::builtin::spec_eq(sub_run.spec_index(::builtin::spec_literal_integer("0")),
                                              run.spec_index(::builtin::spec_literal_integer("1"))));
                                      ::builtin::assert_(::builtin::spec_eq(out,
                                              ::builtin::spec_literal_nat("0")));
                                  }
                           }
                   }
            }
        }
    }
}
mod abstract_system {
    pub mod StampedMap_v {
        use builtin_macros::*;
        use builtin::*;
        use crate::spec::TotalKMMap_t::*;
        use crate::abstract_system::MsgHistory_v::MsgHistory;
        pub type LSN = nat;
        #[doc = " A Stamped type is one which has the concept of a seq_end."]
        #[doc = " I guess the original naming was meant to refer to how"]
        #[doc = " you \"stamp\" the end with an LSN? IDK."]
        #[verus::internal(verus_macro)]
        pub struct Stamped<T> {
            pub value: T,
            pub seq_end: LSN,
        }
        #[doc = " A TotalKMMap with a seq_end field."]
        pub type StampedMap = Stamped<TotalKMMap>;
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn empty() -> StampedMap {
            Stamped {
                value: TotalKMMap::empty(),
                seq_end: ::builtin::spec_literal_integer("0"),
            }
        }
        #[verus::internal(verus_macro)]
        impl StampedMap {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn ext_equal(self, other: StampedMap) -> bool {
                (::builtin::ext_equal(self.value.0, other.value.0)) &&
                    (::builtin::spec_eq(self.seq_end, other.seq_end))
            }
            #[doc =
            " Returns a StampedMap formed by applying the operations in the given journal"]
            #[doc = " (aka Message History) to this StampedMap."]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn plus_history(self, history: MsgHistory) -> StampedMap {
                ::builtin::recommends([self.value.wf(), history.wf(),
                            history.can_follow(self.seq_end)]);
                history.apply_to_stamped_map(self)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn ext_equal_is_equality() {
                ::builtin::ensures([::builtin::forall(|a: StampedMap,
                                    b: StampedMap|
                                    ::builtin::spec_eq(a.ext_equal(b),
                                        (::builtin::spec_eq(a, b))))]);
            }
        }
        fn main() {}
    }
    pub mod MsgHistory_v {
        use builtin_macros::*;
        use builtin::*;
        use vstd::{*, map::*, set::*};
        use crate::spec::KeyType_t::*;
        use crate::spec::Messages_t::*;
        use crate::abstract_system::StampedMap_v::*;
        #[doc =
        " A KeyedMessage stores a \"key\" to perform the operation in the stored"]
        #[doc = " \"message\" on."]
        #[verus::internal(verus_macro)]
        pub struct KeyedMessage {
            pub key: Key,
            pub message: Message,
        }
        #[doc =
        " A contiguous log of kv-store command messages (keyed by LSN)."]
        #[doc = " Stores requests from seq_start <= LSN < seq_end."]
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct MsgHistory {
            #[doc =
            " The messages stored in this history. Stored as key-value pairs,"]
            #[doc =
            " where key is the LSN of the operation, and KeyedMessage stores"]
            #[doc = " the operation to perform."]
            pub msgs: Map<LSN, KeyedMessage>,
            #[doc = " The first LSN in this MsgHistory."]
            pub seq_start: LSN,
            #[doc = " The first LSN *past the end* of this MsgHistory."]
            pub seq_end: LSN,
        }
        #[verus::internal(verus_macro)]
        impl MsgHistory {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                ((self.seq_start).spec_le(self.seq_end)) &&
                    (self.contains_exactly(self.msgs.dom()))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn ext_equal(self, other: MsgHistory) -> bool {
                ((::builtin::ext_equal(self.msgs, other.msgs)) &&
                            (::builtin::spec_eq(self.seq_start, other.seq_start))) &&
                    (::builtin::spec_eq(self.seq_end, other.seq_end))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn ext_equal_is_equality() {
                ::builtin::ensures([::builtin::forall(|a: MsgHistory,
                                    b: MsgHistory|
                                    ::builtin::spec_eq(a.ext_equal(b),
                                        (::builtin::spec_eq(a, b))))]);
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn contains(self, lsn: LSN) -> bool {
                ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(self.seq_start),
                            lsn), self.seq_end))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn contains_key(self, key: Key) -> bool {
                ::builtin::recommends([self.wf()]);
                ::builtin::exists(|lsn|
                        #[verus::internal(auto_trigger)] (::builtin::spec_eq(self.msgs.spec_index(lsn).key,
                                key)))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn contains_exactly(self, lsns: Set<LSN>) -> bool {
                ::builtin::forall(|lsn|
                        ::builtin::spec_eq((lsns.contains(lsn)),
                            (self.contains(lsn))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_empty(self) -> bool {
                ::builtin::spec_eq(self.seq_start, self.seq_end)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn len(self) -> nat {
                ::builtin::recommends([self.wf()]);
                ::builtin::spec_cast_integer::<_,
                        nat>(((self.seq_end).spec_sub(self.seq_start)))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_follow(self, lsn: LSN) -> bool {
                ::builtin::spec_eq(self.seq_start, lsn)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_concat(self, other: MsgHistory) -> bool {
                other.can_follow(self.seq_end)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn concat(self, other: MsgHistory) -> MsgHistory {
                ::builtin::recommends([self.can_concat(other)]);
                MsgHistory {
                    msgs: self.msgs.union_prefer_right(other.msgs),
                    seq_start: self.seq_start,
                    seq_end: other.seq_end,
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn concat_lemma(self, other: MsgHistory) {
                ::builtin::requires([self.wf(), other.wf(),
                            self.can_concat(other)]);
                ::builtin::ensures([({
                                    let result = self.concat(other);
                                    ((result.wf()) &&
                                                ((::builtin::forall(|x|
                                                                ::builtin::spec_eq((result.contains(x)),
                                                                    ((self.contains(x) || other.contains(x)))))))) &&
                                        ((::builtin::imply(other.is_empty(),
                                                    ::builtin::spec_eq(result, self))))
                                })]);
                let result = self.concat(other);
                if other.is_empty() {
                        #[verifier::spec]
                        let m1 = ::vstd::map::check_argument_is_map(result.msgs);
                        #[verifier::spec]
                        let m2 = ::vstd::map::check_argument_is_map(self.msgs);
                        ::builtin::assert_by(::builtin::equal(m1, m2),
                            {
                                ::builtin::assert_forall_by(|key|
                                        {
                                            ::builtin::ensures([::builtin::imply(#[verifier::trigger] m1.dom().contains(key),
                                                                    m2.dom().contains(key)) &&
                                                                ::builtin::imply(m2.dom().contains(key),
                                                                    m1.dom().contains(key)) &&
                                                            ::builtin::imply(m1.dom().contains(key) &&
                                                                    m2.dom().contains(key),
                                                                ::builtin::equal(m1.index(key), m2.index(key)))]);
                                            { {} }
                                        });
                                ::builtin::assert_(::builtin::ext_equal(m1, m2));
                            });
                        ;
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn concat_forall_lemma() {
                ::builtin::ensures([::builtin::forall(|_self: MsgHistory,
                                    other: MsgHistory|
                                    ::builtin::imply({
                                            ((_self.wf()) && (other.wf())) && (_self.can_concat(other))
                                        },
                                        {
                                            let result =
                                                #[verus::internal(trigger)] _self.concat(other);
                                            ((result.wf()) &&
                                                        ((::builtin::forall(|x|
                                                                        ::builtin::spec_eq((result.contains(x)),
                                                                            ((_self.contains(x) || other.contains(x)))))))) &&
                                                ((::builtin::imply(other.is_empty(),
                                                            ::builtin::spec_eq(result, _self))))
                                        }))]);
                {
                    ::builtin::assert_forall_by(|_self: MsgHistory,
                            other: MsgHistory|
                            {
                                ::builtin::requires({
                                        ((_self.wf()) && (other.wf())) && (_self.can_concat(other))
                                    });
                                ::builtin::ensures({
                                        let result =
                                            #[verus::internal(trigger)] _self.concat(other);
                                        ((result.wf()) &&
                                                    ((::builtin::forall(|x|
                                                                    ::builtin::spec_eq((result.contains(x)),
                                                                        ((_self.contains(x) || other.contains(x)))))))) &&
                                            ((::builtin::imply(other.is_empty(),
                                                        ::builtin::spec_eq(result, _self))))
                                    });
                                _self.concat_lemma(other);
                            });
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_discard_to(self, lsn: LSN) -> bool {
                ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(self.seq_start),
                            lsn), self.seq_end))
            }
            #[doc = " Returns this[start, lsn). (Slice off right side)."]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn discard_recent(self, lsn: LSN) -> MsgHistory {
                ::builtin::recommends([self.can_discard_to(lsn)]);
                let keepMap =
                    Map::new(::builtin::closure_to_fn_spec(|k: nat|
                                ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(self.seq_start),
                                            k), lsn))),
                        ::builtin::closure_to_fn_spec(|k: nat|
                                self.msgs.spec_index(k)));
                MsgHistory {
                    msgs: keepMap,
                    seq_start: self.seq_start,
                    seq_end: lsn,
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn _dr(self, lsn: LSN) -> MsgHistory {
                ::builtin::recommends([self.can_discard_to(lsn)]);
                self.discard_recent(lsn)
            }
            #[doc =
            " Returns a StampedMap formed by applying the operations in self (MsgHistory)"]
            #[doc = " to the StampedMap \"orig\"."]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn apply_to_stamped_map(self, orig: StampedMap)
                -> StampedMap {
                ::builtin::recommends([self.can_follow(orig.seq_end)]);
                ::builtin::decreases((self.len()));
                ::builtin::decreases_when(self.wf());
                if self.is_empty() {
                        orig
                    } else {
                       let last_lsn =
                           ::builtin::spec_cast_integer::<_,
                                   nat>(((self.seq_end).spec_sub(::builtin::spec_literal_nat("1"))));
                       let sub_map =
                           self.discard_recent(last_lsn).apply_to_stamped_map(orig);
                       let key = self.msgs.spec_index(last_lsn).key;
                       let new_message = self.msgs.spec_index(last_lsn).message;
                       let old_message = sub_map.value.spec_index(key);
                       let new_value =
                           sub_map.value.insert(key, old_message.merge(new_message));
                       Stamped {
                           value: new_value,
                           seq_end: (sub_map.seq_end).spec_add(::builtin::spec_literal_nat("1")),
                       }
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn apply_to_stamped_map_wf_lemma(self, orig: StampedMap) {
                ::builtin::requires([orig.value.wf(), self.wf(),
                            self.can_follow(orig.seq_end)]);
                ::builtin::ensures([self.apply_to_stamped_map(orig).value.wf()]);
                ::builtin::decreases((self.len()));
                if !self.is_empty() {
                        let last_lsn =
                            ::builtin::spec_cast_integer::<_,
                                    nat>(((self.seq_end).spec_sub(::builtin::spec_literal_nat("1"))));
                        let sub_map =
                            self.discard_recent(last_lsn).apply_to_stamped_map(orig);
                        self.discard_recent(last_lsn).apply_to_stamped_map_wf_lemma(orig);
                        sub_map.value.insert_lemma();
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn apply_to_stamped_map_length_lemma(self, orig: StampedMap) {
                ::builtin::requires([self.wf(),
                            self.can_follow(orig.seq_end)]);
                ::builtin::ensures([::builtin::spec_eq(self.apply_to_stamped_map(orig).seq_end,
                                (orig.seq_end).spec_add(self.len()))]);
                ::builtin::decreases((self.len()));
                if !self.is_empty() {
                        let last_lsn =
                            ::builtin::spec_cast_integer::<_,
                                    nat>(((self.seq_end).spec_sub(::builtin::spec_literal_nat("1"))));
                        self.discard_recent(last_lsn).apply_to_stamped_map_length_lemma(orig);
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn discard_old(self, lsn: LSN) -> MsgHistory {
                ::builtin::recommends([self.can_discard_to(lsn)]);
                let keepMap =
                    Map::new(::builtin::closure_to_fn_spec(|k: nat|
                                ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(lsn),
                                            k), self.seq_end))),
                        ::builtin::closure_to_fn_spec(|k: nat|
                                self.msgs.spec_index(k)));
                MsgHistory {
                    msgs: keepMap,
                    seq_start: lsn,
                    seq_end: self.seq_end,
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn _do(self, lsn: LSN) -> MsgHistory {
                ::builtin::recommends([self.can_discard_to(lsn)]);
                self.discard_old(lsn)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn maybe_discard_old(self, lsn: LSN) -> MsgHistory {
                ::builtin::recommends([self.wf(),
                            (lsn).spec_le(self.seq_end)]);
                if (self.seq_start).spec_le(lsn) {
                        self.discard_old(lsn)
                    } else { self }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn discard_order_is_commutative(self, start: LSN, end: LSN) {
                ::builtin::requires([(start).spec_le(end),
                            self.can_discard_to(start), self.can_discard_to(end)]);
                ::builtin::ensures([::builtin::spec_eq(self.discard_old(start).discard_recent(end),
                                self.discard_recent(end).discard_old(start))]);
                let left = self.discard_old(start).discard_recent(end);
                let right = self.discard_recent(end).discard_old(start);
                ::builtin::assert_(left.ext_equal(right));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn added_slices_union(self, middle: LSN) {
                ::builtin::requires([self.wf(), self.can_discard_to(middle)]);
                ::builtin::ensures([::builtin::spec_eq(self.discard_recent(middle).concat(self.discard_old(middle)),
                                self)]);
                let other =
                    self.discard_recent(middle).concat(self.discard_old(middle));
                ::builtin::assert_(self.ext_equal(other));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn includes_subseq(self, subseq: MsgHistory) -> bool {
                ::builtin::recommends([self.wf(), subseq.wf()]);
                (((self.seq_start).spec_le(subseq.seq_start)) &&
                            ((subseq.seq_end).spec_le(self.seq_end))) &&
                    (::builtin::forall(|lsn|
                                #[verus::internal(auto_trigger)] (::builtin::imply(subseq.contains(lsn),
                                        self.contains(lsn) &&
                                            ::builtin::equal(self.msgs.spec_index(lsn),
                                                subseq.msgs.spec_index(lsn))))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn empty_history_at(lsn: LSN) -> MsgHistory {
                MsgHistory {
                    msgs: ::vstd::map::Map::empty(),
                    seq_start: lsn,
                    seq_end: lsn,
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn singleton_at(lsn: LSN, msg: KeyedMessage) -> MsgHistory {
                MsgHistory {
                    msgs: ::vstd::map::Map::empty().insert(lsn, msg),
                    seq_start: lsn,
                    seq_end: (lsn).spec_add(::builtin::spec_literal_nat("1")),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn map_plus_history(stamped_map: StampedMap,
                history: MsgHistory) -> StampedMap {
                ::builtin::recommends([stamped_map.value.wf(), history.wf(),
                            history.can_follow(stamped_map.seq_end)]);
                history.apply_to_stamped_map(stamped_map)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn map_plus_history_lemma(stamped_map: StampedMap,
                history: MsgHistory) {
                ::builtin::requires([stamped_map.value.wf(), history.wf(),
                            history.can_follow(stamped_map.seq_end)]);
                ::builtin::ensures([Self::map_plus_history(stamped_map,
                                        history).value.wf(),
                            ::builtin::spec_eq(Self::map_plus_history(stamped_map,
                                        history).seq_end,
                                (stamped_map.seq_end).spec_add(history.len()))]);
                history.apply_to_stamped_map_wf_lemma(stamped_map);
                Self::map_plus_history_seq_end_lemma(stamped_map, history);
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn map_plus_history_forall_lemma() {
                ::builtin::ensures([::builtin::forall(|stamped_map:
                                        StampedMap, history: MsgHistory|
                                    ::builtin::imply((stamped_map.value.wf() && history.wf() &&
                                                history.can_follow(stamped_map.seq_end)),
                                        {
                                            ((#[verus::internal(trigger)] Self::map_plus_history(stamped_map,
                                                                    history)).value.wf()) &&
                                                (::builtin::spec_eq(Self::map_plus_history(stamped_map,
                                                                history).seq_end,
                                                        (stamped_map.seq_end).spec_add(history.len())))
                                        }))]);
                {
                    ::builtin::assert_forall_by(|stamped_map: StampedMap,
                            history: MsgHistory|
                            {
                                ::builtin::requires((stamped_map.value.wf() && history.wf()
                                            && history.can_follow(stamped_map.seq_end)));
                                ::builtin::ensures(((#[verus::internal(trigger)] Self::map_plus_history(stamped_map,
                                                            history)).value.wf() &&
                                            ::builtin::spec_eq(Self::map_plus_history(stamped_map,
                                                        history).seq_end,
                                                (stamped_map.seq_end).spec_add(history.len()))));
                                Self::map_plus_history_lemma(stamped_map, history);
                                Self::map_plus_history_seq_end_lemma(stamped_map, history);
                                ::builtin::assert_(::builtin::spec_eq(Self::map_plus_history(stamped_map,
                                                history).seq_end,
                                        (stamped_map.seq_end).spec_add(history.len())));
                            });
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn map_plus_history_seq_end_lemma(stamped_map: StampedMap,
                history: MsgHistory) {
                ::builtin::requires([stamped_map.value.wf(), history.wf(),
                            history.can_follow(stamped_map.seq_end)]);
                ::builtin::ensures([::builtin::spec_eq(history.apply_to_stamped_map(stamped_map).seq_end,
                                (stamped_map.seq_end).spec_add(history.len()))]);
                history.apply_to_stamped_map_length_lemma(stamped_map);
            }
        }
    }
    pub mod AbstractJournal_v {
        #[allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        use crate::abstract_system::StampedMap_v::*;
        use crate::abstract_system::MsgHistory_v::*;
        #[allow(unused_parens)]
        pub mod AbstractJournal {
            use super::*;
            #[verus::internal(verus_macro)]
            pub struct State {
                pub journal: MsgHistory,
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Step {
                read_for_recovery(),
                freeze_for_commit(),
                observe_fresh_journal(),
                put(),
                discard_old(),
                internal(),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Step {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_read_for_recovery(&self) -> bool {
                    ::builtin::is_variant(self, "read_for_recovery")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_freeze_for_commit(&self) -> bool {
                    ::builtin::is_variant(self, "freeze_for_commit")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_observe_fresh_journal(&self) -> bool {
                    ::builtin::is_variant(self, "observe_fresh_journal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_put(&self) -> bool {
                    ::builtin::is_variant(self, "put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_discard_old(&self) -> bool {
                    ::builtin::is_variant(self, "discard_old")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_internal(&self) -> bool {
                    ::builtin::is_variant(self, "internal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Config {
                initialize(MsgHistory),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Config {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_initialize(&self) -> bool {
                    ::builtin::is_variant(self, "initialize")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_initialize_0(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "initialize", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[verus::internal(verus_macro)]
            pub enum Label {
                ReadForRecoveryLabel {
                    messages: MsgHistory,
                },
                FreezeForCommitLabel {
                    frozen_journal: MsgHistory,
                },
                QueryEndLsnLabel {
                    end_lsn: LSN,
                },
                PutLabel {
                    messages: MsgHistory,
                },
                DiscardOldLabel {
                    start_lsn: LSN,
                    require_end: LSN,
                },
                InternalLabel,
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Label {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_ReadForRecoveryLabel(&self) -> bool {
                    ::builtin::is_variant(self, "ReadForRecoveryLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_ReadForRecoveryLabel_messages(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "ReadForRecoveryLabel",
                        "messages")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_FreezeForCommitLabel(&self) -> bool {
                    ::builtin::is_variant(self, "FreezeForCommitLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_FreezeForCommitLabel_frozen_journal(self)
                    -> MsgHistory {
                    ::builtin::get_variant_field(self, "FreezeForCommitLabel",
                        "frozen_journal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_QueryEndLsnLabel(&self) -> bool {
                    ::builtin::is_variant(self, "QueryEndLsnLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_QueryEndLsnLabel_end_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "QueryEndLsnLabel",
                        "end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_PutLabel(&self) -> bool {
                    ::builtin::is_variant(self, "PutLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_PutLabel_messages(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "PutLabel", "messages")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_DiscardOldLabel(&self) -> bool {
                    ::builtin::is_variant(self, "DiscardOldLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_DiscardOldLabel_start_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "DiscardOldLabel",
                        "start_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_DiscardOldLabel_require_end(self) -> LSN {
                    ::builtin::get_variant_field(self, "DiscardOldLabel",
                        "require_end")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_InternalLabel(&self) -> bool {
                    ::builtin::is_variant(self, "InternalLabel")
                }
            }
            pub mod show {
                use super::*;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn read_for_recovery(pre: super::State,
                    post: super::State, lbl: Label) {
                    ::builtin::requires(super::State::read_for_recovery(pre,
                            post, lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as read_for_recovery;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn freeze_for_commit(pre: super::State,
                    post: super::State, lbl: Label) {
                    ::builtin::requires(super::State::freeze_for_commit(pre,
                            post, lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as freeze_for_commit;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn observe_fresh_journal(pre: super::State,
                    post: super::State, lbl: Label) {
                    ::builtin::requires(super::State::observe_fresh_journal(pre,
                            post, lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as observe_fresh_journal;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn put(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::put(pre, post, lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as put;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn discard_old(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::discard_old(pre, post,
                            lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as discard_old;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn internal(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::internal(pre, post, lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as internal;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn initialize(post: super::State,
                    persistent_journal: MsgHistory) {
                    ::builtin::requires(super::State::initialize(post,
                            persistent_journal));
                    ::builtin::ensures(super::State::init(post));
                }
                use bool as initialize;
            }
            pub mod take_step {
                use super::*;
            }
            #[verus::internal(verus_macro)]
            impl State {
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn initialize(post: Self, persistent_journal: MsgHistory)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (persistent_journal.wf())
                                &&
                                {
                                    let update_tmp_journal: MsgHistory = persistent_journal;

                                    #[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")]
                                    (::builtin::equal(post.journal, update_tmp_journal))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn initialize_enabled(persistent_journal: MsgHistory)
                    -> ::core::primitive::bool {
                    {

                        #[verifier::custom_err("cannot prove this condition holds")]
                        (persistent_journal.wf())
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn read_for_recovery(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_journal: MsgHistory = pre.journal;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_ReadForRecoveryLabel())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.journal.includes_subseq(lbl.get_ReadForRecoveryLabel_messages()))
                                                &&
                                                #[verifier::custom_err("cannot prove that the field `journal` is preserved")] (::builtin::equal(post.journal,
                                                        update_tmp_journal)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn read_for_recovery_strong(pre: Self, post: Self,
                    lbl: Label) -> ::core::primitive::bool {
                    {
                        let update_tmp_journal: MsgHistory = pre.journal;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_ReadForRecoveryLabel())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.journal.includes_subseq(lbl.get_ReadForRecoveryLabel_messages()))
                                                &&
                                                #[verifier::custom_err("cannot prove that the field `journal` is preserved")] (::builtin::equal(post.journal,
                                                        update_tmp_journal)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn read_for_recovery_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_ReadForRecoveryLabel())
                                        &&
                                        #[verifier::custom_err("cannot prove this condition holds")] (pre.journal.includes_subseq(lbl.get_ReadForRecoveryLabel_messages()))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn freeze_for_commit(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_journal: MsgHistory = pre.journal;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_FreezeForCommitLabel())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.get_FreezeForCommitLabel_frozen_journal().wf())
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.journal.includes_subseq(lbl.get_FreezeForCommitLabel_frozen_journal()))
                                                        &&
                                                        #[verifier::custom_err("cannot prove that the field `journal` is preserved")] (::builtin::equal(post.journal,
                                                                update_tmp_journal))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn freeze_for_commit_strong(pre: Self, post: Self,
                    lbl: Label) -> ::core::primitive::bool {
                    {
                        let update_tmp_journal: MsgHistory = pre.journal;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_FreezeForCommitLabel())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.get_FreezeForCommitLabel_frozen_journal().wf())
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.journal.includes_subseq(lbl.get_FreezeForCommitLabel_frozen_journal()))
                                                        &&
                                                        #[verifier::custom_err("cannot prove that the field `journal` is preserved")] (::builtin::equal(post.journal,
                                                                update_tmp_journal))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn freeze_for_commit_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_FreezeForCommitLabel())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.get_FreezeForCommitLabel_frozen_journal().wf())
                                                &&
                                                #[verifier::custom_err("cannot prove this condition holds")] (pre.journal.includes_subseq(lbl.get_FreezeForCommitLabel_frozen_journal())))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn observe_fresh_journal(pre: Self, post: Self,
                    lbl: Label) -> ::core::primitive::bool {
                    {
                        let update_tmp_journal: MsgHistory = pre.journal;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_QueryEndLsnLabel())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.can_end_at(lbl.get_QueryEndLsnLabel_end_lsn()))
                                                &&
                                                #[verifier::custom_err("cannot prove that the field `journal` is preserved")] (::builtin::equal(post.journal,
                                                        update_tmp_journal)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn observe_fresh_journal_strong(pre: Self, post: Self,
                    lbl: Label) -> ::core::primitive::bool {
                    {
                        let update_tmp_journal: MsgHistory = pre.journal;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_QueryEndLsnLabel())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.can_end_at(lbl.get_QueryEndLsnLabel_end_lsn()))
                                                &&
                                                #[verifier::custom_err("cannot prove that the field `journal` is preserved")] (::builtin::equal(post.journal,
                                                        update_tmp_journal)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn observe_fresh_journal_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_QueryEndLsnLabel())
                                        &&
                                        #[verifier::custom_err("cannot prove this condition holds")] (pre.can_end_at(lbl.get_QueryEndLsnLabel_end_lsn()))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_PutLabel())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(pre.journal.seq_end,
                                                        lbl.get_PutLabel_messages().seq_start)) &&
                                                {
                                                    let update_tmp_journal: MsgHistory =
                                                        pre.journal.concat(lbl.get_PutLabel_messages());

                                                    #[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")]
                                                    (::builtin::equal(post.journal, update_tmp_journal))
                                                })))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put_strong(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_PutLabel())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(pre.journal.seq_end,
                                                        lbl.get_PutLabel_messages().seq_start)) &&
                                                {
                                                    let update_tmp_journal: MsgHistory =
                                                        pre.journal.concat(lbl.get_PutLabel_messages());

                                                    #[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")]
                                                    (::builtin::equal(post.journal, update_tmp_journal))
                                                })))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_PutLabel())
                                        &&
                                        #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(pre.journal.seq_end,
                                                lbl.get_PutLabel_messages().seq_start))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn discard_old(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_DiscardOldLabel())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(pre.journal.seq_end,
                                                        lbl.get_DiscardOldLabel_require_end())) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.journal.can_discard_to(lbl.get_DiscardOldLabel_start_lsn()))
                                                        &&
                                                        {
                                                            let update_tmp_journal: MsgHistory =
                                                                pre.journal.discard_old(lbl.get_DiscardOldLabel_start_lsn());

                                                            #[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")]
                                                            (::builtin::equal(post.journal, update_tmp_journal))
                                                        }))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn discard_old_strong(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_DiscardOldLabel())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(pre.journal.seq_end,
                                                        lbl.get_DiscardOldLabel_require_end())) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.journal.can_discard_to(lbl.get_DiscardOldLabel_start_lsn()))
                                                        &&
                                                        {
                                                            let update_tmp_journal: MsgHistory =
                                                                pre.journal.discard_old(lbl.get_DiscardOldLabel_start_lsn());

                                                            #[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")]
                                                            (::builtin::equal(post.journal, update_tmp_journal))
                                                        }))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn discard_old_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_DiscardOldLabel())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(pre.journal.seq_end,
                                                        lbl.get_DiscardOldLabel_require_end())) &&
                                                #[verifier::custom_err("cannot prove this condition holds")] (pre.journal.can_discard_to(lbl.get_DiscardOldLabel_start_lsn())))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_journal: MsgHistory = pre.journal;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_InternalLabel())
                                        &&
                                        #[verifier::custom_err("cannot prove that the field `journal` is preserved")] (::builtin::equal(post.journal,
                                                update_tmp_journal))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_strong(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_journal: MsgHistory = pre.journal;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_InternalLabel())
                                        &&
                                        #[verifier::custom_err("cannot prove that the field `journal` is preserved")] (::builtin::equal(post.journal,
                                                update_tmp_journal))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                #[verifier::custom_err("cannot prove this condition holds")] (lbl.is_InternalLabel()))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_by(pre: State, post: State, label: Label,
                    step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::read_for_recovery() =>
                            Self::read_for_recovery(pre, post, label),
                        Step::freeze_for_commit() =>
                            Self::freeze_for_commit(pre, post, label),
                        Step::observe_fresh_journal() =>
                            Self::observe_fresh_journal(pre, post, label),
                        Step::put() => Self::put(pre, post, label),
                        Step::discard_old() => Self::discard_old(pre, post, label),
                        Step::internal() => Self::internal(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next(pre: State, post: State, label: Label)
                    -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                            Self::next_by(pre, post, label, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_strong_by(pre: State, post: State, label: Label,
                    step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::read_for_recovery() =>
                            Self::read_for_recovery_strong(pre, post, label),
                        Step::freeze_for_commit() =>
                            Self::freeze_for_commit_strong(pre, post, label),
                        Step::observe_fresh_journal() =>
                            Self::observe_fresh_journal_strong(pre, post, label),
                        Step::put() => Self::put_strong(pre, post, label),
                        Step::discard_old() =>
                            Self::discard_old_strong(pre, post, label),
                        Step::internal() => Self::internal_strong(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_strong(pre: State, post: State, label: Label)
                    -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                            Self::next_strong_by(pre, post, label, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn init_by(post: State, step: Config)
                    -> ::core::primitive::bool {
                    match step {
                        Config::initialize(persistent_journal) =>
                            Self::initialize(post, persistent_journal),
                        Config::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn init(post: State) -> ::core::primitive::bool {
                    ::builtin::exists(|step: Config| Self::init_by(post, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::spec]
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                pub fn invariant(&self) -> ::core::primitive::bool { true }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn wf(self) -> bool { self.journal.wf() }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn can_end_at(self, lsn: LSN) -> bool {
                    ::builtin::spec_eq(self.journal.seq_end, lsn)
                }
            }
        }
    }
    pub mod AbstractMap_v {
        #[allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        use crate::spec::KeyType_t::*;
        use crate::spec::Messages_t::*;
        use crate::abstract_system::StampedMap_v::*;
        use crate::abstract_system::MsgHistory_v::*;
        #[allow(unused_parens)]
        pub mod AbstractMap {
            use super::*;
            #[verus::internal(verus_macro)]
            pub struct State {
                pub stamped_map: StampedMap,
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Step {
                query(),
                put(),
                freeze_as(),
                internal(),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Step {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_query(&self) -> bool {
                    ::builtin::is_variant(self, "query")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_put(&self) -> bool {
                    ::builtin::is_variant(self, "put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_freeze_as(&self) -> bool {
                    ::builtin::is_variant(self, "freeze_as")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_internal(&self) -> bool {
                    ::builtin::is_variant(self, "internal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Config {
                initialize(StampedMap),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Config {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_initialize(&self) -> bool {
                    ::builtin::is_variant(self, "initialize")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_initialize_0(self) -> StampedMap {
                    ::builtin::get_variant_field(self, "initialize", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[verus::internal(verus_macro)]
            pub enum Label {

                #[doc =
                " When querying, we label the transition with the map LSN (one past the end)"]
                #[doc =
                " at time of querying, plus the queried key and received value."]
                QueryLabel {
                    end_lsn: LSN,
                    key: Key,
                    value: Value,
                },

                #[doc =
                " We label put transitions with a MsgHistory representing the set of messages"]
                #[doc = " to apply."]
                PutLabel {
                    puts: MsgHistory,
                },

                #[doc =
                " FreezeAs transitions are labeled with the StampedMap state at the time the"]
                #[doc =
                " transition is taken. (Label allows state machine client to validate/assert"]
                #[doc =
                " that the version of map they\'re freezing is correct)."]
                FreezeAsLabel {
                    stamped_map: StampedMap,
                },

                #[doc = " Internal transitions are unlabeled."]
                InternalLabel,
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Label {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_QueryLabel(&self) -> bool {
                    ::builtin::is_variant(self, "QueryLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_QueryLabel_end_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "QueryLabel", "end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_QueryLabel_key(self) -> Key {
                    ::builtin::get_variant_field(self, "QueryLabel", "key")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_QueryLabel_value(self) -> Value {
                    ::builtin::get_variant_field(self, "QueryLabel", "value")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_PutLabel(&self) -> bool {
                    ::builtin::is_variant(self, "PutLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_PutLabel_puts(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "PutLabel", "puts")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_FreezeAsLabel(&self) -> bool {
                    ::builtin::is_variant(self, "FreezeAsLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_FreezeAsLabel_stamped_map(self) -> StampedMap {
                    ::builtin::get_variant_field(self, "FreezeAsLabel",
                        "stamped_map")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_InternalLabel(&self) -> bool {
                    ::builtin::is_variant(self, "InternalLabel")
                }
            }
            pub mod show {
                use super::*;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn query(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::query(pre, post, lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as query;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn put(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::put(pre, post, lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as put;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn freeze_as(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::freeze_as(pre, post,
                            lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as freeze_as;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn internal(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::internal(pre, post, lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as internal;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn initialize(post: super::State,
                    persistent_map: StampedMap) {
                    ::builtin::requires(super::State::initialize(post,
                            persistent_map));
                    ::builtin::ensures(super::State::init(post));
                }
                use bool as initialize;
            }
            pub mod take_step {
                use super::*;
            }
            #[verus::internal(verus_macro)]
            impl State {
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn initialize(post: Self, persistent_map: StampedMap)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_stamped_map: StampedMap = persistent_map;

                        #[verifier::custom_err("cannot prove that final value of field `stamped_map` has this updated value")]
                        (::builtin::equal(post.stamped_map, update_tmp_stamped_map))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn initialize_enabled(persistent_map: StampedMap)
                    -> ::core::primitive::bool {
                    { true }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_stamped_map: StampedMap = pre.stamped_map;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_QueryLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(lbl.get_QueryLabel_end_lsn(),
                                                pre.stamped_map.seq_end)) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::equal(lbl.get_QueryLabel_value(),
                                                        pre.stamped_map.value.spec_index(lbl.get_QueryLabel_key()).get_Define_value()))
                                                &&
                                                #[verifier::custom_err("cannot prove that the field `stamped_map` is preserved")] (::builtin::equal(post.stamped_map,
                                                        update_tmp_stamped_map)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_strong(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_stamped_map: StampedMap = pre.stamped_map;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_QueryLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(lbl.get_QueryLabel_end_lsn(),
                                                pre.stamped_map.seq_end)) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::equal(lbl.get_QueryLabel_value(),
                                                        pre.stamped_map.value.spec_index(lbl.get_QueryLabel_key()).get_Define_value()))
                                                &&
                                                #[verifier::custom_err("cannot prove that the field `stamped_map` is preserved")] (::builtin::equal(post.stamped_map,
                                                        update_tmp_stamped_map)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_QueryLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(lbl.get_QueryLabel_end_lsn(),
                                                pre.stamped_map.seq_end)) &&
                                        #[verifier::custom_err("cannot prove this condition holds")] (::builtin::equal(lbl.get_QueryLabel_value(),
                                                pre.stamped_map.value.spec_index(lbl.get_QueryLabel_key()).get_Define_value()))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_PutLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (lbl.get_PutLabel_puts().can_follow(pre.stamped_map.seq_end))
                                        &&
                                        {
                                            let update_tmp_stamped_map: StampedMap =
                                                MsgHistory::map_plus_history(pre.stamped_map,
                                                    lbl.get_PutLabel_puts());

                                            #[verifier::custom_err("cannot prove that final value of field `stamped_map` has this updated value")]
                                            (::builtin::equal(post.stamped_map, update_tmp_stamped_map))
                                        }))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put_strong(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_PutLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (lbl.get_PutLabel_puts().can_follow(pre.stamped_map.seq_end))
                                        &&
                                        {
                                            let update_tmp_stamped_map: StampedMap =
                                                MsgHistory::map_plus_history(pre.stamped_map,
                                                    lbl.get_PutLabel_puts());

                                            #[verifier::custom_err("cannot prove that final value of field `stamped_map` has this updated value")]
                                            (::builtin::equal(post.stamped_map, update_tmp_stamped_map))
                                        }))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_PutLabel())
                                &&
                                #[verifier::custom_err("cannot prove this condition holds")] (lbl.get_PutLabel_puts().can_follow(pre.stamped_map.seq_end)))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn freeze_as(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_stamped_map: StampedMap = pre.stamped_map;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_FreezeAsLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::equal(lbl.get_FreezeAsLabel_stamped_map(),
                                                pre.stamped_map)) &&
                                        #[verifier::custom_err("cannot prove that the field `stamped_map` is preserved")] (::builtin::equal(post.stamped_map,
                                                update_tmp_stamped_map))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn freeze_as_strong(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_stamped_map: StampedMap = pre.stamped_map;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_FreezeAsLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::equal(lbl.get_FreezeAsLabel_stamped_map(),
                                                pre.stamped_map)) &&
                                        #[verifier::custom_err("cannot prove that the field `stamped_map` is preserved")] (::builtin::equal(post.stamped_map,
                                                update_tmp_stamped_map))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn freeze_as_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_FreezeAsLabel())
                                &&
                                #[verifier::custom_err("cannot prove this condition holds")] (::builtin::equal(lbl.get_FreezeAsLabel_stamped_map(),
                                        pre.stamped_map)))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_stamped_map: StampedMap = pre.stamped_map;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_InternalLabel())
                                &&
                                #[verifier::custom_err("cannot prove that the field `stamped_map` is preserved")] (::builtin::equal(post.stamped_map,
                                        update_tmp_stamped_map)))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_strong(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_stamped_map: StampedMap = pre.stamped_map;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_InternalLabel())
                                &&
                                #[verifier::custom_err("cannot prove that the field `stamped_map` is preserved")] (::builtin::equal(post.stamped_map,
                                        update_tmp_stamped_map)))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {

                        #[verifier::custom_err("cannot prove this condition holds")]
                        (lbl.is_InternalLabel())
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_by(pre: State, post: State, label: Label,
                    step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::query() => Self::query(pre, post, label),
                        Step::put() => Self::put(pre, post, label),
                        Step::freeze_as() => Self::freeze_as(pre, post, label),
                        Step::internal() => Self::internal(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next(pre: State, post: State, label: Label)
                    -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                            Self::next_by(pre, post, label, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_strong_by(pre: State, post: State, label: Label,
                    step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::query() => Self::query_strong(pre, post, label),
                        Step::put() => Self::put_strong(pre, post, label),
                        Step::freeze_as() =>
                            Self::freeze_as_strong(pre, post, label),
                        Step::internal() => Self::internal_strong(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_strong(pre: State, post: State, label: Label)
                    -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                            Self::next_strong_by(pre, post, label, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn init_by(post: State, step: Config)
                    -> ::core::primitive::bool {
                    match step {
                        Config::initialize(persistent_map) =>
                            Self::initialize(post, persistent_map),
                        Config::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn init(post: State) -> ::core::primitive::bool {
                    ::builtin::exists(|step: Config| Self::init_by(post, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::spec]
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                pub fn invariant(&self) -> ::core::primitive::bool { true }
            }
        }
    }
    pub mod AbstractCrashAwareJournal_v {
        #[allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        #[allow(unused_imports)]
        use vstd::map::*;
        use crate::spec::Option_t::*;
        use crate::abstract_system::StampedMap_v::*;
        use crate::abstract_system::MsgHistory_v::*;
        use crate::abstract_system::AbstractJournal_v::*;
        pub type StoreImage = MsgHistory;
        #[verus::internal(verus_macro)]
        pub enum Ephemeral {
            Unknown,
            Known {
                v: AbstractJournal::State,
            },
        }
        #[verus::internal(verus_macro)]
        #[cfg(verus_keep_ghost)]
        #[automatically_derived]
        impl Ephemeral {
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_Unknown(&self) -> bool {
                ::builtin::is_variant(self, "Unknown")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_Known(&self) -> bool {
                ::builtin::is_variant(self, "Known")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_Known_v(self) -> AbstractJournal::State {
                ::builtin::get_variant_field(self, "Known", "v")
            }
        }
        #[verus::internal(verus_macro)]
        impl Ephemeral {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                ::builtin::imply(self.is_Known(), self.get_Known_v().wf())
            }
        }
        #[allow(unused_parens)]
        pub mod CrashTolerantJournal {
            use super::*;
            #[verus::internal(verus_macro)]
            pub struct State {
                pub persistent: StoreImage,
                pub ephemeral: Ephemeral,
                pub in_flight: Option<StoreImage>,
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Step {
                load_ephemeral_from_persistent(AbstractJournal::State,
                    AbstractJournal::Config),
                read_for_recovery(),
                query_end_lsn(),
                put(AbstractJournal::State),
                internal(AbstractJournal::State),
                query_lsn_persistence(),
                commit_start(StoreImage, AbstractJournal::State),
                commit_complete(AbstractJournal::State),
                crash(),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Step {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_load_ephemeral_from_persistent(&self) -> bool {
                    ::builtin::is_variant(self,
                        "load_ephemeral_from_persistent")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_load_ephemeral_from_persistent_0(self)
                    -> AbstractJournal::State {
                    ::builtin::get_variant_field(self,
                        "load_ephemeral_from_persistent", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_load_ephemeral_from_persistent_1(self)
                    -> AbstractJournal::Config {
                    ::builtin::get_variant_field(self,
                        "load_ephemeral_from_persistent", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_read_for_recovery(&self) -> bool {
                    ::builtin::is_variant(self, "read_for_recovery")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_query_end_lsn(&self) -> bool {
                    ::builtin::is_variant(self, "query_end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_put(&self) -> bool {
                    ::builtin::is_variant(self, "put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_put_0(self) -> AbstractJournal::State {
                    ::builtin::get_variant_field(self, "put", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_internal(&self) -> bool {
                    ::builtin::is_variant(self, "internal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_0(self) -> AbstractJournal::State {
                    ::builtin::get_variant_field(self, "internal", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_query_lsn_persistence(&self) -> bool {
                    ::builtin::is_variant(self, "query_lsn_persistence")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_commit_start(&self) -> bool {
                    ::builtin::is_variant(self, "commit_start")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_commit_start_0(self) -> StoreImage {
                    ::builtin::get_variant_field(self, "commit_start", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_commit_start_1(self) -> AbstractJournal::State {
                    ::builtin::get_variant_field(self, "commit_start", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_commit_complete(&self) -> bool {
                    ::builtin::is_variant(self, "commit_complete")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_commit_complete_0(self) -> AbstractJournal::State {
                    ::builtin::get_variant_field(self, "commit_complete", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_crash(&self) -> bool {
                    ::builtin::is_variant(self, "crash")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Config { initialize(), dummy_to_use_type_params(State), }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Config {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_initialize(&self) -> bool {
                    ::builtin::is_variant(self, "initialize")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[verus::internal(verus_macro)]
            pub enum Label {
                LoadEphemeralFromPersistentLabel,
                ReadForRecoveryLabel {
                    records: MsgHistory,
                },
                QueryEndLsnLabel {
                    end_lsn: LSN,
                },
                PutLabel {
                    records: MsgHistory,
                },
                InternalLabel,
                QueryLsnPersistenceLabel {
                    sync_lsn: LSN,
                },
                CommitStartLabel {
                    new_boundary_lsn: LSN,
                    max_lsn: LSN,
                },
                CommitCompleteLabel {
                    require_end: LSN,
                },
                CrashLabel,
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Label {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_LoadEphemeralFromPersistentLabel(&self) -> bool {
                    ::builtin::is_variant(self,
                        "LoadEphemeralFromPersistentLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_ReadForRecoveryLabel(&self) -> bool {
                    ::builtin::is_variant(self, "ReadForRecoveryLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_ReadForRecoveryLabel_records(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "ReadForRecoveryLabel",
                        "records")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_QueryEndLsnLabel(&self) -> bool {
                    ::builtin::is_variant(self, "QueryEndLsnLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_QueryEndLsnLabel_end_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "QueryEndLsnLabel",
                        "end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_PutLabel(&self) -> bool {
                    ::builtin::is_variant(self, "PutLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_PutLabel_records(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "PutLabel", "records")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_InternalLabel(&self) -> bool {
                    ::builtin::is_variant(self, "InternalLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_QueryLsnPersistenceLabel(&self) -> bool {
                    ::builtin::is_variant(self, "QueryLsnPersistenceLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_QueryLsnPersistenceLabel_sync_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self,
                        "QueryLsnPersistenceLabel", "sync_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_CommitStartLabel(&self) -> bool {
                    ::builtin::is_variant(self, "CommitStartLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_CommitStartLabel_new_boundary_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "CommitStartLabel",
                        "new_boundary_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_CommitStartLabel_max_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "CommitStartLabel",
                        "max_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_CommitCompleteLabel(&self) -> bool {
                    ::builtin::is_variant(self, "CommitCompleteLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_CommitCompleteLabel_require_end(self) -> LSN {
                    ::builtin::get_variant_field(self, "CommitCompleteLabel",
                        "require_end")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_CrashLabel(&self) -> bool {
                    ::builtin::is_variant(self, "CrashLabel")
                }
            }
            pub mod show {
                use super::*;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn load_ephemeral_from_persistent(pre: super::State,
                    post: super::State, lbl: Label,
                    new_journal: AbstractJournal::State,
                    journal_config: AbstractJournal::Config) {
                    ::builtin::requires(super::State::load_ephemeral_from_persistent(pre,
                            post, lbl, new_journal, journal_config));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as load_ephemeral_from_persistent;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn read_for_recovery(pre: super::State,
                    post: super::State, lbl: Label) {
                    ::builtin::requires(super::State::read_for_recovery(pre,
                            post, lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as read_for_recovery;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn query_end_lsn(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::query_end_lsn(pre, post,
                            lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as query_end_lsn;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn put(pre: super::State, post: super::State, lbl: Label,
                    new_journal: AbstractJournal::State) {
                    ::builtin::requires(super::State::put(pre, post, lbl,
                            new_journal));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as put;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn internal(pre: super::State, post: super::State,
                    lbl: Label, new_journal: AbstractJournal::State) {
                    ::builtin::requires(super::State::internal(pre, post, lbl,
                            new_journal));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as internal;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn query_lsn_persistence(pre: super::State,
                    post: super::State, lbl: Label) {
                    ::builtin::requires(super::State::query_lsn_persistence(pre,
                            post, lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as query_lsn_persistence;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn commit_start(pre: super::State, post: super::State,
                    lbl: Label, frozen_journal: StoreImage,
                    new_journal: AbstractJournal::State) {
                    ::builtin::requires(super::State::commit_start(pre, post,
                            lbl, frozen_journal, new_journal));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as commit_start;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn commit_complete(pre: super::State, post: super::State,
                    lbl: Label, new_journal: AbstractJournal::State) {
                    ::builtin::requires(super::State::commit_complete(pre, post,
                            lbl, new_journal));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as commit_complete;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn crash(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::crash(pre, post, lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as crash;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn initialize(post: super::State) {
                    ::builtin::requires(super::State::initialize(post));
                    ::builtin::ensures(super::State::init(post));
                }
                use bool as initialize;
            }
            pub mod take_step {
                use super::*;
            }
            #[verus::internal(verus_macro)]
            impl State {
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn initialize(post: Self) -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage =
                            MsgHistory {
                                msgs: Map::empty(),
                                seq_start: ::builtin::spec_literal_integer("0"),
                                seq_end: ::builtin::spec_literal_integer("0"),
                            };
                        let update_tmp_ephemeral: Ephemeral = Ephemeral::Unknown;
                        let update_tmp_in_flight: Option<StoreImage> = Option::None;
                        (#[verifier::custom_err("cannot prove that final value of field `in_flight` has this updated value")] (::builtin::equal(post.in_flight,
                                        update_tmp_in_flight)) &&
                                (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                update_tmp_ephemeral)) &&
                                        #[verifier::custom_err("cannot prove that final value of field `persistent` has this updated value")] (::builtin::equal(post.persistent,
                                                update_tmp_persistent))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn initialize_enabled() -> ::core::primitive::bool {
                    { true }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn load_ephemeral_from_persistent(pre: Self, post: Self,
                    lbl: Label, new_journal: AbstractJournal::State,
                    journal_config: AbstractJournal::Config)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_LoadEphemeralFromPersistentLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Unknown())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::equal(journal_config,
                                                        AbstractJournal::Config::initialize(pre.persistent))) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (AbstractJournal::State::init_by(new_journal,
                                                                journal_config)) &&
                                                        {
                                                            let update_tmp_ephemeral: Ephemeral =
                                                                Ephemeral::Known { v: new_journal };
                                                            (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                            update_tmp_ephemeral)) &&
                                                                    (#[verifier::custom_err("cannot prove that the field `in_flight` is preserved")] (::builtin::equal(post.in_flight,
                                                                                    update_tmp_in_flight)) &&
                                                                            #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                                    update_tmp_persistent))))
                                                        }))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn load_ephemeral_from_persistent_strong(pre: Self,
                    post: Self, lbl: Label, new_journal: AbstractJournal::State,
                    journal_config: AbstractJournal::Config)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_LoadEphemeralFromPersistentLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Unknown())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::equal(journal_config,
                                                        AbstractJournal::Config::initialize(pre.persistent))) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (AbstractJournal::State::init_by(new_journal,
                                                                journal_config)) &&
                                                        {
                                                            let update_tmp_ephemeral: Ephemeral =
                                                                Ephemeral::Known { v: new_journal };
                                                            (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                            update_tmp_ephemeral)) &&
                                                                    (#[verifier::custom_err("cannot prove that the field `in_flight` is preserved")] (::builtin::equal(post.in_flight,
                                                                                    update_tmp_in_flight)) &&
                                                                            #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                                    update_tmp_persistent))))
                                                        }))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn load_ephemeral_from_persistent_enabled(pre: Self,
                    lbl: Label, new_journal: AbstractJournal::State,
                    journal_config: AbstractJournal::Config)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_LoadEphemeralFromPersistentLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Unknown())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::equal(journal_config,
                                                        AbstractJournal::Config::initialize(pre.persistent))) &&
                                                #[verifier::custom_err("cannot prove this condition holds")] (AbstractJournal::State::init_by(new_journal,
                                                        journal_config)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn read_for_recovery(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_ReadForRecoveryLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Known())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (AbstractJournal::State::next(pre.ephemeral.get_Known_v(),
                                                        pre.ephemeral.get_Known_v(),
                                                        AbstractJournal::Label::ReadForRecoveryLabel {
                                                            messages: lbl.get_ReadForRecoveryLabel_records(),
                                                        })) &&
                                                (#[verifier::custom_err("cannot prove that the field `in_flight` is preserved")] (::builtin::equal(post.in_flight,
                                                                update_tmp_in_flight)) &&
                                                        (#[verifier::custom_err("cannot prove that the field `ephemeral` is preserved")] (::builtin::equal(post.ephemeral,
                                                                        update_tmp_ephemeral)) &&
                                                                #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                        update_tmp_persistent)))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn read_for_recovery_strong(pre: Self, post: Self,
                    lbl: Label) -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_ReadForRecoveryLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Known())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (AbstractJournal::State::next(pre.ephemeral.get_Known_v(),
                                                        pre.ephemeral.get_Known_v(),
                                                        AbstractJournal::Label::ReadForRecoveryLabel {
                                                            messages: lbl.get_ReadForRecoveryLabel_records(),
                                                        })) &&
                                                (#[verifier::custom_err("cannot prove that the field `in_flight` is preserved")] (::builtin::equal(post.in_flight,
                                                                update_tmp_in_flight)) &&
                                                        (#[verifier::custom_err("cannot prove that the field `ephemeral` is preserved")] (::builtin::equal(post.ephemeral,
                                                                        update_tmp_ephemeral)) &&
                                                                #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                        update_tmp_persistent)))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn read_for_recovery_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_ReadForRecoveryLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Known())
                                        &&
                                        #[verifier::custom_err("cannot prove this condition holds")] (AbstractJournal::State::next(pre.ephemeral.get_Known_v(),
                                                pre.ephemeral.get_Known_v(),
                                                AbstractJournal::Label::ReadForRecoveryLabel {
                                                    messages: lbl.get_ReadForRecoveryLabel_records(),
                                                }))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_end_lsn(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_QueryEndLsnLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Known())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (AbstractJournal::State::next(pre.ephemeral.get_Known_v(),
                                                        pre.ephemeral.get_Known_v(),
                                                        AbstractJournal::Label::QueryEndLsnLabel {
                                                            end_lsn: lbl.get_QueryEndLsnLabel_end_lsn(),
                                                        })) &&
                                                (#[verifier::custom_err("cannot prove that the field `in_flight` is preserved")] (::builtin::equal(post.in_flight,
                                                                update_tmp_in_flight)) &&
                                                        (#[verifier::custom_err("cannot prove that the field `ephemeral` is preserved")] (::builtin::equal(post.ephemeral,
                                                                        update_tmp_ephemeral)) &&
                                                                #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                        update_tmp_persistent)))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_end_lsn_strong(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_QueryEndLsnLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Known())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (AbstractJournal::State::next(pre.ephemeral.get_Known_v(),
                                                        pre.ephemeral.get_Known_v(),
                                                        AbstractJournal::Label::QueryEndLsnLabel {
                                                            end_lsn: lbl.get_QueryEndLsnLabel_end_lsn(),
                                                        })) &&
                                                (#[verifier::custom_err("cannot prove that the field `in_flight` is preserved")] (::builtin::equal(post.in_flight,
                                                                update_tmp_in_flight)) &&
                                                        (#[verifier::custom_err("cannot prove that the field `ephemeral` is preserved")] (::builtin::equal(post.ephemeral,
                                                                        update_tmp_ephemeral)) &&
                                                                #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                        update_tmp_persistent)))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_end_lsn_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_QueryEndLsnLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Known())
                                        &&
                                        #[verifier::custom_err("cannot prove this condition holds")] (AbstractJournal::State::next(pre.ephemeral.get_Known_v(),
                                                pre.ephemeral.get_Known_v(),
                                                AbstractJournal::Label::QueryEndLsnLabel {
                                                    end_lsn: lbl.get_QueryEndLsnLabel_end_lsn(),
                                                }))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put(pre: Self, post: Self, lbl: Label,
                    new_journal: AbstractJournal::State)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_PutLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Known())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (AbstractJournal::State::next(pre.ephemeral.get_Known_v(),
                                                        new_journal,
                                                        AbstractJournal::Label::PutLabel {
                                                            messages: lbl.get_PutLabel_records(),
                                                        })) &&
                                                {
                                                    let update_tmp_ephemeral: Ephemeral =
                                                        Ephemeral::Known { v: new_journal };
                                                    (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                    update_tmp_ephemeral)) &&
                                                            (#[verifier::custom_err("cannot prove that the field `in_flight` is preserved")] (::builtin::equal(post.in_flight,
                                                                            update_tmp_in_flight)) &&
                                                                    #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                            update_tmp_persistent))))
                                                })))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put_strong(pre: Self, post: Self, lbl: Label,
                    new_journal: AbstractJournal::State)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_PutLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Known())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (AbstractJournal::State::next(pre.ephemeral.get_Known_v(),
                                                        new_journal,
                                                        AbstractJournal::Label::PutLabel {
                                                            messages: lbl.get_PutLabel_records(),
                                                        })) &&
                                                {
                                                    let update_tmp_ephemeral: Ephemeral =
                                                        Ephemeral::Known { v: new_journal };
                                                    (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                    update_tmp_ephemeral)) &&
                                                            (#[verifier::custom_err("cannot prove that the field `in_flight` is preserved")] (::builtin::equal(post.in_flight,
                                                                            update_tmp_in_flight)) &&
                                                                    #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                            update_tmp_persistent))))
                                                })))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put_enabled(pre: Self, lbl: Label,
                    new_journal: AbstractJournal::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_PutLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Known())
                                        &&
                                        #[verifier::custom_err("cannot prove this condition holds")] (AbstractJournal::State::next(pre.ephemeral.get_Known_v(),
                                                new_journal,
                                                AbstractJournal::Label::PutLabel {
                                                    messages: lbl.get_PutLabel_records(),
                                                }))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal(pre: Self, post: Self, lbl: Label,
                    new_journal: AbstractJournal::State)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_InternalLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Known())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (AbstractJournal::State::next(pre.ephemeral.get_Known_v(),
                                                        new_journal, AbstractJournal::Label::InternalLabel)) &&
                                                {
                                                    let update_tmp_ephemeral: Ephemeral =
                                                        Ephemeral::Known { v: new_journal };
                                                    (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                    update_tmp_ephemeral)) &&
                                                            (#[verifier::custom_err("cannot prove that the field `in_flight` is preserved")] (::builtin::equal(post.in_flight,
                                                                            update_tmp_in_flight)) &&
                                                                    #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                            update_tmp_persistent))))
                                                })))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_strong(pre: Self, post: Self, lbl: Label,
                    new_journal: AbstractJournal::State)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_InternalLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Known())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (AbstractJournal::State::next(pre.ephemeral.get_Known_v(),
                                                        new_journal, AbstractJournal::Label::InternalLabel)) &&
                                                {
                                                    let update_tmp_ephemeral: Ephemeral =
                                                        Ephemeral::Known { v: new_journal };
                                                    (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                    update_tmp_ephemeral)) &&
                                                            (#[verifier::custom_err("cannot prove that the field `in_flight` is preserved")] (::builtin::equal(post.in_flight,
                                                                            update_tmp_in_flight)) &&
                                                                    #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                            update_tmp_persistent))))
                                                })))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_enabled(pre: Self, lbl: Label,
                    new_journal: AbstractJournal::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_InternalLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Known())
                                        &&
                                        #[verifier::custom_err("cannot prove this condition holds")] (AbstractJournal::State::next(pre.ephemeral.get_Known_v(),
                                                new_journal, AbstractJournal::Label::InternalLabel))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_lsn_persistence(pre: Self, post: Self,
                    lbl: Label) -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_QueryLsnPersistenceLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] ((lbl.get_QueryLsnPersistenceLabel_sync_lsn()).spec_le(pre.persistent.seq_end))
                                        &&
                                        (#[verifier::custom_err("cannot prove that the field `in_flight` is preserved")] (::builtin::equal(post.in_flight,
                                                        update_tmp_in_flight)) &&
                                                (#[verifier::custom_err("cannot prove that the field `ephemeral` is preserved")] (::builtin::equal(post.ephemeral,
                                                                update_tmp_ephemeral)) &&
                                                        #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                update_tmp_persistent))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_lsn_persistence_strong(pre: Self, post: Self,
                    lbl: Label) -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_QueryLsnPersistenceLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] ((lbl.get_QueryLsnPersistenceLabel_sync_lsn()).spec_le(pre.persistent.seq_end))
                                        &&
                                        (#[verifier::custom_err("cannot prove that the field `in_flight` is preserved")] (::builtin::equal(post.in_flight,
                                                        update_tmp_in_flight)) &&
                                                (#[verifier::custom_err("cannot prove that the field `ephemeral` is preserved")] (::builtin::equal(post.ephemeral,
                                                                update_tmp_ephemeral)) &&
                                                        #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                update_tmp_persistent))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_lsn_persistence_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_QueryLsnPersistenceLabel())
                                &&
                                #[verifier::custom_err("cannot prove this condition holds")] ((lbl.get_QueryLsnPersistenceLabel_sync_lsn()).spec_le(pre.persistent.seq_end)))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn commit_start(pre: Self, post: Self, lbl: Label,
                    frozen_journal: StoreImage,
                    new_journal: AbstractJournal::State)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_CommitStartLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Known())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.in_flight.is_None())
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (frozen_journal.wf())
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(frozen_journal.seq_start,
                                                                        lbl.get_CommitStartLabel_new_boundary_lsn())) &&
                                                                (#[verifier::custom_err("cannot prove this condition holds")] ((pre.persistent.seq_end).spec_le(frozen_journal.seq_end))
                                                                        &&
                                                                        (#[verifier::custom_err("cannot prove this condition holds")] ((frozen_journal.seq_start).spec_le(lbl.get_CommitStartLabel_max_lsn()))
                                                                                &&
                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (AbstractJournal::State::next(pre.ephemeral.get_Known_v(),
                                                                                                new_journal,
                                                                                                AbstractJournal::Label::FreezeForCommitLabel {
                                                                                                    frozen_journal: frozen_journal,
                                                                                                })) &&
                                                                                        {
                                                                                            let update_tmp_ephemeral: Ephemeral =
                                                                                                Ephemeral::Known { v: new_journal };
                                                                                            let update_tmp_in_flight: Option<StoreImage> =
                                                                                                Option::Some(frozen_journal);
                                                                                            (#[verifier::custom_err("cannot prove that final value of field `in_flight` has this updated value")] (::builtin::equal(post.in_flight,
                                                                                                            update_tmp_in_flight)) &&
                                                                                                    (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                                                                    update_tmp_ephemeral)) &&
                                                                                                            #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                                                                    update_tmp_persistent))))
                                                                                        }))))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn commit_start_strong(pre: Self, post: Self, lbl: Label,
                    frozen_journal: StoreImage,
                    new_journal: AbstractJournal::State)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_CommitStartLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Known())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.in_flight.is_None())
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (frozen_journal.wf())
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(frozen_journal.seq_start,
                                                                        lbl.get_CommitStartLabel_new_boundary_lsn())) &&
                                                                (#[verifier::custom_err("cannot prove this condition holds")] ((pre.persistent.seq_end).spec_le(frozen_journal.seq_end))
                                                                        &&
                                                                        (#[verifier::custom_err("cannot prove this condition holds")] ((frozen_journal.seq_start).spec_le(lbl.get_CommitStartLabel_max_lsn()))
                                                                                &&
                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (AbstractJournal::State::next(pre.ephemeral.get_Known_v(),
                                                                                                new_journal,
                                                                                                AbstractJournal::Label::FreezeForCommitLabel {
                                                                                                    frozen_journal: frozen_journal,
                                                                                                })) &&
                                                                                        {
                                                                                            let update_tmp_ephemeral: Ephemeral =
                                                                                                Ephemeral::Known { v: new_journal };
                                                                                            let update_tmp_in_flight: Option<StoreImage> =
                                                                                                Option::Some(frozen_journal);
                                                                                            (#[verifier::custom_err("cannot prove that final value of field `in_flight` has this updated value")] (::builtin::equal(post.in_flight,
                                                                                                            update_tmp_in_flight)) &&
                                                                                                    (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                                                                    update_tmp_ephemeral)) &&
                                                                                                            #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                                                                    update_tmp_persistent))))
                                                                                        }))))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn commit_start_enabled(pre: Self, lbl: Label,
                    frozen_journal: StoreImage,
                    new_journal: AbstractJournal::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_CommitStartLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Known())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.in_flight.is_None())
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (frozen_journal.wf())
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(frozen_journal.seq_start,
                                                                        lbl.get_CommitStartLabel_new_boundary_lsn())) &&
                                                                (#[verifier::custom_err("cannot prove this condition holds")] ((pre.persistent.seq_end).spec_le(frozen_journal.seq_end))
                                                                        &&
                                                                        (#[verifier::custom_err("cannot prove this condition holds")] ((frozen_journal.seq_start).spec_le(lbl.get_CommitStartLabel_max_lsn()))
                                                                                &&
                                                                                #[verifier::custom_err("cannot prove this condition holds")] (AbstractJournal::State::next(pre.ephemeral.get_Known_v(),
                                                                                        new_journal,
                                                                                        AbstractJournal::Label::FreezeForCommitLabel {
                                                                                            frozen_journal: frozen_journal,
                                                                                        })))))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn commit_complete(pre: Self, post: Self, lbl: Label,
                    new_journal: AbstractJournal::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_CommitCompleteLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Known())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.in_flight.is_Some())
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (AbstractJournal::State::next(pre.ephemeral.get_Known_v(),
                                                                new_journal,
                                                                AbstractJournal::Label::DiscardOldLabel {
                                                                    start_lsn: pre.in_flight.get_Some_0().seq_start,
                                                                    require_end: lbl.get_CommitCompleteLabel_require_end(),
                                                                })) &&
                                                        {
                                                            let update_tmp_persistent: StoreImage =
                                                                pre.in_flight.get_Some_0();
                                                            let update_tmp_ephemeral: Ephemeral =
                                                                Ephemeral::Known { v: new_journal };
                                                            let update_tmp_in_flight: Option<StoreImage> = Option::None;
                                                            (#[verifier::custom_err("cannot prove that final value of field `in_flight` has this updated value")] (::builtin::equal(post.in_flight,
                                                                            update_tmp_in_flight)) &&
                                                                    (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                                    update_tmp_ephemeral)) &&
                                                                            #[verifier::custom_err("cannot prove that final value of field `persistent` has this updated value")] (::builtin::equal(post.persistent,
                                                                                    update_tmp_persistent))))
                                                        }))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn commit_complete_strong(pre: Self, post: Self,
                    lbl: Label, new_journal: AbstractJournal::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_CommitCompleteLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Known())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.in_flight.is_Some())
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (AbstractJournal::State::next(pre.ephemeral.get_Known_v(),
                                                                new_journal,
                                                                AbstractJournal::Label::DiscardOldLabel {
                                                                    start_lsn: pre.in_flight.get_Some_0().seq_start,
                                                                    require_end: lbl.get_CommitCompleteLabel_require_end(),
                                                                })) &&
                                                        {
                                                            let update_tmp_persistent: StoreImage =
                                                                pre.in_flight.get_Some_0();
                                                            let update_tmp_ephemeral: Ephemeral =
                                                                Ephemeral::Known { v: new_journal };
                                                            let update_tmp_in_flight: Option<StoreImage> = Option::None;
                                                            (#[verifier::custom_err("cannot prove that final value of field `in_flight` has this updated value")] (::builtin::equal(post.in_flight,
                                                                            update_tmp_in_flight)) &&
                                                                    (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                                    update_tmp_ephemeral)) &&
                                                                            #[verifier::custom_err("cannot prove that final value of field `persistent` has this updated value")] (::builtin::equal(post.persistent,
                                                                                    update_tmp_persistent))))
                                                        }))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn commit_complete_enabled(pre: Self, lbl: Label,
                    new_journal: AbstractJournal::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_CommitCompleteLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Known())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.in_flight.is_Some())
                                                &&
                                                #[verifier::custom_err("cannot prove this condition holds")] (AbstractJournal::State::next(pre.ephemeral.get_Known_v(),
                                                        new_journal,
                                                        AbstractJournal::Label::DiscardOldLabel {
                                                            start_lsn: pre.in_flight.get_Some_0().seq_start,
                                                            require_end: lbl.get_CommitCompleteLabel_require_end(),
                                                        })))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn crash(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_CrashLabel())
                                &&
                                {
                                    let update_tmp_ephemeral: Ephemeral = Ephemeral::Unknown;
                                    let update_tmp_in_flight: Option<StoreImage> = Option::None;
                                    (#[verifier::custom_err("cannot prove that final value of field `in_flight` has this updated value")] (::builtin::equal(post.in_flight,
                                                    update_tmp_in_flight)) &&
                                            (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                            update_tmp_ephemeral)) &&
                                                    #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                            update_tmp_persistent))))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn crash_strong(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_CrashLabel())
                                &&
                                {
                                    let update_tmp_ephemeral: Ephemeral = Ephemeral::Unknown;
                                    let update_tmp_in_flight: Option<StoreImage> = Option::None;
                                    (#[verifier::custom_err("cannot prove that final value of field `in_flight` has this updated value")] (::builtin::equal(post.in_flight,
                                                    update_tmp_in_flight)) &&
                                            (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                            update_tmp_ephemeral)) &&
                                                    #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                            update_tmp_persistent))))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn crash_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {

                        #[verifier::custom_err("cannot prove this condition holds")]
                        (lbl.is_CrashLabel())
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_by(pre: State, post: State, label: Label,
                    step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::load_ephemeral_from_persistent(new_journal,
                            journal_config) =>
                            Self::load_ephemeral_from_persistent(pre, post, label,
                                new_journal, journal_config),
                        Step::read_for_recovery() =>
                            Self::read_for_recovery(pre, post, label),
                        Step::query_end_lsn() =>
                            Self::query_end_lsn(pre, post, label),
                        Step::put(new_journal) =>
                            Self::put(pre, post, label, new_journal),
                        Step::internal(new_journal) =>
                            Self::internal(pre, post, label, new_journal),
                        Step::query_lsn_persistence() =>
                            Self::query_lsn_persistence(pre, post, label),
                        Step::commit_start(frozen_journal, new_journal) =>
                            Self::commit_start(pre, post, label, frozen_journal,
                                new_journal),
                        Step::commit_complete(new_journal) =>
                            Self::commit_complete(pre, post, label, new_journal),
                        Step::crash() => Self::crash(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next(pre: State, post: State, label: Label)
                    -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                            Self::next_by(pre, post, label, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_strong_by(pre: State, post: State, label: Label,
                    step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::load_ephemeral_from_persistent(new_journal,
                            journal_config) =>
                            Self::load_ephemeral_from_persistent_strong(pre, post,
                                label, new_journal, journal_config),
                        Step::read_for_recovery() =>
                            Self::read_for_recovery_strong(pre, post, label),
                        Step::query_end_lsn() =>
                            Self::query_end_lsn_strong(pre, post, label),
                        Step::put(new_journal) =>
                            Self::put_strong(pre, post, label, new_journal),
                        Step::internal(new_journal) =>
                            Self::internal_strong(pre, post, label, new_journal),
                        Step::query_lsn_persistence() =>
                            Self::query_lsn_persistence_strong(pre, post, label),
                        Step::commit_start(frozen_journal, new_journal) =>
                            Self::commit_start_strong(pre, post, label, frozen_journal,
                                new_journal),
                        Step::commit_complete(new_journal) =>
                            Self::commit_complete_strong(pre, post, label, new_journal),
                        Step::crash() => Self::crash_strong(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_strong(pre: State, post: State, label: Label)
                    -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                            Self::next_strong_by(pre, post, label, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn init_by(post: State, step: Config)
                    -> ::core::primitive::bool {
                    match step {
                        Config::initialize() => Self::initialize(post),
                        Config::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn init(post: State) -> ::core::primitive::bool {
                    ::builtin::exists(|step: Config| Self::init_by(post, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::spec]
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                pub fn invariant(&self) -> ::core::primitive::bool { true }
            }
        }
    }
    pub mod AbstractCrashAwareMap_v {
        /// An AbstractMap (see `AbstractMap_v.rs`) but wrapped with the concept of crashes and recovery.
        /// We use this as the abstract crash tolerant map which is coordinated with the
        /// CrashAwareJournal in the coordination layer in our refinement proof.
        #[allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        #[allow(unused_imports)]
        use vstd::map::*;
        use crate::spec::Option_t::*;
        use crate::spec::KeyType_t::*;
        use crate::spec::Messages_t::*;
        use crate::abstract_system::StampedMap_v::*;
        use crate::abstract_system::MsgHistory_v::*;
        use crate::abstract_system::AbstractMap_v::*;
        type StoreImage = StampedMap;
        #[doc =
        " Ephemeral state of crash aware map is the ephemeral (not crash-tolerant)"]
        #[doc = " view of the map."]
        #[verus::internal(verus_macro)]
        pub enum Ephemeral {
            Unknown,
            Known {
                v: AbstractMap::State,
            },
        }
        #[verus::internal(verus_macro)]
        #[cfg(verus_keep_ghost)]
        #[automatically_derived]
        impl Ephemeral {
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_Unknown(&self) -> bool {
                ::builtin::is_variant(self, "Unknown")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_Known(&self) -> bool {
                ::builtin::is_variant(self, "Known")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_Known_v(self) -> AbstractMap::State {
                ::builtin::get_variant_field(self, "Known", "v")
            }
        }
        #[allow(unused_parens)]
        pub mod CrashTolerantMap {
            use super::*;
            #[verus::internal(verus_macro)]
            pub struct State {
                pub persistent: StoreImage,
                pub ephemeral: Ephemeral,
                pub in_flight: Option<StoreImage>,
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Step {
                load_ephemeral_from_persistent(),
                put_records(AbstractMap::State),
                query(AbstractMap::State),
                freeze_map_internal(StampedMap, AbstractMap::State),
                ephemeral_internal(AbstractMap::State),
                commit_start(),
                commit_complete(),
                crash(),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Step {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_load_ephemeral_from_persistent(&self) -> bool {
                    ::builtin::is_variant(self,
                        "load_ephemeral_from_persistent")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_put_records(&self) -> bool {
                    ::builtin::is_variant(self, "put_records")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_put_records_0(self) -> AbstractMap::State {
                    ::builtin::get_variant_field(self, "put_records", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_query(&self) -> bool {
                    ::builtin::is_variant(self, "query")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_query_0(self) -> AbstractMap::State {
                    ::builtin::get_variant_field(self, "query", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_freeze_map_internal(&self) -> bool {
                    ::builtin::is_variant(self, "freeze_map_internal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_freeze_map_internal_0(self) -> StampedMap {
                    ::builtin::get_variant_field(self, "freeze_map_internal",
                        "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_freeze_map_internal_1(self) -> AbstractMap::State {
                    ::builtin::get_variant_field(self, "freeze_map_internal",
                        "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_ephemeral_internal(&self) -> bool {
                    ::builtin::is_variant(self, "ephemeral_internal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_ephemeral_internal_0(self) -> AbstractMap::State {
                    ::builtin::get_variant_field(self, "ephemeral_internal",
                        "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_commit_start(&self) -> bool {
                    ::builtin::is_variant(self, "commit_start")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_commit_complete(&self) -> bool {
                    ::builtin::is_variant(self, "commit_complete")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_crash(&self) -> bool {
                    ::builtin::is_variant(self, "crash")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Config { initialize(), dummy_to_use_type_params(State), }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Config {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_initialize(&self) -> bool {
                    ::builtin::is_variant(self, "initialize")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[verus::internal(verus_macro)]
            pub enum Label {
                LoadEphemeralFromPersistentLabel {
                    end_lsn: LSN,
                },
                PutRecordsLabel {
                    records: MsgHistory,
                },
                QueryLabel {
                    end_lsn: LSN,
                    key: Key,
                    value: Value,
                },
                InternalLabel,
                CommitStartLabel {
                    new_boundary_lsn: LSN,
                },
                CommitCompleteLabel,
                CrashLabel,
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Label {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_LoadEphemeralFromPersistentLabel(&self) -> bool {
                    ::builtin::is_variant(self,
                        "LoadEphemeralFromPersistentLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_LoadEphemeralFromPersistentLabel_end_lsn(self)
                    -> LSN {
                    ::builtin::get_variant_field(self,
                        "LoadEphemeralFromPersistentLabel", "end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_PutRecordsLabel(&self) -> bool {
                    ::builtin::is_variant(self, "PutRecordsLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_PutRecordsLabel_records(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "PutRecordsLabel",
                        "records")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_QueryLabel(&self) -> bool {
                    ::builtin::is_variant(self, "QueryLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_QueryLabel_end_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "QueryLabel", "end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_QueryLabel_key(self) -> Key {
                    ::builtin::get_variant_field(self, "QueryLabel", "key")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_QueryLabel_value(self) -> Value {
                    ::builtin::get_variant_field(self, "QueryLabel", "value")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_InternalLabel(&self) -> bool {
                    ::builtin::is_variant(self, "InternalLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_CommitStartLabel(&self) -> bool {
                    ::builtin::is_variant(self, "CommitStartLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_CommitStartLabel_new_boundary_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "CommitStartLabel",
                        "new_boundary_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_CommitCompleteLabel(&self) -> bool {
                    ::builtin::is_variant(self, "CommitCompleteLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_CrashLabel(&self) -> bool {
                    ::builtin::is_variant(self, "CrashLabel")
                }
            }
            pub mod show {
                use super::*;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn load_ephemeral_from_persistent(pre: super::State,
                    post: super::State, lbl: Label) {
                    ::builtin::requires(super::State::load_ephemeral_from_persistent(pre,
                            post, lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as load_ephemeral_from_persistent;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn put_records(pre: super::State, post: super::State,
                    lbl: Label, new_map: AbstractMap::State) {
                    ::builtin::requires(super::State::put_records(pre, post,
                            lbl, new_map));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as put_records;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn query(pre: super::State, post: super::State,
                    lbl: Label, new_map: AbstractMap::State) {
                    ::builtin::requires(super::State::query(pre, post, lbl,
                            new_map));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as query;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn freeze_map_internal(pre: super::State,
                    post: super::State, lbl: Label, frozen_map: StampedMap,
                    new_map: AbstractMap::State) {
                    ::builtin::requires(super::State::freeze_map_internal(pre,
                            post, lbl, frozen_map, new_map));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as freeze_map_internal;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn ephemeral_internal(pre: super::State,
                    post: super::State, lbl: Label,
                    new_map: AbstractMap::State) {
                    ::builtin::requires(super::State::ephemeral_internal(pre,
                            post, lbl, new_map));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as ephemeral_internal;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn commit_start(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::commit_start(pre, post,
                            lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as commit_start;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn commit_complete(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::commit_complete(pre, post,
                            lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as commit_complete;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn crash(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::crash(pre, post, lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as crash;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn initialize(post: super::State) {
                    ::builtin::requires(super::State::initialize(post));
                    ::builtin::ensures(super::State::init(post));
                }
                use bool as initialize;
            }
            pub mod take_step {
                use super::*;
            }
            #[verus::internal(verus_macro)]
            impl State {
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn initialize(post: Self) -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = empty();
                        let update_tmp_ephemeral: Ephemeral = Ephemeral::Unknown;
                        let update_tmp_in_flight: Option<StoreImage> = Option::None;
                        (#[verifier::custom_err("cannot prove that final value of field `in_flight` has this updated value")] (::builtin::equal(post.in_flight,
                                        update_tmp_in_flight)) &&
                                (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                update_tmp_ephemeral)) &&
                                        #[verifier::custom_err("cannot prove that final value of field `persistent` has this updated value")] (::builtin::equal(post.persistent,
                                                update_tmp_persistent))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn initialize_enabled() -> ::core::primitive::bool {
                    { true }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn load_ephemeral_from_persistent(pre: Self, post: Self,
                    lbl: Label) -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_LoadEphemeralFromPersistentLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Unknown())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(lbl.get_LoadEphemeralFromPersistentLabel_end_lsn(),
                                                        pre.persistent.seq_end)) &&
                                                (({
                                                                let new_abstract_map =
                                                                    AbstractMap::State { stamped_map: pre.persistent };
                                                                (#[verifier::custom_err("cannot prove this condition holds")] (AbstractMap::State::init_by(new_abstract_map,
                                                                                AbstractMap::Config::initialize(pre.persistent))) &&
                                                                        {
                                                                            let update_tmp_ephemeral: Ephemeral =
                                                                                Ephemeral::Known { v: new_abstract_map };

                                                                            #[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")]
                                                                            (::builtin::equal(post.ephemeral, update_tmp_ephemeral))
                                                                        })
                                                            }) &&
                                                        ((#[verifier::custom_err("cannot prove that the field `in_flight` is preserved")] (::builtin::equal(post.in_flight,
                                                                            update_tmp_in_flight)) &&
                                                                    #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                            update_tmp_persistent))))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn load_ephemeral_from_persistent_strong(pre: Self,
                    post: Self, lbl: Label) -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_LoadEphemeralFromPersistentLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Unknown())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(lbl.get_LoadEphemeralFromPersistentLabel_end_lsn(),
                                                        pre.persistent.seq_end)) &&
                                                (({
                                                                let new_abstract_map =
                                                                    AbstractMap::State { stamped_map: pre.persistent };
                                                                (#[verifier::custom_err("cannot prove this condition holds")] (AbstractMap::State::init_by(new_abstract_map,
                                                                                AbstractMap::Config::initialize(pre.persistent))) &&
                                                                        {
                                                                            let update_tmp_ephemeral: Ephemeral =
                                                                                Ephemeral::Known { v: new_abstract_map };

                                                                            #[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")]
                                                                            (::builtin::equal(post.ephemeral, update_tmp_ephemeral))
                                                                        })
                                                            }) &&
                                                        ((#[verifier::custom_err("cannot prove that the field `in_flight` is preserved")] (::builtin::equal(post.in_flight,
                                                                            update_tmp_in_flight)) &&
                                                                    #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                            update_tmp_persistent))))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn load_ephemeral_from_persistent_enabled(pre: Self,
                    lbl: Label) -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_LoadEphemeralFromPersistentLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Unknown())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(lbl.get_LoadEphemeralFromPersistentLabel_end_lsn(),
                                                        pre.persistent.seq_end)) &&
                                                {
                                                    let new_abstract_map =
                                                        AbstractMap::State { stamped_map: pre.persistent };

                                                    #[verifier::custom_err("cannot prove this condition holds")]
                                                    (AbstractMap::State::init_by(new_abstract_map,
                                                            AbstractMap::Config::initialize(pre.persistent)))
                                                })))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put_records(pre: Self, post: Self, lbl: Label,
                    new_map: AbstractMap::State) -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_PutRecordsLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Known())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (AbstractMap::State::next(pre.ephemeral.get_Known_v(),
                                                        new_map,
                                                        AbstractMap::Label::PutLabel {
                                                            puts: lbl.get_PutRecordsLabel_records(),
                                                        })) &&
                                                {
                                                    let update_tmp_ephemeral: Ephemeral =
                                                        Ephemeral::Known { v: new_map };
                                                    (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                    update_tmp_ephemeral)) &&
                                                            (#[verifier::custom_err("cannot prove that the field `in_flight` is preserved")] (::builtin::equal(post.in_flight,
                                                                            update_tmp_in_flight)) &&
                                                                    #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                            update_tmp_persistent))))
                                                })))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put_records_strong(pre: Self, post: Self, lbl: Label,
                    new_map: AbstractMap::State) -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_PutRecordsLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Known())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (AbstractMap::State::next(pre.ephemeral.get_Known_v(),
                                                        new_map,
                                                        AbstractMap::Label::PutLabel {
                                                            puts: lbl.get_PutRecordsLabel_records(),
                                                        })) &&
                                                {
                                                    let update_tmp_ephemeral: Ephemeral =
                                                        Ephemeral::Known { v: new_map };
                                                    (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                    update_tmp_ephemeral)) &&
                                                            (#[verifier::custom_err("cannot prove that the field `in_flight` is preserved")] (::builtin::equal(post.in_flight,
                                                                            update_tmp_in_flight)) &&
                                                                    #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                            update_tmp_persistent))))
                                                })))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put_records_enabled(pre: Self, lbl: Label,
                    new_map: AbstractMap::State) -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_PutRecordsLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Known())
                                        &&
                                        #[verifier::custom_err("cannot prove this condition holds")] (AbstractMap::State::next(pre.ephemeral.get_Known_v(),
                                                new_map,
                                                AbstractMap::Label::PutLabel {
                                                    puts: lbl.get_PutRecordsLabel_records(),
                                                }))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query(pre: Self, post: Self, lbl: Label,
                    new_map: AbstractMap::State) -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_QueryLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Known())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (AbstractMap::State::next(pre.ephemeral.get_Known_v(),
                                                        new_map,
                                                        AbstractMap::Label::QueryLabel {
                                                            end_lsn: lbl.get_QueryLabel_end_lsn(),
                                                            key: lbl.get_QueryLabel_key(),
                                                            value: lbl.get_QueryLabel_value(),
                                                        })) &&
                                                (#[verifier::custom_err("cannot prove that the field `in_flight` is preserved")] (::builtin::equal(post.in_flight,
                                                                update_tmp_in_flight)) &&
                                                        (#[verifier::custom_err("cannot prove that the field `ephemeral` is preserved")] (::builtin::equal(post.ephemeral,
                                                                        update_tmp_ephemeral)) &&
                                                                #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                        update_tmp_persistent)))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_strong(pre: Self, post: Self, lbl: Label,
                    new_map: AbstractMap::State) -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_QueryLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Known())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (AbstractMap::State::next(pre.ephemeral.get_Known_v(),
                                                        new_map,
                                                        AbstractMap::Label::QueryLabel {
                                                            end_lsn: lbl.get_QueryLabel_end_lsn(),
                                                            key: lbl.get_QueryLabel_key(),
                                                            value: lbl.get_QueryLabel_value(),
                                                        })) &&
                                                (#[verifier::custom_err("cannot prove that the field `in_flight` is preserved")] (::builtin::equal(post.in_flight,
                                                                update_tmp_in_flight)) &&
                                                        (#[verifier::custom_err("cannot prove that the field `ephemeral` is preserved")] (::builtin::equal(post.ephemeral,
                                                                        update_tmp_ephemeral)) &&
                                                                #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                        update_tmp_persistent)))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_enabled(pre: Self, lbl: Label,
                    new_map: AbstractMap::State) -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_QueryLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Known())
                                        &&
                                        #[verifier::custom_err("cannot prove this condition holds")] (AbstractMap::State::next(pre.ephemeral.get_Known_v(),
                                                new_map,
                                                AbstractMap::Label::QueryLabel {
                                                    end_lsn: lbl.get_QueryLabel_end_lsn(),
                                                    key: lbl.get_QueryLabel_key(),
                                                    value: lbl.get_QueryLabel_value(),
                                                }))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn freeze_map_internal(pre: Self, post: Self, lbl: Label,
                    frozen_map: StampedMap, new_map: AbstractMap::State)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_InternalLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Known())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.in_flight.is_None())
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (AbstractMap::State::next(pre.ephemeral.get_Known_v(),
                                                                new_map,
                                                                AbstractMap::Label::FreezeAsLabel {
                                                                    stamped_map: frozen_map,
                                                                })) &&
                                                        {
                                                            let update_tmp_ephemeral: Ephemeral =
                                                                Ephemeral::Known { v: new_map };
                                                            let update_tmp_in_flight: Option<StoreImage> =
                                                                Option::Some(frozen_map);
                                                            (#[verifier::custom_err("cannot prove that final value of field `in_flight` has this updated value")] (::builtin::equal(post.in_flight,
                                                                            update_tmp_in_flight)) &&
                                                                    (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                                    update_tmp_ephemeral)) &&
                                                                            #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                                    update_tmp_persistent))))
                                                        }))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn freeze_map_internal_strong(pre: Self, post: Self,
                    lbl: Label, frozen_map: StampedMap,
                    new_map: AbstractMap::State) -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_InternalLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Known())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.in_flight.is_None())
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (AbstractMap::State::next(pre.ephemeral.get_Known_v(),
                                                                new_map,
                                                                AbstractMap::Label::FreezeAsLabel {
                                                                    stamped_map: frozen_map,
                                                                })) &&
                                                        {
                                                            let update_tmp_ephemeral: Ephemeral =
                                                                Ephemeral::Known { v: new_map };
                                                            let update_tmp_in_flight: Option<StoreImage> =
                                                                Option::Some(frozen_map);
                                                            (#[verifier::custom_err("cannot prove that final value of field `in_flight` has this updated value")] (::builtin::equal(post.in_flight,
                                                                            update_tmp_in_flight)) &&
                                                                    (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                                    update_tmp_ephemeral)) &&
                                                                            #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                                    update_tmp_persistent))))
                                                        }))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn freeze_map_internal_enabled(pre: Self, lbl: Label,
                    frozen_map: StampedMap, new_map: AbstractMap::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_InternalLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Known())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.in_flight.is_None())
                                                &&
                                                #[verifier::custom_err("cannot prove this condition holds")] (AbstractMap::State::next(pre.ephemeral.get_Known_v(),
                                                        new_map,
                                                        AbstractMap::Label::FreezeAsLabel {
                                                            stamped_map: frozen_map,
                                                        })))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn ephemeral_internal(pre: Self, post: Self, lbl: Label,
                    new_map: AbstractMap::State) -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_InternalLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Known())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (AbstractMap::State::next(pre.ephemeral.get_Known_v(),
                                                        new_map, AbstractMap::Label::InternalLabel)) &&
                                                {
                                                    let update_tmp_ephemeral: Ephemeral =
                                                        Ephemeral::Known { v: new_map };
                                                    (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                    update_tmp_ephemeral)) &&
                                                            (#[verifier::custom_err("cannot prove that the field `in_flight` is preserved")] (::builtin::equal(post.in_flight,
                                                                            update_tmp_in_flight)) &&
                                                                    #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                            update_tmp_persistent))))
                                                })))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn ephemeral_internal_strong(pre: Self, post: Self,
                    lbl: Label, new_map: AbstractMap::State)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_InternalLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Known())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (AbstractMap::State::next(pre.ephemeral.get_Known_v(),
                                                        new_map, AbstractMap::Label::InternalLabel)) &&
                                                {
                                                    let update_tmp_ephemeral: Ephemeral =
                                                        Ephemeral::Known { v: new_map };
                                                    (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                    update_tmp_ephemeral)) &&
                                                            (#[verifier::custom_err("cannot prove that the field `in_flight` is preserved")] (::builtin::equal(post.in_flight,
                                                                            update_tmp_in_flight)) &&
                                                                    #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                            update_tmp_persistent))))
                                                })))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn ephemeral_internal_enabled(pre: Self, lbl: Label,
                    new_map: AbstractMap::State) -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_InternalLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Known())
                                        &&
                                        #[verifier::custom_err("cannot prove this condition holds")] (AbstractMap::State::next(pre.ephemeral.get_Known_v(),
                                                new_map, AbstractMap::Label::InternalLabel))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn commit_start(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_CommitStartLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Known())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.in_flight.is_Some())
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] ((pre.persistent.seq_end).spec_le(lbl.get_CommitStartLabel_new_boundary_lsn()))
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(lbl.get_CommitStartLabel_new_boundary_lsn(),
                                                                        pre.in_flight.get_Some_0().seq_end)) &&
                                                                (#[verifier::custom_err("cannot prove that the field `in_flight` is preserved")] (::builtin::equal(post.in_flight,
                                                                                update_tmp_in_flight)) &&
                                                                        (#[verifier::custom_err("cannot prove that the field `ephemeral` is preserved")] (::builtin::equal(post.ephemeral,
                                                                                        update_tmp_ephemeral)) &&
                                                                                #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                                        update_tmp_persistent)))))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn commit_start_strong(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        let update_tmp_in_flight: Option<StoreImage> =
                            pre.in_flight;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_CommitStartLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Known())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.in_flight.is_Some())
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] ((pre.persistent.seq_end).spec_le(lbl.get_CommitStartLabel_new_boundary_lsn()))
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(lbl.get_CommitStartLabel_new_boundary_lsn(),
                                                                        pre.in_flight.get_Some_0().seq_end)) &&
                                                                (#[verifier::custom_err("cannot prove that the field `in_flight` is preserved")] (::builtin::equal(post.in_flight,
                                                                                update_tmp_in_flight)) &&
                                                                        (#[verifier::custom_err("cannot prove that the field `ephemeral` is preserved")] (::builtin::equal(post.ephemeral,
                                                                                        update_tmp_ephemeral)) &&
                                                                                #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                                        update_tmp_persistent)))))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn commit_start_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_CommitStartLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Known())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.in_flight.is_Some())
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] ((pre.persistent.seq_end).spec_le(lbl.get_CommitStartLabel_new_boundary_lsn()))
                                                        &&
                                                        #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(lbl.get_CommitStartLabel_new_boundary_lsn(),
                                                                pre.in_flight.get_Some_0().seq_end))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn commit_complete(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_CommitCompleteLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.in_flight.is_Some())
                                        &&
                                        {
                                            let update_tmp_persistent: StoreImage =
                                                pre.in_flight.get_Some_0();
                                            let update_tmp_in_flight: Option<StoreImage> = Option::None;
                                            (#[verifier::custom_err("cannot prove that final value of field `in_flight` has this updated value")] (::builtin::equal(post.in_flight,
                                                            update_tmp_in_flight)) &&
                                                    (#[verifier::custom_err("cannot prove that final value of field `persistent` has this updated value")] (::builtin::equal(post.persistent,
                                                                    update_tmp_persistent)) &&
                                                            #[verifier::custom_err("cannot prove that the field `ephemeral` is preserved")] (::builtin::equal(post.ephemeral,
                                                                    update_tmp_ephemeral))))
                                        }))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn commit_complete_strong(pre: Self, post: Self,
                    lbl: Label) -> ::core::primitive::bool {
                    {
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_CommitCompleteLabel())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.in_flight.is_Some())
                                        &&
                                        {
                                            let update_tmp_persistent: StoreImage =
                                                pre.in_flight.get_Some_0();
                                            let update_tmp_in_flight: Option<StoreImage> = Option::None;
                                            (#[verifier::custom_err("cannot prove that final value of field `in_flight` has this updated value")] (::builtin::equal(post.in_flight,
                                                            update_tmp_in_flight)) &&
                                                    (#[verifier::custom_err("cannot prove that final value of field `persistent` has this updated value")] (::builtin::equal(post.persistent,
                                                                    update_tmp_persistent)) &&
                                                            #[verifier::custom_err("cannot prove that the field `ephemeral` is preserved")] (::builtin::equal(post.ephemeral,
                                                                    update_tmp_ephemeral))))
                                        }))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn commit_complete_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_CommitCompleteLabel())
                                &&
                                #[verifier::custom_err("cannot prove this condition holds")] (pre.in_flight.is_Some()))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn crash(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_CrashLabel())
                                &&
                                {
                                    let update_tmp_ephemeral: Ephemeral = Ephemeral::Unknown;
                                    let update_tmp_in_flight: Option<StoreImage> = Option::None;
                                    (#[verifier::custom_err("cannot prove that final value of field `in_flight` has this updated value")] (::builtin::equal(post.in_flight,
                                                    update_tmp_in_flight)) &&
                                            (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                            update_tmp_ephemeral)) &&
                                                    #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                            update_tmp_persistent))))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn crash_strong(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_CrashLabel())
                                &&
                                {
                                    let update_tmp_ephemeral: Ephemeral = Ephemeral::Unknown;
                                    let update_tmp_in_flight: Option<StoreImage> = Option::None;
                                    (#[verifier::custom_err("cannot prove that final value of field `in_flight` has this updated value")] (::builtin::equal(post.in_flight,
                                                    update_tmp_in_flight)) &&
                                            (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                            update_tmp_ephemeral)) &&
                                                    #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                            update_tmp_persistent))))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn crash_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {

                        #[verifier::custom_err("cannot prove this condition holds")]
                        (lbl.is_CrashLabel())
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_by(pre: State, post: State, label: Label,
                    step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::load_ephemeral_from_persistent() =>
                            Self::load_ephemeral_from_persistent(pre, post, label),
                        Step::put_records(new_map) =>
                            Self::put_records(pre, post, label, new_map),
                        Step::query(new_map) =>
                            Self::query(pre, post, label, new_map),
                        Step::freeze_map_internal(frozen_map, new_map) =>
                            Self::freeze_map_internal(pre, post, label, frozen_map,
                                new_map),
                        Step::ephemeral_internal(new_map) =>
                            Self::ephemeral_internal(pre, post, label, new_map),
                        Step::commit_start() =>
                            Self::commit_start(pre, post, label),
                        Step::commit_complete() =>
                            Self::commit_complete(pre, post, label),
                        Step::crash() => Self::crash(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next(pre: State, post: State, label: Label)
                    -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                            Self::next_by(pre, post, label, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_strong_by(pre: State, post: State, label: Label,
                    step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::load_ephemeral_from_persistent() =>
                            Self::load_ephemeral_from_persistent_strong(pre, post,
                                label),
                        Step::put_records(new_map) =>
                            Self::put_records_strong(pre, post, label, new_map),
                        Step::query(new_map) =>
                            Self::query_strong(pre, post, label, new_map),
                        Step::freeze_map_internal(frozen_map, new_map) =>
                            Self::freeze_map_internal_strong(pre, post, label,
                                frozen_map, new_map),
                        Step::ephemeral_internal(new_map) =>
                            Self::ephemeral_internal_strong(pre, post, label, new_map),
                        Step::commit_start() =>
                            Self::commit_start_strong(pre, post, label),
                        Step::commit_complete() =>
                            Self::commit_complete_strong(pre, post, label),
                        Step::crash() => Self::crash_strong(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_strong(pre: State, post: State, label: Label)
                    -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                            Self::next_strong_by(pre, post, label, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn init_by(post: State, step: Config)
                    -> ::core::primitive::bool {
                    match step {
                        Config::initialize() => Self::initialize(post),
                        Config::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn init(post: State) -> ::core::primitive::bool {
                    ::builtin::exists(|step: Config| Self::init_by(post, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::spec]
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                pub fn invariant(&self) -> ::core::primitive::bool { true }
            }
        }
    }
    pub mod AbstractCrashTolerantSystem_v {
        /// AbstractCrashTolerantSystem. Formerly named AbstractCoordinationSystem.
        /// Coordinates a map and a journal to present a unified map once abstracted.
        ///
        /// This is the final refinement layer before the top level trusted spec.
        use builtin::*;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        use vstd::prelude::*;
        use crate::spec::Messages_t::*;
        use crate::spec::MapSpec_t;
        use crate::spec::MapSpec_t::*;
        use crate::abstract_system::AbstractCrashAwareJournal_v::*;
        use crate::abstract_system::AbstractCrashAwareMap_v::*;
        use crate::abstract_system::StampedMap_v::*;
        use crate::abstract_system::MsgHistory_v::{MsgHistory, KeyedMessage};
        #[doc =
        " SyncReqId\'s are used to assign sync requests unique IDs. Actual value is meaningless beyond"]
        #[doc = " identifying a specific sync request."]
        type SyncReqId = nat;
        #[doc =
        " SyncReqs represents a set of outstanding sync requests. Sync requests are stored as key-value"]
        #[doc =
        " pairs: (key, map_lsn), where \"key\" is the sync request ID, and \"map_lsn\" was the last executed"]
        #[doc = " LSN on the map at the time the sync request was made."]
        type SyncReqs = Map<SyncReqId, LSN>;
        #[doc =
        " The ephemeral state of the Coordination Layer (when known)."]
        #[verus::internal(verus_macro)]
        pub struct Known {
            #[doc =
            " Tracks the set of outstanding client requests and undelivered replies. See MapSpec_t::EphemeralState."]
            pub progress: MapSpec_t::EphemeralState,
            #[doc = " The set of outstanding sync requests."]
            pub sync_reqs: SyncReqs,
            #[doc = " The LSN one past the end of "]
            pub map_lsn: LSN,
        }
        #[doc =
        " Ephemeral state for coordination layer can be known or unknown. The ephemeral"]
        #[doc =
        " state is known if the Option type is Some, and unknown if the Option type is"]
        #[doc = " None."]
        type Ephemeral = Option<Known>;
        #[allow(unused_parens)]
        pub mod CoordinationSystem {
            use super::*;
            #[verus::internal(verus_macro)]
            pub struct State {
                pub journal: CrashTolerantJournal::State,
                pub mapadt: CrashTolerantMap::State,
                pub ephemeral: Ephemeral,
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Step {
                load_ephemeral_from_persistent(CrashTolerantJournal::State,
                    CrashTolerantMap::State, LSN),
                recover(CrashTolerantJournal::State, CrashTolerantMap::State,
                    MsgHistory),
                accept_request(),
                query(CrashTolerantJournal::State, CrashTolerantMap::State),
                put(CrashTolerantJournal::State, CrashTolerantMap::State),
                deliver_reply(),
                journal_internal(CrashTolerantJournal::State),
                map_internal(CrashTolerantMap::State),
                req_sync(CrashTolerantJournal::State),
                reply_sync(CrashTolerantJournal::State),
                commit_start(LSN, CrashTolerantMap::State,
                    CrashTolerantJournal::State),
                commit_complete(CrashTolerantMap::State,
                    CrashTolerantJournal::State),
                crash(CrashTolerantJournal::State, CrashTolerantMap::State),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Step {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_load_ephemeral_from_persistent(&self) -> bool {
                    ::builtin::is_variant(self,
                        "load_ephemeral_from_persistent")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_load_ephemeral_from_persistent_0(self)
                    -> CrashTolerantJournal::State {
                    ::builtin::get_variant_field(self,
                        "load_ephemeral_from_persistent", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_load_ephemeral_from_persistent_1(self)
                    -> CrashTolerantMap::State {
                    ::builtin::get_variant_field(self,
                        "load_ephemeral_from_persistent", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_load_ephemeral_from_persistent_2(self) -> LSN {
                    ::builtin::get_variant_field(self,
                        "load_ephemeral_from_persistent", "2")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_recover(&self) -> bool {
                    ::builtin::is_variant(self, "recover")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_recover_0(self) -> CrashTolerantJournal::State {
                    ::builtin::get_variant_field(self, "recover", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_recover_1(self) -> CrashTolerantMap::State {
                    ::builtin::get_variant_field(self, "recover", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_recover_2(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "recover", "2")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_accept_request(&self) -> bool {
                    ::builtin::is_variant(self, "accept_request")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_query(&self) -> bool {
                    ::builtin::is_variant(self, "query")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_query_0(self) -> CrashTolerantJournal::State {
                    ::builtin::get_variant_field(self, "query", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_query_1(self) -> CrashTolerantMap::State {
                    ::builtin::get_variant_field(self, "query", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_put(&self) -> bool {
                    ::builtin::is_variant(self, "put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_put_0(self) -> CrashTolerantJournal::State {
                    ::builtin::get_variant_field(self, "put", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_put_1(self) -> CrashTolerantMap::State {
                    ::builtin::get_variant_field(self, "put", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_deliver_reply(&self) -> bool {
                    ::builtin::is_variant(self, "deliver_reply")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_journal_internal(&self) -> bool {
                    ::builtin::is_variant(self, "journal_internal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_journal_internal_0(self)
                    -> CrashTolerantJournal::State {
                    ::builtin::get_variant_field(self, "journal_internal", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_map_internal(&self) -> bool {
                    ::builtin::is_variant(self, "map_internal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_map_internal_0(self) -> CrashTolerantMap::State {
                    ::builtin::get_variant_field(self, "map_internal", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_req_sync(&self) -> bool {
                    ::builtin::is_variant(self, "req_sync")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_req_sync_0(self) -> CrashTolerantJournal::State {
                    ::builtin::get_variant_field(self, "req_sync", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_reply_sync(&self) -> bool {
                    ::builtin::is_variant(self, "reply_sync")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_reply_sync_0(self) -> CrashTolerantJournal::State {
                    ::builtin::get_variant_field(self, "reply_sync", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_commit_start(&self) -> bool {
                    ::builtin::is_variant(self, "commit_start")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_commit_start_0(self) -> LSN {
                    ::builtin::get_variant_field(self, "commit_start", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_commit_start_1(self) -> CrashTolerantMap::State {
                    ::builtin::get_variant_field(self, "commit_start", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_commit_start_2(self)
                    -> CrashTolerantJournal::State {
                    ::builtin::get_variant_field(self, "commit_start", "2")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_commit_complete(&self) -> bool {
                    ::builtin::is_variant(self, "commit_complete")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_commit_complete_0(self)
                    -> CrashTolerantMap::State {
                    ::builtin::get_variant_field(self, "commit_complete", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_commit_complete_1(self)
                    -> CrashTolerantJournal::State {
                    ::builtin::get_variant_field(self, "commit_complete", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_crash(&self) -> bool {
                    ::builtin::is_variant(self, "crash")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_crash_0(self) -> CrashTolerantJournal::State {
                    ::builtin::get_variant_field(self, "crash", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_crash_1(self) -> CrashTolerantMap::State {
                    ::builtin::get_variant_field(self, "crash", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Config {
                initialize(CoordinationSystem::State),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Config {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_initialize(&self) -> bool {
                    ::builtin::is_variant(self, "initialize")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_initialize_0(self) -> CoordinationSystem::State {
                    ::builtin::get_variant_field(self, "initialize", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[verus::internal(verus_macro)]
            pub enum Label {
                Label {
                    ctam_label: CrashTolerantAsyncMap::Label,
                },
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Label {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_Label(&self) -> bool {
                    ::builtin::is_variant(self, "Label")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_Label_ctam_label(self)
                    -> CrashTolerantAsyncMap::Label {
                    ::builtin::get_variant_field(self, "Label", "ctam_label")
                }
            }
            pub mod show {
                use super::*;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn load_ephemeral_from_persistent(pre: super::State,
                    post: super::State, label: Label,
                    new_journal: CrashTolerantJournal::State,
                    new_mapadt: CrashTolerantMap::State, map_lsn: LSN) {
                    ::builtin::requires(super::State::load_ephemeral_from_persistent(pre,
                            post, label, new_journal, new_mapadt, map_lsn));
                    ::builtin::ensures(super::State::next(pre, post, label));
                }
                use bool as load_ephemeral_from_persistent;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn recover(pre: super::State, post: super::State,
                    label: Label, new_journal: CrashTolerantJournal::State,
                    new_mapadt: CrashTolerantMap::State, records: MsgHistory) {
                    ::builtin::requires(super::State::recover(pre, post, label,
                            new_journal, new_mapadt, records));
                    ::builtin::ensures(super::State::next(pre, post, label));
                }
                use bool as recover;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn accept_request(pre: super::State, post: super::State,
                    label: Label) {
                    ::builtin::requires(super::State::accept_request(pre, post,
                            label));
                    ::builtin::ensures(super::State::next(pre, post, label));
                }
                use bool as accept_request;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn query(pre: super::State, post: super::State,
                    label: Label, new_journal: CrashTolerantJournal::State,
                    new_mapadt: CrashTolerantMap::State) {
                    ::builtin::requires(super::State::query(pre, post, label,
                            new_journal, new_mapadt));
                    ::builtin::ensures(super::State::next(pre, post, label));
                }
                use bool as query;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn put(pre: super::State, post: super::State,
                    label: Label, new_journal: CrashTolerantJournal::State,
                    new_mapadt: CrashTolerantMap::State) {
                    ::builtin::requires(super::State::put(pre, post, label,
                            new_journal, new_mapadt));
                    ::builtin::ensures(super::State::next(pre, post, label));
                }
                use bool as put;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn deliver_reply(pre: super::State, post: super::State,
                    label: Label) {
                    ::builtin::requires(super::State::deliver_reply(pre, post,
                            label));
                    ::builtin::ensures(super::State::next(pre, post, label));
                }
                use bool as deliver_reply;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn journal_internal(pre: super::State, post: super::State,
                    label: Label, new_journal: CrashTolerantJournal::State) {
                    ::builtin::requires(super::State::journal_internal(pre,
                            post, label, new_journal));
                    ::builtin::ensures(super::State::next(pre, post, label));
                }
                use bool as journal_internal;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn map_internal(pre: super::State, post: super::State,
                    label: Label, new_mapadt: CrashTolerantMap::State) {
                    ::builtin::requires(super::State::map_internal(pre, post,
                            label, new_mapadt));
                    ::builtin::ensures(super::State::next(pre, post, label));
                }
                use bool as map_internal;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn req_sync(pre: super::State, post: super::State,
                    label: Label, new_journal: CrashTolerantJournal::State) {
                    ::builtin::requires(super::State::req_sync(pre, post, label,
                            new_journal));
                    ::builtin::ensures(super::State::next(pre, post, label));
                }
                use bool as req_sync;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn reply_sync(pre: super::State, post: super::State,
                    label: Label, new_journal: CrashTolerantJournal::State) {
                    ::builtin::requires(super::State::reply_sync(pre, post,
                            label, new_journal));
                    ::builtin::ensures(super::State::next(pre, post, label));
                }
                use bool as reply_sync;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn commit_start(pre: super::State, post: super::State,
                    label: Label, new_boundary_lsn: LSN,
                    new_mapadt: CrashTolerantMap::State,
                    new_journal: CrashTolerantJournal::State) {
                    ::builtin::requires(super::State::commit_start(pre, post,
                            label, new_boundary_lsn, new_mapadt, new_journal));
                    ::builtin::ensures(super::State::next(pre, post, label));
                }
                use bool as commit_start;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn commit_complete(pre: super::State, post: super::State,
                    label: Label, new_mapadt: CrashTolerantMap::State,
                    new_journal: CrashTolerantJournal::State) {
                    ::builtin::requires(super::State::commit_complete(pre, post,
                            label, new_mapadt, new_journal));
                    ::builtin::ensures(super::State::next(pre, post, label));
                }
                use bool as commit_complete;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn crash(pre: super::State, post: super::State,
                    label: Label, new_journal: CrashTolerantJournal::State,
                    new_mapadt: CrashTolerantMap::State) {
                    ::builtin::requires(super::State::crash(pre, post, label,
                            new_journal, new_mapadt));
                    ::builtin::ensures(super::State::next(pre, post, label));
                }
                use bool as crash;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn initialize(post: super::State,
                    state: CoordinationSystem::State) {
                    ::builtin::requires(super::State::initialize(post, state));
                    ::builtin::ensures(super::State::init(post));
                }
                use bool as initialize;
            }
            pub mod take_step {
                use super::*;
            }
            #[verus::internal(verus_macro)]
            impl State {
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn initialize(post: Self,
                    state: CoordinationSystem::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantJournal::State::init(state.journal))
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantMap::State::init(state.mapadt))
                                        &&
                                        {
                                            let update_tmp_journal: CrashTolerantJournal::State =
                                                state.journal;
                                            let update_tmp_mapadt: CrashTolerantMap::State =
                                                state.mapadt;
                                            let update_tmp_ephemeral: Ephemeral = None;
                                            (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                            update_tmp_ephemeral)) &&
                                                    (#[verifier::custom_err("cannot prove that final value of field `mapadt` has this updated value")] (::builtin::equal(post.mapadt,
                                                                    update_tmp_mapadt)) &&
                                                            #[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")] (::builtin::equal(post.journal,
                                                                    update_tmp_journal))))
                                        }))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn initialize_enabled(state: CoordinationSystem::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantJournal::State::init(state.journal))
                                &&
                                #[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantMap::State::init(state.mapadt)))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn load_ephemeral_from_persistent(pre: Self, post: Self,
                    label: Label, new_journal: CrashTolerantJournal::State,
                    new_mapadt: CrashTolerantMap::State, map_lsn: LSN)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = label;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Label {
                                            ctam_label: CrashTolerantAsyncMap::Label::Noop } => true,
                                        _ => false,
                                    }) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantJournal::State::next(pre.journal,
                                                new_journal,
                                                CrashTolerantJournal::Label::LoadEphemeralFromPersistentLabel))
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantMap::State::next(pre.mapadt,
                                                        new_mapadt,
                                                        CrashTolerantMap::Label::LoadEphemeralFromPersistentLabel {
                                                            end_lsn: map_lsn,
                                                        })) &&
                                                {
                                                    let update_tmp_ephemeral: Ephemeral =
                                                        Some(Known {
                                                                progress: AsyncMap::State::init_ephemeral_state(),
                                                                sync_reqs: Map::empty(),
                                                                map_lsn: map_lsn,
                                                            });
                                                    let update_tmp_journal: CrashTolerantJournal::State =
                                                        new_journal;
                                                    let update_tmp_mapadt: CrashTolerantMap::State = new_mapadt;
                                                    (#[verifier::custom_err("cannot prove that final value of field `mapadt` has this updated value")] (::builtin::equal(post.mapadt,
                                                                    update_tmp_mapadt)) &&
                                                            (#[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")] (::builtin::equal(post.journal,
                                                                            update_tmp_journal)) &&
                                                                    #[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                            update_tmp_ephemeral))))
                                                })))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn load_ephemeral_from_persistent_strong(pre: Self,
                    post: Self, label: Label,
                    new_journal: CrashTolerantJournal::State,
                    new_mapadt: CrashTolerantMap::State, map_lsn: LSN)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = label;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Label {
                                            ctam_label: CrashTolerantAsyncMap::Label::Noop } => true,
                                        _ => false,
                                    }) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantJournal::State::next(pre.journal,
                                                new_journal,
                                                CrashTolerantJournal::Label::LoadEphemeralFromPersistentLabel))
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantMap::State::next(pre.mapadt,
                                                        new_mapadt,
                                                        CrashTolerantMap::Label::LoadEphemeralFromPersistentLabel {
                                                            end_lsn: map_lsn,
                                                        })) &&
                                                {
                                                    let update_tmp_ephemeral: Ephemeral =
                                                        Some(Known {
                                                                progress: AsyncMap::State::init_ephemeral_state(),
                                                                sync_reqs: Map::empty(),
                                                                map_lsn: map_lsn,
                                                            });
                                                    let update_tmp_journal: CrashTolerantJournal::State =
                                                        new_journal;
                                                    let update_tmp_mapadt: CrashTolerantMap::State = new_mapadt;
                                                    (#[verifier::custom_err("cannot prove that final value of field `mapadt` has this updated value")] (::builtin::equal(post.mapadt,
                                                                    update_tmp_mapadt)) &&
                                                            (#[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")] (::builtin::equal(post.journal,
                                                                            update_tmp_journal)) &&
                                                                    #[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                            update_tmp_ephemeral))))
                                                })))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn load_ephemeral_from_persistent_enabled(pre: Self,
                    label: Label, new_journal: CrashTolerantJournal::State,
                    new_mapadt: CrashTolerantMap::State, map_lsn: LSN)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = label;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Label {
                                            ctam_label: CrashTolerantAsyncMap::Label::Noop } => true,
                                        _ => false,
                                    }) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantJournal::State::next(pre.journal,
                                                new_journal,
                                                CrashTolerantJournal::Label::LoadEphemeralFromPersistentLabel))
                                        &&
                                        #[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantMap::State::next(pre.mapadt,
                                                new_mapadt,
                                                CrashTolerantMap::Label::LoadEphemeralFromPersistentLabel {
                                                    end_lsn: map_lsn,
                                                }))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn recover(pre: Self, post: Self, label: Label,
                    new_journal: CrashTolerantJournal::State,
                    new_mapadt: CrashTolerantMap::State, records: MsgHistory)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = label;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Label {
                                            ctam_label: CrashTolerantAsyncMap::Label::Noop } => true,
                                        _ => false,
                                    }) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Some())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (records.wf())
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantJournal::State::next(pre.journal,
                                                                new_journal,
                                                                CrashTolerantJournal::Label::ReadForRecoveryLabel {
                                                                    records,
                                                                })) &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantMap::State::next(pre.mapadt,
                                                                        new_mapadt,
                                                                        CrashTolerantMap::Label::PutRecordsLabel { records })) &&
                                                                {
                                                                    let update_tmp_ephemeral: Ephemeral =
                                                                        Some(Known {
                                                                                map_lsn: records.seq_end,
                                                                                ..pre.ephemeral.get_Some_0()
                                                                            });
                                                                    let update_tmp_journal: CrashTolerantJournal::State =
                                                                        new_journal;
                                                                    let update_tmp_mapadt: CrashTolerantMap::State = new_mapadt;
                                                                    (#[verifier::custom_err("cannot prove that final value of field `mapadt` has this updated value")] (::builtin::equal(post.mapadt,
                                                                                    update_tmp_mapadt)) &&
                                                                            (#[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")] (::builtin::equal(post.journal,
                                                                                            update_tmp_journal)) &&
                                                                                    #[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                                            update_tmp_ephemeral))))
                                                                })))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn recover_strong(pre: Self, post: Self, label: Label,
                    new_journal: CrashTolerantJournal::State,
                    new_mapadt: CrashTolerantMap::State, records: MsgHistory)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = label;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Label {
                                            ctam_label: CrashTolerantAsyncMap::Label::Noop } => true,
                                        _ => false,
                                    }) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Some())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (records.wf())
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantJournal::State::next(pre.journal,
                                                                new_journal,
                                                                CrashTolerantJournal::Label::ReadForRecoveryLabel {
                                                                    records,
                                                                })) &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantMap::State::next(pre.mapadt,
                                                                        new_mapadt,
                                                                        CrashTolerantMap::Label::PutRecordsLabel { records })) &&
                                                                {
                                                                    let update_tmp_ephemeral: Ephemeral =
                                                                        Some(Known {
                                                                                map_lsn: records.seq_end,
                                                                                ..pre.ephemeral.get_Some_0()
                                                                            });
                                                                    let update_tmp_journal: CrashTolerantJournal::State =
                                                                        new_journal;
                                                                    let update_tmp_mapadt: CrashTolerantMap::State = new_mapadt;
                                                                    (#[verifier::custom_err("cannot prove that final value of field `mapadt` has this updated value")] (::builtin::equal(post.mapadt,
                                                                                    update_tmp_mapadt)) &&
                                                                            (#[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")] (::builtin::equal(post.journal,
                                                                                            update_tmp_journal)) &&
                                                                                    #[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                                            update_tmp_ephemeral))))
                                                                })))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn recover_enabled(pre: Self, label: Label,
                    new_journal: CrashTolerantJournal::State,
                    new_mapadt: CrashTolerantMap::State, records: MsgHistory)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = label;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Label {
                                            ctam_label: CrashTolerantAsyncMap::Label::Noop } => true,
                                        _ => false,
                                    }) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Some())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (records.wf())
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantJournal::State::next(pre.journal,
                                                                new_journal,
                                                                CrashTolerantJournal::Label::ReadForRecoveryLabel {
                                                                    records,
                                                                })) &&
                                                        #[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantMap::State::next(pre.mapadt,
                                                                new_mapadt,
                                                                CrashTolerantMap::Label::PutRecordsLabel { records }))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn accept_request(pre: Self, post: Self, label: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_journal: CrashTolerantJournal::State =
                            pre.journal;
                        let update_tmp_mapadt: CrashTolerantMap::State = pre.mapadt;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Some())
                                &&
                                (({
                                                let tmp_for_match_0 = label;
                                                (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                                {
                                                                Label::Label {
                                                                    ctam_label: CrashTolerantAsyncMap::Label::OperateOp {
                                                                        base_op: AsyncMap::Label::RequestOp { req }
                                                                        } } => true,
                                                                _ => false,
                                                            }) &&
                                                        {
                                                            let req =
                                                                match tmp_for_match_0 {
                                                                    Label::Label {
                                                                        ctam_label: CrashTolerantAsyncMap::Label::OperateOp {
                                                                            base_op: AsyncMap::Label::RequestOp { req }
                                                                            } } => req,
                                                                    _ => ::vstd::pervasive::arbitrary(),
                                                                };
                                                            let Label::Label { ctam_label: ctam_label } = label;
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (!pre.ephemeral.get_Some_0().progress.requests.contains(req))
                                                                    &&
                                                                    {
                                                                        let update_tmp_ephemeral: Ephemeral =
                                                                            Some(Known {
                                                                                    progress: MapSpec_t::EphemeralState {
                                                                                        requests: pre.ephemeral.get_Some_0().progress.requests.insert(req),
                                                                                        ..pre.ephemeral.get_Some_0().progress
                                                                                    },
                                                                                    ..pre.ephemeral.get_Some_0()
                                                                                });

                                                                        #[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")]
                                                                        (::builtin::equal(post.ephemeral, update_tmp_ephemeral))
                                                                    })
                                                        })
                                            }) &&
                                        ((#[verifier::custom_err("cannot prove that the field `mapadt` is preserved")] (::builtin::equal(post.mapadt,
                                                            update_tmp_mapadt)) &&
                                                    #[verifier::custom_err("cannot prove that the field `journal` is preserved")] (::builtin::equal(post.journal,
                                                            update_tmp_journal))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn accept_request_strong(pre: Self, post: Self,
                    label: Label) -> ::core::primitive::bool {
                    {
                        let update_tmp_journal: CrashTolerantJournal::State =
                            pre.journal;
                        let update_tmp_mapadt: CrashTolerantMap::State = pre.mapadt;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Some())
                                &&
                                (({
                                                let tmp_for_match_0 = label;
                                                (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                                {
                                                                Label::Label {
                                                                    ctam_label: CrashTolerantAsyncMap::Label::OperateOp {
                                                                        base_op: AsyncMap::Label::RequestOp { req }
                                                                        } } => true,
                                                                _ => false,
                                                            }) &&
                                                        {
                                                            let req =
                                                                match tmp_for_match_0 {
                                                                    Label::Label {
                                                                        ctam_label: CrashTolerantAsyncMap::Label::OperateOp {
                                                                            base_op: AsyncMap::Label::RequestOp { req }
                                                                            } } => req,
                                                                    _ => ::vstd::pervasive::arbitrary(),
                                                                };
                                                            let Label::Label { ctam_label: ctam_label } = label;
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (!pre.ephemeral.get_Some_0().progress.requests.contains(req))
                                                                    &&
                                                                    {
                                                                        let update_tmp_ephemeral: Ephemeral =
                                                                            Some(Known {
                                                                                    progress: MapSpec_t::EphemeralState {
                                                                                        requests: pre.ephemeral.get_Some_0().progress.requests.insert(req),
                                                                                        ..pre.ephemeral.get_Some_0().progress
                                                                                    },
                                                                                    ..pre.ephemeral.get_Some_0()
                                                                                });

                                                                        #[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")]
                                                                        (::builtin::equal(post.ephemeral, update_tmp_ephemeral))
                                                                    })
                                                        })
                                            }) &&
                                        ((#[verifier::custom_err("cannot prove that the field `mapadt` is preserved")] (::builtin::equal(post.mapadt,
                                                            update_tmp_mapadt)) &&
                                                    #[verifier::custom_err("cannot prove that the field `journal` is preserved")] (::builtin::equal(post.journal,
                                                            update_tmp_journal))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn accept_request_enabled(pre: Self, label: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Some())
                                &&
                                {
                                    let tmp_for_match_0 = label;
                                    (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                    {
                                                    Label::Label {
                                                        ctam_label: CrashTolerantAsyncMap::Label::OperateOp {
                                                            base_op: AsyncMap::Label::RequestOp { req }
                                                            } } => true,
                                                    _ => false,
                                                }) &&
                                            {
                                                let req =
                                                    match tmp_for_match_0 {
                                                        Label::Label {
                                                            ctam_label: CrashTolerantAsyncMap::Label::OperateOp {
                                                                base_op: AsyncMap::Label::RequestOp { req }
                                                                } } => req,
                                                        _ => ::vstd::pervasive::arbitrary(),
                                                    };
                                                let Label::Label { ctam_label: ctam_label } = label;

                                                #[verifier::custom_err("cannot prove this condition holds")]
                                                (!pre.ephemeral.get_Some_0().progress.requests.contains(req))
                                            })
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query(pre: Self, post: Self, label: Label,
                    new_journal: CrashTolerantJournal::State,
                    new_mapadt: CrashTolerantMap::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Some())
                                &&
                                {
                                    let pre_ephemeral = pre.ephemeral.get_Some_0();
                                    let ctam_label = label.get_Label_ctam_label();
                                    (#[verifier::custom_err("cannot prove this condition holds")] (ctam_label.is_OperateOp())
                                            &&
                                            {
                                                let base_op = ctam_label.get_OperateOp_base_op();
                                                (#[verifier::custom_err("cannot prove this condition holds")] (base_op.is_ExecuteOp())
                                                        &&
                                                        {
                                                            let req = base_op.get_ExecuteOp_req();
                                                            let reply = base_op.get_ExecuteOp_reply();
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (req.input.is_QueryInput())
                                                                    &&
                                                                    (#[verifier::custom_err("cannot prove this condition holds")] (reply.output.is_QueryOutput())
                                                                            &&
                                                                            {
                                                                                let key = req.input.get_QueryInput_key();
                                                                                let value = reply.output.get_QueryOutput_value();
                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre_ephemeral.progress.requests.contains(req))
                                                                                        &&
                                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(req.id,
                                                                                                        reply.id)) &&
                                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (!pre_ephemeral.progress.replies.contains(reply))
                                                                                                        &&
                                                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantJournal::State::next(pre.journal,
                                                                                                                        new_journal,
                                                                                                                        CrashTolerantJournal::Label::QueryEndLsnLabel {
                                                                                                                            end_lsn: pre_ephemeral.map_lsn,
                                                                                                                        })) &&
                                                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantMap::State::next(pre.mapadt,
                                                                                                                                new_mapadt,
                                                                                                                                CrashTolerantMap::Label::QueryLabel {
                                                                                                                                    end_lsn: pre_ephemeral.map_lsn,
                                                                                                                                    key: key,
                                                                                                                                    value: value,
                                                                                                                                })) &&
                                                                                                                        {
                                                                                                                            let update_tmp_ephemeral: Ephemeral =
                                                                                                                                Some(Known {
                                                                                                                                        progress: MapSpec_t::EphemeralState {
                                                                                                                                            requests: pre_ephemeral.progress.requests.remove(req),
                                                                                                                                            replies: pre_ephemeral.progress.replies.insert(reply),
                                                                                                                                        },
                                                                                                                                        ..pre_ephemeral
                                                                                                                                    });
                                                                                                                            let update_tmp_journal: CrashTolerantJournal::State =
                                                                                                                                new_journal;
                                                                                                                            let update_tmp_mapadt: CrashTolerantMap::State = new_mapadt;
                                                                                                                            (#[verifier::custom_err("cannot prove that final value of field `mapadt` has this updated value")] (::builtin::equal(post.mapadt,
                                                                                                                                            update_tmp_mapadt)) &&
                                                                                                                                    (#[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")] (::builtin::equal(post.journal,
                                                                                                                                                    update_tmp_journal)) &&
                                                                                                                                            #[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                                                                                                    update_tmp_ephemeral))))
                                                                                                                        })))))
                                                                            }))
                                                        })
                                            })
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_strong(pre: Self, post: Self, label: Label,
                    new_journal: CrashTolerantJournal::State,
                    new_mapadt: CrashTolerantMap::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Some())
                                &&
                                {
                                    let pre_ephemeral = pre.ephemeral.get_Some_0();
                                    let ctam_label = label.get_Label_ctam_label();
                                    (#[verifier::custom_err("cannot prove this condition holds")] (ctam_label.is_OperateOp())
                                            &&
                                            {
                                                let base_op = ctam_label.get_OperateOp_base_op();
                                                (#[verifier::custom_err("cannot prove this condition holds")] (base_op.is_ExecuteOp())
                                                        &&
                                                        {
                                                            let req = base_op.get_ExecuteOp_req();
                                                            let reply = base_op.get_ExecuteOp_reply();
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (req.input.is_QueryInput())
                                                                    &&
                                                                    (#[verifier::custom_err("cannot prove this condition holds")] (reply.output.is_QueryOutput())
                                                                            &&
                                                                            {
                                                                                let key = req.input.get_QueryInput_key();
                                                                                let value = reply.output.get_QueryOutput_value();
                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre_ephemeral.progress.requests.contains(req))
                                                                                        &&
                                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(req.id,
                                                                                                        reply.id)) &&
                                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (!pre_ephemeral.progress.replies.contains(reply))
                                                                                                        &&
                                                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantJournal::State::next(pre.journal,
                                                                                                                        new_journal,
                                                                                                                        CrashTolerantJournal::Label::QueryEndLsnLabel {
                                                                                                                            end_lsn: pre_ephemeral.map_lsn,
                                                                                                                        })) &&
                                                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantMap::State::next(pre.mapadt,
                                                                                                                                new_mapadt,
                                                                                                                                CrashTolerantMap::Label::QueryLabel {
                                                                                                                                    end_lsn: pre_ephemeral.map_lsn,
                                                                                                                                    key: key,
                                                                                                                                    value: value,
                                                                                                                                })) &&
                                                                                                                        {
                                                                                                                            let update_tmp_ephemeral: Ephemeral =
                                                                                                                                Some(Known {
                                                                                                                                        progress: MapSpec_t::EphemeralState {
                                                                                                                                            requests: pre_ephemeral.progress.requests.remove(req),
                                                                                                                                            replies: pre_ephemeral.progress.replies.insert(reply),
                                                                                                                                        },
                                                                                                                                        ..pre_ephemeral
                                                                                                                                    });
                                                                                                                            let update_tmp_journal: CrashTolerantJournal::State =
                                                                                                                                new_journal;
                                                                                                                            let update_tmp_mapadt: CrashTolerantMap::State = new_mapadt;
                                                                                                                            (#[verifier::custom_err("cannot prove that final value of field `mapadt` has this updated value")] (::builtin::equal(post.mapadt,
                                                                                                                                            update_tmp_mapadt)) &&
                                                                                                                                    (#[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")] (::builtin::equal(post.journal,
                                                                                                                                                    update_tmp_journal)) &&
                                                                                                                                            #[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                                                                                                    update_tmp_ephemeral))))
                                                                                                                        })))))
                                                                            }))
                                                        })
                                            })
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_enabled(pre: Self, label: Label,
                    new_journal: CrashTolerantJournal::State,
                    new_mapadt: CrashTolerantMap::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Some())
                                &&
                                {
                                    let pre_ephemeral = pre.ephemeral.get_Some_0();
                                    let ctam_label = label.get_Label_ctam_label();
                                    (#[verifier::custom_err("cannot prove this condition holds")] (ctam_label.is_OperateOp())
                                            &&
                                            {
                                                let base_op = ctam_label.get_OperateOp_base_op();
                                                (#[verifier::custom_err("cannot prove this condition holds")] (base_op.is_ExecuteOp())
                                                        &&
                                                        {
                                                            let req = base_op.get_ExecuteOp_req();
                                                            let reply = base_op.get_ExecuteOp_reply();
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (req.input.is_QueryInput())
                                                                    &&
                                                                    (#[verifier::custom_err("cannot prove this condition holds")] (reply.output.is_QueryOutput())
                                                                            &&
                                                                            {
                                                                                let key = req.input.get_QueryInput_key();
                                                                                let value = reply.output.get_QueryOutput_value();
                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre_ephemeral.progress.requests.contains(req))
                                                                                        &&
                                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(req.id,
                                                                                                        reply.id)) &&
                                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (!pre_ephemeral.progress.replies.contains(reply))
                                                                                                        &&
                                                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantJournal::State::next(pre.journal,
                                                                                                                        new_journal,
                                                                                                                        CrashTolerantJournal::Label::QueryEndLsnLabel {
                                                                                                                            end_lsn: pre_ephemeral.map_lsn,
                                                                                                                        })) &&
                                                                                                                #[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantMap::State::next(pre.mapadt,
                                                                                                                        new_mapadt,
                                                                                                                        CrashTolerantMap::Label::QueryLabel {
                                                                                                                            end_lsn: pre_ephemeral.map_lsn,
                                                                                                                            key: key,
                                                                                                                            value: value,
                                                                                                                        }))))))
                                                                            }))
                                                        })
                                            })
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put(pre: Self, post: Self, label: Label,
                    new_journal: CrashTolerantJournal::State,
                    new_mapadt: CrashTolerantMap::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Some())
                                &&
                                {
                                    let pre_ephemeral = pre.ephemeral.get_Some_0();
                                    let tmp_for_match_0 = label;
                                    (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                    {
                                                    Label::Label {
                                                        ctam_label: CrashTolerantAsyncMap::Label::OperateOp {
                                                            base_op: AsyncMap::Label::ExecuteOp { req, reply }
                                                            } } => true,
                                                    _ => false,
                                                }) &&
                                            {
                                                let (req, reply) =
                                                    match tmp_for_match_0 {
                                                        Label::Label {
                                                            ctam_label: CrashTolerantAsyncMap::Label::OperateOp {
                                                                base_op: AsyncMap::Label::ExecuteOp { req, reply }
                                                                } } => (req, reply),
                                                        _ => ::vstd::pervasive::arbitrary(),
                                                    };
                                                let tmp_for_match_1 = req;
                                                (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_1
                                                                {
                                                                Request {
                                                                    input: Input::PutInput { key, value }, id: request_id } =>
                                                                    true,
                                                                _ => false,
                                                            }) &&
                                                        {
                                                            let (key, value, request_id) =
                                                                match tmp_for_match_1 {
                                                                    Request {
                                                                        input: Input::PutInput { key, value }, id: request_id } =>
                                                                        (key, value, request_id),
                                                                    _ => ::vstd::pervasive::arbitrary(),
                                                                };
                                                            let tmp_for_match_2 = reply;
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_2
                                                                            {
                                                                            Reply { output: Output::PutOutput, id: reply_id } => true,
                                                                            _ => false,
                                                                        }) &&
                                                                    {
                                                                        let reply_id =
                                                                            match tmp_for_match_2 {
                                                                                Reply { output: Output::PutOutput, id: reply_id } =>
                                                                                    reply_id,
                                                                                _ => ::vstd::pervasive::arbitrary(),
                                                                            };
                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre_ephemeral.progress.requests.contains(req))
                                                                                &&
                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(req.id,
                                                                                                reply.id)) &&
                                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (!pre_ephemeral.progress.replies.contains(reply))
                                                                                                &&
                                                                                                {
                                                                                                    let keyed_message =
                                                                                                        KeyedMessage {
                                                                                                            key: key,
                                                                                                            message: Message::Define { value: value },
                                                                                                        };
                                                                                                    let singleton =
                                                                                                        MsgHistory::singleton_at(pre_ephemeral.map_lsn,
                                                                                                            keyed_message);
                                                                                                    (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantJournal::State::next(pre.journal,
                                                                                                                    new_journal,
                                                                                                                    CrashTolerantJournal::Label::PutLabel {
                                                                                                                        records: singleton,
                                                                                                                    })) &&
                                                                                                            (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantMap::State::next(pre.mapadt,
                                                                                                                            new_mapadt,
                                                                                                                            CrashTolerantMap::Label::PutRecordsLabel {
                                                                                                                                records: singleton,
                                                                                                                            })) &&
                                                                                                                    {
                                                                                                                        let update_tmp_ephemeral: Ephemeral =
                                                                                                                            Some(Known {
                                                                                                                                    map_lsn: (pre_ephemeral.map_lsn).spec_add(::builtin::spec_literal_nat("1")),
                                                                                                                                    progress: MapSpec_t::EphemeralState {
                                                                                                                                        requests: pre_ephemeral.progress.requests.remove(req),
                                                                                                                                        replies: pre_ephemeral.progress.replies.insert(reply),
                                                                                                                                    },
                                                                                                                                    ..pre_ephemeral
                                                                                                                                });
                                                                                                                        let update_tmp_journal: CrashTolerantJournal::State =
                                                                                                                            new_journal;
                                                                                                                        let update_tmp_mapadt: CrashTolerantMap::State = new_mapadt;
                                                                                                                        (#[verifier::custom_err("cannot prove that final value of field `mapadt` has this updated value")] (::builtin::equal(post.mapadt,
                                                                                                                                        update_tmp_mapadt)) &&
                                                                                                                                (#[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")] (::builtin::equal(post.journal,
                                                                                                                                                update_tmp_journal)) &&
                                                                                                                                        #[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                                                                                                update_tmp_ephemeral))))
                                                                                                                    }))
                                                                                                })))
                                                                    })
                                                        })
                                            })
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put_strong(pre: Self, post: Self, label: Label,
                    new_journal: CrashTolerantJournal::State,
                    new_mapadt: CrashTolerantMap::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Some())
                                &&
                                {
                                    let pre_ephemeral = pre.ephemeral.get_Some_0();
                                    let tmp_for_match_0 = label;
                                    (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                    {
                                                    Label::Label {
                                                        ctam_label: CrashTolerantAsyncMap::Label::OperateOp {
                                                            base_op: AsyncMap::Label::ExecuteOp { req, reply }
                                                            } } => true,
                                                    _ => false,
                                                }) &&
                                            {
                                                let (req, reply) =
                                                    match tmp_for_match_0 {
                                                        Label::Label {
                                                            ctam_label: CrashTolerantAsyncMap::Label::OperateOp {
                                                                base_op: AsyncMap::Label::ExecuteOp { req, reply }
                                                                } } => (req, reply),
                                                        _ => ::vstd::pervasive::arbitrary(),
                                                    };
                                                let tmp_for_match_1 = req;
                                                (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_1
                                                                {
                                                                Request {
                                                                    input: Input::PutInput { key, value }, id: request_id } =>
                                                                    true,
                                                                _ => false,
                                                            }) &&
                                                        {
                                                            let (key, value, request_id) =
                                                                match tmp_for_match_1 {
                                                                    Request {
                                                                        input: Input::PutInput { key, value }, id: request_id } =>
                                                                        (key, value, request_id),
                                                                    _ => ::vstd::pervasive::arbitrary(),
                                                                };
                                                            let tmp_for_match_2 = reply;
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_2
                                                                            {
                                                                            Reply { output: Output::PutOutput, id: reply_id } => true,
                                                                            _ => false,
                                                                        }) &&
                                                                    {
                                                                        let reply_id =
                                                                            match tmp_for_match_2 {
                                                                                Reply { output: Output::PutOutput, id: reply_id } =>
                                                                                    reply_id,
                                                                                _ => ::vstd::pervasive::arbitrary(),
                                                                            };
                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre_ephemeral.progress.requests.contains(req))
                                                                                &&
                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(req.id,
                                                                                                reply.id)) &&
                                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (!pre_ephemeral.progress.replies.contains(reply))
                                                                                                &&
                                                                                                {
                                                                                                    let keyed_message =
                                                                                                        KeyedMessage {
                                                                                                            key: key,
                                                                                                            message: Message::Define { value: value },
                                                                                                        };
                                                                                                    let singleton =
                                                                                                        MsgHistory::singleton_at(pre_ephemeral.map_lsn,
                                                                                                            keyed_message);
                                                                                                    (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantJournal::State::next(pre.journal,
                                                                                                                    new_journal,
                                                                                                                    CrashTolerantJournal::Label::PutLabel {
                                                                                                                        records: singleton,
                                                                                                                    })) &&
                                                                                                            (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantMap::State::next(pre.mapadt,
                                                                                                                            new_mapadt,
                                                                                                                            CrashTolerantMap::Label::PutRecordsLabel {
                                                                                                                                records: singleton,
                                                                                                                            })) &&
                                                                                                                    {
                                                                                                                        let update_tmp_ephemeral: Ephemeral =
                                                                                                                            Some(Known {
                                                                                                                                    map_lsn: (pre_ephemeral.map_lsn).spec_add(::builtin::spec_literal_nat("1")),
                                                                                                                                    progress: MapSpec_t::EphemeralState {
                                                                                                                                        requests: pre_ephemeral.progress.requests.remove(req),
                                                                                                                                        replies: pre_ephemeral.progress.replies.insert(reply),
                                                                                                                                    },
                                                                                                                                    ..pre_ephemeral
                                                                                                                                });
                                                                                                                        let update_tmp_journal: CrashTolerantJournal::State =
                                                                                                                            new_journal;
                                                                                                                        let update_tmp_mapadt: CrashTolerantMap::State = new_mapadt;
                                                                                                                        (#[verifier::custom_err("cannot prove that final value of field `mapadt` has this updated value")] (::builtin::equal(post.mapadt,
                                                                                                                                        update_tmp_mapadt)) &&
                                                                                                                                (#[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")] (::builtin::equal(post.journal,
                                                                                                                                                update_tmp_journal)) &&
                                                                                                                                        #[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                                                                                                update_tmp_ephemeral))))
                                                                                                                    }))
                                                                                                })))
                                                                    })
                                                        })
                                            })
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put_enabled(pre: Self, label: Label,
                    new_journal: CrashTolerantJournal::State,
                    new_mapadt: CrashTolerantMap::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Some())
                                &&
                                {
                                    let pre_ephemeral = pre.ephemeral.get_Some_0();
                                    let tmp_for_match_0 = label;
                                    (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                    {
                                                    Label::Label {
                                                        ctam_label: CrashTolerantAsyncMap::Label::OperateOp {
                                                            base_op: AsyncMap::Label::ExecuteOp { req, reply }
                                                            } } => true,
                                                    _ => false,
                                                }) &&
                                            {
                                                let (req, reply) =
                                                    match tmp_for_match_0 {
                                                        Label::Label {
                                                            ctam_label: CrashTolerantAsyncMap::Label::OperateOp {
                                                                base_op: AsyncMap::Label::ExecuteOp { req, reply }
                                                                } } => (req, reply),
                                                        _ => ::vstd::pervasive::arbitrary(),
                                                    };
                                                let tmp_for_match_1 = req;
                                                (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_1
                                                                {
                                                                Request {
                                                                    input: Input::PutInput { key, value }, id: request_id } =>
                                                                    true,
                                                                _ => false,
                                                            }) &&
                                                        {
                                                            let (key, value, request_id) =
                                                                match tmp_for_match_1 {
                                                                    Request {
                                                                        input: Input::PutInput { key, value }, id: request_id } =>
                                                                        (key, value, request_id),
                                                                    _ => ::vstd::pervasive::arbitrary(),
                                                                };
                                                            let tmp_for_match_2 = reply;
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_2
                                                                            {
                                                                            Reply { output: Output::PutOutput, id: reply_id } => true,
                                                                            _ => false,
                                                                        }) &&
                                                                    {
                                                                        let reply_id =
                                                                            match tmp_for_match_2 {
                                                                                Reply { output: Output::PutOutput, id: reply_id } =>
                                                                                    reply_id,
                                                                                _ => ::vstd::pervasive::arbitrary(),
                                                                            };
                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre_ephemeral.progress.requests.contains(req))
                                                                                &&
                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(req.id,
                                                                                                reply.id)) &&
                                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (!pre_ephemeral.progress.replies.contains(reply))
                                                                                                &&
                                                                                                {
                                                                                                    let keyed_message =
                                                                                                        KeyedMessage {
                                                                                                            key: key,
                                                                                                            message: Message::Define { value: value },
                                                                                                        };
                                                                                                    let singleton =
                                                                                                        MsgHistory::singleton_at(pre_ephemeral.map_lsn,
                                                                                                            keyed_message);
                                                                                                    (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantJournal::State::next(pre.journal,
                                                                                                                    new_journal,
                                                                                                                    CrashTolerantJournal::Label::PutLabel {
                                                                                                                        records: singleton,
                                                                                                                    })) &&
                                                                                                            #[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantMap::State::next(pre.mapadt,
                                                                                                                    new_mapadt,
                                                                                                                    CrashTolerantMap::Label::PutRecordsLabel {
                                                                                                                        records: singleton,
                                                                                                                    })))
                                                                                                })))
                                                                    })
                                                        })
                                            })
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn deliver_reply(pre: Self, post: Self, label: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_journal: CrashTolerantJournal::State =
                            pre.journal;
                        let update_tmp_mapadt: CrashTolerantMap::State = pre.mapadt;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Some())
                                &&
                                (({
                                                let pre_ephemeral = pre.ephemeral.get_Some_0();
                                                let ctam_label = label.get_Label_ctam_label();
                                                (#[verifier::custom_err("cannot prove this condition holds")] (ctam_label.is_OperateOp())
                                                        &&
                                                        {
                                                            let base_op = ctam_label.get_OperateOp_base_op();
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (base_op.is_ReplyOp())
                                                                    &&
                                                                    {
                                                                        let reply = base_op.get_ReplyOp_reply();
                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre_ephemeral.progress.replies.contains(reply))
                                                                                &&
                                                                                {
                                                                                    let update_tmp_ephemeral: Ephemeral =
                                                                                        Some(Known {
                                                                                                progress: MapSpec_t::EphemeralState {
                                                                                                    replies: pre_ephemeral.progress.replies.remove(reply),
                                                                                                    ..pre_ephemeral.progress
                                                                                                },
                                                                                                ..pre_ephemeral
                                                                                            });

                                                                                    #[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")]
                                                                                    (::builtin::equal(post.ephemeral, update_tmp_ephemeral))
                                                                                })
                                                                    })
                                                        })
                                            }) &&
                                        ((#[verifier::custom_err("cannot prove that the field `mapadt` is preserved")] (::builtin::equal(post.mapadt,
                                                            update_tmp_mapadt)) &&
                                                    #[verifier::custom_err("cannot prove that the field `journal` is preserved")] (::builtin::equal(post.journal,
                                                            update_tmp_journal))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn deliver_reply_strong(pre: Self, post: Self,
                    label: Label) -> ::core::primitive::bool {
                    {
                        let update_tmp_journal: CrashTolerantJournal::State =
                            pre.journal;
                        let update_tmp_mapadt: CrashTolerantMap::State = pre.mapadt;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Some())
                                &&
                                (({
                                                let pre_ephemeral = pre.ephemeral.get_Some_0();
                                                let ctam_label = label.get_Label_ctam_label();
                                                (#[verifier::custom_err("cannot prove this condition holds")] (ctam_label.is_OperateOp())
                                                        &&
                                                        {
                                                            let base_op = ctam_label.get_OperateOp_base_op();
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (base_op.is_ReplyOp())
                                                                    &&
                                                                    {
                                                                        let reply = base_op.get_ReplyOp_reply();
                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre_ephemeral.progress.replies.contains(reply))
                                                                                &&
                                                                                {
                                                                                    let update_tmp_ephemeral: Ephemeral =
                                                                                        Some(Known {
                                                                                                progress: MapSpec_t::EphemeralState {
                                                                                                    replies: pre_ephemeral.progress.replies.remove(reply),
                                                                                                    ..pre_ephemeral.progress
                                                                                                },
                                                                                                ..pre_ephemeral
                                                                                            });

                                                                                    #[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")]
                                                                                    (::builtin::equal(post.ephemeral, update_tmp_ephemeral))
                                                                                })
                                                                    })
                                                        })
                                            }) &&
                                        ((#[verifier::custom_err("cannot prove that the field `mapadt` is preserved")] (::builtin::equal(post.mapadt,
                                                            update_tmp_mapadt)) &&
                                                    #[verifier::custom_err("cannot prove that the field `journal` is preserved")] (::builtin::equal(post.journal,
                                                            update_tmp_journal))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn deliver_reply_enabled(pre: Self, label: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Some())
                                &&
                                {
                                    let pre_ephemeral = pre.ephemeral.get_Some_0();
                                    let ctam_label = label.get_Label_ctam_label();
                                    (#[verifier::custom_err("cannot prove this condition holds")] (ctam_label.is_OperateOp())
                                            &&
                                            {
                                                let base_op = ctam_label.get_OperateOp_base_op();
                                                (#[verifier::custom_err("cannot prove this condition holds")] (base_op.is_ReplyOp())
                                                        &&
                                                        {
                                                            let reply = base_op.get_ReplyOp_reply();

                                                            #[verifier::custom_err("cannot prove this condition holds")]
                                                            (pre_ephemeral.progress.replies.contains(reply))
                                                        })
                                            })
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn journal_internal(pre: Self, post: Self, label: Label,
                    new_journal: CrashTolerantJournal::State)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_mapadt: CrashTolerantMap::State = pre.mapadt;
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Some())
                                &&
                                (({
                                                let pre_ephemeral = pre.ephemeral.get_Some_0();
                                                let ctam_label = label.get_Label_ctam_label();
                                                (#[verifier::custom_err("cannot prove this condition holds")] (ctam_label.is_Noop())
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantJournal::State::next(pre.journal,
                                                                        new_journal, CrashTolerantJournal::Label::InternalLabel)) &&
                                                                {
                                                                    let update_tmp_journal: CrashTolerantJournal::State =
                                                                        new_journal;

                                                                    #[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")]
                                                                    (::builtin::equal(post.journal, update_tmp_journal))
                                                                }))
                                            }) &&
                                        ((#[verifier::custom_err("cannot prove that the field `ephemeral` is preserved")] (::builtin::equal(post.ephemeral,
                                                            update_tmp_ephemeral)) &&
                                                    #[verifier::custom_err("cannot prove that the field `mapadt` is preserved")] (::builtin::equal(post.mapadt,
                                                            update_tmp_mapadt))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn journal_internal_strong(pre: Self, post: Self,
                    label: Label, new_journal: CrashTolerantJournal::State)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_mapadt: CrashTolerantMap::State = pre.mapadt;
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Some())
                                &&
                                (({
                                                let pre_ephemeral = pre.ephemeral.get_Some_0();
                                                let ctam_label = label.get_Label_ctam_label();
                                                (#[verifier::custom_err("cannot prove this condition holds")] (ctam_label.is_Noop())
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantJournal::State::next(pre.journal,
                                                                        new_journal, CrashTolerantJournal::Label::InternalLabel)) &&
                                                                {
                                                                    let update_tmp_journal: CrashTolerantJournal::State =
                                                                        new_journal;

                                                                    #[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")]
                                                                    (::builtin::equal(post.journal, update_tmp_journal))
                                                                }))
                                            }) &&
                                        ((#[verifier::custom_err("cannot prove that the field `ephemeral` is preserved")] (::builtin::equal(post.ephemeral,
                                                            update_tmp_ephemeral)) &&
                                                    #[verifier::custom_err("cannot prove that the field `mapadt` is preserved")] (::builtin::equal(post.mapadt,
                                                            update_tmp_mapadt))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn journal_internal_enabled(pre: Self, label: Label,
                    new_journal: CrashTolerantJournal::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Some())
                                &&
                                {
                                    let pre_ephemeral = pre.ephemeral.get_Some_0();
                                    let ctam_label = label.get_Label_ctam_label();
                                    (#[verifier::custom_err("cannot prove this condition holds")] (ctam_label.is_Noop())
                                            &&
                                            #[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantJournal::State::next(pre.journal,
                                                    new_journal, CrashTolerantJournal::Label::InternalLabel)))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn map_internal(pre: Self, post: Self, label: Label,
                    new_mapadt: CrashTolerantMap::State)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_journal: CrashTolerantJournal::State =
                            pre.journal;
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Some())
                                &&
                                (({
                                                let pre_ephemeral = pre.ephemeral.get_Some_0();
                                                let ctam_label = label.get_Label_ctam_label();
                                                (#[verifier::custom_err("cannot prove this condition holds")] (ctam_label.is_Noop())
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantMap::State::next(pre.mapadt,
                                                                        new_mapadt, CrashTolerantMap::Label::InternalLabel)) &&
                                                                {
                                                                    let update_tmp_mapadt: CrashTolerantMap::State = new_mapadt;

                                                                    #[verifier::custom_err("cannot prove that final value of field `mapadt` has this updated value")]
                                                                    (::builtin::equal(post.mapadt, update_tmp_mapadt))
                                                                }))
                                            }) &&
                                        ((#[verifier::custom_err("cannot prove that the field `ephemeral` is preserved")] (::builtin::equal(post.ephemeral,
                                                            update_tmp_ephemeral)) &&
                                                    #[verifier::custom_err("cannot prove that the field `journal` is preserved")] (::builtin::equal(post.journal,
                                                            update_tmp_journal))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn map_internal_strong(pre: Self, post: Self,
                    label: Label, new_mapadt: CrashTolerantMap::State)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_journal: CrashTolerantJournal::State =
                            pre.journal;
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Some())
                                &&
                                (({
                                                let pre_ephemeral = pre.ephemeral.get_Some_0();
                                                let ctam_label = label.get_Label_ctam_label();
                                                (#[verifier::custom_err("cannot prove this condition holds")] (ctam_label.is_Noop())
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantMap::State::next(pre.mapadt,
                                                                        new_mapadt, CrashTolerantMap::Label::InternalLabel)) &&
                                                                {
                                                                    let update_tmp_mapadt: CrashTolerantMap::State = new_mapadt;

                                                                    #[verifier::custom_err("cannot prove that final value of field `mapadt` has this updated value")]
                                                                    (::builtin::equal(post.mapadt, update_tmp_mapadt))
                                                                }))
                                            }) &&
                                        ((#[verifier::custom_err("cannot prove that the field `ephemeral` is preserved")] (::builtin::equal(post.ephemeral,
                                                            update_tmp_ephemeral)) &&
                                                    #[verifier::custom_err("cannot prove that the field `journal` is preserved")] (::builtin::equal(post.journal,
                                                            update_tmp_journal))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn map_internal_enabled(pre: Self, label: Label,
                    new_mapadt: CrashTolerantMap::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Some())
                                &&
                                {
                                    let pre_ephemeral = pre.ephemeral.get_Some_0();
                                    let ctam_label = label.get_Label_ctam_label();
                                    (#[verifier::custom_err("cannot prove this condition holds")] (ctam_label.is_Noop())
                                            &&
                                            #[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantMap::State::next(pre.mapadt,
                                                    new_mapadt, CrashTolerantMap::Label::InternalLabel)))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn req_sync(pre: Self, post: Self, label: Label,
                    new_journal: CrashTolerantJournal::State)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_mapadt: CrashTolerantMap::State = pre.mapadt;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Some())
                                &&
                                (({
                                                let pre_ephemeral = pre.ephemeral.get_Some_0();
                                                let ctam_label = label.get_Label_ctam_label();
                                                (#[verifier::custom_err("cannot prove this condition holds")] (ctam_label.is_ReqSyncOp())
                                                        &&
                                                        {
                                                            let sync_req_id = ctam_label.get_ReqSyncOp_sync_req_id();
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (!pre_ephemeral.sync_reqs.dom().contains(sync_req_id))
                                                                    &&
                                                                    (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantJournal::State::next(pre.journal,
                                                                                    new_journal,
                                                                                    CrashTolerantJournal::Label::QueryEndLsnLabel {
                                                                                        end_lsn: pre_ephemeral.map_lsn,
                                                                                    })) &&
                                                                            {
                                                                                let update_tmp_journal: CrashTolerantJournal::State =
                                                                                    new_journal;
                                                                                let update_tmp_ephemeral: Ephemeral =
                                                                                    Some(Known {
                                                                                            sync_reqs: pre_ephemeral.sync_reqs.insert(sync_req_id,
                                                                                                pre_ephemeral.map_lsn),
                                                                                            ..pre_ephemeral
                                                                                        });
                                                                                (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                                                update_tmp_ephemeral)) &&
                                                                                        #[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")] (::builtin::equal(post.journal,
                                                                                                update_tmp_journal)))
                                                                            }))
                                                        })
                                            }) &&
                                        (#[verifier::custom_err("cannot prove that the field `mapadt` is preserved")] (::builtin::equal(post.mapadt,
                                                    update_tmp_mapadt)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn req_sync_strong(pre: Self, post: Self, label: Label,
                    new_journal: CrashTolerantJournal::State)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_mapadt: CrashTolerantMap::State = pre.mapadt;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Some())
                                &&
                                (({
                                                let pre_ephemeral = pre.ephemeral.get_Some_0();
                                                let ctam_label = label.get_Label_ctam_label();
                                                (#[verifier::custom_err("cannot prove this condition holds")] (ctam_label.is_ReqSyncOp())
                                                        &&
                                                        {
                                                            let sync_req_id = ctam_label.get_ReqSyncOp_sync_req_id();
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (!pre_ephemeral.sync_reqs.dom().contains(sync_req_id))
                                                                    &&
                                                                    (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantJournal::State::next(pre.journal,
                                                                                    new_journal,
                                                                                    CrashTolerantJournal::Label::QueryEndLsnLabel {
                                                                                        end_lsn: pre_ephemeral.map_lsn,
                                                                                    })) &&
                                                                            {
                                                                                let update_tmp_journal: CrashTolerantJournal::State =
                                                                                    new_journal;
                                                                                let update_tmp_ephemeral: Ephemeral =
                                                                                    Some(Known {
                                                                                            sync_reqs: pre_ephemeral.sync_reqs.insert(sync_req_id,
                                                                                                pre_ephemeral.map_lsn),
                                                                                            ..pre_ephemeral
                                                                                        });
                                                                                (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                                                update_tmp_ephemeral)) &&
                                                                                        #[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")] (::builtin::equal(post.journal,
                                                                                                update_tmp_journal)))
                                                                            }))
                                                        })
                                            }) &&
                                        (#[verifier::custom_err("cannot prove that the field `mapadt` is preserved")] (::builtin::equal(post.mapadt,
                                                    update_tmp_mapadt)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn req_sync_enabled(pre: Self, label: Label,
                    new_journal: CrashTolerantJournal::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Some())
                                &&
                                {
                                    let pre_ephemeral = pre.ephemeral.get_Some_0();
                                    let ctam_label = label.get_Label_ctam_label();
                                    (#[verifier::custom_err("cannot prove this condition holds")] (ctam_label.is_ReqSyncOp())
                                            &&
                                            {
                                                let sync_req_id = ctam_label.get_ReqSyncOp_sync_req_id();
                                                (#[verifier::custom_err("cannot prove this condition holds")] (!pre_ephemeral.sync_reqs.dom().contains(sync_req_id))
                                                        &&
                                                        #[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantJournal::State::next(pre.journal,
                                                                new_journal,
                                                                CrashTolerantJournal::Label::QueryEndLsnLabel {
                                                                    end_lsn: pre_ephemeral.map_lsn,
                                                                })))
                                            })
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn reply_sync(pre: Self, post: Self, label: Label,
                    new_journal: CrashTolerantJournal::State)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_mapadt: CrashTolerantMap::State = pre.mapadt;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Some())
                                &&
                                (({
                                                let pre_ephemeral = pre.ephemeral.get_Some_0();
                                                let ctam_label = label.get_Label_ctam_label();
                                                (#[verifier::custom_err("cannot prove this condition holds")] (ctam_label.is_ReplySyncOp())
                                                        &&
                                                        {
                                                            let sync_req_id = ctam_label.get_ReplySyncOp_sync_req_id();
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (pre_ephemeral.sync_reqs.dom().contains(sync_req_id))
                                                                    &&
                                                                    (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantJournal::State::next(pre.journal,
                                                                                    new_journal,
                                                                                    CrashTolerantJournal::Label::QueryLsnPersistenceLabel {
                                                                                        sync_lsn: pre_ephemeral.sync_reqs.spec_index(sync_req_id),
                                                                                    })) &&
                                                                            {
                                                                                let update_tmp_journal: CrashTolerantJournal::State =
                                                                                    new_journal;
                                                                                let update_tmp_ephemeral: Ephemeral =
                                                                                    Some(Known {
                                                                                            sync_reqs: pre_ephemeral.sync_reqs.remove(sync_req_id),
                                                                                            ..pre_ephemeral
                                                                                        });
                                                                                (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                                                update_tmp_ephemeral)) &&
                                                                                        #[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")] (::builtin::equal(post.journal,
                                                                                                update_tmp_journal)))
                                                                            }))
                                                        })
                                            }) &&
                                        (#[verifier::custom_err("cannot prove that the field `mapadt` is preserved")] (::builtin::equal(post.mapadt,
                                                    update_tmp_mapadt)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn reply_sync_strong(pre: Self, post: Self, label: Label,
                    new_journal: CrashTolerantJournal::State)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_mapadt: CrashTolerantMap::State = pre.mapadt;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Some())
                                &&
                                (({
                                                let pre_ephemeral = pre.ephemeral.get_Some_0();
                                                let ctam_label = label.get_Label_ctam_label();
                                                (#[verifier::custom_err("cannot prove this condition holds")] (ctam_label.is_ReplySyncOp())
                                                        &&
                                                        {
                                                            let sync_req_id = ctam_label.get_ReplySyncOp_sync_req_id();
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (pre_ephemeral.sync_reqs.dom().contains(sync_req_id))
                                                                    &&
                                                                    (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantJournal::State::next(pre.journal,
                                                                                    new_journal,
                                                                                    CrashTolerantJournal::Label::QueryLsnPersistenceLabel {
                                                                                        sync_lsn: pre_ephemeral.sync_reqs.spec_index(sync_req_id),
                                                                                    })) &&
                                                                            {
                                                                                let update_tmp_journal: CrashTolerantJournal::State =
                                                                                    new_journal;
                                                                                let update_tmp_ephemeral: Ephemeral =
                                                                                    Some(Known {
                                                                                            sync_reqs: pre_ephemeral.sync_reqs.remove(sync_req_id),
                                                                                            ..pre_ephemeral
                                                                                        });
                                                                                (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                                                update_tmp_ephemeral)) &&
                                                                                        #[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")] (::builtin::equal(post.journal,
                                                                                                update_tmp_journal)))
                                                                            }))
                                                        })
                                            }) &&
                                        (#[verifier::custom_err("cannot prove that the field `mapadt` is preserved")] (::builtin::equal(post.mapadt,
                                                    update_tmp_mapadt)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn reply_sync_enabled(pre: Self, label: Label,
                    new_journal: CrashTolerantJournal::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Some())
                                &&
                                {
                                    let pre_ephemeral = pre.ephemeral.get_Some_0();
                                    let ctam_label = label.get_Label_ctam_label();
                                    (#[verifier::custom_err("cannot prove this condition holds")] (ctam_label.is_ReplySyncOp())
                                            &&
                                            {
                                                let sync_req_id = ctam_label.get_ReplySyncOp_sync_req_id();
                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre_ephemeral.sync_reqs.dom().contains(sync_req_id))
                                                        &&
                                                        #[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantJournal::State::next(pre.journal,
                                                                new_journal,
                                                                CrashTolerantJournal::Label::QueryLsnPersistenceLabel {
                                                                    sync_lsn: pre_ephemeral.sync_reqs.spec_index(sync_req_id),
                                                                })))
                                            })
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn commit_start(pre: Self, post: Self, label: Label,
                    new_boundary_lsn: LSN, new_mapadt: CrashTolerantMap::State,
                    new_journal: CrashTolerantJournal::State)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Some())
                                &&
                                (({
                                                let pre_ephemeral = pre.ephemeral.get_Some_0();
                                                let ctam_label = label.get_Label_ctam_label();
                                                (#[verifier::custom_err("cannot prove this condition holds")] (ctam_label.is_Noop())
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantJournal::State::next(pre.journal,
                                                                        new_journal,
                                                                        CrashTolerantJournal::Label::CommitStartLabel {
                                                                            new_boundary_lsn: new_boundary_lsn,
                                                                            max_lsn: pre_ephemeral.map_lsn,
                                                                        })) &&
                                                                (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantMap::State::next(pre.mapadt,
                                                                                new_mapadt,
                                                                                CrashTolerantMap::Label::CommitStartLabel {
                                                                                    new_boundary_lsn: new_boundary_lsn,
                                                                                })) &&
                                                                        {
                                                                            let update_tmp_journal: CrashTolerantJournal::State =
                                                                                new_journal;
                                                                            let update_tmp_mapadt: CrashTolerantMap::State = new_mapadt;
                                                                            (#[verifier::custom_err("cannot prove that final value of field `mapadt` has this updated value")] (::builtin::equal(post.mapadt,
                                                                                            update_tmp_mapadt)) &&
                                                                                    #[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")] (::builtin::equal(post.journal,
                                                                                            update_tmp_journal)))
                                                                        })))
                                            }) &&
                                        (#[verifier::custom_err("cannot prove that the field `ephemeral` is preserved")] (::builtin::equal(post.ephemeral,
                                                    update_tmp_ephemeral)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn commit_start_strong(pre: Self, post: Self,
                    label: Label, new_boundary_lsn: LSN,
                    new_mapadt: CrashTolerantMap::State,
                    new_journal: CrashTolerantJournal::State)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Some())
                                &&
                                (({
                                                let pre_ephemeral = pre.ephemeral.get_Some_0();
                                                let ctam_label = label.get_Label_ctam_label();
                                                (#[verifier::custom_err("cannot prove this condition holds")] (ctam_label.is_Noop())
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantJournal::State::next(pre.journal,
                                                                        new_journal,
                                                                        CrashTolerantJournal::Label::CommitStartLabel {
                                                                            new_boundary_lsn: new_boundary_lsn,
                                                                            max_lsn: pre_ephemeral.map_lsn,
                                                                        })) &&
                                                                (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantMap::State::next(pre.mapadt,
                                                                                new_mapadt,
                                                                                CrashTolerantMap::Label::CommitStartLabel {
                                                                                    new_boundary_lsn: new_boundary_lsn,
                                                                                })) &&
                                                                        {
                                                                            let update_tmp_journal: CrashTolerantJournal::State =
                                                                                new_journal;
                                                                            let update_tmp_mapadt: CrashTolerantMap::State = new_mapadt;
                                                                            (#[verifier::custom_err("cannot prove that final value of field `mapadt` has this updated value")] (::builtin::equal(post.mapadt,
                                                                                            update_tmp_mapadt)) &&
                                                                                    #[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")] (::builtin::equal(post.journal,
                                                                                            update_tmp_journal)))
                                                                        })))
                                            }) &&
                                        (#[verifier::custom_err("cannot prove that the field `ephemeral` is preserved")] (::builtin::equal(post.ephemeral,
                                                    update_tmp_ephemeral)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn commit_start_enabled(pre: Self, label: Label,
                    new_boundary_lsn: LSN, new_mapadt: CrashTolerantMap::State,
                    new_journal: CrashTolerantJournal::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Some())
                                &&
                                {
                                    let pre_ephemeral = pre.ephemeral.get_Some_0();
                                    let ctam_label = label.get_Label_ctam_label();
                                    (#[verifier::custom_err("cannot prove this condition holds")] (ctam_label.is_Noop())
                                            &&
                                            (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantJournal::State::next(pre.journal,
                                                            new_journal,
                                                            CrashTolerantJournal::Label::CommitStartLabel {
                                                                new_boundary_lsn: new_boundary_lsn,
                                                                max_lsn: pre_ephemeral.map_lsn,
                                                            })) &&
                                                    #[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantMap::State::next(pre.mapadt,
                                                            new_mapadt,
                                                            CrashTolerantMap::Label::CommitStartLabel {
                                                                new_boundary_lsn: new_boundary_lsn,
                                                            }))))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn commit_complete(pre: Self, post: Self, label: Label,
                    new_mapadt: CrashTolerantMap::State,
                    new_journal: CrashTolerantJournal::State)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Some())
                                &&
                                (({
                                                let pre_ephemeral = pre.ephemeral.get_Some_0();
                                                let ctam_label = label.get_Label_ctam_label();
                                                (#[verifier::custom_err("cannot prove this condition holds")] (ctam_label.is_SyncOp())
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantJournal::State::next(pre.journal,
                                                                        new_journal,
                                                                        CrashTolerantJournal::Label::CommitCompleteLabel {
                                                                            require_end: pre_ephemeral.map_lsn,
                                                                        })) &&
                                                                (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantMap::State::next(pre.mapadt,
                                                                                new_mapadt, CrashTolerantMap::Label::CommitCompleteLabel))
                                                                        &&
                                                                        {
                                                                            let update_tmp_journal: CrashTolerantJournal::State =
                                                                                new_journal;
                                                                            let update_tmp_mapadt: CrashTolerantMap::State = new_mapadt;
                                                                            (#[verifier::custom_err("cannot prove that final value of field `mapadt` has this updated value")] (::builtin::equal(post.mapadt,
                                                                                            update_tmp_mapadt)) &&
                                                                                    #[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")] (::builtin::equal(post.journal,
                                                                                            update_tmp_journal)))
                                                                        })))
                                            }) &&
                                        (#[verifier::custom_err("cannot prove that the field `ephemeral` is preserved")] (::builtin::equal(post.ephemeral,
                                                    update_tmp_ephemeral)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn commit_complete_strong(pre: Self, post: Self,
                    label: Label, new_mapadt: CrashTolerantMap::State,
                    new_journal: CrashTolerantJournal::State)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Some())
                                &&
                                (({
                                                let pre_ephemeral = pre.ephemeral.get_Some_0();
                                                let ctam_label = label.get_Label_ctam_label();
                                                (#[verifier::custom_err("cannot prove this condition holds")] (ctam_label.is_SyncOp())
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantJournal::State::next(pre.journal,
                                                                        new_journal,
                                                                        CrashTolerantJournal::Label::CommitCompleteLabel {
                                                                            require_end: pre_ephemeral.map_lsn,
                                                                        })) &&
                                                                (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantMap::State::next(pre.mapadt,
                                                                                new_mapadt, CrashTolerantMap::Label::CommitCompleteLabel))
                                                                        &&
                                                                        {
                                                                            let update_tmp_journal: CrashTolerantJournal::State =
                                                                                new_journal;
                                                                            let update_tmp_mapadt: CrashTolerantMap::State = new_mapadt;
                                                                            (#[verifier::custom_err("cannot prove that final value of field `mapadt` has this updated value")] (::builtin::equal(post.mapadt,
                                                                                            update_tmp_mapadt)) &&
                                                                                    #[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")] (::builtin::equal(post.journal,
                                                                                            update_tmp_journal)))
                                                                        })))
                                            }) &&
                                        (#[verifier::custom_err("cannot prove that the field `ephemeral` is preserved")] (::builtin::equal(post.ephemeral,
                                                    update_tmp_ephemeral)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn commit_complete_enabled(pre: Self, label: Label,
                    new_mapadt: CrashTolerantMap::State,
                    new_journal: CrashTolerantJournal::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.is_Some())
                                &&
                                {
                                    let pre_ephemeral = pre.ephemeral.get_Some_0();
                                    let ctam_label = label.get_Label_ctam_label();
                                    (#[verifier::custom_err("cannot prove this condition holds")] (ctam_label.is_SyncOp())
                                            &&
                                            (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantJournal::State::next(pre.journal,
                                                            new_journal,
                                                            CrashTolerantJournal::Label::CommitCompleteLabel {
                                                                require_end: pre_ephemeral.map_lsn,
                                                            })) &&
                                                    #[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantMap::State::next(pre.mapadt,
                                                            new_mapadt, CrashTolerantMap::Label::CommitCompleteLabel))))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn crash(pre: Self, post: Self, label: Label,
                    new_journal: CrashTolerantJournal::State,
                    new_mapadt: CrashTolerantMap::State)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = label;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Label {
                                            ctam_label: CrashTolerantAsyncMap::Label::CrashOp } => true,
                                        _ => false,
                                    }) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantJournal::State::next(pre.journal,
                                                new_journal, CrashTolerantJournal::Label::CrashLabel)) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantMap::State::next(pre.mapadt,
                                                        new_mapadt, CrashTolerantMap::Label::CrashLabel)) &&
                                                {
                                                    let update_tmp_journal: CrashTolerantJournal::State =
                                                        new_journal;
                                                    let update_tmp_mapadt: CrashTolerantMap::State = new_mapadt;
                                                    let update_tmp_ephemeral: Ephemeral = None;
                                                    (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                    update_tmp_ephemeral)) &&
                                                            (#[verifier::custom_err("cannot prove that final value of field `mapadt` has this updated value")] (::builtin::equal(post.mapadt,
                                                                            update_tmp_mapadt)) &&
                                                                    #[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")] (::builtin::equal(post.journal,
                                                                            update_tmp_journal))))
                                                })))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn crash_strong(pre: Self, post: Self, label: Label,
                    new_journal: CrashTolerantJournal::State,
                    new_mapadt: CrashTolerantMap::State)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = label;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Label {
                                            ctam_label: CrashTolerantAsyncMap::Label::CrashOp } => true,
                                        _ => false,
                                    }) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantJournal::State::next(pre.journal,
                                                new_journal, CrashTolerantJournal::Label::CrashLabel)) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantMap::State::next(pre.mapadt,
                                                        new_mapadt, CrashTolerantMap::Label::CrashLabel)) &&
                                                {
                                                    let update_tmp_journal: CrashTolerantJournal::State =
                                                        new_journal;
                                                    let update_tmp_mapadt: CrashTolerantMap::State = new_mapadt;
                                                    let update_tmp_ephemeral: Ephemeral = None;
                                                    (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                    update_tmp_ephemeral)) &&
                                                            (#[verifier::custom_err("cannot prove that final value of field `mapadt` has this updated value")] (::builtin::equal(post.mapadt,
                                                                            update_tmp_mapadt)) &&
                                                                    #[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")] (::builtin::equal(post.journal,
                                                                            update_tmp_journal))))
                                                })))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn crash_enabled(pre: Self, label: Label,
                    new_journal: CrashTolerantJournal::State,
                    new_mapadt: CrashTolerantMap::State)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = label;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Label {
                                            ctam_label: CrashTolerantAsyncMap::Label::CrashOp } => true,
                                        _ => false,
                                    }) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantJournal::State::next(pre.journal,
                                                new_journal, CrashTolerantJournal::Label::CrashLabel)) &&
                                        #[verifier::custom_err("cannot prove this condition holds")] (CrashTolerantMap::State::next(pre.mapadt,
                                                new_mapadt, CrashTolerantMap::Label::CrashLabel))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_by(pre: State, post: State, label: Label,
                    step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::load_ephemeral_from_persistent(new_journal,
                            new_mapadt, map_lsn) =>
                            Self::load_ephemeral_from_persistent(pre, post, label,
                                new_journal, new_mapadt, map_lsn),
                        Step::recover(new_journal, new_mapadt, records) =>
                            Self::recover(pre, post, label, new_journal, new_mapadt,
                                records),
                        Step::accept_request() =>
                            Self::accept_request(pre, post, label),
                        Step::query(new_journal, new_mapadt) =>
                            Self::query(pre, post, label, new_journal, new_mapadt),
                        Step::put(new_journal, new_mapadt) =>
                            Self::put(pre, post, label, new_journal, new_mapadt),
                        Step::deliver_reply() =>
                            Self::deliver_reply(pre, post, label),
                        Step::journal_internal(new_journal) =>
                            Self::journal_internal(pre, post, label, new_journal),
                        Step::map_internal(new_mapadt) =>
                            Self::map_internal(pre, post, label, new_mapadt),
                        Step::req_sync(new_journal) =>
                            Self::req_sync(pre, post, label, new_journal),
                        Step::reply_sync(new_journal) =>
                            Self::reply_sync(pre, post, label, new_journal),
                        Step::commit_start(new_boundary_lsn, new_mapadt,
                            new_journal) =>
                            Self::commit_start(pre, post, label, new_boundary_lsn,
                                new_mapadt, new_journal),
                        Step::commit_complete(new_mapadt, new_journal) =>
                            Self::commit_complete(pre, post, label, new_mapadt,
                                new_journal),
                        Step::crash(new_journal, new_mapadt) =>
                            Self::crash(pre, post, label, new_journal, new_mapadt),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next(pre: State, post: State, label: Label)
                    -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                            Self::next_by(pre, post, label, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_strong_by(pre: State, post: State, label: Label,
                    step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::load_ephemeral_from_persistent(new_journal,
                            new_mapadt, map_lsn) =>
                            Self::load_ephemeral_from_persistent_strong(pre, post,
                                label, new_journal, new_mapadt, map_lsn),
                        Step::recover(new_journal, new_mapadt, records) =>
                            Self::recover_strong(pre, post, label, new_journal,
                                new_mapadt, records),
                        Step::accept_request() =>
                            Self::accept_request_strong(pre, post, label),
                        Step::query(new_journal, new_mapadt) =>
                            Self::query_strong(pre, post, label, new_journal,
                                new_mapadt),
                        Step::put(new_journal, new_mapadt) =>
                            Self::put_strong(pre, post, label, new_journal, new_mapadt),
                        Step::deliver_reply() =>
                            Self::deliver_reply_strong(pre, post, label),
                        Step::journal_internal(new_journal) =>
                            Self::journal_internal_strong(pre, post, label,
                                new_journal),
                        Step::map_internal(new_mapadt) =>
                            Self::map_internal_strong(pre, post, label, new_mapadt),
                        Step::req_sync(new_journal) =>
                            Self::req_sync_strong(pre, post, label, new_journal),
                        Step::reply_sync(new_journal) =>
                            Self::reply_sync_strong(pre, post, label, new_journal),
                        Step::commit_start(new_boundary_lsn, new_mapadt,
                            new_journal) =>
                            Self::commit_start_strong(pre, post, label,
                                new_boundary_lsn, new_mapadt, new_journal),
                        Step::commit_complete(new_mapadt, new_journal) =>
                            Self::commit_complete_strong(pre, post, label, new_mapadt,
                                new_journal),
                        Step::crash(new_journal, new_mapadt) =>
                            Self::crash_strong(pre, post, label, new_journal,
                                new_mapadt),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_strong(pre: State, post: State, label: Label)
                    -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                            Self::next_strong_by(pre, post, label, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn init_by(post: State, step: Config)
                    -> ::core::primitive::bool {
                    match step {
                        Config::initialize(state) => Self::initialize(post, state),
                        Config::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn init(post: State) -> ::core::primitive::bool {
                    ::builtin::exists(|step: Config| Self::init_by(post, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::spec]
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                pub fn invariant(&self) -> ::core::primitive::bool { true }
            }
        }
    }
    pub mod AbstractCrashTolerantSystemRefinement_v {
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        use vstd::map::*;
        use vstd::prelude::*;
        use vstd::seq_lib::*;
        use vstd::set_lib::*;
        use crate::spec::FloatingSeq_t::*;
        use crate::spec::MapSpec_t;
        use crate::spec::MapSpec_t::*;
        use crate::spec::Messages_t::*;
        use crate::spec::Option_t;
        use crate::spec::TotalKMMap_t;
        use crate::abstract_system::AbstractCrashAwareJournal_v;
        use crate::abstract_system::AbstractCrashAwareJournal_v::*;
        use crate::abstract_system::AbstractCrashAwareMap_v;
        use crate::abstract_system::AbstractCrashAwareMap_v::*;
        use crate::abstract_system::AbstractCrashTolerantSystem_v::*;
        use crate::abstract_system::AbstractJournal_v::AbstractJournal;
        use crate::abstract_system::AbstractMap_v::*;
        use crate::abstract_system::MsgHistory_v::{KeyedMessage, MsgHistory};
        use crate::abstract_system::StampedMap_v::*;
        #[verus::internal(verus_macro)]
        impl CrashTolerantJournal::State {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> MsgHistory {
                ::builtin::recommends([self.ephemeral.is_Known()]);
                self.ephemeral.get_Known_v().journal
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                ((self.persistent.wf()) && (self.ephemeral.wf())) &&
                    ((::builtin::imply(self.in_flight.is_Some(),
                                self.in_flight.get_Some_0().wf())))
            }
        }
        #[verus::internal(verus_macro)]
        impl CrashTolerantMap::State {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> StampedMap {
                ::builtin::recommends([self.ephemeral.is_Known()]);
                self.ephemeral.get_Known_v().stamped_map
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                ((self.persistent.value.wf()) &&
                            (match self.ephemeral {
                                    AbstractCrashAwareMap_v::Ephemeral::Known { v } =>
                                        v.stamped_map.value.wf(),
                                    _ => true,
                                })) &&
                    (match self.in_flight {
                            Option_t::Option::Some(v) => v.value.wf(),
                            _ => true,
                        })
            }
        }
        type Journal = MsgHistory;
        #[verus::internal(verus_macro)]
        impl CoordinationSystem::State {
            #[doc =
            " Return the \"seq_end\" of the ephemeral (most up-to-date, not necessarily persisted)"]
            #[doc = " state."]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn ephemeral_seq_end(self) -> LSN {
                ::builtin::recommends([self.ephemeral.is_Some(),
                            self.journal.ephemeral.is_Known()]);
                self.journal.i().seq_end
            }
            #[doc =
            " Return the CrashTolerantAsyncMap state that this CoordinationSystem state"]
            #[doc = " corresponds to. (Interpretation function)."]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> CrashTolerantAsyncMap::State {
                ::builtin::recommends([self.inv()]);
                let stable_lsn = self.journal.persistent.seq_end;
                match self.ephemeral {
                    Some(Known { progress, sync_reqs, .. }) => {
                        let _ =
                            spec_affirm(::builtin::spec_eq(self.journal.i(),
                                    self.journal.ephemeral.get_Known_v().journal));
                        let _ =
                            spec_affirm(self.journal.i().can_follow(self.mapadt.persistent.seq_end));
                        let _ =
                            spec_affirm(self.journal.i().can_discard_to(stable_lsn));
                        CrashTolerantAsyncMap::State {
                            versions: floating_versions(self.mapadt.persistent,
                                self.journal.i(), stable_lsn),
                            async_ephemeral: progress,
                            sync_requests: sync_reqs,
                        }
                    }
                    None => {
                        let _ =
                            spec_affirm(self.journal.persistent.can_follow(self.mapadt.persistent.seq_end));
                        CrashTolerantAsyncMap::State {
                            versions: floating_versions(self.mapadt.persistent,
                                self.journal.persistent, stable_lsn),
                            async_ephemeral: AsyncMap::State::init_ephemeral_state(),
                            sync_requests: Map::empty(),
                        }
                    }
                }
            }
        }
        #[doc =
        " Convert a StampedMap to a Version. (Both are representations of a map\'s concrete"]
        #[doc =
        " state (key-value pairs), Version just doesn\'t have seq_end)."]
        #[verus::internal(verus_macro)]
        impl StampedMap {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn to_version(self) -> Version {
                PersistentState { appv: MapSpec::State { kmmap: self.value } }
            }
        }
        #[doc =
        " Return a FloatingSeq `s` of Versions (map state snapshots), with active"]
        #[doc =
        " indices in the range [stable_lsn, msg_history.seq_end], where"]
        #[doc =
        " `s[stable_lsn + i]` is the state of the map after the first `i` active"]
        #[doc = " operations in `msg_history` have been applied to `base`."]
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn floating_versions(base: StampedMap, msg_history: MsgHistory,
            stable_lsn: LSN) -> FloatingSeq<Version> {
            ::builtin::recommends([base.value.wf(), msg_history.wf(),
                        msg_history.can_follow(base.seq_end),
                        msg_history.can_discard_to(stable_lsn)]);
            FloatingSeq::new(stable_lsn,
                (msg_history.seq_end).spec_add(::builtin::spec_literal_nat("1")),
                ::builtin::closure_to_fn_spec(|lsn: int|
                        MsgHistory::map_plus_history(base,
                                msg_history.discard_recent(::builtin::spec_cast_integer::<_,
                                            LSN>(lsn))).to_version()))
        }
        #[verus::internal(verus_macro)]
        impl CoordinationSystem::State { }
        #[verus::internal(verus_macro)]
        #[verus::internal(closed)]
        #[verus::internal(spec(checked))]
        pub fn journal_overlaps_agree(j0: Journal, j1: Journal) -> bool {
            ::builtin::recommends([j0.wf(), j1.wf()]);
            ::builtin::forall(|lsn|
                    #[verus::internal(auto_trigger)] (::builtin::imply(j0.contains(lsn)
                                && j1.contains(lsn),
                            ::builtin::spec_eq(j0.msgs.spec_index(lsn),
                                j1.msgs.spec_index(lsn)))))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn journal_extends_journal(jlong: Journal, jshort: Journal,
            start_lsn: LSN) -> bool {
            ::builtin::recommends([jlong.can_follow(start_lsn),
                        jshort.can_follow(start_lsn)]);
            (jlong.can_discard_to(jshort.seq_end)) &&
                (::builtin::spec_eq(jlong.discard_recent(jshort.seq_end),
                        jshort))
        }
        #[verus::internal(verus_macro)]
        impl CoordinationSystem::State {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                ((((self.journal.wf()) && (self.mapadt.wf())) &&
                                    (::builtin::spec_eq(self.ephemeral.is_Some(),
                                            self.journal.ephemeral.is_Known()))) &&
                            (::builtin::spec_eq(self.journal.ephemeral.is_Known(),
                                    self.mapadt.ephemeral.is_Known()))) &&
                    (::builtin::imply(self.journal.in_flight.is_Some(),
                            self.mapadt.in_flight.is_Some()))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn inv_persistent_journal_geometry(self) -> bool {
                self.journal.persistent.can_follow(self.mapadt.persistent.seq_end)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn inv_ephemeral_geometry(self) -> bool {
                ::builtin::recommends([self.wf(), self.ephemeral.is_Some()]);
                ((((self.journal.i().can_follow(self.mapadt.persistent.seq_end))
                                            &&
                                            ((self.mapadt.persistent.seq_end).spec_le(self.mapadt.i().seq_end)))
                                    &&
                                    (self.journal.i().can_discard_to(self.mapadt.i().seq_end)))
                            &&
                            ((self.journal.persistent.seq_end).spec_le(self.ephemeral_seq_end())))
                    &&
                    (::builtin::spec_eq(self.ephemeral.get_Some_0().map_lsn,
                            self.mapadt.ephemeral.get_Known_v().stamped_map.seq_end))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn inv_ephemeral_value_agreement(self) -> bool {
                ::builtin::recommends([self.wf(), self.ephemeral.is_Some(),
                            self.inv_ephemeral_geometry()]);
                (journal_overlaps_agree(self.journal.persistent,
                            self.journal.i())) &&
                    (::builtin::spec_eq(self.mapadt.i(),
                            MsgHistory::map_plus_history(self.mapadt.persistent,
                                self.journal.i().discard_recent(self.mapadt.i().seq_end))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn map_is_frozen(self) -> bool {
                self.mapadt.in_flight.is_Some()
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn commit_started(self) -> bool {
                self.journal.in_flight.is_Some()
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn inv_frozen_map_geometry(self) -> bool {
                ::builtin::recommends([self.wf(), self.ephemeral.is_Some(),
                            self.map_is_frozen()]);
                ((self.mapadt.in_flight.get_Some_0().seq_end).spec_le(self.ephemeral_seq_end()))
                    &&
                    ((self.mapadt.persistent.seq_end).spec_le(self.mapadt.in_flight.get_Some_0().seq_end))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn inv_frozen_map_value_agreement(self) -> bool {
                ::builtin::recommends([self.wf(), self.ephemeral.is_Some(),
                            self.inv_ephemeral_geometry(), self.map_is_frozen(),
                            self.inv_frozen_map_geometry()]);
                ::builtin::spec_eq(self.mapadt.in_flight.get_Some_0(),
                    MsgHistory::map_plus_history(self.mapadt.persistent,
                        self.journal.i().discard_recent(self.mapadt.in_flight.get_Some_0().seq_end)))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn inv_commit_started_geometry(self) -> bool {
                ::builtin::recommends([self.commit_started()]);
                let if_map = self.mapadt.in_flight.get_Some_0();
                let if_journal = self.journal.in_flight.get_Some_0();
                ((((((self.wf()) && (self.ephemeral.is_Some())) &&
                                                    (self.inv_ephemeral_geometry())) &&
                                            (if_journal.can_follow(if_map.seq_end))) &&
                                    ((self.journal.persistent.seq_end).spec_le(if_journal.seq_end)))
                            &&
                            ((self.mapadt.persistent.seq_end).spec_le(if_map.seq_end)))
                    && ((if_journal.seq_end).spec_le(self.ephemeral_seq_end()))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn inv_commit_started_value_agreement(self) -> bool {
                ::builtin::recommends([self.commit_started(),
                            self.inv_commit_started_geometry()]);
                let if_map = self.mapadt.in_flight.get_Some_0();
                let if_journal = self.journal.in_flight.get_Some_0();
                ((journal_overlaps_agree(if_journal, self.journal.persistent))
                            && (journal_overlaps_agree(if_journal, self.journal.i())))
                    &&
                    (::builtin::spec_eq(if_map,
                            MsgHistory::map_plus_history(self.mapadt.persistent,
                                self.journal.i().discard_recent(if_map.seq_end))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn inv(self) -> bool {
                ((((self.wf()) && (self.inv_persistent_journal_geometry())) &&
                                    (::builtin::imply(self.ephemeral.is_None(),
                                            { !self.map_is_frozen() && !self.commit_started() }))) &&
                            (::builtin::imply(self.ephemeral.is_Some(),
                                    {
                                        ((self.inv_ephemeral_geometry()) &&
                                                    (self.inv_ephemeral_value_agreement())) &&
                                            (::builtin::imply(self.map_is_frozen(),
                                                    {
                                                        (self.inv_frozen_map_geometry()) &&
                                                            (self.inv_frozen_map_value_agreement())
                                                    }))
                                    }))) &&
                    (::builtin::imply(self.commit_started(),
                            {
                                (self.inv_commit_started_geometry()) &&
                                    (self.inv_commit_started_value_agreement())
                            }))
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_init_refines(v: CoordinationSystem::State) {
            ::builtin::requires([CoordinationSystem::State::init(v)]);
            ::builtin::ensures([v.inv(),
                        CrashTolerantAsyncMap::State::init(v.i())]);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CoordinationSystem::State::init)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CoordinationSystem::State::init_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::init)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::init_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantMap::State::init)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantMap::State::init_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            match ::builtin::choose(|config: CoordinationSystem::Config|
                        CoordinationSystem::State::init_by(v, config)) {
                CoordinationSystem::Config::initialize(state) => {
                    v.i().versions.extensionality(FloatingSeq::new(::builtin::spec_literal_integer("0"),
                            ::builtin::spec_literal_integer("1"),
                            ::builtin::closure_to_fn_spec(|i|
                                    AsyncMap::State::init_persistent_state())));
                    ::builtin::assert_(CrashTolerantAsyncMap::State::initialize(v.i()));
                    CrashTolerantAsyncMap::show::initialize(v.i());
                }
                CoordinationSystem::Config::dummy_to_use_type_params(_) => {}
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn commit_step_preserves_history(v: CoordinationSystem::State,
            vp: CoordinationSystem::State, label: CoordinationSystem::Label,
            step: CoordinationSystem::Step, lsn: LSN) {
            ::builtin::requires([v.inv(),
                        CoordinationSystem::State::next(v, vp, label),
                        CoordinationSystem::State::next_by(v, vp, label, step),
                        match step {
                            CoordinationSystem::Step::commit_complete(_, _) => true,
                            _ => false,
                        },
                        ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(v.mapadt.persistent.seq_end),
                                    lsn), v.ephemeral_seq_end())),
                        (v.mapadt.in_flight.get_Some_0().seq_end).spec_le(lsn)]);
            ::builtin::ensures([v.journal.i().can_discard_to(lsn),
                        ::builtin::spec_eq(MsgHistory::map_plus_history(v.mapadt.persistent,
                                v.journal.i().discard_recent(lsn)),
                            MsgHistory::map_plus_history(vp.mapadt.persistent,
                                vp.journal.i().discard_recent(lsn)))]);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CoordinationSystem::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CoordinationSystem::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantMap::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantMap::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractJournal::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractJournal::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::assert_(v.ephemeral.is_Some());
            ::builtin::assert_(v.journal.ephemeral.is_Known());
            ::builtin::assert_(CrashTolerantJournal::State::next(v.journal,
                    vp.journal,
                    CrashTolerantJournal::Label::CommitCompleteLabel {
                        require_end: v.ephemeral.get_Some_0().map_lsn,
                    }));
            let ref_lsn = v.mapadt.in_flight.get_Some_0().seq_end;
            let ej = v.journal.i();
            ::builtin::assert_(ej.can_discard_to(lsn));
            let eji = ej.discard_recent(lsn);
            journal_associativity(v.mapadt.persistent,
                ej.discard_recent(ref_lsn),
                ej.discard_recent(lsn).discard_old(ref_lsn));
            ej.discard_recent(ref_lsn).concat_lemma(ej.discard_old(ref_lsn));
            #[verifier::spec]
            let m1 =
                ::vstd::map::check_argument_is_map(ej.discard_recent(ref_lsn).concat(ej.discard_old(ref_lsn)).msgs);
            #[verifier::spec]
            let m2 = ::vstd::map::check_argument_is_map(ej.msgs);
            ::builtin::assert_by(::builtin::equal(m1, m2),
                {
                    ::builtin::assert_forall_by(|key|
                            {
                                ::builtin::ensures([::builtin::imply(#[verifier::trigger] m1.dom().contains(key),
                                                        m2.dom().contains(key)) &&
                                                    ::builtin::imply(m2.dom().contains(key),
                                                        m1.dom().contains(key)) &&
                                                ::builtin::imply(m1.dom().contains(key) &&
                                                        m2.dom().contains(key),
                                                    ::builtin::equal(m1.index(key), m2.index(key)))]);
                                { {} }
                            });
                    ::builtin::assert_(::builtin::ext_equal(m1, m2));
                });
            ;
            #[verifier::spec]
            let m1 =
                ::vstd::map::check_argument_is_map(ej.discard_old(ref_lsn).discard_recent(lsn).msgs);
            #[verifier::spec]
            let m2 =
                ::vstd::map::check_argument_is_map(ej.discard_recent(lsn).discard_old(ref_lsn).msgs);
            ::builtin::assert_by(::builtin::equal(m1, m2),
                {
                    ::builtin::assert_forall_by(|key|
                            {
                                ::builtin::ensures([::builtin::imply(#[verifier::trigger] m1.dom().contains(key),
                                                        m2.dom().contains(key)) &&
                                                    ::builtin::imply(m2.dom().contains(key),
                                                        m1.dom().contains(key)) &&
                                                ::builtin::imply(m1.dom().contains(key) &&
                                                        m2.dom().contains(key),
                                                    ::builtin::equal(m1.index(key), m2.index(key)))]);
                                { {} }
                            });
                    ::builtin::assert_(::builtin::ext_equal(m1, m2));
                });
            ;
            #[verifier::spec]
            let m1 =
                ::vstd::map::check_argument_is_map(ej.discard_recent(ref_lsn).concat(ej.discard_old(ref_lsn).discard_recent(lsn)).msgs);
            #[verifier::spec]
            let m2 =
                ::vstd::map::check_argument_is_map(ej.discard_recent(ref_lsn).concat(ej.discard_old(ref_lsn)).discard_recent(lsn).msgs);
            ::builtin::assert_by(::builtin::equal(m1, m2),
                {
                    ::builtin::assert_forall_by(|key|
                            {
                                ::builtin::ensures([::builtin::imply(#[verifier::trigger] m1.dom().contains(key),
                                                        m2.dom().contains(key)) &&
                                                    ::builtin::imply(m2.dom().contains(key),
                                                        m1.dom().contains(key)) &&
                                                ::builtin::imply(m1.dom().contains(key) &&
                                                        m2.dom().contains(key),
                                                    ::builtin::equal(m1.index(key), m2.index(key)))]);
                                { {} }
                            });
                    ::builtin::assert_(::builtin::ext_equal(m1, m2));
                });
            ;
            MsgHistory::map_plus_history_forall_lemma();
            MsgHistory::map_plus_history_seq_end_lemma(v.mapadt.persistent,
                v.journal.i().discard_recent(lsn));
            MsgHistory::map_plus_history_seq_end_lemma(vp.mapadt.persistent,
                vp.journal.i().discard_recent(lsn));
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn journal_associativity(x: StampedMap, y: MsgHistory,
            z: MsgHistory) {
            ::builtin::requires([y.wf(), z.wf(), y.can_follow(x.seq_end),
                        z.can_follow(y.seq_end)]);
            ::builtin::ensures([::builtin::spec_eq(MsgHistory::map_plus_history(MsgHistory::map_plus_history(x,
                                    y), z), MsgHistory::map_plus_history(x, y.concat(z)))]);
            ::builtin::decreases((z.len(),));
            let left =
                MsgHistory::map_plus_history(MsgHistory::map_plus_history(x,
                        y), z);
            let right = MsgHistory::map_plus_history(x, y.concat(z));
            if !z.is_empty() {
                    let ztrim =
                        z.discard_recent(::builtin::spec_cast_integer::<_,
                                    nat>(((z.seq_end).spec_sub(::builtin::spec_literal_nat("1")))));
                    let yz = y.concat(z);
                    journal_associativity(x, y, ztrim);
                    {
                        ::builtin::assert_by(::builtin::spec_eq(yz.discard_recent(::builtin::spec_cast_integer::<_,
                                            nat>(((yz.seq_end).spec_sub(::builtin::spec_literal_nat("1"))))),
                                y.concat(ztrim)),
                            {
                                #[verifier::spec]
                                let m1 =
                                    ::vstd::map::check_argument_is_map(yz.discard_recent(::builtin::spec_cast_integer::<_,
                                                        nat>(((yz.seq_end).spec_sub(::builtin::spec_literal_nat("1"))))).msgs);
                                #[verifier::spec]
                                let m2 =
                                    ::vstd::map::check_argument_is_map(y.concat(ztrim).msgs);
                                ::builtin::assert_by(::builtin::equal(m1, m2),
                                    {
                                        ::builtin::assert_forall_by(|key|
                                                {
                                                    ::builtin::ensures([::builtin::imply(#[verifier::trigger] m1.dom().contains(key),
                                                                            m2.dom().contains(key)) &&
                                                                        ::builtin::imply(m2.dom().contains(key),
                                                                            m1.dom().contains(key)) &&
                                                                    ::builtin::imply(m1.dom().contains(key) &&
                                                                            m2.dom().contains(key),
                                                                        ::builtin::equal(m1.index(key), m2.index(key)))]);
                                                    { {} }
                                                });
                                        ::builtin::assert_(::builtin::ext_equal(m1, m2));
                                    });
                                ;
                            });
                    }
                    ::builtin::assert_(::builtin::spec_eq(left, right));
                } else {
                   let yz = y.concat(z);
                   #[verifier::spec]
                   let m1 = ::vstd::map::check_argument_is_map(yz.msgs);
                   #[verifier::spec]
                   let m2 = ::vstd::map::check_argument_is_map(y.msgs);
                   ::builtin::assert_by(::builtin::equal(m1, m2),
                       {
                           ::builtin::assert_forall_by(|key|
                                   {
                                       ::builtin::ensures([::builtin::imply(#[verifier::trigger] m1.dom().contains(key),
                                                               m2.dom().contains(key)) &&
                                                           ::builtin::imply(m2.dom().contains(key),
                                                               m1.dom().contains(key)) &&
                                                       ::builtin::imply(m1.dom().contains(key) &&
                                                               m2.dom().contains(key),
                                                           ::builtin::equal(m1.index(key), m2.index(key)))]);
                                       { {} }
                                   });
                           ::builtin::assert_(::builtin::ext_equal(m1, m2));
                       });
                   ;
                   ::builtin::assert_(::builtin::spec_eq(left, right));
               }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn inv_inductive_put_step(v: CoordinationSystem::State,
            vp: CoordinationSystem::State, label: CoordinationSystem::Label,
            step: CoordinationSystem::Step) {
            ::builtin::requires([v.inv(),
                        CoordinationSystem::State::next(v, vp, label),
                        CoordinationSystem::State::next_by(v, vp, label, step),
                        match step {
                            CoordinationSystem::Step::put(_, _) => true,
                            _ => false,
                        }]);
            ::builtin::ensures([vp.inv()]);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CoordinationSystem::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CoordinationSystem::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractJournal::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractJournal::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantMap::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantMap::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractMap::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractMap::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            if v.map_is_frozen() {
                    let frozen_end = v.mapadt.in_flight.get_Some_0().seq_end;
                    {
                        ::builtin::assert_by(::builtin::spec_eq(v.journal.i().discard_recent(frozen_end),
                                vp.journal.i().discard_recent(frozen_end)),
                            {
                                #[verifier::spec]
                                let m1 =
                                    ::vstd::map::check_argument_is_map(v.journal.i().discard_recent(frozen_end).msgs);
                                #[verifier::spec]
                                let m2 =
                                    ::vstd::map::check_argument_is_map(vp.journal.i().discard_recent(frozen_end).msgs);
                                ::builtin::assert_by(::builtin::equal(m1, m2),
                                    {
                                        ::builtin::assert_forall_by(|key|
                                                {
                                                    ::builtin::ensures([::builtin::imply(#[verifier::trigger] m1.dom().contains(key),
                                                                            m2.dom().contains(key)) &&
                                                                        ::builtin::imply(m2.dom().contains(key),
                                                                            m1.dom().contains(key)) &&
                                                                    ::builtin::imply(m1.dom().contains(key) &&
                                                                            m2.dom().contains(key),
                                                                        ::builtin::equal(m1.index(key), m2.index(key)))]);
                                                    { {} }
                                                });
                                        ::builtin::assert_(::builtin::ext_equal(m1, m2));
                                    });
                                ;
                            });
                    }
                }
            let key =
                label.get_Label_ctam_label().get_OperateOp_base_op().get_ExecuteOp_req().input.get_PutInput_key();
            let value =
                label.get_Label_ctam_label().get_OperateOp_base_op().get_ExecuteOp_req().input.get_PutInput_value();
            let keyed_message =
                KeyedMessage {
                    key: key,
                    message: Message::Define { value: value },
                };
            let singleton =
                MsgHistory::singleton_at(v.ephemeral.get_Some_0().map_lsn,
                    keyed_message);
            ::builtin::assert_(CrashTolerantJournal::State::next(v.journal,
                    vp.journal,
                    CrashTolerantJournal::Label::PutLabel {
                        records: singleton,
                    }));
            journal_associativity(v.mapadt.persistent, v.journal.i(),
                singleton);
            {
                ::builtin::assert_by(::builtin::spec_eq(v.journal.i().discard_recent(v.mapadt.i().seq_end),
                        v.journal.i()),
                    {
                        #[verifier::spec]
                        let m1 =
                            ::vstd::map::check_argument_is_map(v.journal.i().discard_recent(v.mapadt.i().seq_end).msgs);
                        #[verifier::spec]
                        let m2 =
                            ::vstd::map::check_argument_is_map(v.journal.i().msgs);
                        ::builtin::assert_by(::builtin::equal(m1, m2),
                            {
                                ::builtin::assert_forall_by(|key|
                                        {
                                            ::builtin::ensures([::builtin::imply(#[verifier::trigger] m1.dom().contains(key),
                                                                    m2.dom().contains(key)) &&
                                                                ::builtin::imply(m2.dom().contains(key),
                                                                    m1.dom().contains(key)) &&
                                                            ::builtin::imply(m1.dom().contains(key) &&
                                                                    m2.dom().contains(key),
                                                                ::builtin::equal(m1.index(key), m2.index(key)))]);
                                            { {} }
                                        });
                                ::builtin::assert_(::builtin::ext_equal(m1, m2));
                            });
                        ;
                    });
            }
            ::builtin::assert_(::builtin::spec_eq(vp.mapadt.i(),
                    MsgHistory::map_plus_history(v.mapadt.i(), singleton)));
            MsgHistory::map_plus_history_forall_lemma();
            {
                ::builtin::assert_by(::builtin::spec_eq(vp.journal.i(),
                        vp.journal.i().discard_recent(vp.mapadt.i().seq_end)),
                    {
                        #[verifier::spec]
                        let m1 =
                            ::vstd::map::check_argument_is_map(vp.journal.i().msgs);
                        #[verifier::spec]
                        let m2 =
                            ::vstd::map::check_argument_is_map(vp.journal.i().discard_recent(vp.mapadt.i().seq_end).msgs);
                        ::builtin::assert_by(::builtin::equal(m1, m2),
                            {
                                ::builtin::assert_forall_by(|key|
                                        {
                                            ::builtin::ensures([::builtin::imply(#[verifier::trigger] m1.dom().contains(key),
                                                                    m2.dom().contains(key)) &&
                                                                ::builtin::imply(m2.dom().contains(key),
                                                                    m1.dom().contains(key)) &&
                                                            ::builtin::imply(m1.dom().contains(key) &&
                                                                    m2.dom().contains(key),
                                                                ::builtin::equal(m1.index(key), m2.index(key)))]);
                                            { {} }
                                        });
                                ::builtin::assert_(::builtin::ext_equal(m1, m2));
                            });
                        ;
                    });
            }
            ::builtin::assert_(vp.inv());
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn inv_inductive_commit_start_step(v: CoordinationSystem::State,
            vp: CoordinationSystem::State, label: CoordinationSystem::Label,
            step: CoordinationSystem::Step) {
            ::builtin::requires([v.inv(),
                        CoordinationSystem::State::next(v, vp, label),
                        CoordinationSystem::State::next_by(v, vp, label, step),
                        match step {
                            CoordinationSystem::Step::commit_start(_, _, _) => true,
                            _ => false,
                        }]);
            ::builtin::ensures([vp.inv()]);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CoordinationSystem::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CoordinationSystem::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractJournal::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractJournal::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantMap::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantMap::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn inv_inductive_commit_complete_step(v:
                CoordinationSystem::State, vp: CoordinationSystem::State,
            label: CoordinationSystem::Label,
            step: CoordinationSystem::Step) {
            ::builtin::requires([v.inv(),
                        CoordinationSystem::State::next(v, vp, label),
                        CoordinationSystem::State::next_by(v, vp, label, step),
                        match step {
                            CoordinationSystem::Step::commit_complete(_, _) => true,
                            _ => false,
                        }]);
            ::builtin::ensures([vp.inv()]);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CoordinationSystem::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CoordinationSystem::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractJournal::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractJournal::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantMap::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantMap::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractMap::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractMap::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            MsgHistory::map_plus_history_forall_lemma();
            let pm = v.mapadt.persistent;
            let em_end = v.mapadt.i().seq_end;
            let ej = v.journal.i();
            let im_end = v.mapadt.in_flight.get_Some_0().seq_end;
            {
                ::builtin::assert_by(::builtin::spec_eq(ej.discard_recent(em_end),
                        ej.discard_recent(im_end).concat(ej.discard_old(im_end).discard_recent(em_end))),
                    {
                        let left = ej.discard_recent(em_end);
                        let right =
                            ej.discard_recent(im_end).concat(ej.discard_old(im_end).discard_recent(em_end));
                        #[verifier::spec]
                        let m1 = ::vstd::map::check_argument_is_map(left.msgs);
                        #[verifier::spec]
                        let m2 = ::vstd::map::check_argument_is_map(right.msgs);
                        ::builtin::assert_by(::builtin::equal(m1, m2),
                            {
                                ::builtin::assert_forall_by(|key|
                                        {
                                            ::builtin::ensures([::builtin::imply(#[verifier::trigger] m1.dom().contains(key),
                                                                    m2.dom().contains(key)) &&
                                                                ::builtin::imply(m2.dom().contains(key),
                                                                    m1.dom().contains(key)) &&
                                                            ::builtin::imply(m1.dom().contains(key) &&
                                                                    m2.dom().contains(key),
                                                                ::builtin::equal(m1.index(key), m2.index(key)))]);
                                            { {} }
                                        });
                                ::builtin::assert_(::builtin::ext_equal(m1, m2));
                            });
                        ;
                    });
            }
            journal_associativity(v.mapadt.persistent,
                ej.discard_recent(im_end),
                ej.discard_old(im_end).discard_recent(em_end));
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn inv_inductive(v: CoordinationSystem::State,
            vp: CoordinationSystem::State, label: CoordinationSystem::Label) {
            ::builtin::requires([v.inv(),
                        CoordinationSystem::State::next(v, vp, label)]);
            ::builtin::ensures([vp.inv()]);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CoordinationSystem::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CoordinationSystem::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractJournal::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractJournal::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantMap::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantMap::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractMap::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractMap::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::init)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::init_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractJournal::State::init_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            MsgHistory::ext_equal_is_equality();
            StampedMap::ext_equal_is_equality();
            let step =
                ::builtin::choose(|s|
                        CoordinationSystem::State::next_by(v, vp, label, s));
            match step {
                CoordinationSystem::Step::load_ephemeral_from_persistent(..)
                    => {
                    ::builtin::assert_(vp.inv());
                }
                CoordinationSystem::Step::recover(new_journal, new_mapadt,
                    records) => {
                    MsgHistory::map_plus_history_forall_lemma();
                    let em = v.mapadt.i();
                    let em_end = v.mapadt.i().seq_end;
                    let ej = v.journal.i();
                    let pm = v.mapadt.persistent;
                    let em_p = vp.mapadt.i();
                    let em_end_p = vp.mapadt.i().seq_end;
                    let pm_p = vp.mapadt.persistent;
                    let ej_p = vp.journal.i();
                    ::builtin::assert_(records.ext_equal(ej.discard_old(em_end).discard_recent(em_end_p)));
                    ::builtin::assert_(ej.discard_recent(em_end_p).ext_equal(ej.discard_recent(em_end).concat(ej.discard_old(em_end).discard_recent(em_end_p))));
                    journal_associativity(pm, ej._dr(em_end),
                        ej._do(em_end)._dr(em_end_p));
                }
                CoordinationSystem::Step::accept_request(..) => {
                    ::builtin::assert_(vp.inv());
                }
                CoordinationSystem::Step::query(..) => {
                    ::builtin::assert_(vp.inv());
                }
                CoordinationSystem::Step::put(..) => {
                    inv_inductive_put_step(v, vp, label, step);
                    ::builtin::assert_(vp.inv());
                }
                CoordinationSystem::Step::deliver_reply(..) => {
                    ::builtin::assert_(vp.inv());
                }
                CoordinationSystem::Step::journal_internal(..) => {
                    ::builtin::assert_(vp.inv());
                }
                CoordinationSystem::Step::map_internal(..) => {
                    ::builtin::assert_(vp.inv());
                }
                CoordinationSystem::Step::req_sync(..) => {
                    ::builtin::assert_(v.inv());
                }
                CoordinationSystem::Step::reply_sync(..) => {
                    ::builtin::assert_(vp.inv());
                }
                CoordinationSystem::Step::commit_start(..) => {
                    inv_inductive_commit_start_step(v, vp, label, step);
                }
                CoordinationSystem::Step::commit_complete(..) => {
                    inv_inductive_commit_complete_step(v, vp, label, step);
                }
                CoordinationSystem::Step::crash(..) => {
                    ::builtin::assert_(vp.inv());
                }
                _ => { ::builtin::assert_(vp.inv()); }
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn put_step_refines(v: CoordinationSystem::State,
            vp: CoordinationSystem::State, label: CoordinationSystem::Label,
            step: CoordinationSystem::Step) {
            ::builtin::requires([v.inv(),
                        CoordinationSystem::State::next(v, vp, label),
                        CoordinationSystem::State::next_by(v, vp, label, step),
                        match step {
                            CoordinationSystem::Step::put(..) => true,
                            _ => false,
                        }]);
            ::builtin::ensures([vp.inv(),
                        CrashTolerantAsyncMap::State::next(v.i(), vp.i(),
                            label.get_Label_ctam_label())]);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CoordinationSystem::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CoordinationSystem::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractJournal::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractJournal::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantMap::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantMap::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractMap::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractMap::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::init)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::init_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractJournal::State::init_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantAsyncMap::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantAsyncMap::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AsyncMap::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AsyncMap::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(MapSpec::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(MapSpec::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            MsgHistory::ext_equal_is_equality();
            StampedMap::ext_equal_is_equality();
            FloatingSeq::<Version>::ext_equal_is_equality();
            inv_inductive_put_step(v, vp, label, step);
            let j = v.journal.i();
            let jp = vp.journal.i();
            let base = v.mapadt.persistent;
            let key =
                label.get_Label_ctam_label().get_OperateOp_base_op().get_ExecuteOp_req().input.get_PutInput_key();
            let value =
                label.get_Label_ctam_label().get_OperateOp_base_op().get_ExecuteOp_req().input.get_PutInput_value();
            ::builtin::assert_(jp.ext_equal(jp._dr((jp.seq_start).spec_add(jp.len()))));
            ::builtin::assert_(j.ext_equal(j._dr((j.seq_start).spec_add(j.len()))));
            ::builtin::assert_(::builtin::forall(|i: LSN|
                        ::builtin::imply((::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(v.mapadt.persistent.seq_end),
                                            i), v.i().versions.len()))),
                            (#[verus::internal(trigger)] jp.discard_recent(i)).ext_equal(j.discard_recent(i)))));
            let new_versions = vp.i().versions;
            let new_async_ephemeral = vp.i().async_ephemeral;
            let ctam_step =
                CrashTolerantAsyncMap::Step::operate(new_versions,
                    new_async_ephemeral);
            let versions_prime = vp.i().versions;
            let versions = v.i().versions;
            ::builtin::assert_(versions_prime.drop_last().ext_equal(versions));
            ::builtin::assert_((::builtin::spec_literal_nat("0")).spec_lt(versions_prime.len()));
            ::builtin::assert_(::builtin::spec_eq(versions_prime.drop_last(),
                    versions));
            ::builtin::assert_(CrashTolerantAsyncMap::State::optionally_append_version(versions,
                    versions_prime));
            let async_op =
                label.get_Label_ctam_label().get_OperateOp_base_op();
            ::builtin::assert_(match async_op {
                    AsyncMap::Label::ExecuteOp { .. } => true,
                    _ => false,
                });
            let input = async_op.get_ExecuteOp_req().input;
            let output = async_op.get_ExecuteOp_reply().output;
            let map_label =
                MapSpec::Label::Put { input: input, output: output };
            let post_persistent = versions_prime.last();
            let execute_step =
                AsyncMap::Step::execute(map_label, post_persistent);
            let pre_async =
                AsyncMap::State {
                    persistent: versions.last(),
                    ephemeral: v.i().async_ephemeral,
                };
            let post_async =
                AsyncMap::State {
                    persistent: versions_prime.last(),
                    ephemeral: vp.i().async_ephemeral,
                };
            let pre_map = versions.last().appv;
            let post_map = versions_prime.last().appv;
            ::builtin::assert_(MapSpec::State::put(pre_map, post_map,
                    map_label));
            MapSpec::show::put(pre_map, post_map, map_label);
            ::builtin::assert_(MapSpec::State::next(pre_map, post_map,
                    map_label));
            ::builtin::assert_(AsyncMap::State::next_by(pre_async, post_async,
                    async_op, execute_step));
            ::builtin::assert_(AsyncMap::State::next(AsyncMap::State {
                        persistent: versions.last(),
                        ephemeral: v.i().async_ephemeral,
                    },
                    AsyncMap::State {
                        persistent: versions_prime.last(),
                        ephemeral: vp.i().async_ephemeral,
                    }, label.get_Label_ctam_label().get_OperateOp_base_op()));
            ::builtin::assert_(CrashTolerantAsyncMap::State::next_by(v.i(),
                    vp.i(), label.get_Label_ctam_label(), ctam_step));
            ::builtin::assert_(CrashTolerantAsyncMap::State::next(v.i(),
                    vp.i(), label.get_Label_ctam_label()));
        }
        #[doc =
        " Proof that a \"commit_complete\" transition maps to a \"sync\" transition"]
        #[doc = " in abstract CrashTolerantAsyncMap."]
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn commit_complete_step_refines(v: CoordinationSystem::State,
            vp: CoordinationSystem::State, label: CoordinationSystem::Label,
            step: CoordinationSystem::Step) {
            ::builtin::requires([v.inv(),
                        CoordinationSystem::State::next(v, vp, label),
                        CoordinationSystem::State::next_by(v, vp, label, step),
                        match step {
                            CoordinationSystem::Step::commit_complete(..) => true,
                            _ => false,
                        }]);
            ::builtin::ensures([vp.inv(),
                        CrashTolerantAsyncMap::State::next(v.i(), vp.i(),
                            label.get_Label_ctam_label())]);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CoordinationSystem::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CoordinationSystem::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractJournal::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractJournal::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantMap::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantMap::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractMap::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractMap::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::init)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::init_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractJournal::State::init_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantAsyncMap::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantAsyncMap::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AsyncMap::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AsyncMap::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(MapSpec::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(MapSpec::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            inv_inductive(v, vp, label);
            let new_stable_index = vp.i().stable_index();
            let vers_s = v.i().versions.get_suffix(new_stable_index);
            let vers_p = vp.i().versions;
            {
                ::builtin::assert_forall_by(|lsn|
                        {
                            ::builtin::requires({ vers_p.is_active(lsn) });
                            ::builtin::ensures({
                                    ::builtin::spec_eq(vers_p.spec_index(lsn),
                                        vers_s.spec_index(lsn))
                                });
                            if ((v.journal.in_flight.get_Some_0().seq_end).spec_le(lsn))
                                    {
                                    commit_step_preserves_history(v, vp, label, step,
                                        ::builtin::spec_cast_integer::<_, nat>(lsn));
                                }
                        });
            }
            vers_s.extensionality(vers_p);
            ::builtin::assert_(CrashTolerantAsyncMap::State::sync(v.i(),
                    vp.i(), CrashTolerantAsyncMap::Label::SyncOp {},
                    new_stable_index));
            CrashTolerantAsyncMap::show::sync(v.i(), vp.i(),
                CrashTolerantAsyncMap::Label::SyncOp {}, new_stable_index);
        }
        #[doc =
        " Proof that a \"Crash\" transition maps to a \"Crash\" transition"]
        #[doc = " in abstract CrashTolerantAsyncMap."]
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn crash_step_refines(v: CoordinationSystem::State,
            vp: CoordinationSystem::State, label: CoordinationSystem::Label,
            step: CoordinationSystem::Step) {
            ::builtin::requires([v.inv(),
                        CoordinationSystem::State::next(v, vp, label),
                        CoordinationSystem::State::next_by(v, vp, label, step),
                        match step {
                            CoordinationSystem::Step::crash(..) => true,
                            _ => false,
                        }]);
            ::builtin::ensures([vp.inv(),
                        CrashTolerantAsyncMap::State::next(v.i(), vp.i(),
                            label.get_Label_ctam_label())]);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CoordinationSystem::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CoordinationSystem::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractJournal::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractJournal::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantMap::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantMap::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractMap::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractMap::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::init)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::init_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractJournal::State::init_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantAsyncMap::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantAsyncMap::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AsyncMap::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AsyncMap::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(MapSpec::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(MapSpec::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(journal_overlaps_agree)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            let stable_lsn = vp.journal.persistent.seq_end;
            if (v.ephemeral.is_Some()) {
                    ::builtin::assert_(::builtin::ext_equal_deep(vp.journal.persistent.discard_recent(vp.journal.persistent.seq_end),
                            vp.journal.persistent));
                    ::builtin::assert_(vp.journal.persistent.discard_recent(stable_lsn).ext_equal(v.journal.i().discard_recent(stable_lsn)));
                }
            ::builtin::assert_(::builtin::ext_equal_deep(vp.i().versions,
                    v.i().versions.get_prefix((v.i().stable_index()).spec_add(::builtin::spec_literal_nat("1")))));
            ::builtin::assert_(CrashTolerantAsyncMap::State::crash(v.i(),
                    vp.i(), label.get_Label_ctam_label()));
            CrashTolerantAsyncMap::show::crash(v.i(), vp.i(),
                label.get_Label_ctam_label());
        }
        #[doc =
        " Proof that all transitions which map to no-ops in the refined state machine can be"]
        #[doc = " refined to, well, no-ops."]
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn noop_steps_refine(v: CoordinationSystem::State,
            vp: CoordinationSystem::State, label: CoordinationSystem::Label,
            step: CoordinationSystem::Step) {
            ::builtin::requires([v.inv(),
                        CoordinationSystem::State::next(v, vp, label),
                        CoordinationSystem::State::next_by(v, vp, label, step),
                        match step {
                            CoordinationSystem::Step::load_ephemeral_from_persistent(..)
                                => true,
                            CoordinationSystem::Step::recover(..) => true,
                            CoordinationSystem::Step::journal_internal(..) => true,
                            CoordinationSystem::Step::map_internal(..) => true,
                            CoordinationSystem::Step::commit_start(..) => true,
                            _ => false,
                        }]);
            ::builtin::ensures([vp.inv(),
                        CrashTolerantAsyncMap::State::next(v.i(), vp.i(),
                            label.get_Label_ctam_label())]);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CoordinationSystem::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CoordinationSystem::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractJournal::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractJournal::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantMap::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantMap::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractMap::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractMap::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::init)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::init_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractJournal::State::init_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantAsyncMap::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantAsyncMap::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AsyncMap::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AsyncMap::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(MapSpec::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(MapSpec::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            inv_inductive(v, vp, label);
            if (match step {
                            CoordinationSystem::Step::load_ephemeral_from_persistent(..)
                                => true,
                            _ => false,
                        }) {
                    ::builtin::assert_(match label.get_Label_ctam_label() {
                            CrashTolerantAsyncMap::Label::Noop { .. } => true,
                            _ => false,
                        });
                }
            ::builtin::assert_(CrashTolerantAsyncMap::State::noop(v.i(),
                    vp.i(), CrashTolerantAsyncMap::Label::Noop {}));
            CrashTolerantAsyncMap::show::noop(v.i(), vp.i(),
                CrashTolerantAsyncMap::Label::Noop {});
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn query_step_refines(v: CoordinationSystem::State,
            vp: CoordinationSystem::State, label: CoordinationSystem::Label,
            step: CoordinationSystem::Step) {
            ::builtin::requires([v.inv(),
                        CoordinationSystem::State::next(v, vp, label),
                        CoordinationSystem::State::next_by(v, vp, label, step),
                        match step {
                            CoordinationSystem::Step::query(..) => true,
                            _ => false,
                        }]);
            ::builtin::ensures([vp.inv(),
                        CrashTolerantAsyncMap::State::next(v.i(), vp.i(),
                            label.get_Label_ctam_label())]);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CoordinationSystem::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CoordinationSystem::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractJournal::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractJournal::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantMap::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantMap::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractMap::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractMap::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::init)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::init_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractJournal::State::init_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantAsyncMap::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantAsyncMap::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AsyncMap::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AsyncMap::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(MapSpec::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(MapSpec::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            inv_inductive(v, vp, label);
            let ctam_label = label.get_Label_ctam_label();
            let ctam_pre = v.i();
            let ctam_post = vp.i();
            let new_versions = vp.i().versions;
            let new_async_ephemeral = vp.i().async_ephemeral;
            let async_label = ctam_label.get_OperateOp_base_op();
            let async_pre =
                AsyncMap::State {
                    persistent: ctam_pre.versions.last(),
                    ephemeral: ctam_pre.async_ephemeral,
                };
            let async_post =
                AsyncMap::State {
                    persistent: ctam_post.versions.last(),
                    ephemeral: ctam_post.async_ephemeral,
                };
            let map_pre = async_pre.persistent.appv;
            let map_post = async_post.persistent.appv;
            let req = async_label.get_ExecuteOp_req();
            let reply = async_label.get_ExecuteOp_reply();
            let map_label =
                MapSpec::Label::Query {
                    input: req.input,
                    output: reply.output,
                };
            MapSpec::show::query(map_pre, map_post, map_label);
            AsyncMap::show::execute(async_pre, async_post, async_label,
                map_label, async_post.persistent);
            CrashTolerantAsyncMap::show::operate(v.i(), vp.i(), ctam_label,
                new_versions, new_async_ephemeral);
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn accept_request_step_and_deliver_reply_step_refine(v:
                CoordinationSystem::State, vp: CoordinationSystem::State,
            label: CoordinationSystem::Label,
            step: CoordinationSystem::Step) {
            ::builtin::requires([v.inv(),
                        CoordinationSystem::State::next(v, vp, label),
                        CoordinationSystem::State::next_by(v, vp, label, step),
                        match step {
                            CoordinationSystem::Step::accept_request(..) => true,
                            CoordinationSystem::Step::deliver_reply(..) => true,
                            _ => false,
                        }]);
            ::builtin::ensures([vp.inv(),
                        CrashTolerantAsyncMap::State::next(v.i(), vp.i(),
                            label.get_Label_ctam_label())]);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CoordinationSystem::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CoordinationSystem::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractJournal::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractJournal::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantMap::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantMap::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractMap::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractMap::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::init)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::init_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractJournal::State::init_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantAsyncMap::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantAsyncMap::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AsyncMap::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AsyncMap::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(MapSpec::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(MapSpec::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            inv_inductive(v, vp, label);
            let ctam_pre = v.i();
            let ctam_post = vp.i();
            let ctam_label = label.get_Label_ctam_label();
            let async_pre =
                AsyncMap::State {
                    persistent: ctam_pre.versions.last(),
                    ephemeral: ctam_pre.async_ephemeral,
                };
            let async_post =
                AsyncMap::State {
                    persistent: ctam_post.versions.last(),
                    ephemeral: ctam_post.async_ephemeral,
                };
            let async_label = ctam_label.get_OperateOp_base_op();
            match async_label {
                AsyncMap::Label::RequestOp { .. } => {
                    AsyncMap::show::request(async_pre, async_post, async_label);
                }
                AsyncMap::Label::ReplyOp { .. } => {
                    AsyncMap::show::reply(async_pre, async_post, async_label);
                }
                _ => {}
            }
            CrashTolerantAsyncMap::show::operate(ctam_pre, ctam_post,
                label.get_Label_ctam_label(), ctam_post.versions,
                ctam_post.async_ephemeral);
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn req_sync_step_and_reply_sync_step_refine(v:
                CoordinationSystem::State, vp: CoordinationSystem::State,
            label: CoordinationSystem::Label,
            step: CoordinationSystem::Step) {
            ::builtin::requires([v.inv(),
                        CoordinationSystem::State::next(v, vp, label),
                        CoordinationSystem::State::next_by(v, vp, label, step),
                        match step {
                            CoordinationSystem::Step::req_sync(..) => true,
                            CoordinationSystem::Step::reply_sync(..) => true,
                            _ => false,
                        }]);
            ::builtin::ensures([vp.inv(),
                        CrashTolerantAsyncMap::State::next(v.i(), vp.i(),
                            label.get_Label_ctam_label())]);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CoordinationSystem::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CoordinationSystem::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractJournal::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractJournal::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantMap::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantMap::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractMap::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractMap::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::init)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantJournal::State::init_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AbstractJournal::State::init_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantAsyncMap::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CrashTolerantAsyncMap::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AsyncMap::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(AsyncMap::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(MapSpec::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(MapSpec::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            inv_inductive(v, vp, label);
            let ctam_pre = v.i();
            let ctam_post = vp.i();
            let ctam_label = label.get_Label_ctam_label();
            let ctam_step =
                ::builtin::choose(|step: CrashTolerantAsyncMap::Step|
                        CrashTolerantAsyncMap::State::next_by(ctam_pre, ctam_post,
                            ctam_label, step));
            match step {
                CoordinationSystem::Step::req_sync(..) => {
                    CrashTolerantAsyncMap::show::req_sync(ctam_pre, ctam_post,
                        ctam_label);
                }
                CoordinationSystem::Step::reply_sync(..) => {
                    CrashTolerantAsyncMap::show::reply_sync(ctam_pre, ctam_post,
                        ctam_label);
                }
                _ => {}
            }
            ::builtin::assert_(CrashTolerantAsyncMap::State::next_by(ctam_pre,
                    ctam_post, ctam_label, ctam_step));
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn next_refines(v: CoordinationSystem::State,
            vp: CoordinationSystem::State, label: CoordinationSystem::Label) {
            ::builtin::requires([v.inv(),
                        CoordinationSystem::State::next(v, vp, label)]);
            ::builtin::ensures([vp.inv(),
                        CrashTolerantAsyncMap::State::next(v.i(), vp.i(),
                            label.get_Label_ctam_label())]);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CoordinationSystem::State::next)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(CoordinationSystem::State::next_by)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            inv_inductive(v, vp, label);
            let step =
                ::builtin::choose(|s|
                        CoordinationSystem::State::next_by(v, vp, label, s));
            ::builtin::assert_(CoordinationSystem::State::next_by(v, vp,
                    label, step));
            match step {
                CoordinationSystem::Step::load_ephemeral_from_persistent(..)
                    => noop_steps_refine(v, vp, label, step),
                CoordinationSystem::Step::recover(..) =>
                    noop_steps_refine(v, vp, label, step),
                CoordinationSystem::Step::accept_request(..) =>
                    accept_request_step_and_deliver_reply_step_refine(v, vp,
                        label, step),
                CoordinationSystem::Step::query(..) =>
                    query_step_refines(v, vp, label, step),
                CoordinationSystem::Step::put(..) =>
                    put_step_refines(v, vp, label, step),
                CoordinationSystem::Step::deliver_reply(..) =>
                    accept_request_step_and_deliver_reply_step_refine(v, vp,
                        label, step),
                CoordinationSystem::Step::journal_internal(..) =>
                    noop_steps_refine(v, vp, label, step),
                CoordinationSystem::Step::map_internal(..) =>
                    noop_steps_refine(v, vp, label, step),
                CoordinationSystem::Step::req_sync(..) =>
                    req_sync_step_and_reply_sync_step_refine(v, vp, label,
                        step),
                CoordinationSystem::Step::reply_sync(..) =>
                    req_sync_step_and_reply_sync_step_refine(v, vp, label,
                        step),
                CoordinationSystem::Step::commit_start(..) =>
                    noop_steps_refine(v, vp, label, step),
                CoordinationSystem::Step::commit_complete(..) =>
                    commit_complete_step_refines(v, vp, label, step),
                CoordinationSystem::Step::crash(..) =>
                    crash_step_refines(v, vp, label, step),
                CoordinationSystem::Step::dummy_to_use_type_params(..) => {}
            }
        }
    }
}
mod betree {
    pub mod Buffer_v {
        use builtin_macros::*;
        use vstd::{map::*, set::*};
        use crate::spec::KeyType_t::*;
        use crate::spec::Messages_t::*;
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn all_keys() -> Set<Key> {
            Set::new(::builtin::closure_to_fn_spec(|k| true))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn total_keys(keys: Set<Key>) -> bool {
            ::builtin::forall(|k| keys.contains(k))
        }
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct Buffer {
            pub map: Map<Key, Message>,
        }
        #[verus::internal(verus_macro)]
        impl Buffer {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn query(self, key: Key) -> Message {
                if self.map.contains_key(key) {
                        self.map.spec_index(key)
                    } else { Message::Update { delta: nop_delta() } }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn apply_filter(self, accept: Set<Key>) -> Buffer {
                Buffer {
                    map: Map::new(::builtin::closure_to_fn_spec(|k|
                                accept.contains(k) && self.map.contains_key(k)),
                        ::builtin::closure_to_fn_spec(|k| self.map.spec_index(k))),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn merge(self, new_buffer: Buffer) -> Buffer {
                Buffer {
                    map: Map::new(::builtin::closure_to_fn_spec(|k|
                                self.map.contains_key(k) || new_buffer.map.contains_key(k)),
                        ::builtin::closure_to_fn_spec(|k|
                                if new_buffer.map.contains_key(k) &&
                                            self.map.contains_key(k) {
                                        self.map.spec_index(k).merge(new_buffer.map.spec_index(k))
                                    } else if new_buffer.map.contains_key(k) {
                                       new_buffer.map.spec_index(k)
                                   } else { self.map.spec_index(k) })),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn empty() -> Buffer { Buffer { map: Map::empty() } }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn insert(self, key: Key, msg: Message) -> Buffer {
                Buffer { map: self.map.insert(key, msg) }
            }
        }
    }
    pub mod BufferSeq_v {
        use builtin::*;
        use builtin_macros::*;
        use vstd::{*, seq::*, set::*};
        use crate::spec::KeyType_t::*;
        use crate::spec::Messages_t::*;
        use crate::betree::Buffer_v::*;
        use crate::betree::OffsetMap_v::*;
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct BufferSeq {
            pub buffers: Seq<Buffer>,
        }
        #[verus::internal(verus_macro)]
        impl BufferSeq {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn empty() -> BufferSeq {
                BufferSeq { buffers: ::vstd::seq::Seq::empty() }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn len(self) -> nat { self.buffers.len() }
            #[verifier::inline]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn spec_index(self, i: int) -> Buffer {
                ::builtin::recommends([::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        i), self.len()))]);
                self.buffers.spec_index(i)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn slice(self, start: int, end: int) -> BufferSeq {
                ::builtin::recommends([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            start), end), self.len()))]);
                BufferSeq { buffers: self.buffers.subrange(start, end) }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn drop_first(self) -> BufferSeq {
                ::builtin::recommends([(::builtin::spec_literal_nat("0")).spec_lt(self.len())]);
                self.slice(::builtin::spec_literal_integer("1"),
                    ::builtin::spec_cast_integer::<_, int>(self.len()))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn query_from(self, key: Key, start: int) -> Message {
                ::builtin::recommends([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        start), self.len()))]);
                ::builtin::decreases(((self.len()).spec_sub(start)));
                ::builtin::decreases_when((start).spec_le(self.len()));
                if ::builtin::spec_eq(start, self.len()) {
                        Message::Update { delta: nop_delta() }
                    } else {
                       self.buffers.spec_index(start).query(key).merge(self.query_from(key,
                               (start).spec_add(::builtin::spec_literal_nat("1"))))
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn query(self, key: Key) -> Message {
                self.query_from(key, ::builtin::spec_literal_integer("0"))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn apply_filter(self, accept: Set<Key>) -> BufferSeq {
                BufferSeq {
                    buffers: Seq::new(self.len(),
                        ::builtin::closure_to_fn_spec(|i: int|
                                self.buffers.spec_index(i).apply_filter(accept))),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn extend(self, new_buffers: BufferSeq) -> BufferSeq {
                BufferSeq {
                    buffers: (self.buffers).spec_add(new_buffers.buffers),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn update_subrange(self, start: int, end: int,
                new_buffer: Buffer) -> BufferSeq {
                ::builtin::recommends([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            start), end), self.len()))]);
                let s = ::vstd::seq::Seq::empty().push(new_buffer);
                BufferSeq {
                    buffers: ((self.buffers.subrange(::builtin::spec_literal_integer("0"),
                                        start)).spec_add(s)).spec_add(self.buffers.subrange(end,
                            ::builtin::spec_cast_integer::<_, int>(self.len()))),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i_from(self, idx: int) -> Buffer {
                ::builtin::recommends([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        idx), self.len()))]);
                ::builtin::decreases(((self.len()).spec_sub(idx)));
                ::builtin::decreases_when(::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                idx), self.len())));
                if ::builtin::spec_eq(self.len(), idx) {
                        Buffer::empty()
                    } else {
                       self.spec_index(idx).merge(self.i_from((idx).spec_add(::builtin::spec_literal_nat("1"))))
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> Buffer {
                self.i_from(::builtin::spec_literal_integer("0"))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn key_in_buffer(self, from_idx: int, k: Key, buffer_idx: int)
                -> bool {
                (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(from_idx),
                                    buffer_idx), self.len()))) &&
                    (self.spec_index(buffer_idx).map.contains_key(k))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn i_filtered_from(self, offset_map: OffsetMap, idx: int)
                -> Buffer {
                ::builtin::recommends([offset_map.is_total(),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        idx), self.len()))]);
                ::builtin::decreases(((self.len()).spec_sub(idx)));
                ::builtin::decreases_when(::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                idx), self.len())));
                if ::builtin::spec_eq(self.len(), idx) {
                        Buffer::empty()
                    } else {
                       let bottom_buffer =
                           self.spec_index(idx).apply_filter(offset_map.active_keys(::builtin::spec_cast_integer::<_,
                                           nat>(idx)));
                       bottom_buffer.merge(self.i_filtered_from(offset_map,
                               (idx).spec_add(::builtin::spec_literal_nat("1"))))
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i_filtered(self, offset_map: OffsetMap) -> Buffer {
                ::builtin::recommends([offset_map.is_total()]);
                self.i_filtered_from(offset_map,
                    ::builtin::spec_literal_integer("0"))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn key_in_buffer_filtered(self, offset_map: OffsetMap,
                from_idx: int, k: Key, buffer_idx: int) -> bool {
                ::builtin::recommends([offset_map.is_total(),
                            (::builtin::spec_literal_nat("0")).spec_le(from_idx)]);
                (self.key_in_buffer(from_idx, k, buffer_idx)) &&
                    ((offset_map.offsets.spec_index(k)).spec_le(buffer_idx))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn query_agrees_with_i(self, k: Key, start: int) {
                ::builtin::requires([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        start), self.len()))]);
                ::builtin::ensures([::builtin::imply(self.i_from(start).map.contains_key(k),
                                ::builtin::spec_eq(self.query_from(k, start),
                                    self.i_from(start).map.spec_index(k))),
                            ::builtin::imply(!self.i_from(start).map.contains_key(k),
                                ::builtin::spec_eq(self.query_from(k, start),
                                    (Message::Update { delta: nop_delta() })))]);
                ::builtin::decreases(((self.len()).spec_sub(start)));
                if (start).spec_lt(self.len()) {
                        self.query_agrees_with_i(k,
                            (start).spec_add(::builtin::spec_literal_nat("1")));
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn i_from_domain(self, idx: int) {
                ::builtin::requires([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        idx), self.len()))]);
                ::builtin::ensures([::builtin::forall(|k|
                                    ::builtin::spec_eq((self.i_from(idx).map.contains_key(k)),
                                        (::builtin::exists(|buffer_idx|
                                                    self.key_in_buffer(idx, k, buffer_idx)))))]);
                ::builtin::decreases(((self.len()).spec_sub(idx)));
                {
                    ::builtin::assert_forall_by(|k|
                            {
                                ::builtin::ensures(::builtin::spec_eq((#[verus::internal(trigger)] self.i_from(idx).map.contains_key(k)),
                                        (::builtin::exists(|buffer_idx|
                                                    self.key_in_buffer(idx, k, buffer_idx)))));
                                if self.i_from(idx).map.contains_key(k) {
                                        ::builtin::assert_((idx).spec_lt(self.len()));
                                        if self.key_in_buffer(idx, k, idx)
                                                {} else {
                                               self.i_from_domain((idx).spec_add(::builtin::spec_literal_nat("1")));
                                               ::builtin::assert_(self.i_from((idx).spec_add(::builtin::spec_literal_nat("1"))).map.contains_key(k));
                                               let next_idx =
                                                   (idx).spec_add(::builtin::spec_literal_nat("1"));
                                               let buffer_idx =
                                                   ::builtin::choose(|buffer_idx|
                                                           self.key_in_buffer(next_idx, k, buffer_idx));
                                               ::builtin::assert_(self.key_in_buffer(idx, k, buffer_idx));
                                           }
                                    }
                                if ::builtin::exists(|buffer_idx|
                                                self.key_in_buffer(idx, k, buffer_idx)) {
                                        let buffer_idx =
                                            ::builtin::choose(|buffer_idx|
                                                    self.key_in_buffer(idx, k, buffer_idx));
                                        if ::builtin::spec_eq(buffer_idx, idx) {
                                                ::builtin::assert_(self.i_from(idx).map.contains_key(k));
                                            } else {
                                               self.i_from_domain((idx).spec_add(::builtin::spec_literal_nat("1")));
                                               ::builtin::assert_(self.key_in_buffer((idx).spec_add(::builtin::spec_literal_nat("1")),
                                                       k, buffer_idx));
                                               ::builtin::assert_(self.i_from((idx).spec_add(::builtin::spec_literal_nat("1"))).map.contains_key(k));
                                           }
                                    }
                            });
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn i_filtered_from_domain(self, offset_map: OffsetMap,
                idx: int) {
                ::builtin::requires([offset_map.is_total(),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        idx), self.len()))]);
                ::builtin::ensures([::builtin::forall(|k|
                                    ::builtin::spec_eq((self.i_filtered_from(offset_map,
                                                        idx).map.contains_key(k)),
                                        (::builtin::exists(|buffer_idx|
                                                    self.key_in_buffer_filtered(offset_map, idx, k,
                                                        buffer_idx)))))]);
                ::builtin::decreases(((self.len()).spec_sub(idx)));
                let result = self.i_filtered_from(offset_map, idx);
                {
                    ::builtin::assert_forall_by(|k|
                            {
                                ::builtin::ensures(::builtin::spec_eq((#[verus::internal(trigger)] result.map.contains_key(k)),
                                        (::builtin::exists(|buffer_idx|
                                                    self.key_in_buffer_filtered(offset_map, idx, k,
                                                        buffer_idx)))));
                                if result.map.contains_key(k) {
                                        ::builtin::assert_((idx).spec_lt(self.len()));
                                        if self.key_in_buffer_filtered(offset_map, idx, k, idx)
                                                {} else {
                                               let sub_result =
                                                   self.i_filtered_from(offset_map,
                                                       (idx).spec_add(::builtin::spec_literal_nat("1")));
                                               self.i_filtered_from_domain(offset_map,
                                                   (idx).spec_add(::builtin::spec_literal_nat("1")));
                                               ::builtin::assert_(sub_result.map.contains_key(k));
                                               let next_idx =
                                                   (idx).spec_add(::builtin::spec_literal_nat("1"));
                                               let buffer_idx =
                                                   ::builtin::choose(|buffer_idx|
                                                           self.key_in_buffer_filtered(offset_map, next_idx, k,
                                                               buffer_idx));
                                               ::builtin::assert_(self.key_in_buffer_filtered(offset_map,
                                                       idx, k, buffer_idx));
                                           }
                                    }
                                if ::builtin::exists(|buffer_idx|
                                                self.key_in_buffer_filtered(offset_map, idx, k, buffer_idx))
                                        {
                                        let buffer_idx =
                                            ::builtin::choose(|buffer_idx|
                                                    self.key_in_buffer_filtered(offset_map, idx, k,
                                                        buffer_idx));
                                        if ::builtin::spec_eq(buffer_idx, idx) {
                                                ::builtin::assert_(result.map.contains_key(k));
                                            } else {
                                               let sub_result =
                                                   self.i_filtered_from(offset_map,
                                                       (idx).spec_add(::builtin::spec_literal_nat("1")));
                                               self.i_filtered_from_domain(offset_map,
                                                   (idx).spec_add(::builtin::spec_literal_nat("1")));
                                               ::builtin::assert_(self.key_in_buffer_filtered(offset_map,
                                                       (idx).spec_add(::builtin::spec_literal_nat("1")), k,
                                                       buffer_idx));
                                           }
                                    }
                            });
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn query_from_same_as_i_filtered(self, k: Key,
                buffer_idx: int, offset_map: OffsetMap) {
                ::builtin::requires([offset_map.is_total(),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        buffer_idx), self.len())),
                            (offset_map.offsets.spec_index(k)).spec_le(self.len())]);
                ::builtin::ensures([({
                                    let start =
                                        ::builtin::spec_cast_integer::<_,
                                                int>(offset_map.offsets.spec_index(k));
                                    (::builtin::imply((start).spec_le(buffer_idx),
                                                ::builtin::spec_eq(self.i_filtered_from(offset_map,
                                                            buffer_idx).query(k), self.query_from(k, buffer_idx)))) &&
                                        (::builtin::imply((start).spec_gt(buffer_idx),
                                                ::builtin::spec_eq(self.i_filtered_from(offset_map,
                                                            buffer_idx).query(k), self.query_from(k, start))))
                                })]);
                ::builtin::decreases(((self.len()).spec_sub(buffer_idx)));
                if (buffer_idx).spec_lt(self.len()) {
                        self.query_from_same_as_i_filtered(k,
                            (buffer_idx).spec_add(::builtin::spec_literal_nat("1")),
                            offset_map);
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn common_buffer_seqs(a: BufferSeq, b: BufferSeq,
                a_start: int, b_delta: int, key: Key) {
                ::builtin::requires([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        a_start), a.len())),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        (a_start).spec_add(b_delta)), b.len())),
                            ::builtin::spec_eq((a.len()).spec_sub(a_start),
                                ((b.len()).spec_sub(a_start)).spec_sub(b_delta)),
                            ::builtin::forall(|i: int|
                                    ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(a_start),
                                                    i), a.len())),
                                        ::builtin::spec_eq(a.buffers.spec_index(i),
                                            b.buffers.spec_index((i).spec_add(b_delta)))))]);
                ::builtin::ensures([::builtin::spec_eq(a.query_from(key,
                                    a_start), b.query_from(key, (a_start).spec_add(b_delta)))]);
                ::builtin::decreases(((a.len()).spec_sub(a_start)));
                if (a_start).spec_lt(a.len()) {
                        Self::common_buffer_seqs(a, b,
                            (a_start).spec_add(::builtin::spec_literal_nat("1")),
                            b_delta, key);
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn extend_buffer_seq_lemma(top: BufferSeq, bottom: BufferSeq,
                key: Key, start: int) {
                ::builtin::requires([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        start), bottom.len()))]);
                ::builtin::ensures([::builtin::spec_eq(bottom.extend(top).query_from(key,
                                    start),
                                bottom.query_from(key, start).merge(top.query(key)))]);
                ::builtin::decreases(((bottom.len()).spec_sub(start)));
                if ::builtin::spec_eq(start, bottom.len()) {
                        Self::common_buffer_seqs(bottom.extend(top), top, start,
                            (::builtin::spec_literal_nat("0")).spec_sub(start), key);
                    } else {
                       ::builtin::assert_(::builtin::spec_eq(bottom.extend(top).buffers.spec_index(start),
                               bottom.buffers.spec_index(start)));
                       Self::extend_buffer_seq_lemma(top, bottom, key,
                           (start).spec_add(::builtin::spec_literal_nat("1")));
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn not_present_query_lemma(self, k: Key, start: int) {
                ::builtin::requires([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        start), self.len())),
                            ::builtin::forall(|i|
                                    #[verus::internal(auto_trigger)] (::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(start),
                                                        i), self.len())),
                                            !self.spec_index(i).map.contains_key(k))))]);
                ::builtin::ensures([::builtin::spec_eq(self.query_from(k,
                                    start), (Message::Update { delta: nop_delta() }))]);
                ::builtin::decreases(((self.len()).spec_sub(start)));
                if (start).spec_lt(self.len()) {
                        self.not_present_query_lemma(k,
                            (start).spec_add(::builtin::spec_literal_nat("1")));
                    }
            }
        }
    }
    pub mod OffsetMap_v {
        use builtin::*;
        use builtin_macros::*;
        use vstd::{map::*, set::*};
        use crate::spec::KeyType_t::*;
        use crate::betree::Buffer_v::*;
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct OffsetMap {
            pub offsets: Map<Key, nat>,
        }
        #[verus::internal(verus_macro)]
        impl OffsetMap {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_total(self) -> bool { total_keys(self.offsets.dom()) }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn get(self, k: Key) -> nat {
                ::builtin::recommends([self.is_total()]);
                self.offsets.spec_index(k)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn active_keys(self, offset: nat) -> Set<Key> {
                ::builtin::recommends([self.is_total()]);
                Set::new(::builtin::closure_to_fn_spec(|k|
                            (self.offsets.spec_index(k)).spec_le(offset)))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn decrement(self, i: nat) -> OffsetMap {
                ::builtin::recommends([self.is_total()]);
                OffsetMap {
                    offsets: Map::new(::builtin::closure_to_fn_spec(|k| true),
                        ::builtin::closure_to_fn_spec(|k|
                                if (i).spec_le(self.offsets.spec_index(k)) {
                                        ::builtin::spec_cast_integer::<_,
                                                nat>(((self.offsets.spec_index(k)).spec_sub(i)))
                                    } else {
                                       ::builtin::spec_cast_integer::<_,
                                               nat>(::builtin::spec_literal_nat("0"))
                                   })),
                }
            }
        }
    }
    pub mod Memtable_v {
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use vstd::map::*;
        use crate::betree::Buffer_v::*;
        use crate::spec::Messages_t::*;
        use crate::spec::KeyType_t::*;
        use crate::abstract_system::StampedMap_v::*;
        use crate::abstract_system::MsgHistory_v::*;
        #[verus::internal(verus_macro)]
        pub struct Memtable {
            pub buffer: Buffer,
            pub seq_end: LSN,
        }
        #[verus::internal(verus_macro)]
        impl Memtable {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn query(self, key: Key) -> Message { self.buffer.query(key) }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn apply_put(self, km: KeyedMessage) -> Memtable {
                Memtable {
                    buffer: Buffer {
                        map: self.buffer.map.insert(km.key,
                            self.query(km.key).merge(km.message)),
                    },
                    seq_end: (self.seq_end).spec_add(::builtin::spec_literal_nat("1")),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn apply_puts(self, puts: MsgHistory) -> Memtable {
                ::builtin::recommends([puts.wf(),
                            puts.can_follow(self.seq_end)]);
                ::builtin::decreases((puts.seq_end));
                ::builtin::decreases_when(puts.wf());
                if puts.is_empty() {
                        self
                    } else {
                       let last_lsn =
                           ::builtin::spec_cast_integer::<_,
                                   nat>(((puts.seq_end).spec_sub(::builtin::spec_literal_nat("1"))));
                       self.apply_puts(puts.discard_recent(last_lsn)).apply_put(puts.msgs.spec_index(last_lsn))
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn apply_puts_end(self, puts: MsgHistory) {
                ::builtin::requires([puts.wf(),
                            puts.can_follow(self.seq_end)]);
                ::builtin::ensures([::builtin::spec_eq(self.apply_puts(puts).seq_end,
                                puts.seq_end)]);
                ::builtin::decreases((puts.len()));
                if (::builtin::spec_literal_nat("0")).spec_lt(puts.len()) {
                        let last_lsn =
                            ::builtin::spec_cast_integer::<_,
                                    nat>(((puts.seq_end).spec_sub(::builtin::spec_literal_nat("1"))));
                        self.apply_puts_end(puts.discard_recent(last_lsn));
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn apply_puts_additive(self, puts1: MsgHistory,
                puts2: MsgHistory) {
                ::builtin::requires([puts1.wf(), puts2.wf(),
                            puts1.can_follow(self.seq_end),
                            puts2.can_follow(puts1.seq_end)]);
                ::builtin::ensures([::builtin::spec_eq(self.apply_puts(puts1).apply_puts(puts2),
                                self.apply_puts(puts1.concat(puts2)))]);
                ::builtin::decreases(((puts1.len()).spec_add(puts2.len())));
                MsgHistory::concat_forall_lemma();
                if (puts2.len()).spec_gt(::builtin::spec_literal_nat("0")) {
                        let last_lsn =
                            ::builtin::spec_cast_integer::<_,
                                    nat>(((puts2.seq_end).spec_sub(::builtin::spec_literal_nat("1"))));
                        self.apply_puts_additive(puts1,
                            puts2.discard_recent(last_lsn));
                        #[verifier::spec]
                        let m1 =
                            ::vstd::map::check_argument_is_map(puts1.concat(puts2).discard_recent(last_lsn).msgs);
                        #[verifier::spec]
                        let m2 =
                            ::vstd::map::check_argument_is_map(puts1.concat(puts2.discard_recent(last_lsn)).msgs);
                        ::builtin::assert_by(::builtin::equal(m1, m2),
                            {
                                ::builtin::assert_forall_by(|key|
                                        {
                                            ::builtin::ensures([::builtin::imply(#[verifier::trigger] m1.dom().contains(key),
                                                                    m2.dom().contains(key)) &&
                                                                ::builtin::imply(m2.dom().contains(key),
                                                                    m1.dom().contains(key)) &&
                                                            ::builtin::imply(m1.dom().contains(key) &&
                                                                    m2.dom().contains(key),
                                                                ::builtin::equal(m1.index(key), m2.index(key)))]);
                                            { {} }
                                        });
                                ::builtin::assert_(::builtin::ext_equal(m1, m2));
                            });
                        ;
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn empty_memtable(lsn: LSN) -> Memtable {
                Memtable { buffer: Buffer::empty(), seq_end: lsn }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn drain(self) -> Memtable {
                Self::empty_memtable(self.seq_end)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_empty(self) -> bool {
                ::builtin::spec_eq(self.buffer, Buffer::empty())
            }
        }
    }
    pub mod PagedBetree_v {
        use builtin::*;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        use vstd::prelude::*;
        use crate::spec::KeyType_t::*;
        use crate::spec::Messages_t::*;
        use crate::betree::Buffer_v::*;
        use crate::betree::Memtable_v::*;
        use crate::abstract_system::StampedMap_v::*;
        use crate::abstract_system::MsgHistory_v::*;
        pub type StampedBetree = Stamped<BetreeNode>;
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn empty_image() -> StampedBetree {
            Stamped {
                value: BetreeNode::Nil,
                seq_end: ::builtin::spec_literal_integer("0"),
            }
        }
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct ChildMap {
            pub map: Map<Key, BetreeNode>,
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn constant_child_map(target: BetreeNode) -> ChildMap {
            ChildMap {
                map: Map::new(::builtin::closure_to_fn_spec(|k| true),
                    ::builtin::closure_to_fn_spec(|k| target)),
            }
        }
        #[verus::internal(verus_macro)]
        impl ChildMap {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                ::builtin::decreases((self));
                (total_keys(self.map.dom())) &&
                    (::builtin::forall(|k: Key|
                                #[verus::internal(auto_trigger)] (self.map.spec_index(k).wf())))
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn empty_child_map() -> ChildMap {
            constant_child_map(BetreeNode::Nil)
        }
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub enum BetreeNode {
            Nil,
            Node {
                buffer: Buffer,
                children: ChildMap,
            },
        }
        #[verus::internal(verus_macro)]
        #[cfg(verus_keep_ghost)]
        #[automatically_derived]
        impl BetreeNode {
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_Nil(&self) -> bool {
                ::builtin::is_variant(self, "Nil")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_Node(&self) -> bool {
                ::builtin::is_variant(self, "Node")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_Node_buffer(self) -> Buffer {
                ::builtin::get_variant_field(self, "Node", "buffer")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_Node_children(self) -> ChildMap {
                ::builtin::get_variant_field(self, "Node", "children")
            }
        }
        #[verus::internal(verus_macro)]
        impl BetreeNode {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                ::builtin::decreases((self));
                ::builtin::imply(self.is_Node(),
                    self.get_Node_children().wf())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn child(self, key: Key) -> BetreeNode {
                ::builtin::recommends([self.wf(), self.is_Node()]);
                self.get_Node_children().map.spec_index(key)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn empty_root() -> BetreeNode {
                BetreeNode::Node {
                    buffer: Buffer::empty(),
                    children: empty_child_map(),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn promote(self) -> BetreeNode {
                if self.is_Nil() { Self::empty_root() } else { self }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn merge_buffer(self, new_buffer: Buffer) -> BetreeNode {
                BetreeNode::Node {
                    buffer: self.get_Node_buffer().merge(new_buffer),
                    children: self.get_Node_children(),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn push_memtable(self, memtable: Memtable) -> StampedBetree {
                Stamped {
                    value: self.promote().merge_buffer(memtable.buffer),
                    seq_end: memtable.seq_end,
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn filter_buffer_and_children(self, filter: Set<Key>)
                -> BetreeNode {
                if self.is_Nil() {
                        self
                    } else {
                       let filtered_children =
                           ChildMap {
                               map: Map::new(::builtin::closure_to_fn_spec(|k| true),
                                   ::builtin::closure_to_fn_spec(|k|
                                           if filter.contains(k) {
                                                   self.get_Node_children().map.spec_index(k)
                                               } else { BetreeNode::Nil })),
                           };
                       BetreeNode::Node {
                           buffer: self.get_Node_buffer().apply_filter(filter),
                           children: filtered_children,
                       }
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split(self, left_keys: Set<Key>, right_keys: Set<Key>)
                -> BetreeNode {
                let map =
                    Map::new(::builtin::closure_to_fn_spec(|k| true),
                        ::builtin::closure_to_fn_spec(|k|
                                if left_keys.contains(k) {
                                        self.child(k).filter_buffer_and_children(left_keys)
                                    } else if right_keys.contains(k) {
                                       self.child(k).filter_buffer_and_children(right_keys)
                                   } else { self.child(k) }));
                BetreeNode::Node {
                    buffer: self.get_Node_buffer(),
                    children: ChildMap { map },
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn flush(self, down_keys: Set<Key>) -> BetreeNode {
                let kept_buffer =
                    self.get_Node_buffer().apply_filter(all_keys().difference(down_keys));
                let moved_buffer =
                    self.get_Node_buffer().apply_filter(down_keys);
                let out_children_map =
                    Map::new(::builtin::closure_to_fn_spec(|k| true),
                        ::builtin::closure_to_fn_spec(|k|
                                if down_keys.contains(k) {
                                        self.child(k).promote().merge_buffer(moved_buffer)
                                    } else { self.child(k) }));
                BetreeNode::Node {
                    buffer: kept_buffer,
                    children: ChildMap { map: out_children_map },
                }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct QueryReceiptLine {
            pub node: BetreeNode,
            pub result: Message,
        }
        #[verus::internal(verus_macro)]
        impl QueryReceiptLine {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                (self.node.wf()) && (self.result.is_Define())
            }
        }
        #[verus::internal(verus_macro)]
        pub struct QueryReceipt {
            pub key: Key,
            pub root: BetreeNode,
            pub lines: Seq<QueryReceiptLine>,
        }
        #[verus::internal(verus_macro)]
        impl QueryReceipt {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn structure(self) -> bool {
                ((((::builtin::spec_literal_nat("0")).spec_lt(self.lines.len()))
                                    &&
                                    (::builtin::spec_eq(self.lines.spec_index(::builtin::spec_literal_integer("0")).node,
                                            self.root))) &&
                            ((::builtin::forall(|i|
                                            #[verus::internal(auto_trigger)] (::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                i), self.lines.len())),
                                                    (::builtin::spec_eq((self.lines.spec_index(i).node.is_Node()),
                                                            ((i).spec_lt((self.lines.len()).spec_sub(::builtin::spec_literal_nat("1"))))))))))))
                    &&
                    (::builtin::spec_eq(self.lines.last().result,
                            Message::empty()))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn all_lines_wf(self) -> bool {
                ::builtin::forall(|i|
                        #[verus::internal(auto_trigger)] (::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            i), self.lines.len())), self.lines.spec_index(i).wf())))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn child_at(self, i: int) -> BetreeNode {
                ::builtin::recommends([self.all_lines_wf(), self.structure(),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        i),
                                    (self.lines.len()).spec_sub(::builtin::spec_literal_nat("1"))))]);
                self.lines.spec_index(i).node.child(self.key)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn child_linked_at(self, i: int) -> bool {
                ::builtin::recommends([self.all_lines_wf(), self.structure(),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        i),
                                    (self.lines.len()).spec_sub(::builtin::spec_literal_nat("1"))))]);
                ::builtin::spec_eq(self.lines.spec_index((i).spec_add(::builtin::spec_literal_nat("1"))).node,
                    self.child_at(i))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn result_at(self, i: int) -> Message {
                ::builtin::recommends([::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        i), self.lines.len()))]);
                self.lines.spec_index(i).result
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn result_linked_at(self, i: int) -> bool {
                ::builtin::recommends([self.all_lines_wf(), self.structure(),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        i),
                                    (self.lines.len()).spec_sub(::builtin::spec_literal_nat("1"))))]);
                let msg =
                    self.lines.spec_index(i).node.get_Node_buffer().query(self.key);
                ::builtin::spec_eq(self.result_at(i),
                    self.result_at((i).spec_add(::builtin::spec_literal_nat("1"))).merge(msg))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid(self) -> bool {
                (((self.structure()) && (self.all_lines_wf())) &&
                            ((::builtin::forall(|i|
                                            #[verus::internal(auto_trigger)] (::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                i),
                                                            (self.lines.len()).spec_sub(::builtin::spec_literal_nat("1")))),
                                                    self.child_linked_at(i))))))) &&
                    ((::builtin::forall(|i|
                                    #[verus::internal(auto_trigger)] (::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                        i),
                                                    (self.lines.len()).spec_sub(::builtin::spec_literal_nat("1")))),
                                            self.result_linked_at(i))))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn result(self) -> Message {
                ::builtin::recommends([self.structure()]);
                self.result_at(::builtin::spec_literal_integer("0"))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid_for(self, root: BetreeNode, key: Key) -> bool {
                ((self.valid()) && (::builtin::spec_eq(self.root, root))) &&
                    (::builtin::spec_eq(self.key, key))
            }
        }
        #[verus::internal(verus_macro)]
        pub struct Path {
            pub node: BetreeNode,
            pub key: Key,
            pub routing: Seq<Set<Key>>,
        }
        #[verus::internal(verus_macro)]
        impl Path {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn subpath(self) -> Path {
                ::builtin::recommends([(::builtin::spec_literal_nat("0")).spec_lt(self.routing.len()),
                            self.node.wf(), self.node.is_Node()]);
                Path {
                    node: self.node.child(self.key),
                    key: self.key,
                    routing: self.routing.subrange(::builtin::spec_literal_integer("1"),
                        ::builtin::spec_cast_integer::<_, int>(self.routing.len())),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn common_children(self) -> bool {
                ::builtin::recommends([self.node.wf(), self.node.is_Node(),
                            (::builtin::spec_literal_nat("0")).spec_lt(self.routing.len())]);
                ::builtin::forall(|k: Key|
                        #[verus::internal(auto_trigger)] (::builtin::imply(self.routing.index(::builtin::spec_literal_integer("0")).contains(k),
                                ::builtin::spec_eq(self.node.child(k),
                                    self.node.child(self.key)))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid(self) -> bool {
                ::builtin::decreases((self.routing.len()));
                ((self.node.wf()) && (self.node.is_Node())) &&
                    (::builtin::imply((::builtin::spec_literal_nat("0")).spec_lt(self.routing.len()),
                            { (self.subpath().valid()) && (self.common_children()) }))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn target(self) -> BetreeNode {
                ::builtin::recommends([self.valid()]);
                ::builtin::decreases((self.routing.len()));
                if ::builtin::spec_eq(self.routing.len(),
                            ::builtin::spec_literal_nat("0")) {
                        self.node
                    } else { self.subpath().target() }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn replaced_children(self, replacement: BetreeNode)
                -> ChildMap {
                ::builtin::recommends([self.valid(), replacement.wf(),
                            (::builtin::spec_literal_nat("0")).spec_lt(self.routing.len())]);
                ::builtin::decreases((self.subpath().routing.len()));
                let replaced_child = self.subpath().substitute(replacement);
                ChildMap {
                    map: Map::new(::builtin::closure_to_fn_spec(|k| true),
                        ::builtin::closure_to_fn_spec(|k|
                                if self.routing.index(::builtin::spec_literal_integer("0")).contains(k)
                                        {
                                        replaced_child
                                    } else { self.node.child(k) })),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn substitute(self, replacement: BetreeNode) -> BetreeNode {
                ::builtin::recommends([self.valid(), replacement.wf()]);
                ::builtin::decreases((self.routing.len(),
                        ::builtin::spec_literal_nat("1")));
                if ::builtin::spec_eq(self.routing.len(),
                            ::builtin::spec_literal_nat("0")) {
                        replacement
                    } else {
                       BetreeNode::Node {
                           buffer: self.node.get_Node_buffer(),
                           children: self.replaced_children(replacement),
                       }
                   }
            }
        }
        #[allow(unused_parens)]
        pub mod PagedBetree {
            use super::*;
            #[verus::internal(verus_macro)]
            pub struct State {
                pub memtable: Memtable,
                pub root: BetreeNode,
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Step {
                query(QueryReceipt),
                put(),
                freeze_as(),
                internal_flush_memtable(),
                internal_grow(),
                internal_split(Path, Set<Key>, Set<Key>),
                internal_flush(Path, Set<Key>),
                internal_noop(),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Step {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_query(&self) -> bool {
                    ::builtin::is_variant(self, "query")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_query_0(self) -> QueryReceipt {
                    ::builtin::get_variant_field(self, "query", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_put(&self) -> bool {
                    ::builtin::is_variant(self, "put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_freeze_as(&self) -> bool {
                    ::builtin::is_variant(self, "freeze_as")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_internal_flush_memtable(&self) -> bool {
                    ::builtin::is_variant(self, "internal_flush_memtable")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_internal_grow(&self) -> bool {
                    ::builtin::is_variant(self, "internal_grow")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_internal_split(&self) -> bool {
                    ::builtin::is_variant(self, "internal_split")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_split_0(self) -> Path {
                    ::builtin::get_variant_field(self, "internal_split", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_split_1(self) -> Set<Key> {
                    ::builtin::get_variant_field(self, "internal_split", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_split_2(self) -> Set<Key> {
                    ::builtin::get_variant_field(self, "internal_split", "2")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_internal_flush(&self) -> bool {
                    ::builtin::is_variant(self, "internal_flush")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_flush_0(self) -> Path {
                    ::builtin::get_variant_field(self, "internal_flush", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_flush_1(self) -> Set<Key> {
                    ::builtin::get_variant_field(self, "internal_flush", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_internal_noop(&self) -> bool {
                    ::builtin::is_variant(self, "internal_noop")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Config {
                initialize(StampedBetree),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Config {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_initialize(&self) -> bool {
                    ::builtin::is_variant(self, "initialize")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_initialize_0(self) -> StampedBetree {
                    ::builtin::get_variant_field(self, "initialize", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[verus::internal(verus_macro)]
            pub enum Label {
                Query {
                    end_lsn: LSN,
                    key: Key,
                    value: Value,
                },
                Put {
                    puts: MsgHistory,
                },
                FreezeAs {
                    stamped_betree: StampedBetree,
                },
                Internal {},
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Label {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_Query(&self) -> bool {
                    ::builtin::is_variant(self, "Query")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_Query_end_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "Query", "end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_Query_key(self) -> Key {
                    ::builtin::get_variant_field(self, "Query", "key")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_Query_value(self) -> Value {
                    ::builtin::get_variant_field(self, "Query", "value")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_Put(&self) -> bool {
                    ::builtin::is_variant(self, "Put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_Put_puts(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "Put", "puts")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_FreezeAs(&self) -> bool {
                    ::builtin::is_variant(self, "FreezeAs")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_FreezeAs_stamped_betree(self) -> StampedBetree {
                    ::builtin::get_variant_field(self, "FreezeAs",
                        "stamped_betree")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_Internal(&self) -> bool {
                    ::builtin::is_variant(self, "Internal")
                }
            }
            pub mod show {
                use super::*;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn query(pre: super::State, post: super::State,
                    lbl: Label, receipt: QueryReceipt) {
                    ::builtin::requires(super::State::query(pre, post, lbl,
                            receipt));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as query;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn put(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::put(pre, post, lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as put;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn freeze_as(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::freeze_as(pre, post,
                            lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as freeze_as;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn internal_flush_memtable(pre: super::State,
                    post: super::State, lbl: Label) {
                    ::builtin::requires(super::State::internal_flush_memtable(pre,
                            post, lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as internal_flush_memtable;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn internal_grow(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::internal_grow(pre, post,
                            lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as internal_grow;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn internal_split(pre: super::State, post: super::State,
                    lbl: Label, path: Path, left_keys: Set<Key>,
                    right_keys: Set<Key>) {
                    ::builtin::requires(super::State::internal_split(pre, post,
                            lbl, path, left_keys, right_keys));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as internal_split;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn internal_flush(pre: super::State, post: super::State,
                    lbl: Label, path: Path, down_keys: Set<Key>) {
                    ::builtin::requires(super::State::internal_flush(pre, post,
                            lbl, path, down_keys));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as internal_flush;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn internal_noop(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::internal_noop(pre, post,
                            lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as internal_noop;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn initialize(post: super::State,
                    stamped_betree: StampedBetree) {
                    ::builtin::requires(super::State::initialize(post,
                            stamped_betree));
                    ::builtin::ensures(super::State::init(post));
                }
                use bool as initialize;
            }
            pub mod take_step {
                use super::*;
            }
            #[verus::internal(verus_macro)]
            impl State {
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query(pre: Self, post: Self, lbl: Label,
                    receipt: QueryReceipt) -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        let update_tmp_root: BetreeNode = pre.root;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Query { end_lsn, key, value } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let (end_lsn, key, value) =
                                                        match tmp_for_match_0 {
                                                            Label::Query { end_lsn, key, value } =>
                                                                (end_lsn, key, value),
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(end_lsn,
                                                                    pre.memtable.seq_end)) &&
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (receipt.valid_for(pre.root,
                                                                            key)) &&
                                                                    #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(Message::Define {
                                                                                value,
                                                                            }, receipt.result().merge(pre.memtable.query(key))))))
                                                })
                                    }) &&
                                ((#[verifier::custom_err("cannot prove that the field `root` is preserved")] (::builtin::equal(post.root,
                                                    update_tmp_root)) &&
                                            #[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                                    update_tmp_memtable)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_strong(pre: Self, post: Self, lbl: Label,
                    receipt: QueryReceipt) -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        let update_tmp_root: BetreeNode = pre.root;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Query { end_lsn, key, value } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let (end_lsn, key, value) =
                                                        match tmp_for_match_0 {
                                                            Label::Query { end_lsn, key, value } =>
                                                                (end_lsn, key, value),
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(end_lsn,
                                                                    pre.memtable.seq_end)) &&
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (receipt.valid_for(pre.root,
                                                                            key)) &&
                                                                    #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(Message::Define {
                                                                                value,
                                                                            }, receipt.result().merge(pre.memtable.query(key))))))
                                                })
                                    }) &&
                                ((#[verifier::custom_err("cannot prove that the field `root` is preserved")] (::builtin::equal(post.root,
                                                    update_tmp_root)) &&
                                            #[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                                    update_tmp_memtable)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_enabled(pre: Self, lbl: Label,
                    receipt: QueryReceipt) -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Query { end_lsn, key, value } => true,
                                        _ => false,
                                    }) &&
                                {
                                    let (end_lsn, key, value) =
                                        match tmp_for_match_0 {
                                            Label::Query { end_lsn, key, value } =>
                                                (end_lsn, key, value),
                                            _ => ::vstd::pervasive::arbitrary(),
                                        };
                                    (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(end_lsn,
                                                    pre.memtable.seq_end)) &&
                                            (#[verifier::custom_err("cannot prove this condition holds")] (receipt.valid_for(pre.root,
                                                            key)) &&
                                                    #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(Message::Define {
                                                                value,
                                                            }, receipt.result().merge(pre.memtable.query(key))))))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_root: BetreeNode = pre.root;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Put { puts } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let puts =
                                                        match tmp_for_match_0 {
                                                            Label::Put { puts } => puts,
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (puts.wf())
                                                            &&
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(puts.seq_start,
                                                                            pre.memtable.seq_end)) &&
                                                                    {
                                                                        let update_tmp_memtable: Memtable =
                                                                            pre.memtable.apply_puts(puts);

                                                                        #[verifier::custom_err("cannot prove that final value of field `memtable` has this updated value")]
                                                                        (::builtin::equal(post.memtable, update_tmp_memtable))
                                                                    }))
                                                })
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `root` is preserved")] (::builtin::equal(post.root,
                                            update_tmp_root))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put_strong(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_root: BetreeNode = pre.root;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Put { puts } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let puts =
                                                        match tmp_for_match_0 {
                                                            Label::Put { puts } => puts,
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (puts.wf())
                                                            &&
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(puts.seq_start,
                                                                            pre.memtable.seq_end)) &&
                                                                    {
                                                                        let update_tmp_memtable: Memtable =
                                                                            pre.memtable.apply_puts(puts);

                                                                        #[verifier::custom_err("cannot prove that final value of field `memtable` has this updated value")]
                                                                        (::builtin::equal(post.memtable, update_tmp_memtable))
                                                                    }))
                                                })
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `root` is preserved")] (::builtin::equal(post.root,
                                            update_tmp_root))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Put { puts } => true,
                                        _ => false,
                                    }) &&
                                {
                                    let puts =
                                        match tmp_for_match_0 {
                                            Label::Put { puts } => puts,
                                            _ => ::vstd::pervasive::arbitrary(),
                                        };
                                    (#[verifier::custom_err("cannot prove this condition holds")] (puts.wf())
                                            &&
                                            #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(puts.seq_start,
                                                    pre.memtable.seq_end)))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn freeze_as(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        let update_tmp_root: BetreeNode = pre.root;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::FreezeAs { stamped_betree } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let stamped_betree =
                                                        match tmp_for_match_0 {
                                                            Label::FreezeAs { stamped_betree } => stamped_betree,
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                                            &&
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (pre.memtable.is_empty())
                                                                    &&
                                                                    #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(stamped_betree,
                                                                            Stamped {
                                                                                value: pre.root,
                                                                                seq_end: pre.memtable.seq_end,
                                                                            }))))
                                                })
                                    }) &&
                                ((#[verifier::custom_err("cannot prove that the field `root` is preserved")] (::builtin::equal(post.root,
                                                    update_tmp_root)) &&
                                            #[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                                    update_tmp_memtable)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn freeze_as_strong(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        let update_tmp_root: BetreeNode = pre.root;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::FreezeAs { stamped_betree } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let stamped_betree =
                                                        match tmp_for_match_0 {
                                                            Label::FreezeAs { stamped_betree } => stamped_betree,
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                                            &&
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (pre.memtable.is_empty())
                                                                    &&
                                                                    #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(stamped_betree,
                                                                            Stamped {
                                                                                value: pre.root,
                                                                                seq_end: pre.memtable.seq_end,
                                                                            }))))
                                                })
                                    }) &&
                                ((#[verifier::custom_err("cannot prove that the field `root` is preserved")] (::builtin::equal(post.root,
                                                    update_tmp_root)) &&
                                            #[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                                    update_tmp_memtable)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn freeze_as_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::FreezeAs { stamped_betree } => true,
                                        _ => false,
                                    }) &&
                                {
                                    let stamped_betree =
                                        match tmp_for_match_0 {
                                            Label::FreezeAs { stamped_betree } => stamped_betree,
                                            _ => ::vstd::pervasive::arbitrary(),
                                        };
                                    (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                            &&
                                            (#[verifier::custom_err("cannot prove this condition holds")] (pre.memtable.is_empty())
                                                    &&
                                                    #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(stamped_betree,
                                                            Stamped {
                                                                value: pre.root,
                                                                seq_end: pre.memtable.seq_end,
                                                            }))))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_flush_memtable(pre: Self, post: Self,
                    lbl: Label) -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Internal {} => true,
                                        _ => false,
                                    }) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                        &&
                                        {
                                            let update_tmp_memtable: Memtable = pre.memtable.drain();
                                            let update_tmp_root: BetreeNode =
                                                pre.root.push_memtable(pre.memtable).value;
                                            (#[verifier::custom_err("cannot prove that final value of field `root` has this updated value")] (::builtin::equal(post.root,
                                                            update_tmp_root)) &&
                                                    #[verifier::custom_err("cannot prove that final value of field `memtable` has this updated value")] (::builtin::equal(post.memtable,
                                                            update_tmp_memtable)))
                                        }))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_flush_memtable_strong(pre: Self, post: Self,
                    lbl: Label) -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Internal {} => true,
                                        _ => false,
                                    }) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                        &&
                                        {
                                            let update_tmp_memtable: Memtable = pre.memtable.drain();
                                            let update_tmp_root: BetreeNode =
                                                pre.root.push_memtable(pre.memtable).value;
                                            (#[verifier::custom_err("cannot prove that final value of field `root` has this updated value")] (::builtin::equal(post.root,
                                                            update_tmp_root)) &&
                                                    #[verifier::custom_err("cannot prove that final value of field `memtable` has this updated value")] (::builtin::equal(post.memtable,
                                                            update_tmp_memtable)))
                                        }))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_flush_memtable_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Internal {} => true,
                                        _ => false,
                                    }) &&
                                #[verifier::custom_err("cannot prove this condition holds")] (pre.wf()))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_grow(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Internal {} => true,
                                                        _ => false,
                                                    }) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                                        &&
                                                        {
                                                            let update_tmp_root: BetreeNode =
                                                                BetreeNode::Node {
                                                                    buffer: Buffer::empty(),
                                                                    children: constant_child_map(pre.root),
                                                                };

                                                            #[verifier::custom_err("cannot prove that final value of field `root` has this updated value")]
                                                            (::builtin::equal(post.root, update_tmp_root))
                                                        }))
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                            update_tmp_memtable))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_grow_strong(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Internal {} => true,
                                                        _ => false,
                                                    }) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                                        &&
                                                        {
                                                            let update_tmp_root: BetreeNode =
                                                                BetreeNode::Node {
                                                                    buffer: Buffer::empty(),
                                                                    children: constant_child_map(pre.root),
                                                                };

                                                            #[verifier::custom_err("cannot prove that final value of field `root` has this updated value")]
                                                            (::builtin::equal(post.root, update_tmp_root))
                                                        }))
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                            update_tmp_memtable))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_grow_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Internal {} => true,
                                        _ => false,
                                    }) &&
                                #[verifier::custom_err("cannot prove this condition holds")] (pre.wf()))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_split(pre: Self, post: Self, lbl: Label,
                    path: Path, left_keys: Set<Key>, right_keys: Set<Key>)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Internal {} => true,
                                                        _ => false,
                                                    }) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (path.valid())
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.node,
                                                                        pre.root)) &&
                                                                {
                                                                    let update_tmp_root: BetreeNode =
                                                                        path.substitute(path.target().split(left_keys, right_keys));

                                                                    #[verifier::custom_err("cannot prove that final value of field `root` has this updated value")]
                                                                    (::builtin::equal(post.root, update_tmp_root))
                                                                })))
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                            update_tmp_memtable))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_split_strong(pre: Self, post: Self,
                    lbl: Label, path: Path, left_keys: Set<Key>,
                    right_keys: Set<Key>) -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Internal {} => true,
                                                        _ => false,
                                                    }) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (path.valid())
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.node,
                                                                        pre.root)) &&
                                                                {
                                                                    let update_tmp_root: BetreeNode =
                                                                        path.substitute(path.target().split(left_keys, right_keys));

                                                                    #[verifier::custom_err("cannot prove that final value of field `root` has this updated value")]
                                                                    (::builtin::equal(post.root, update_tmp_root))
                                                                })))
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                            update_tmp_memtable))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_split_enabled(pre: Self, lbl: Label,
                    path: Path, left_keys: Set<Key>, right_keys: Set<Key>)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Internal {} => true,
                                        _ => false,
                                    }) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (path.valid())
                                        &&
                                        #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.node,
                                                pre.root))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_flush(pre: Self, post: Self, lbl: Label,
                    path: Path, down_keys: Set<Key>)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Internal {} => true,
                                                        _ => false,
                                                    }) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (path.valid())
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.node,
                                                                        pre.root)) &&
                                                                {
                                                                    let update_tmp_root: BetreeNode =
                                                                        path.substitute(path.target().flush(down_keys));

                                                                    #[verifier::custom_err("cannot prove that final value of field `root` has this updated value")]
                                                                    (::builtin::equal(post.root, update_tmp_root))
                                                                })))
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                            update_tmp_memtable))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_flush_strong(pre: Self, post: Self,
                    lbl: Label, path: Path, down_keys: Set<Key>)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Internal {} => true,
                                                        _ => false,
                                                    }) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (path.valid())
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.node,
                                                                        pre.root)) &&
                                                                {
                                                                    let update_tmp_root: BetreeNode =
                                                                        path.substitute(path.target().flush(down_keys));

                                                                    #[verifier::custom_err("cannot prove that final value of field `root` has this updated value")]
                                                                    (::builtin::equal(post.root, update_tmp_root))
                                                                })))
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                            update_tmp_memtable))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_flush_enabled(pre: Self, lbl: Label,
                    path: Path, down_keys: Set<Key>)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Internal {} => true,
                                        _ => false,
                                    }) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (path.valid())
                                        &&
                                        #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.node,
                                                pre.root))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_noop(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        let update_tmp_root: BetreeNode = pre.root;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Internal {} => true,
                                                        _ => false,
                                                    }) &&
                                                #[verifier::custom_err("cannot prove this condition holds")] (pre.wf()))
                                    }) &&
                                ((#[verifier::custom_err("cannot prove that the field `root` is preserved")] (::builtin::equal(post.root,
                                                    update_tmp_root)) &&
                                            #[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                                    update_tmp_memtable)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_noop_strong(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        let update_tmp_root: BetreeNode = pre.root;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Internal {} => true,
                                                        _ => false,
                                                    }) &&
                                                #[verifier::custom_err("cannot prove this condition holds")] (pre.wf()))
                                    }) &&
                                ((#[verifier::custom_err("cannot prove that the field `root` is preserved")] (::builtin::equal(post.root,
                                                    update_tmp_root)) &&
                                            #[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                                    update_tmp_memtable)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_noop_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Internal {} => true,
                                        _ => false,
                                    }) &&
                                #[verifier::custom_err("cannot prove this condition holds")] (pre.wf()))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn initialize(post: Self, stamped_betree: StampedBetree)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (stamped_betree.value.wf())
                                &&
                                {
                                    let update_tmp_memtable: Memtable =
                                        Memtable::empty_memtable(stamped_betree.seq_end);
                                    let update_tmp_root: BetreeNode = stamped_betree.value;
                                    (#[verifier::custom_err("cannot prove that final value of field `root` has this updated value")] (::builtin::equal(post.root,
                                                    update_tmp_root)) &&
                                            #[verifier::custom_err("cannot prove that final value of field `memtable` has this updated value")] (::builtin::equal(post.memtable,
                                                    update_tmp_memtable)))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn initialize_enabled(stamped_betree: StampedBetree)
                    -> ::core::primitive::bool {
                    {

                        #[verifier::custom_err("cannot prove this condition holds")]
                        (stamped_betree.value.wf())
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_by(pre: State, post: State, label: Label,
                    step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::query(receipt) =>
                            Self::query(pre, post, label, receipt),
                        Step::put() => Self::put(pre, post, label),
                        Step::freeze_as() => Self::freeze_as(pre, post, label),
                        Step::internal_flush_memtable() =>
                            Self::internal_flush_memtable(pre, post, label),
                        Step::internal_grow() =>
                            Self::internal_grow(pre, post, label),
                        Step::internal_split(path, left_keys, right_keys) =>
                            Self::internal_split(pre, post, label, path, left_keys,
                                right_keys),
                        Step::internal_flush(path, down_keys) =>
                            Self::internal_flush(pre, post, label, path, down_keys),
                        Step::internal_noop() =>
                            Self::internal_noop(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next(pre: State, post: State, label: Label)
                    -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                            Self::next_by(pre, post, label, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_strong_by(pre: State, post: State, label: Label,
                    step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::query(receipt) =>
                            Self::query_strong(pre, post, label, receipt),
                        Step::put() => Self::put_strong(pre, post, label),
                        Step::freeze_as() =>
                            Self::freeze_as_strong(pre, post, label),
                        Step::internal_flush_memtable() =>
                            Self::internal_flush_memtable_strong(pre, post, label),
                        Step::internal_grow() =>
                            Self::internal_grow_strong(pre, post, label),
                        Step::internal_split(path, left_keys, right_keys) =>
                            Self::internal_split_strong(pre, post, label, path,
                                left_keys, right_keys),
                        Step::internal_flush(path, down_keys) =>
                            Self::internal_flush_strong(pre, post, label, path,
                                down_keys),
                        Step::internal_noop() =>
                            Self::internal_noop_strong(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_strong(pre: State, post: State, label: Label)
                    -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                            Self::next_strong_by(pre, post, label, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn init_by(post: State, step: Config)
                    -> ::core::primitive::bool {
                    match step {
                        Config::initialize(stamped_betree) =>
                            Self::initialize(post, stamped_betree),
                        Config::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn init(post: State) -> ::core::primitive::bool {
                    ::builtin::exists(|step: Config| Self::init_by(post, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::spec]
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                pub fn invariant(&self) -> ::core::primitive::bool { true }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn wf(self) -> bool { self.root.wf() }
            }
        }
    }
    pub mod PagedBetreeRefinement_v {
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use vstd::map::*;
        use crate::spec::KeyType_t::*;
        use crate::spec::Messages_t::*;
        use crate::spec::TotalKMMap_t::*;
        use crate::abstract_system::StampedMap_v::*;
        use crate::abstract_system::MsgHistory_v::*;
        use crate::abstract_system::AbstractMap_v::*;
        use crate::betree::PagedBetree_v::*;
        use crate::betree::Buffer_v::*;
        use crate::betree::Memtable_v::*;
        #[verus::internal(verus_macro)]
        impl BetreeNode {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn build_query_receipt(self, key: Key) -> QueryReceipt {
                ::builtin::recommends([self.wf()]);
                ::builtin::decreases((self));
                ::builtin::decreases_when(self.wf());
                if self.is_Nil() {
                        let msg = Message::Define { value: default_value() };
                        let line = QueryReceiptLine { node: self, result: msg };
                        QueryReceipt {
                            key: key,
                            root: self,
                            lines: ::vstd::seq::Seq::empty().push(line),
                        }
                    } else {
                       let child_receipt =
                           self.child(key).build_query_receipt(key);
                       let msg = self.get_Node_buffer().query(key);
                       let line =
                           QueryReceiptLine {
                               node: self,
                               result: child_receipt.result().merge(msg),
                           };
                       QueryReceipt {
                           key: key,
                           root: self,
                           lines: (::vstd::seq::Seq::empty().push(line)).spec_add(child_receipt.lines),
                       }
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn build_query_receipt_valid(self, key: Key) {
                ::builtin::requires([self.wf()]);
                ::builtin::ensures([self.build_query_receipt(key).valid()]);
                ::builtin::decreases((self));
                if self.is_Node() {
                        let child_receipt =
                            self.child(key).build_query_receipt(key);
                        self.child(key).build_query_receipt_valid(key);
                        let msg = self.get_Node_buffer().query(key);
                        let line =
                            QueryReceiptLine {
                                node: self,
                                result: child_receipt.result().merge(msg),
                            };
                        let receipt =
                            QueryReceipt {
                                key: key,
                                root: self,
                                lines: (::vstd::seq::Seq::empty().push(line)).spec_add(child_receipt.lines),
                            };
                        {
                            ::builtin::assert_forall_by(|i: int|
                                    {
                                        ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_lt(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                        i),
                                                    (receipt.lines.len()).spec_sub(::builtin::spec_literal_nat("1")))));
                                        ::builtin::ensures(({
                                                    (receipt.child_linked_at(i)) &&
                                                        (receipt.result_linked_at(i))
                                                }));
                                        ::builtin::assert_(child_receipt.child_linked_at((i).spec_sub(::builtin::spec_literal_nat("1"))));
                                        ::builtin::assert_(child_receipt.result_linked_at((i).spec_sub(::builtin::spec_literal_nat("1"))));
                                    });
                        }
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn i_at(self, key: Key) -> Message {
                ::builtin::recommends([self.wf()]);
                self.build_query_receipt(key).result()
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> TotalKMMap {
                TotalKMMap(Map::new(::builtin::closure_to_fn_spec(|k: Key|
                                true), ::builtin::closure_to_fn_spec(|k| self.i_at(k))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn memtable_distributes_over_betree(self,
                memtable: Memtable) {
                ::builtin::requires([self.wf()]);
                ::builtin::ensures([::builtin::spec_eq(map_apply(memtable,
                                    self.i()), self.push_memtable(memtable).value.i())]);
                let map_a = map_apply(memtable, self.i());
                let map_b = self.push_memtable(memtable).value.i();
                ::builtin::assert_(::builtin::ext_equal(map_a, map_b));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn push_empty_memtable_refines(self, memtable: Memtable) {
                ::builtin::requires([self.wf(), memtable.is_empty()]);
                ::builtin::ensures([::builtin::spec_eq(i_stamped_betree(Stamped {
                                        value: self,
                                        seq_end: memtable.seq_end,
                                    }), i_stamped_betree(self.push_memtable(memtable)))]);
                ::builtin::assert_(::builtin::ext_equal(self.i(),
                        self.push_memtable(memtable).value.i()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn merge_buffer_lemma(self, new_buffer: Buffer, key: Key) {
                ::builtin::requires([self.wf()]);
                ::builtin::ensures([::builtin::spec_eq(self.promote().merge_buffer(new_buffer).i_at(key),
                                self.i_at(key).merge(new_buffer.query(key)))]);
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn filter_buffer_and_children_wf(self, filter: Set<Key>) {
                ::builtin::requires([self.wf()]);
                ::builtin::ensures([self.filter_buffer_and_children(filter).wf()]);
                if self.is_Node() {
                        ::builtin::assert_(self.filter_buffer_and_children(filter).get_Node_children().wf());
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn split_wf(self, left_keys: Set<Key>, right_keys: Set<Key>) {
                ::builtin::requires([self.wf(), self.is_Node()]);
                ::builtin::ensures([self.split(left_keys, right_keys).wf()]);
                let child_map =
                    self.split(left_keys, right_keys).get_Node_children();
                {
                    ::builtin::assert_forall_by(|k: Key|
                            {
                                ::builtin::ensures((#[verus::internal(trigger)] child_map.map.spec_index(k)).wf());
                                if left_keys.contains(k) {
                                        self.child(k).filter_buffer_and_children_wf(left_keys);
                                    } else if right_keys.contains(k) {
                                       self.child(k).filter_buffer_and_children_wf(right_keys);
                                   } else { self.child(k); }
                            });
                }
                ::builtin::assert_(total_keys(child_map.map.dom()));
                ::builtin::assert_(child_map.wf());
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn apply_filter_equivalence(self, filter: Set<Key>,
                key: Key) {
                ::builtin::requires([self.wf(), filter.contains(key)]);
                ::builtin::ensures([::builtin::spec_eq(self.filter_buffer_and_children(filter).i_at(key),
                                self.i_at(key))]);
                let receipt = self.build_query_receipt(key);
                self.build_query_receipt_valid(key);
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn flush_wf(self, down_keys: Set<Key>) {
                ::builtin::requires([self.wf(), self.is_Node()]);
                ::builtin::ensures([self.flush(down_keys).wf()]);
                let child_map = self.flush(down_keys).get_Node_children();
                ::builtin::assert_(self.get_Node_children().wf());
                {
                    ::builtin::assert_forall_by(|k: Key|
                            {
                                ::builtin::ensures((#[verus::internal(trigger)] child_map.map.spec_index(k)).wf());
                            });
                }
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn map_apply(memtable: Memtable, base: TotalKMMap) -> TotalKMMap {
            TotalKMMap(Map::new(::builtin::closure_to_fn_spec(|k: Key| true),
                    ::builtin::closure_to_fn_spec(|k: Key|
                            base.spec_index(k).merge(memtable.query(k)))))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn i_stamped_betree(stamped: StampedBetree) -> StampedMap {
            Stamped { value: stamped.value.i(), seq_end: stamped.seq_end }
        }
        #[verus::internal(verus_macro)]
        impl QueryReceipt {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn drop_first(self) -> QueryReceipt {
                ::builtin::recommends([self.root.wf(), self.root.is_Node(),
                            (::builtin::spec_literal_nat("1")).spec_lt(self.lines.len())]);
                QueryReceipt {
                    key: self.key,
                    root: self.root.child(self.key),
                    lines: self.lines.subrange(::builtin::spec_literal_integer("1"),
                        ::builtin::spec_cast_integer::<_, int>(self.lines.len())),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn drop_first_valid(self) {
                ::builtin::requires([self.valid(),
                            (::builtin::spec_literal_nat("1")).spec_lt(self.lines.len())]);
                ::builtin::ensures([self.drop_first().valid()]);
                let out = self.drop_first();
                ::builtin::assert_(self.child_linked_at(::builtin::spec_literal_integer("0")));
                {
                    ::builtin::assert_forall_by(|i: int|
                            {
                                ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                i),
                                            (out.lines.len()).spec_sub(::builtin::spec_literal_nat("1")))));
                                ::builtin::ensures(({
                                            (out.child_linked_at(i)) && (out.result_linked_at(i))
                                        }));
                                ::builtin::assert_(self.child_linked_at((i).spec_add(::builtin::spec_literal_nat("1"))));
                                ::builtin::assert_(self.result_linked_at((i).spec_add(::builtin::spec_literal_nat("1"))));
                            });
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn equal_receipts(self, other: QueryReceipt) {
                ::builtin::requires([self.valid(), other.valid(),
                            ::builtin::spec_eq(self.key, other.key),
                            ::builtin::spec_eq(self.root, other.root)]);
                ::builtin::ensures([::builtin::spec_eq(self.result(),
                                other.result())]);
                ::builtin::decreases((self.lines.len()));
                if (::builtin::spec_literal_nat("1")).spec_lt(self.lines.len())
                        {
                        ::builtin::assert_(self.result_linked_at(::builtin::spec_literal_integer("0")));
                        ::builtin::assert_(other.result_linked_at(::builtin::spec_literal_integer("0")));
                        self.drop_first_valid();
                        other.drop_first_valid();
                        self.drop_first().equal_receipts(other.drop_first());
                    }
            }
        }
        #[verus::internal(verus_macro)]
        impl Path {
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn target_wf(self) {
                ::builtin::requires([self.valid()]);
                ::builtin::ensures([self.target().wf(),
                            self.target().is_Node()]);
                ::builtin::decreases((self.routing.len()));
                if (self.routing.len()).spec_gt(::builtin::spec_literal_nat("0"))
                        {
                        self.subpath().target_wf();
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn substitute_preserves_wf(self, replacement: BetreeNode) {
                ::builtin::requires([self.valid(), replacement.wf()]);
                ::builtin::ensures([self.substitute(replacement).wf()]);
                ::builtin::decreases((self.routing.len()));
                if (self.routing.len()).spec_gt(::builtin::spec_literal_nat("0"))
                        {
                        self.subpath().substitute_preserves_wf(replacement);
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn substitute_receipt_equivalence(self,
                replacement: BetreeNode, key: Key) {
                ::builtin::requires([self.valid(), replacement.wf(),
                            self.substitute(replacement).wf(),
                            ::builtin::spec_eq(self.target().i(), replacement.i())]);
                ::builtin::ensures([::builtin::spec_eq(self.node.i_at(key),
                                self.substitute(replacement).i_at(key))]);
                ::builtin::decreases((self.routing.len()));
                ::builtin::assert_(::builtin::spec_eq(self.target().i_at(key),
                        self.target().i().spec_index(key)));
                ::builtin::assert_(::builtin::spec_eq(self.target().i_at(key),
                        replacement.i_at(key)));
                if (self.routing.len()).spec_gt(::builtin::spec_literal_nat("0"))
                        {
                        if self.routing.spec_index(::builtin::spec_literal_integer("0")).contains(key)
                                {
                                let receipt = self.node.build_query_receipt(key);
                                self.node.build_query_receipt_valid(key);
                                receipt.drop_first_valid();
                                ::builtin::assert_(::builtin::spec_eq(receipt.drop_first().root,
                                        self.subpath().node));
                                self.subpath().node.build_query_receipt_valid(key);
                                self.subpath().node.build_query_receipt(key).equal_receipts(receipt.drop_first());
                                self.subpath().substitute(replacement).build_query_receipt_valid(key);
                                self.substitute(replacement).build_query_receipt_valid(key);
                                self.substitute(replacement).build_query_receipt(key).drop_first_valid();
                                self.subpath().substitute(replacement).build_query_receipt(key).equal_receipts(self.substitute(replacement).build_query_receipt(key).drop_first());
                                self.subpath().substitute_receipt_equivalence(replacement,
                                    key);
                            } else {
                               ::builtin::assert_(::builtin::spec_eq(self.node.i_at(key),
                                       self.substitute(replacement).i_at(key)));
                           }
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn substitute_equivalence(self, replacement: BetreeNode) {
                ::builtin::requires([self.valid(), replacement.wf(),
                            ::builtin::spec_eq(self.target().i(), replacement.i())]);
                ::builtin::ensures([self.substitute(replacement).wf(),
                            ::builtin::spec_eq(self.node.i(),
                                self.substitute(replacement).i())]);
                self.substitute_preserves_wf(replacement);
                {
                    ::builtin::assert_forall_by(|k: Key|
                            {
                                ::builtin::ensures(::builtin::spec_eq((#[verus::internal(trigger)] self.node.i_at(k)),
                                        self.substitute(replacement).i_at(k)));
                                self.substitute_receipt_equivalence(replacement, k);
                            });
                }
                ::builtin::assert_(::builtin::ext_equal(self.node.i(),
                        self.substitute(replacement).i()));
            }
        }
        #[verus::internal(verus_macro)]
        impl PagedBetree::Label {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> AbstractMap::Label {
                match self {
                    PagedBetree::Label::Query { end_lsn, key, value } =>
                        AbstractMap::Label::QueryLabel {
                            end_lsn: end_lsn,
                            key: key,
                            value: value,
                        },
                    PagedBetree::Label::Put { puts } =>
                        AbstractMap::Label::PutLabel { puts: puts },
                    PagedBetree::Label::FreezeAs { stamped_betree } =>
                        AbstractMap::Label::FreezeAsLabel {
                            stamped_map: i_stamped_betree(stamped_betree),
                        },
                    PagedBetree::Label::Internal {} =>
                        AbstractMap::Label::InternalLabel {},
                }
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn composite_single_put(puts1: MsgHistory, puts2: MsgHistory,
            stamped_map: StampedMap) {
            ::builtin::requires([puts1.wf(), puts2.wf(),
                        ::builtin::spec_eq(puts2.len(),
                            ::builtin::spec_literal_nat("1")),
                        puts1.can_follow(stamped_map.seq_end),
                        puts2.can_follow(puts1.seq_end)]);
            ::builtin::ensures([::builtin::spec_eq(puts1.concat(puts2).apply_to_stamped_map(stamped_map),
                            puts2.apply_to_stamped_map(puts1.apply_to_stamped_map(stamped_map)))]);
            let last_lsn =
                ::builtin::spec_cast_integer::<_,
                        nat>(((puts2.seq_end).spec_sub(::builtin::spec_literal_nat("1"))));
            #[verifier::spec]
            let m1 = ::vstd::map::check_argument_is_map(puts1.msgs);
            #[verifier::spec]
            let m2 =
                ::vstd::map::check_argument_is_map(puts1.concat(puts2).discard_recent(last_lsn).msgs);
            ::builtin::assert_by(::builtin::equal(m1, m2),
                {
                    ::builtin::assert_forall_by(|key|
                            {
                                ::builtin::ensures([::builtin::imply(#[verifier::trigger] m1.dom().contains(key),
                                                        m2.dom().contains(key)) &&
                                                    ::builtin::imply(m2.dom().contains(key),
                                                        m1.dom().contains(key)) &&
                                                ::builtin::imply(m1.dom().contains(key) &&
                                                        m2.dom().contains(key),
                                                    ::builtin::equal(m1.index(key), m2.index(key)))]);
                                { {} }
                            });
                    ::builtin::assert_(::builtin::ext_equal(m1, m2));
                });
            ;
            ::builtin::assert_(::builtin::spec_eq(puts1,
                    puts1.concat(puts2).discard_recent(last_lsn)));
            ::builtin::assert_(::builtin::spec_eq(puts2.discard_recent(last_lsn).apply_to_stamped_map(puts1.apply_to_stamped_map(stamped_map)),
                    puts1.apply_to_stamped_map(stamped_map)));
            puts1.concat(puts2).apply_to_stamped_map_length_lemma(stamped_map);
            puts1.apply_to_stamped_map_length_lemma(stamped_map);
            puts2.apply_to_stamped_map_length_lemma(puts1.apply_to_stamped_map(stamped_map));
        }
        #[verus::internal(verus_macro)]
        impl PagedBetree::State {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn inv(self) -> bool { self.wf() }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> AbstractMap::State {
                AbstractMap::State {
                    stamped_map: i_stamped_betree(self.root.push_memtable(self.memtable)),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn init_refines(self, stamped_betree: StampedBetree) {
                ::builtin::requires([PagedBetree::State::initialize(self,
                                stamped_betree)]);
                ::builtin::ensures([self.inv(),
                            AbstractMap::State::initialize(self.i(),
                                i_stamped_betree(stamped_betree))]);
                self.root.push_empty_memtable_refines(self.memtable);
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn query_refines(self, post: Self, lbl: PagedBetree::Label,
                receipt: QueryReceipt) {
                ::builtin::requires([self.inv(),
                            PagedBetree::State::query(self, post, lbl, receipt)]);
                ::builtin::ensures([post.inv(),
                            AbstractMap::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(AbstractMap::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(AbstractMap::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                let built_receipt =
                    self.root.build_query_receipt(lbl.get_Query_key());
                self.root.build_query_receipt_valid(lbl.get_Query_key());
                receipt.equal_receipts(built_receipt);
                ::builtin::assert_(AbstractMap::State::next_by(self.i(),
                        post.i(), lbl.i(), AbstractMap::Step::query()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn apply_single_put_is_map_plus_history(self, post: Self,
                puts: MsgHistory) {
                ::builtin::requires([self.wf(), post.wf(), puts.wf(),
                            ::builtin::spec_eq(puts.len(),
                                ::builtin::spec_literal_nat("1")),
                            ::builtin::spec_eq(puts.seq_start, self.memtable.seq_end),
                            ::builtin::spec_eq(post.memtable,
                                self.memtable.apply_puts(puts)),
                            ::builtin::spec_eq(post.root, self.root)]);
                ::builtin::ensures([::builtin::spec_eq(post.i().stamped_map,
                                MsgHistory::map_plus_history(self.i().stamped_map, puts))]);
                let KeyedMessage { key: key, message: message } =
                    puts.msgs.spec_index(puts.seq_start);
                let map_a = post.root.push_memtable(post.memtable).value.i();
                self.memtable.apply_puts_end(puts);
                let map_b =
                    puts.apply_to_stamped_map(self.i().stamped_map).value;
                MsgHistory::map_plus_history_lemma(self.i().stamped_map,
                    puts);
                let sub_map_b =
                    puts.discard_recent(puts.seq_start).apply_to_stamped_map(self.i().stamped_map).value;
                ::builtin::assert_(::builtin::spec_eq(map_b,
                        sub_map_b.insert(key,
                            sub_map_b.spec_index(key).merge(message))));
                ::builtin::assert_(::builtin::ext_equal(map_a, map_b));
                ::builtin::assert_(::builtin::spec_eq(post.i().stamped_map.value,
                        map_a));
                ::builtin::assert_(::builtin::spec_eq(MsgHistory::map_plus_history(self.i().stamped_map,
                                puts).value, map_b));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn apply_put_is_map_plus_history(self, post: Self,
                puts: MsgHistory) {
                ::builtin::requires([self.wf(), post.wf(), puts.wf(),
                            ::builtin::spec_eq(puts.seq_start, self.memtable.seq_end),
                            ::builtin::spec_eq(post.memtable,
                                self.memtable.apply_puts(puts)),
                            ::builtin::spec_eq(post.root, self.root)]);
                ::builtin::ensures([::builtin::spec_eq(post.i().stamped_map,
                                MsgHistory::map_plus_history(self.i().stamped_map, puts))]);
                ::builtin::decreases((puts.len()));
                if (::builtin::spec_literal_nat("0")).spec_lt(puts.len()) {
                        let last =
                            ::builtin::spec_cast_integer::<_,
                                    nat>(((puts.seq_end).spec_sub(::builtin::spec_literal_nat("1"))));
                        let last_put = puts.discard_old(last);
                        let short_puts = puts.discard_recent(last);
                        let intermediate_post =
                            PagedBetree::State {
                                root: self.root,
                                memtable: self.memtable.apply_puts(short_puts),
                            };
                        self.apply_put_is_map_plus_history(intermediate_post,
                            short_puts);
                        self.memtable.apply_puts_end(short_puts);
                        ::builtin::assert_(last_put.can_follow(intermediate_post.memtable.seq_end));
                        self.memtable.apply_puts_additive(short_puts, last_put);
                        ::builtin::assert_(::builtin::ext_equal(short_puts.concat(last_put).msgs,
                                puts.msgs));
                        ::builtin::assert_(::builtin::spec_eq(post.memtable,
                                intermediate_post.memtable.apply_puts(last_put)));
                        intermediate_post.apply_single_put_is_map_plus_history(post,
                            last_put);
                        composite_single_put(short_puts, last_put,
                            self.i().stamped_map);
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn put_refines(self, post: Self, lbl: PagedBetree::Label) {
                ::builtin::requires([self.inv(),
                            PagedBetree::State::put(self, post, lbl)]);
                ::builtin::ensures([post.inv(),
                            AbstractMap::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(AbstractMap::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(AbstractMap::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                self.apply_put_is_map_plus_history(post, lbl.get_Put_puts());
                ::builtin::assert_(AbstractMap::State::next_by(self.i(),
                        post.i(), lbl.i(), AbstractMap::Step::put()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn freeze_as_refines(self, post: Self,
                lbl: PagedBetree::Label) {
                ::builtin::requires([self.inv(),
                            PagedBetree::State::freeze_as(self, post, lbl)]);
                ::builtin::ensures([post.inv(),
                            AbstractMap::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(AbstractMap::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(AbstractMap::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                self.root.push_empty_memtable_refines(self.memtable);
                ::builtin::assert_(AbstractMap::State::next_by(self.i(),
                        post.i(), lbl.i(), AbstractMap::Step::freeze_as()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn internal_flush_memtable_noop(self, post: Self,
                lbl: PagedBetree::Label) {
                ::builtin::requires([self.inv(),
                            PagedBetree::State::internal_flush_memtable(self, post,
                                lbl)]);
                ::builtin::ensures([post.inv(),
                            AbstractMap::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(AbstractMap::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(AbstractMap::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                post.root.push_empty_memtable_refines(post.memtable);
                ::builtin::assert_(AbstractMap::State::next_by(self.i(),
                        post.i(), lbl.i(), AbstractMap::Step::internal()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn equivalent_roots(self, post: Self) {
                ::builtin::requires([self.wf(), post.wf(),
                            ::builtin::spec_eq(self.memtable, post.memtable),
                            ::builtin::spec_eq(self.root.i(), post.root.i())]);
                ::builtin::ensures([::builtin::spec_eq(self.i(), post.i())]);
                self.root.memtable_distributes_over_betree(self.memtable);
                post.root.memtable_distributes_over_betree(post.memtable);
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn internal_grow_noop(self, post: Self,
                lbl: PagedBetree::Label) {
                ::builtin::requires([self.inv(),
                            PagedBetree::State::internal_grow(self, post, lbl)]);
                ::builtin::ensures([post.inv(),
                            AbstractMap::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(AbstractMap::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(AbstractMap::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::assert_(::builtin::ext_equal(post.root.i(),
                        self.root.i()));
                self.equivalent_roots(post);
                ::builtin::assert_(AbstractMap::State::next_by(self.i(),
                        post.i(), lbl.i(), AbstractMap::Step::internal()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn internal_split_noop(self, post: Self,
                lbl: PagedBetree::Label, path: Path, left_keys: Set<Key>,
                right_keys: Set<Key>) {
                ::builtin::requires([self.inv(),
                            PagedBetree::State::internal_split(self, post, lbl, path,
                                left_keys, right_keys)]);
                ::builtin::ensures([post.inv(),
                            AbstractMap::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(AbstractMap::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(AbstractMap::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                let target = path.target();
                path.target_wf();
                let top = target.split(left_keys, right_keys);
                target.split_wf(left_keys, right_keys);
                {
                    ::builtin::assert_forall_by(|k: Key|
                            {
                                ::builtin::ensures(::builtin::spec_eq(target.i_at(k),
                                        top.i_at(k)));
                                if left_keys.contains(k) {
                                        target.child(k).apply_filter_equivalence(left_keys, k);
                                    } else if right_keys.contains(k) {
                                       target.child(k).apply_filter_equivalence(right_keys, k);
                                   }
                            });
                }
                ::builtin::assert_(::builtin::ext_equal(target.i(), top.i()));
                path.substitute_equivalence(top);
                self.equivalent_roots(post);
                ::builtin::assert_(AbstractMap::State::next_by(self.i(),
                        post.i(), lbl.i(), AbstractMap::Step::internal()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn internal_flush_noop(self, post: Self,
                lbl: PagedBetree::Label, path: Path, down_keys: Set<Key>) {
                ::builtin::requires([self.inv(),
                            PagedBetree::State::internal_flush(self, post, lbl, path,
                                down_keys)]);
                ::builtin::ensures([post.inv(),
                            AbstractMap::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(AbstractMap::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(AbstractMap::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                let target = path.target();
                path.target_wf();
                let top = target.flush(down_keys);
                target.flush_wf(down_keys);
                let kept_keys = all_keys().difference(down_keys);
                {
                    ::builtin::assert_forall_by(|k: Key|
                            {
                                ::builtin::ensures(::builtin::spec_eq(target.i_at(k),
                                        top.i_at(k)));
                                if down_keys.contains(k) {
                                        let moved_buffer =
                                            target.get_Node_buffer().apply_filter(down_keys);
                                        let child = target.get_Node_children().map.spec_index(k);
                                        child.merge_buffer_lemma(moved_buffer, k);
                                    }
                            });
                }
                ::builtin::assert_(::builtin::ext_equal(target.i(), top.i()));
                path.substitute_equivalence(top);
                self.equivalent_roots(post);
                ::builtin::assert_(AbstractMap::State::next_by(self.i(),
                        post.i(), lbl.i(), AbstractMap::Step::internal()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn internal_noop_noop(self, post: Self,
                lbl: PagedBetree::Label) {
                ::builtin::requires([self.inv(),
                            PagedBetree::State::internal_noop(self, post, lbl)]);
                ::builtin::ensures([post.inv(),
                            AbstractMap::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(AbstractMap::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(AbstractMap::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::assert_(AbstractMap::State::next_by(self.i(),
                        post.i(), lbl.i(), AbstractMap::Step::internal()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn next_refines(self, post: Self, lbl: PagedBetree::Label) {
                ::builtin::requires([self.inv(),
                            PagedBetree::State::next(self, post, lbl)]);
                ::builtin::ensures([post.inv(),
                            AbstractMap::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PagedBetree::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PagedBetree::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                match ::builtin::choose(|step|
                            PagedBetree::State::next_by(self, post, lbl, step)) {
                    PagedBetree::Step::query(receipt) => {
                        self.query_refines(post, lbl, receipt);
                    }
                    PagedBetree::Step::put() => { self.put_refines(post, lbl); }
                    PagedBetree::Step::freeze_as() => {
                        self.freeze_as_refines(post, lbl);
                    }
                    PagedBetree::Step::internal_flush_memtable() => {
                        self.internal_flush_memtable_noop(post, lbl);
                    }
                    PagedBetree::Step::internal_grow() => {
                        self.internal_grow_noop(post, lbl);
                    }
                    PagedBetree::Step::internal_split(path, left_keys,
                        right_keys) => {
                        self.internal_split_noop(post, lbl, path, left_keys,
                            right_keys);
                    }
                    PagedBetree::Step::internal_flush(path, down_keys) => {
                        self.internal_flush_noop(post, lbl, path, down_keys);
                    }
                    PagedBetree::Step::internal_noop() => {
                        self.internal_noop_noop(post, lbl);
                    }
                    _ => { ::builtin::assert_(false); }
                }
            }
        }
    }
    pub mod Domain_v {
        use builtin_macros::*;
        use vstd::set::*;
        use crate::spec::KeyType_t::*;
        #[verus::internal(verus_macro)]
        pub enum Domain {
            EmptyDomain,
            Domain {
                start: Element,
                end: Element,
            },
        }
        #[verus::internal(verus_macro)]
        #[cfg(verus_keep_ghost)]
        #[automatically_derived]
        impl Domain {
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_EmptyDomain(&self) -> bool {
                ::builtin::is_variant(self, "EmptyDomain")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_Domain(&self) -> bool {
                ::builtin::is_variant(self, "Domain")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_Domain_start(self) -> Element {
                ::builtin::get_variant_field(self, "Domain", "start")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_Domain_end(self) -> Element {
                ::builtin::get_variant_field(self, "Domain", "end")
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn total_domain() -> Domain {
            Domain::Domain { start: Element::min_elem(), end: Element::Max }
        }
        #[verus::internal(verus_macro)]
        impl Domain {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                ::builtin::imply(self.is_Domain(),
                    {
                        (Element::lt(self.get_Domain_start(),
                                    self.get_Domain_end())) &&
                            (self.get_Domain_start().is_Elem())
                    })
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn contains(self, key: Key) -> bool {
                ((self.is_Domain()) &&
                            (Element::lte(self.get_Domain_start(), to_element(key)))) &&
                    (Element::lt(to_element(key), self.get_Domain_end()))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn key_set(self) -> Set<Key> {
                Set::new(::builtin::closure_to_fn_spec(|k| self.contains(k)))
            }
        }
    }
    pub mod PivotTable_v {
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use vstd::{*, map::*, seq::*, set::*};
        use crate::spec::KeyType_t::*;
        use crate::betree::Domain_v::*;
        #[verus::internal(verus_macro)]
        pub struct PivotTable {
            pub pivots: Seq<Element>,
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn domain_to_pivots(domain: Domain) -> PivotTable {
            PivotTable {
                pivots: ::vstd::seq::Seq::empty().push(domain.get_Domain_start()).push(domain.get_Domain_end()),
            }
        }
        #[verus::internal(verus_macro)]
        impl PivotTable {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn num_ranges(self) -> int {
                (self.pivots.len()).spec_sub(::builtin::spec_literal_nat("1"))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                (((self.num_ranges()).spec_gt(::builtin::spec_literal_nat("0")))
                            && (Element::is_strictly_sorted(self.pivots))) &&
                    ((::builtin::forall(|i: int|
                                    ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                    i), self.num_ranges())),
                                        (#[verus::internal(trigger)] self.pivots.spec_index(i).is_Elem())))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn len(self) -> nat { self.pivots.len() }
            #[verifier::inline]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn spec_index(self, i: int) -> Element {
                ::builtin::recommends([::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        i), self.len()))]);
                self.pivots.spec_index(i)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn update(self, i: int, element: Element) -> PivotTable {
                ::builtin::recommends([::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        i), self.len()))]);
                PivotTable { pivots: self.pivots.update(i, element) }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn subrange(self, start: int, end: int) -> PivotTable {
                ::builtin::recommends([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            start), end), self.len()))]);
                PivotTable { pivots: self.pivots.subrange(start, end) }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_insert(self, i: int, element: Element) -> bool {
                (((((self.wf()) && (element.is_Elem())) &&
                                            (::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                            i), self.len())))) &&
                                    ((::builtin::imply(::builtin::spec_eq(i,
                                                    ::builtin::spec_literal_nat("0")),
                                                Element::lt(element,
                                                    self.pivots.spec_index(::builtin::spec_literal_integer("0")))))))
                            &&
                            ((::builtin::imply(::builtin::spec_eq(i, self.len()),
                                        Element::lt(self.pivots.last(), element))))) &&
                    ((::builtin::imply((::builtin::spec_literal_nat("0")).spec_lt(i)
                                    && (i).spec_lt(self.len()),
                                Element::lt(self.pivots.spec_index((i).spec_sub(::builtin::spec_literal_nat("1"))),
                                        element) &&
                                    Element::lt(element, self.pivots.spec_index(i)))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn insert(self, i: int, element: Element) -> PivotTable {
                ::builtin::recommends([self.can_insert(i, element)]);
                PivotTable { pivots: self.pivots.insert(i, element) }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn insert_wf(self, idx: int, element: Element) {
                ::builtin::requires([self.wf(),
                            self.can_insert(idx, element)]);
                ::builtin::ensures([self.insert(idx, element).wf()]);
                let result = self.insert(idx, element).pivots;
                Element::lte_transitive_forall();
                {
                    ::builtin::assert_forall_by(|i: int, j: int|
                            {
                                ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                    i), j), result.len())));
                                ::builtin::ensures(Element::lt(result.spec_index(i),
                                        result.spec_index(j)));
                                if ::builtin::spec_eq(i, idx) &&
                                            (j).spec_gt((i).spec_add(::builtin::spec_literal_nat("1")))
                                        {
                                        ::builtin::assert_(Element::lt(result.spec_index((i).spec_add(::builtin::spec_literal_nat("1"))),
                                                result.spec_index(j)));
                                    } else if (i).spec_lt((idx).spec_sub(::builtin::spec_literal_nat("1")))
                                           && ::builtin::spec_eq(j, idx) {
                                       ::builtin::assert_(Element::lt(result.spec_index(i),
                                               result.spec_index((j).spec_sub(::builtin::spec_literal_nat("1")))));
                                   }
                            });
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn bounded_key(self, key: Key) -> bool {
                ::builtin::recommends([self.wf()]);
                (Element::lte(self.pivots.spec_index(::builtin::spec_literal_integer("0")),
                            to_element(key))) &&
                    (Element::lt(to_element(key), self.pivots.last()))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn route(self, key: Key) -> int {
                ::builtin::recommends([self.wf(), self.bounded_key(key)]);
                Element::largest_lte(self.pivots, to_element(key))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn route_lemma(self, key: Key) {
                ::builtin::requires([self.wf(), self.bounded_key(key)]);
                ::builtin::ensures([::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        self.route(key)), self.num_ranges())),
                            Element::lte(self.pivots.spec_index(self.route(key)),
                                to_element(key)),
                            Element::lt(to_element(key),
                                self.pivots.spec_index((self.route(key)).spec_add(::builtin::spec_literal_nat("1"))))]);
                Element::strictly_sorted_implies_sorted(self.pivots);
                Element::largest_lte_lemma(self.pivots, to_element(key),
                    self.route(key));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn route_lemma_auto() {
                ::builtin::ensures([::builtin::forall(|pt: PivotTable,
                                    key: Key|
                                    ::builtin::imply(pt.wf() && pt.bounded_key(key),
                                        {
                                            ((::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                        #[verus::internal(trigger)] pt.route(key)),
                                                                    pt.num_ranges()))) &&
                                                        (Element::lte(pt.pivots.spec_index(pt.route(key)),
                                                                to_element(key)))) &&
                                                (Element::lt(to_element(key),
                                                        pt.pivots.spec_index((pt.route(key)).spec_add(::builtin::spec_literal_nat("1")))))
                                        }))]);
                {
                    ::builtin::assert_forall_by(|pt: PivotTable, key: Key|
                            {
                                ::builtin::requires(pt.wf() && pt.bounded_key(key));
                                ::builtin::ensures({
                                        ((::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                    #[verus::internal(trigger)] pt.route(key)),
                                                                pt.num_ranges()))) &&
                                                    (Element::lte(pt.pivots.spec_index(pt.route(key)),
                                                            to_element(key)))) &&
                                            (Element::lt(to_element(key),
                                                    pt.pivots.spec_index((pt.route(key)).spec_add(::builtin::spec_literal_nat("1")))))
                                    });
                                pt.route_lemma(key);
                            });
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn route_is_lemma(self, key: Key, r: int) {
                ::builtin::requires([self.wf(),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        r), self.num_ranges())),
                            Element::lte(self.pivots.spec_index(r), to_element(key)),
                            Element::lt(to_element(key),
                                self.pivots.spec_index((r).spec_add(::builtin::spec_literal_nat("1"))))]);
                ::builtin::ensures([self.bounded_key(key),
                            ::builtin::spec_eq(self.route(key), r)]);
                Element::strictly_sorted_implies_sorted(self.pivots);
                Element::largest_lte_lemma(self.pivots, to_element(key),
                    self.route(key));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn route_is_lemma_auto() {
                ::builtin::ensures([::builtin::forall(|pt: PivotTable,
                                    key: Key, r: int|
                                    ::builtin::imply({
                                            ((pt.wf() &&
                                                                ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                            r), pt.num_ranges()))) &&
                                                        (Element::lte(pt.pivots.spec_index(r), to_element(key)))) &&
                                                (Element::lt(to_element(key),
                                                        pt.pivots.spec_index((r).spec_add(::builtin::spec_literal_nat("1")))))
                                        },
                                        {
                                            (pt.bounded_key(key)) &&
                                                (::builtin::spec_eq(pt.route(key), r))
                                        }))]);
                {
                    ::builtin::assert_forall_by(|pt: PivotTable, key: Key,
                            r: int|
                            {
                                ::builtin::requires({
                                        ((pt.wf() &&
                                                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                        r), pt.num_ranges()))) &&
                                                    (Element::lte(pt.pivots.spec_index(r), to_element(key)))) &&
                                            (Element::lt(to_element(key),
                                                    pt.pivots.spec_index((r).spec_add(::builtin::spec_literal_nat("1")))))
                                    });
                                ::builtin::ensures({
                                        (pt.bounded_key(key)) &&
                                            (::builtin::spec_eq(pt.route(key), r))
                                    });
                                pt.route_is_lemma(key, r);
                            });
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn pivot_range_keyset(self, i: int) -> Set<Key> {
                ::builtin::recommends([self.wf(),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        i), self.num_ranges()))]);
                Set::new(::builtin::closure_to_fn_spec(|k: Key|
                            self.bounded_key(k) &&
                                ::builtin::spec_eq(self.route(k), i)))
            }
        }
    }
    pub mod PivotBetree_v {
        use builtin::*;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        use vstd::prelude::*;
        use crate::spec::KeyType_t::*;
        use crate::spec::Messages_t::*;
        use crate::betree::Buffer_v::*;
        use crate::betree::Memtable_v::*;
        use crate::betree::Domain_v::*;
        use crate::betree::PivotTable_v::*;
        use crate::betree::SplitRequest_v::*;
        use crate::abstract_system::StampedMap_v::*;
        use crate::abstract_system::MsgHistory_v::*;
        pub type StampedBetree = Stamped<BetreeNode>;
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn empty_image() -> StampedBetree {
            Stamped {
                value: BetreeNode::Nil,
                seq_end: ::builtin::spec_literal_integer("0"),
            }
        }
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub enum BetreeNode {
            Nil,
            Node {
                buffer: Buffer,
                pivots: PivotTable,
                children: Seq<BetreeNode>,
            },
        }
        #[verus::internal(verus_macro)]
        #[cfg(verus_keep_ghost)]
        #[automatically_derived]
        impl BetreeNode {
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_Nil(&self) -> bool {
                ::builtin::is_variant(self, "Nil")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_Node(&self) -> bool {
                ::builtin::is_variant(self, "Node")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_Node_buffer(self) -> Buffer {
                ::builtin::get_variant_field(self, "Node", "buffer")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_Node_pivots(self) -> PivotTable {
                ::builtin::get_variant_field(self, "Node", "pivots")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_Node_children(self) -> Seq<BetreeNode> {
                ::builtin::get_variant_field(self, "Node", "children")
            }
        }
        #[verus::internal(verus_macro)]
        impl BetreeNode {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn local_structure(self) -> bool {
                ::builtin::imply(self.is_Node(),
                    {
                        (self.get_Node_pivots().wf()) &&
                            (::builtin::spec_eq(self.get_Node_children().len(),
                                    self.get_Node_pivots().num_ranges()))
                    })
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid_child_index(self, child_idx: nat) -> bool {
                (self.is_Node()) &&
                    ((child_idx).spec_lt(self.get_Node_children().len()))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn my_domain(self) -> Domain {
                ::builtin::recommends([self.local_structure(),
                            self.is_Node()]);
                let _ =
                    spec_affirm((::builtin::spec_literal_nat("0")).spec_lt(self.get_Node_pivots().num_ranges()));
                Domain::Domain {
                    start: self.get_Node_pivots().pivots.spec_index(::builtin::spec_literal_integer("0")),
                    end: self.get_Node_pivots().pivots.last(),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn child_domain(self, child_idx: nat) -> Domain {
                ::builtin::recommends([self.local_structure(), self.is_Node(),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        child_idx), self.get_Node_children().len()))]);
                Domain::Domain {
                    start: self.get_Node_pivots().pivots.spec_index(::builtin::spec_cast_integer::<_,
                                int>(child_idx)),
                    end: self.get_Node_pivots().pivots.spec_index((::builtin::spec_cast_integer::<_,
                                        int>(child_idx)).spec_add(::builtin::spec_literal_nat("1"))),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn linked_children(self) -> bool {
                ::builtin::recommends([self.local_structure(),
                            self.is_Node()]);
                ::builtin::forall(|i|
                        ::builtin::imply(((#[verus::internal(trigger)] self.valid_child_index(i))
                                        &&
                                        self.get_Node_children().spec_index(::builtin::spec_cast_integer::<_,
                                                        int>(i)).is_Node() &&
                                    self.get_Node_children().spec_index(::builtin::spec_cast_integer::<_,
                                                    int>(i)).local_structure()),
                            {
                                ::builtin::spec_eq(self.get_Node_children().spec_index(::builtin::spec_cast_integer::<_,
                                                    int>(i)).my_domain(), self.child_domain(i))
                            }))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf_children(self) -> bool {
                ::builtin::recommends([self.is_Node()]);
                ::builtin::decreases((self,
                        ::builtin::spec_literal_nat("0")));
                ::builtin::decreases_when(self.is_Node());
                (::builtin::forall(|i|
                            ::builtin::imply(#[verus::internal(trigger)] self.valid_child_index(i),
                                self.get_Node_children().spec_index(::builtin::spec_cast_integer::<_,
                                                int>(i)).wf())))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                ::builtin::decreases((self,
                        ::builtin::spec_literal_nat("1")));
                (self.local_structure()) &&
                    (::builtin::imply(self.is_Node(),
                            { (self.wf_children()) && (self.linked_children()) }))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn merge_buffer(self, new_buffer: Buffer) -> BetreeNode {
                ::builtin::recommends([self.is_Node()]);
                BetreeNode::Node {
                    buffer: self.get_Node_buffer().merge(new_buffer),
                    pivots: self.get_Node_pivots(),
                    children: self.get_Node_children(),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn push_memtable(self, memtable: Memtable) -> BetreeNode {
                ::builtin::recommends([self.wf()]);
                self.promote(total_domain()).merge_buffer(memtable.buffer)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_leaf(self) -> bool {
                ((self.is_Node()) &&
                            (::builtin::spec_eq(self.get_Node_children().len(),
                                    ::builtin::spec_literal_nat("1")))) &&
                    (self.get_Node_children().spec_index(::builtin::spec_literal_integer("0")).is_Nil())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_index(self) -> bool {
                (self.is_Node()) &&
                    (::builtin::forall(|i|
                                ::builtin::imply(#[verus::internal(trigger)] self.valid_child_index(i),
                                    self.get_Node_children().spec_index(::builtin::spec_cast_integer::<_,
                                                    int>(i)).is_Node())))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_split_leaf(self, split_key: Key) -> bool {
                (((self.wf()) && (self.is_leaf())) &&
                            (self.my_domain().contains(split_key))) &&
                    (!::builtin::spec_eq(self.my_domain().get_Domain_start(),
                                to_element(split_key)))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split_leaf(self, split_key: Key)
                -> (BetreeNode, BetreeNode) {
                ::builtin::recommends([self.can_split_leaf(split_key)]);
                let left_filter =
                    Domain::Domain {
                        start: self.my_domain().get_Domain_start(),
                        end: to_element(split_key),
                    };
                let right_filter =
                    Domain::Domain {
                        start: to_element(split_key),
                        end: self.my_domain().get_Domain_end(),
                    };
                let new_left =
                    BetreeNode::Node {
                        buffer: self.get_Node_buffer().apply_filter(left_filter.key_set()),
                        pivots: self.get_Node_pivots().update(::builtin::spec_literal_integer("1"),
                            to_element(split_key)),
                        children: self.get_Node_children(),
                    };
                let new_right =
                    BetreeNode::Node {
                        buffer: self.get_Node_buffer().apply_filter(right_filter.key_set()),
                        pivots: self.get_Node_pivots().update(::builtin::spec_literal_integer("0"),
                            to_element(split_key)),
                        children: self.get_Node_children(),
                    };
                (new_left, new_right)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_split_index(self, pivot_idx: nat) -> bool {
                ((self.wf()) && (self.is_index())) &&
                    (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_lt(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                    pivot_idx), self.get_Node_pivots().num_ranges())))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split_index(self, pivot_idx: nat)
                -> (BetreeNode, BetreeNode) {
                ::builtin::recommends([self.can_split_index(pivot_idx)]);
                let split_element =
                    self.get_Node_pivots().pivots.spec_index(::builtin::spec_cast_integer::<_,
                                int>(pivot_idx));
                let left_filter =
                    Domain::Domain {
                        start: self.my_domain().get_Domain_start(),
                        end: split_element,
                    };
                let right_filter =
                    Domain::Domain {
                        start: split_element,
                        end: self.my_domain().get_Domain_end(),
                    };
                let new_left =
                    BetreeNode::Node {
                        buffer: self.get_Node_buffer().apply_filter(left_filter.key_set()),
                        pivots: self.get_Node_pivots().subrange(::builtin::spec_literal_integer("0"),
                            (::builtin::spec_cast_integer::<_,
                                            int>(pivot_idx)).spec_add(::builtin::spec_literal_nat("1"))),
                        children: self.get_Node_children().subrange(::builtin::spec_literal_integer("0"),
                            ::builtin::spec_cast_integer::<_, int>(pivot_idx)),
                    };
                let new_right =
                    BetreeNode::Node {
                        buffer: self.get_Node_buffer().apply_filter(right_filter.key_set()),
                        pivots: self.get_Node_pivots().subrange(::builtin::spec_cast_integer::<_,
                                    int>(pivot_idx),
                            ::builtin::spec_cast_integer::<_,
                                    int>(self.get_Node_pivots().len())),
                        children: self.get_Node_children().subrange(::builtin::spec_cast_integer::<_,
                                    int>(pivot_idx),
                            ::builtin::spec_cast_integer::<_,
                                    int>(self.get_Node_children().len())),
                    };
                (new_left, new_right)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_split_parent(self, request: SplitRequest) -> bool {
                ((self.wf()) && (self.is_Node())) &&
                    (match request {
                            SplitRequest::SplitLeaf { child_idx, split_key } => {
                                (self.valid_child_index(child_idx)) &&
                                    (self.get_Node_children().spec_index(::builtin::spec_cast_integer::<_,
                                                        int>(child_idx)).can_split_leaf(split_key))
                            }
                            SplitRequest::SplitIndex { child_idx, child_pivot_idx } => {
                                (self.valid_child_index(child_idx)) &&
                                    (self.get_Node_children().spec_index(::builtin::spec_cast_integer::<_,
                                                        int>(child_idx)).can_split_index(child_pivot_idx))
                            }
                        })
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split_parent(self, request: SplitRequest) -> BetreeNode {
                ::builtin::recommends([self.can_split_parent(request)]);
                match request {
                    SplitRequest::SplitLeaf { child_idx, split_key } => {
                        let idx = ::builtin::spec_cast_integer::<_, int>(child_idx);
                        let old_child = self.get_Node_children().spec_index(idx);
                        let (new_left_child, new_right_child) =
                            old_child.split_leaf(split_key);
                        BetreeNode::Node {
                            buffer: self.get_Node_buffer(),
                            pivots: self.get_Node_pivots().insert((idx).spec_add(::builtin::spec_literal_nat("1")),
                                to_element(split_key)),
                            children: self.get_Node_children().update(idx,
                                    new_left_child).insert((idx).spec_add(::builtin::spec_literal_nat("1")),
                                new_right_child),
                        }
                    }
                    SplitRequest::SplitIndex { child_idx, child_pivot_idx } => {
                        let idx = ::builtin::spec_cast_integer::<_, int>(child_idx);
                        let old_child = self.get_Node_children().spec_index(idx);
                        let (new_left_child, new_right_child) =
                            old_child.split_index(child_pivot_idx);
                        let split_element =
                            old_child.get_Node_pivots().pivots.spec_index(::builtin::spec_cast_integer::<_,
                                        int>(child_pivot_idx));
                        BetreeNode::Node {
                            buffer: self.get_Node_buffer(),
                            pivots: self.get_Node_pivots().insert((idx).spec_add(::builtin::spec_literal_nat("1")),
                                split_element),
                            children: self.get_Node_children().update(idx,
                                    new_left_child).insert((idx).spec_add(::builtin::spec_literal_nat("1")),
                                new_right_child),
                        }
                    }
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn empty_root(domain: Domain) -> BetreeNode {
                ::builtin::recommends([domain.wf(), domain.is_Domain()]);
                BetreeNode::Node {
                    buffer: Buffer::empty(),
                    pivots: domain_to_pivots(domain),
                    children: ::vstd::seq::Seq::empty().push(BetreeNode::Nil),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn grow(self) -> BetreeNode {
                BetreeNode::Node {
                    buffer: Buffer::empty(),
                    pivots: domain_to_pivots(total_domain()),
                    children: ::vstd::seq::Seq::empty().push(self),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn promote(self, domain: Domain) -> BetreeNode {
                ::builtin::recommends([self.wf(), domain.wf(),
                            domain.is_Domain()]);
                if self.is_Nil() {
                        BetreeNode::empty_root(domain)
                    } else { self }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_flush(self, child_idx: nat) -> bool {
                ((self.wf()) && (self.is_Node())) &&
                    (self.valid_child_index(child_idx))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn flush(self, child_idx: nat) -> BetreeNode {
                ::builtin::recommends([self.can_flush(child_idx)]);
                let child_domain = self.child_domain(child_idx);
                let keep_keys = all_keys().difference(child_domain.key_set());
                let kept_buffer =
                    self.get_Node_buffer().apply_filter(keep_keys);
                let moved_buffer =
                    self.get_Node_buffer().apply_filter(child_domain.key_set());
                let old_child =
                    self.get_Node_children().spec_index(::builtin::spec_cast_integer::<_,
                                int>(child_idx));
                let new_child =
                    old_child.promote(child_domain).merge_buffer(moved_buffer);
                BetreeNode::Node {
                    buffer: kept_buffer,
                    pivots: self.get_Node_pivots(),
                    children: self.get_Node_children().update(::builtin::spec_cast_integer::<_,
                                int>(child_idx), new_child),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn key_in_domain(self, key: Key) -> bool {
                ((self.wf()) && (self.is_Node())) &&
                    (self.get_Node_pivots().bounded_key(key))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn child(self, key: Key) -> BetreeNode {
                ::builtin::recommends([self.wf(), self.is_Node(),
                            self.key_in_domain(key)]);
                self.get_Node_children().spec_index(self.get_Node_pivots().route(key))
            }
        }
        #[verus::internal(verus_macro)]
        pub struct QueryReceiptLine {
            pub node: BetreeNode,
            pub result: Message,
        }
        #[verus::internal(verus_macro)]
        impl QueryReceiptLine {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                (self.node.wf()) && (self.result.is_Define())
            }
        }
        #[verus::internal(verus_macro)]
        pub struct QueryReceipt {
            pub key: Key,
            pub root: BetreeNode,
            pub lines: Seq<QueryReceiptLine>,
        }
        #[verus::internal(verus_macro)]
        impl QueryReceipt {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn structure(self) -> bool {
                ((((::builtin::spec_literal_nat("0")).spec_lt(self.lines.len()))
                                    &&
                                    (::builtin::spec_eq(self.lines.spec_index(::builtin::spec_literal_integer("0")).node,
                                            self.root))) &&
                            ((::builtin::forall(|i|
                                            #[verus::internal(auto_trigger)] (::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                i), self.lines.len())),
                                                    {
                                                        ::builtin::spec_eq((self.lines.spec_index(i).node.is_Node()),
                                                            ((i).spec_lt((self.lines.len()).spec_sub(::builtin::spec_literal_nat("1")))))
                                                    })))))) &&
                    (::builtin::spec_eq(self.lines.last().result,
                            Message::Define { value: default_value() }))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn all_lines_wf(self) -> bool {
                ((::builtin::forall(|i|
                                    #[verus::internal(auto_trigger)] (::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                        i), self.lines.len())), self.lines.spec_index(i).wf())))))
                    &&
                    ((::builtin::forall(|i|
                                    #[verus::internal(auto_trigger)] (::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                        i),
                                                    (self.lines.len()).spec_sub(::builtin::spec_literal_nat("1")))),
                                            self.lines.spec_index(i).node.key_in_domain(self.key))))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn child_at(self, i: int) -> BetreeNode {
                ::builtin::recommends([self.all_lines_wf(), self.structure(),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        i),
                                    (self.lines.len()).spec_sub(::builtin::spec_literal_nat("1"))))]);
                self.lines.spec_index(i).node.child(self.key)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn child_linked_at(self, i: int) -> bool {
                ::builtin::recommends([self.all_lines_wf(), self.structure(),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        i),
                                    (self.lines.len()).spec_sub(::builtin::spec_literal_nat("1"))))]);
                ::builtin::spec_eq(self.lines.spec_index((i).spec_add(::builtin::spec_literal_nat("1"))).node,
                    self.child_at(i))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn result_at(self, i: int) -> Message {
                ::builtin::recommends([::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        i), self.lines.len()))]);
                self.lines.spec_index(i).result
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn result_linked_at(self, i: int) -> bool {
                ::builtin::recommends([self.all_lines_wf(), self.structure(),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        i),
                                    (self.lines.len()).spec_sub(::builtin::spec_literal_nat("1"))))]);
                let msg =
                    self.lines.spec_index(i).node.get_Node_buffer().query(self.key);
                ::builtin::spec_eq(self.lines.spec_index(i).result,
                    self.result_at((i).spec_add(::builtin::spec_literal_nat("1"))).merge(msg))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid(self) -> bool {
                (((self.structure()) && (self.all_lines_wf())) &&
                            ((::builtin::forall(|i|
                                            #[verus::internal(auto_trigger)] (::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                i),
                                                            (self.lines.len()).spec_sub(::builtin::spec_literal_nat("1")))),
                                                    self.child_linked_at(i))))))) &&
                    ((::builtin::forall(|i|
                                    #[verus::internal(auto_trigger)] (::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                        i),
                                                    (self.lines.len()).spec_sub(::builtin::spec_literal_nat("1")))),
                                            self.result_linked_at(i))))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn result(self) -> Message {
                ::builtin::recommends([self.structure()]);
                self.result_at(::builtin::spec_literal_integer("0"))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid_for(self, root: BetreeNode, key: Key) -> bool {
                ((self.valid()) && (::builtin::spec_eq(self.root, root))) &&
                    (::builtin::spec_eq(self.key, key))
            }
        }
        #[verus::internal(verus_macro)]
        pub struct Path {
            pub node: BetreeNode,
            pub key: Key,
            pub depth: nat,
        }
        #[verus::internal(verus_macro)]
        impl Path {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn subpath(self) -> Path {
                ::builtin::recommends([(::builtin::spec_literal_nat("0")).spec_lt(self.depth),
                            self.node.key_in_domain(self.key)]);
                let depth =
                    ::builtin::spec_cast_integer::<_,
                            nat>(((self.depth).spec_sub(::builtin::spec_literal_nat("1"))));
                Path {
                    node: self.node.child(self.key),
                    key: self.key,
                    depth: depth,
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid(self) -> bool {
                ::builtin::decreases((self.depth));
                (((self.node.wf()) && (self.node.key_in_domain(self.key))) &&
                            ((::builtin::imply((::builtin::spec_literal_nat("0")).spec_lt(self.depth),
                                        self.node.is_index())))) &&
                    ((::builtin::imply((::builtin::spec_literal_nat("0")).spec_lt(self.depth),
                                self.subpath().valid())))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn target(self) -> BetreeNode {
                ::builtin::recommends([self.valid()]);
                ::builtin::decreases((self.depth));
                if ::builtin::spec_eq(self.depth,
                            ::builtin::spec_literal_nat("0")) {
                        self.node
                    } else { self.subpath().target() }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn can_substitute(self, replacement: BetreeNode) -> bool {
                (((self.valid()) && (replacement.wf())) &&
                            (replacement.is_Node())) &&
                    (::builtin::spec_eq(replacement.my_domain(),
                            self.target().my_domain()))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn replaced_children(self, replacement: BetreeNode)
                -> Seq<BetreeNode> {
                ::builtin::recommends([self.can_substitute(replacement),
                            (::builtin::spec_literal_nat("0")).spec_lt(self.depth)]);
                ::builtin::decreases((self.subpath().depth));
                let new_child = self.subpath().substitute(replacement);
                let r = self.node.get_Node_pivots().route(self.key);
                self.node.get_Node_children().update(r, new_child)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn substitute(self, replacement: BetreeNode) -> BetreeNode {
                ::builtin::recommends([self.can_substitute(replacement)]);
                ::builtin::decreases((self.depth,
                        ::builtin::spec_literal_nat("1")));
                if ::builtin::spec_eq(self.depth,
                            ::builtin::spec_literal_nat("0")) {
                        replacement
                    } else {
                       BetreeNode::Node {
                           buffer: self.node.get_Node_buffer(),
                           pivots: self.node.get_Node_pivots(),
                           children: self.replaced_children(replacement),
                       }
                   }
            }
        }
        #[allow(unused_parens)]
        pub mod PivotBetree {
            use super::*;
            #[verus::internal(verus_macro)]
            pub struct State {
                pub memtable: Memtable,
                pub root: BetreeNode,
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Step {
                query(QueryReceipt),
                put(),
                freeze_as(),
                internal_flush_memtable(),
                internal_grow(),
                internal_split(Path, SplitRequest),
                internal_flush(Path, nat),
                internal_noop(),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Step {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_query(&self) -> bool {
                    ::builtin::is_variant(self, "query")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_query_0(self) -> QueryReceipt {
                    ::builtin::get_variant_field(self, "query", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_put(&self) -> bool {
                    ::builtin::is_variant(self, "put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_freeze_as(&self) -> bool {
                    ::builtin::is_variant(self, "freeze_as")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_internal_flush_memtable(&self) -> bool {
                    ::builtin::is_variant(self, "internal_flush_memtable")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_internal_grow(&self) -> bool {
                    ::builtin::is_variant(self, "internal_grow")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_internal_split(&self) -> bool {
                    ::builtin::is_variant(self, "internal_split")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_split_0(self) -> Path {
                    ::builtin::get_variant_field(self, "internal_split", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_split_1(self) -> SplitRequest {
                    ::builtin::get_variant_field(self, "internal_split", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_internal_flush(&self) -> bool {
                    ::builtin::is_variant(self, "internal_flush")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_flush_0(self) -> Path {
                    ::builtin::get_variant_field(self, "internal_flush", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_flush_1(self) -> nat {
                    ::builtin::get_variant_field(self, "internal_flush", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_internal_noop(&self) -> bool {
                    ::builtin::is_variant(self, "internal_noop")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Config {
                initialize(StampedBetree),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Config {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_initialize(&self) -> bool {
                    ::builtin::is_variant(self, "initialize")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_initialize_0(self) -> StampedBetree {
                    ::builtin::get_variant_field(self, "initialize", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[verus::internal(verus_macro)]
            pub enum Label {
                Query {
                    end_lsn: LSN,
                    key: Key,
                    value: Value,
                },
                Put {
                    puts: MsgHistory,
                },
                FreezeAs {
                    stamped_betree: StampedBetree,
                },
                Internal {},
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Label {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_Query(&self) -> bool {
                    ::builtin::is_variant(self, "Query")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_Query_end_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "Query", "end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_Query_key(self) -> Key {
                    ::builtin::get_variant_field(self, "Query", "key")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_Query_value(self) -> Value {
                    ::builtin::get_variant_field(self, "Query", "value")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_Put(&self) -> bool {
                    ::builtin::is_variant(self, "Put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_Put_puts(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "Put", "puts")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_FreezeAs(&self) -> bool {
                    ::builtin::is_variant(self, "FreezeAs")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_FreezeAs_stamped_betree(self) -> StampedBetree {
                    ::builtin::get_variant_field(self, "FreezeAs",
                        "stamped_betree")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_Internal(&self) -> bool {
                    ::builtin::is_variant(self, "Internal")
                }
            }
            pub mod show {
                use super::*;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn query(pre: super::State, post: super::State,
                    lbl: Label, receipt: QueryReceipt) {
                    ::builtin::requires(super::State::query(pre, post, lbl,
                            receipt));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as query;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn put(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::put(pre, post, lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as put;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn freeze_as(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::freeze_as(pre, post,
                            lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as freeze_as;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn internal_flush_memtable(pre: super::State,
                    post: super::State, lbl: Label) {
                    ::builtin::requires(super::State::internal_flush_memtable(pre,
                            post, lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as internal_flush_memtable;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn internal_grow(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::internal_grow(pre, post,
                            lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as internal_grow;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn internal_split(pre: super::State, post: super::State,
                    lbl: Label, path: Path, request: SplitRequest) {
                    ::builtin::requires(super::State::internal_split(pre, post,
                            lbl, path, request));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as internal_split;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn internal_flush(pre: super::State, post: super::State,
                    lbl: Label, path: Path, child_idx: nat) {
                    ::builtin::requires(super::State::internal_flush(pre, post,
                            lbl, path, child_idx));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as internal_flush;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn internal_noop(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::internal_noop(pre, post,
                            lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as internal_noop;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn initialize(post: super::State,
                    stamped_betree: StampedBetree) {
                    ::builtin::requires(super::State::initialize(post,
                            stamped_betree));
                    ::builtin::ensures(super::State::init(post));
                }
                use bool as initialize;
            }
            pub mod take_step {
                use super::*;
            }
            #[verus::internal(verus_macro)]
            impl State {
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query(pre: Self, post: Self, lbl: Label,
                    receipt: QueryReceipt) -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        let update_tmp_root: BetreeNode = pre.root;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Query { end_lsn, key, value } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let (end_lsn, key, value) =
                                                        match tmp_for_match_0 {
                                                            Label::Query { end_lsn, key, value } =>
                                                                (end_lsn, key, value),
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(end_lsn,
                                                                    pre.memtable.seq_end)) &&
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (receipt.valid_for(pre.root,
                                                                            key)) &&
                                                                    #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(Message::Define {
                                                                                value,
                                                                            }, receipt.result().merge(pre.memtable.query(key))))))
                                                })
                                    }) &&
                                ((#[verifier::custom_err("cannot prove that the field `root` is preserved")] (::builtin::equal(post.root,
                                                    update_tmp_root)) &&
                                            #[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                                    update_tmp_memtable)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_strong(pre: Self, post: Self, lbl: Label,
                    receipt: QueryReceipt) -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        let update_tmp_root: BetreeNode = pre.root;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Query { end_lsn, key, value } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let (end_lsn, key, value) =
                                                        match tmp_for_match_0 {
                                                            Label::Query { end_lsn, key, value } =>
                                                                (end_lsn, key, value),
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(end_lsn,
                                                                    pre.memtable.seq_end)) &&
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (receipt.valid_for(pre.root,
                                                                            key)) &&
                                                                    #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(Message::Define {
                                                                                value,
                                                                            }, receipt.result().merge(pre.memtable.query(key))))))
                                                })
                                    }) &&
                                ((#[verifier::custom_err("cannot prove that the field `root` is preserved")] (::builtin::equal(post.root,
                                                    update_tmp_root)) &&
                                            #[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                                    update_tmp_memtable)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_enabled(pre: Self, lbl: Label,
                    receipt: QueryReceipt) -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Query { end_lsn, key, value } => true,
                                        _ => false,
                                    }) &&
                                {
                                    let (end_lsn, key, value) =
                                        match tmp_for_match_0 {
                                            Label::Query { end_lsn, key, value } =>
                                                (end_lsn, key, value),
                                            _ => ::vstd::pervasive::arbitrary(),
                                        };
                                    (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(end_lsn,
                                                    pre.memtable.seq_end)) &&
                                            (#[verifier::custom_err("cannot prove this condition holds")] (receipt.valid_for(pre.root,
                                                            key)) &&
                                                    #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(Message::Define {
                                                                value,
                                                            }, receipt.result().merge(pre.memtable.query(key))))))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_root: BetreeNode = pre.root;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Put { puts } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let puts =
                                                        match tmp_for_match_0 {
                                                            Label::Put { puts } => puts,
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (puts.wf())
                                                            &&
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(puts.seq_start,
                                                                            pre.memtable.seq_end)) &&
                                                                    {
                                                                        let update_tmp_memtable: Memtable =
                                                                            pre.memtable.apply_puts(puts);

                                                                        #[verifier::custom_err("cannot prove that final value of field `memtable` has this updated value")]
                                                                        (::builtin::equal(post.memtable, update_tmp_memtable))
                                                                    }))
                                                })
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `root` is preserved")] (::builtin::equal(post.root,
                                            update_tmp_root))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put_strong(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_root: BetreeNode = pre.root;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Put { puts } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let puts =
                                                        match tmp_for_match_0 {
                                                            Label::Put { puts } => puts,
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (puts.wf())
                                                            &&
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(puts.seq_start,
                                                                            pre.memtable.seq_end)) &&
                                                                    {
                                                                        let update_tmp_memtable: Memtable =
                                                                            pre.memtable.apply_puts(puts);

                                                                        #[verifier::custom_err("cannot prove that final value of field `memtable` has this updated value")]
                                                                        (::builtin::equal(post.memtable, update_tmp_memtable))
                                                                    }))
                                                })
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `root` is preserved")] (::builtin::equal(post.root,
                                            update_tmp_root))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Put { puts } => true,
                                        _ => false,
                                    }) &&
                                {
                                    let puts =
                                        match tmp_for_match_0 {
                                            Label::Put { puts } => puts,
                                            _ => ::vstd::pervasive::arbitrary(),
                                        };
                                    (#[verifier::custom_err("cannot prove this condition holds")] (puts.wf())
                                            &&
                                            #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(puts.seq_start,
                                                    pre.memtable.seq_end)))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn freeze_as(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        let update_tmp_root: BetreeNode = pre.root;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::FreezeAs { stamped_betree } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let stamped_betree =
                                                        match tmp_for_match_0 {
                                                            Label::FreezeAs { stamped_betree } => stamped_betree,
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                                            &&
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (pre.memtable.is_empty())
                                                                    &&
                                                                    #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(stamped_betree,
                                                                            Stamped {
                                                                                value: pre.root,
                                                                                seq_end: pre.memtable.seq_end,
                                                                            }))))
                                                })
                                    }) &&
                                ((#[verifier::custom_err("cannot prove that the field `root` is preserved")] (::builtin::equal(post.root,
                                                    update_tmp_root)) &&
                                            #[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                                    update_tmp_memtable)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn freeze_as_strong(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        let update_tmp_root: BetreeNode = pre.root;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::FreezeAs { stamped_betree } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let stamped_betree =
                                                        match tmp_for_match_0 {
                                                            Label::FreezeAs { stamped_betree } => stamped_betree,
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                                            &&
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (pre.memtable.is_empty())
                                                                    &&
                                                                    #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(stamped_betree,
                                                                            Stamped {
                                                                                value: pre.root,
                                                                                seq_end: pre.memtable.seq_end,
                                                                            }))))
                                                })
                                    }) &&
                                ((#[verifier::custom_err("cannot prove that the field `root` is preserved")] (::builtin::equal(post.root,
                                                    update_tmp_root)) &&
                                            #[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                                    update_tmp_memtable)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn freeze_as_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::FreezeAs { stamped_betree } => true,
                                        _ => false,
                                    }) &&
                                {
                                    let stamped_betree =
                                        match tmp_for_match_0 {
                                            Label::FreezeAs { stamped_betree } => stamped_betree,
                                            _ => ::vstd::pervasive::arbitrary(),
                                        };
                                    (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                            &&
                                            (#[verifier::custom_err("cannot prove this condition holds")] (pre.memtable.is_empty())
                                                    &&
                                                    #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(stamped_betree,
                                                            Stamped {
                                                                value: pre.root,
                                                                seq_end: pre.memtable.seq_end,
                                                            }))))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_flush_memtable(pre: Self, post: Self,
                    lbl: Label) -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Internal {} => true,
                                        _ => false,
                                    }) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                        &&
                                        {
                                            let update_tmp_memtable: Memtable = pre.memtable.drain();
                                            let update_tmp_root: BetreeNode =
                                                pre.root.push_memtable(pre.memtable);
                                            (#[verifier::custom_err("cannot prove that final value of field `root` has this updated value")] (::builtin::equal(post.root,
                                                            update_tmp_root)) &&
                                                    #[verifier::custom_err("cannot prove that final value of field `memtable` has this updated value")] (::builtin::equal(post.memtable,
                                                            update_tmp_memtable)))
                                        }))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_flush_memtable_strong(pre: Self, post: Self,
                    lbl: Label) -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Internal {} => true,
                                        _ => false,
                                    }) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                        &&
                                        {
                                            let update_tmp_memtable: Memtable = pre.memtable.drain();
                                            let update_tmp_root: BetreeNode =
                                                pre.root.push_memtable(pre.memtable);
                                            (#[verifier::custom_err("cannot prove that final value of field `root` has this updated value")] (::builtin::equal(post.root,
                                                            update_tmp_root)) &&
                                                    #[verifier::custom_err("cannot prove that final value of field `memtable` has this updated value")] (::builtin::equal(post.memtable,
                                                            update_tmp_memtable)))
                                        }))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_flush_memtable_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Internal {} => true,
                                        _ => false,
                                    }) &&
                                #[verifier::custom_err("cannot prove this condition holds")] (pre.wf()))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_grow(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Internal {} => true,
                                                        _ => false,
                                                    }) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                                        &&
                                                        {
                                                            let update_tmp_root: BetreeNode = pre.root.grow();

                                                            #[verifier::custom_err("cannot prove that final value of field `root` has this updated value")]
                                                            (::builtin::equal(post.root, update_tmp_root))
                                                        }))
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                            update_tmp_memtable))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_grow_strong(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Internal {} => true,
                                                        _ => false,
                                                    }) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                                        &&
                                                        {
                                                            let update_tmp_root: BetreeNode = pre.root.grow();

                                                            #[verifier::custom_err("cannot prove that final value of field `root` has this updated value")]
                                                            (::builtin::equal(post.root, update_tmp_root))
                                                        }))
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                            update_tmp_memtable))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_grow_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Internal {} => true,
                                        _ => false,
                                    }) &&
                                #[verifier::custom_err("cannot prove this condition holds")] (pre.wf()))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_split(pre: Self, post: Self, lbl: Label,
                    path: Path, request: SplitRequest)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Internal {} => true,
                                                        _ => false,
                                                    }) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (path.valid())
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (path.target().can_split_parent(request))
                                                                &&
                                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.node,
                                                                                pre.root)) &&
                                                                        {
                                                                            let update_tmp_root: BetreeNode =
                                                                                path.substitute(path.target().split_parent(request));

                                                                            #[verifier::custom_err("cannot prove that final value of field `root` has this updated value")]
                                                                            (::builtin::equal(post.root, update_tmp_root))
                                                                        }))))
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                            update_tmp_memtable))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_split_strong(pre: Self, post: Self,
                    lbl: Label, path: Path, request: SplitRequest)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Internal {} => true,
                                                        _ => false,
                                                    }) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (path.valid())
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (path.target().can_split_parent(request))
                                                                &&
                                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.node,
                                                                                pre.root)) &&
                                                                        {
                                                                            let update_tmp_root: BetreeNode =
                                                                                path.substitute(path.target().split_parent(request));

                                                                            #[verifier::custom_err("cannot prove that final value of field `root` has this updated value")]
                                                                            (::builtin::equal(post.root, update_tmp_root))
                                                                        }))))
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                            update_tmp_memtable))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_split_enabled(pre: Self, lbl: Label,
                    path: Path, request: SplitRequest)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Internal {} => true,
                                        _ => false,
                                    }) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (path.valid())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (path.target().can_split_parent(request))
                                                &&
                                                #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.node,
                                                        pre.root)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_flush(pre: Self, post: Self, lbl: Label,
                    path: Path, child_idx: nat) -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Internal {} => true,
                                                        _ => false,
                                                    }) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (path.valid())
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (path.target().can_flush(child_idx))
                                                                &&
                                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.node,
                                                                                pre.root)) &&
                                                                        {
                                                                            let update_tmp_root: BetreeNode =
                                                                                path.substitute(path.target().flush(child_idx));

                                                                            #[verifier::custom_err("cannot prove that final value of field `root` has this updated value")]
                                                                            (::builtin::equal(post.root, update_tmp_root))
                                                                        }))))
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                            update_tmp_memtable))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_flush_strong(pre: Self, post: Self,
                    lbl: Label, path: Path, child_idx: nat)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Internal {} => true,
                                                        _ => false,
                                                    }) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (path.valid())
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (path.target().can_flush(child_idx))
                                                                &&
                                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.node,
                                                                                pre.root)) &&
                                                                        {
                                                                            let update_tmp_root: BetreeNode =
                                                                                path.substitute(path.target().flush(child_idx));

                                                                            #[verifier::custom_err("cannot prove that final value of field `root` has this updated value")]
                                                                            (::builtin::equal(post.root, update_tmp_root))
                                                                        }))))
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                            update_tmp_memtable))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_flush_enabled(pre: Self, lbl: Label,
                    path: Path, child_idx: nat) -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Internal {} => true,
                                        _ => false,
                                    }) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (path.valid())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (path.target().can_flush(child_idx))
                                                &&
                                                #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.node,
                                                        pre.root)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_noop(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        let update_tmp_root: BetreeNode = pre.root;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Internal {} => true,
                                                        _ => false,
                                                    }) &&
                                                #[verifier::custom_err("cannot prove this condition holds")] (pre.wf()))
                                    }) &&
                                ((#[verifier::custom_err("cannot prove that the field `root` is preserved")] (::builtin::equal(post.root,
                                                    update_tmp_root)) &&
                                            #[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                                    update_tmp_memtable)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_noop_strong(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        let update_tmp_root: BetreeNode = pre.root;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Internal {} => true,
                                                        _ => false,
                                                    }) &&
                                                #[verifier::custom_err("cannot prove this condition holds")] (pre.wf()))
                                    }) &&
                                ((#[verifier::custom_err("cannot prove that the field `root` is preserved")] (::builtin::equal(post.root,
                                                    update_tmp_root)) &&
                                            #[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                                    update_tmp_memtable)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_noop_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Internal {} => true,
                                        _ => false,
                                    }) &&
                                #[verifier::custom_err("cannot prove this condition holds")] (pre.wf()))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn initialize(post: Self, stamped_betree: StampedBetree)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (stamped_betree.value.wf())
                                &&
                                {
                                    let update_tmp_memtable: Memtable =
                                        Memtable::empty_memtable(stamped_betree.seq_end);
                                    let update_tmp_root: BetreeNode = stamped_betree.value;
                                    (#[verifier::custom_err("cannot prove that final value of field `root` has this updated value")] (::builtin::equal(post.root,
                                                    update_tmp_root)) &&
                                            #[verifier::custom_err("cannot prove that final value of field `memtable` has this updated value")] (::builtin::equal(post.memtable,
                                                    update_tmp_memtable)))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn initialize_enabled(stamped_betree: StampedBetree)
                    -> ::core::primitive::bool {
                    {

                        #[verifier::custom_err("cannot prove this condition holds")]
                        (stamped_betree.value.wf())
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_by(pre: State, post: State, label: Label,
                    step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::query(receipt) =>
                            Self::query(pre, post, label, receipt),
                        Step::put() => Self::put(pre, post, label),
                        Step::freeze_as() => Self::freeze_as(pre, post, label),
                        Step::internal_flush_memtable() =>
                            Self::internal_flush_memtable(pre, post, label),
                        Step::internal_grow() =>
                            Self::internal_grow(pre, post, label),
                        Step::internal_split(path, request) =>
                            Self::internal_split(pre, post, label, path, request),
                        Step::internal_flush(path, child_idx) =>
                            Self::internal_flush(pre, post, label, path, child_idx),
                        Step::internal_noop() =>
                            Self::internal_noop(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next(pre: State, post: State, label: Label)
                    -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                            Self::next_by(pre, post, label, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_strong_by(pre: State, post: State, label: Label,
                    step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::query(receipt) =>
                            Self::query_strong(pre, post, label, receipt),
                        Step::put() => Self::put_strong(pre, post, label),
                        Step::freeze_as() =>
                            Self::freeze_as_strong(pre, post, label),
                        Step::internal_flush_memtable() =>
                            Self::internal_flush_memtable_strong(pre, post, label),
                        Step::internal_grow() =>
                            Self::internal_grow_strong(pre, post, label),
                        Step::internal_split(path, request) =>
                            Self::internal_split_strong(pre, post, label, path,
                                request),
                        Step::internal_flush(path, child_idx) =>
                            Self::internal_flush_strong(pre, post, label, path,
                                child_idx),
                        Step::internal_noop() =>
                            Self::internal_noop_strong(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_strong(pre: State, post: State, label: Label)
                    -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                            Self::next_strong_by(pre, post, label, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn init_by(post: State, step: Config)
                    -> ::core::primitive::bool {
                    match step {
                        Config::initialize(stamped_betree) =>
                            Self::initialize(post, stamped_betree),
                        Config::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn init(post: State) -> ::core::primitive::bool {
                    ::builtin::exists(|step: Config| Self::init_by(post, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::spec]
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                pub fn invariant(&self) -> ::core::primitive::bool { true }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn wf(self) -> bool { self.root.wf() }
            }
        }
    }
    pub mod PivotBetreeRefinement_v {
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use crate::spec::KeyType_t::*;
        use crate::abstract_system::StampedMap_v::*;
        use crate::betree::Domain_v::*;
        use crate::betree::PivotTable_v::*;
        use crate::betree::Buffer_v::*;
        use crate::betree::PagedBetree_v;
        use crate::betree::PagedBetree_v::PagedBetree;
        use crate::betree::PivotBetree_v::*;
        use crate::betree::SplitRequest_v::*;
        #[verus::internal(verus_macro)]
        impl BetreeNode {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i_children_seq(self, start: int)
                -> Seq<PagedBetree_v::BetreeNode> {
                ::builtin::recommends([self.is_Node(),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        start), self.get_Node_children().len()))]);
                ::builtin::decreases((self, ::builtin::spec_literal_nat("0"),
                        (self.get_Node_children().len()).spec_sub(start)));
                ::builtin::decreases_when(self.is_Node() &&
                        ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                    start), self.get_Node_children().len())));
                if ::builtin::spec_eq(start, self.get_Node_children().len()) {
                        ::vstd::seq::Seq::empty()
                    } else {
                       let child = self.get_Node_children().spec_index(start).i();
                       (::vstd::seq::Seq::empty().push(child)).spec_add(self.i_children_seq((start).spec_add(::builtin::spec_literal_nat("1"))))
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i_children(self) -> PagedBetree_v::ChildMap {
                ::builtin::recommends([self.is_Node()]);
                ::builtin::decreases((self,
                        ::builtin::spec_literal_nat("1")));
                let seq_result =
                    self.i_children_seq(::builtin::spec_literal_integer("0"));
                PagedBetree_v::ChildMap {
                    map: Map::new(::builtin::closure_to_fn_spec(|k: Key| true),
                        ::builtin::closure_to_fn_spec(|k: Key|
                                if self.key_in_domain(k) {
                                        let r = self.get_Node_pivots().route(k);
                                        seq_result.spec_index(r)
                                    } else { PagedBetree_v::BetreeNode::Nil })),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> PagedBetree_v::BetreeNode {
                ::builtin::decreases((self));
                if self.is_Nil() {
                        PagedBetree_v::BetreeNode::Nil {}
                    } else {
                       PagedBetree_v::BetreeNode::Node {
                           buffer: self.get_Node_buffer(),
                           children: self.i_children(),
                       }
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i_child(self, k: Key) -> PagedBetree_v::BetreeNode {
                ::builtin::recommends([self.is_Node()]);
                if self.key_in_domain(k) {
                        self.child(k).i()
                    } else { PagedBetree_v::BetreeNode::Nil {} }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn i_children_seq_lemma(self, start: int) {
                ::builtin::requires([self.wf(), self.is_Node(),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        start), self.get_Node_children().len()))]);
                ::builtin::ensures([::builtin::spec_eq(self.i_children_seq(start).len(),
                                (self.get_Node_children().len()).spec_sub(start)),
                            ::builtin::forall(|i|
                                    ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                    i), self.i_children_seq(start).len())),
                                        {
                                            ((#[verus::internal(trigger)] self.i_children_seq(start).spec_index(i)).wf())
                                                &&
                                                (::builtin::spec_eq(self.i_children_seq(start).spec_index(i),
                                                        self.get_Node_children().spec_index((i).spec_add(start)).i()))
                                        }))]);
                ::builtin::decreases((self, ::builtin::spec_literal_nat("0"),
                        (self.get_Node_children().len()).spec_sub(start)));
                if (start).spec_lt(self.get_Node_children().len()) {
                        ::builtin::assert_(self.valid_child_index(::builtin::spec_cast_integer::<_,
                                        nat>(start)));
                        let result = self.i_children_seq(start);
                        let child = self.get_Node_children().spec_index(start);
                        let sub_seq =
                            self.i_children_seq((start).spec_add(::builtin::spec_literal_nat("1")));
                        child.i_wf();
                        self.i_children_seq_lemma((start).spec_add(::builtin::spec_literal_nat("1")));
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn i_children_seq_same(self, other: BetreeNode, start: int) {
                ::builtin::requires([self.wf(), self.is_Node(),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        start), self.get_Node_children().len())), other.wf(),
                            other.is_Node(),
                            ::builtin::spec_eq(other.get_Node_children(),
                                self.get_Node_children())]);
                ::builtin::ensures([::builtin::spec_eq(self.i_children_seq(start),
                                other.i_children_seq(start))]);
                ::builtin::decreases(((self.get_Node_children().len()).spec_sub(start)));
                if (start).spec_lt(self.get_Node_children().len()) {
                        self.i_children_seq_same(other,
                            (start).spec_add(::builtin::spec_literal_nat("1")));
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn i_children_lemma(self) {
                ::builtin::requires([self.is_Node(), self.wf()]);
                ::builtin::ensures([::builtin::forall(|k: Key|
                                    {
                                        (#[verus::internal(trigger)] self.i_children().map.spec_index(k)).wf()
                                            &&
                                            ::builtin::spec_eq(self.i_children().map.spec_index(k),
                                                self.i_child(k))
                                    })]);
                ::builtin::decreases((self,
                        ::builtin::spec_literal_nat("1")));
                let seq_result =
                    self.i_children_seq(::builtin::spec_literal_integer("0"));
                self.i_children_seq_lemma(::builtin::spec_literal_integer("0"));
                PivotTable::route_lemma_auto();
                {
                    ::builtin::assert_forall_by(|k: Key|
                            {
                                ::builtin::ensures({
                                        (#[verus::internal(trigger)] self.i_children().map.spec_index(k)).wf()
                                            &&
                                            ::builtin::spec_eq(self.i_children().map.spec_index(k),
                                                self.i_child(k))
                                    });
                                if self.key_in_domain(k) {
                                        let r = self.get_Node_pivots().route(k);
                                        ::builtin::assert_(::builtin::spec_eq(self.i_children().map.spec_index(k),
                                                seq_result.spec_index(r)));
                                        ::builtin::assert_(::builtin::spec_eq(self.i_children().map.spec_index(k),
                                                self.i_child(k)));
                                    }
                            });
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn i_wf(self) {
                ::builtin::requires([self.wf()]);
                ::builtin::ensures([self.i().wf()]);
                ::builtin::decreases((self,
                        ::builtin::spec_literal_nat("2")));
                if self.is_Node() { self.i_children_lemma(); }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn children_have_matching_domains(self,
                other_children: Seq<BetreeNode>) -> bool {
                ::builtin::recommends([self.wf(), self.is_index()]);
                (::builtin::spec_eq(other_children.len(),
                            self.get_Node_children().len())) &&
                    ((::builtin::forall(|i|
                                    ::builtin::imply(#[verus::internal(trigger)] self.valid_child_index(i),
                                        {
                                            ((other_children.spec_index(::builtin::spec_cast_integer::<_,
                                                                            int>(i)).wf()) &&
                                                        (other_children.spec_index(::builtin::spec_cast_integer::<_,
                                                                            int>(i)).is_Node())) &&
                                                (::builtin::spec_eq(other_children.spec_index(::builtin::spec_cast_integer::<_,
                                                                        int>(i)).my_domain(),
                                                        self.get_Node_children().spec_index(::builtin::spec_cast_integer::<_,
                                                                        int>(i)).my_domain()))
                                        }))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn empty_root_refines() {
                ::builtin::ensures([::builtin::spec_eq(Self::empty_root(total_domain()).i(),
                                PagedBetree_v::BetreeNode::empty_root())]);
                let empty = Self::empty_root(total_domain());
                let empty_child_map = PagedBetree_v::empty_child_map();
                ::builtin::assert_(empty.wf_children());
                empty.i_children_lemma();
                PivotTable::route_lemma_auto();
                ::builtin::assert_(::builtin::ext_equal(empty.i().get_Node_children().map,
                        empty_child_map.map));
                ::builtin::assert_(::builtin::spec_eq(empty.i(),
                        PagedBetree_v::BetreeNode::empty_root()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split_element(self, request: SplitRequest) -> Element {
                ::builtin::recommends([self.wf(),
                            self.can_split_parent(request)]);
                let old_child =
                    self.get_Node_children().spec_index(::builtin::spec_cast_integer::<_,
                                int>(request.get_child_idx()));
                match request {
                    SplitRequest::SplitLeaf { child_idx, split_key } =>
                        to_element(split_key),
                    SplitRequest::SplitIndex { child_idx, child_pivot_idx } =>
                        old_child.get_Node_pivots().pivots.spec_index(::builtin::spec_cast_integer::<_,
                                    int>(child_pivot_idx)),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn split_leaf_wf(self, split_key: Key) {
                ::builtin::requires([self.can_split_leaf(split_key)]);
                ::builtin::ensures([self.split_leaf(split_key).0.wf(),
                            self.split_leaf(split_key).1.wf()]);
                ::builtin::assert_(self.split_leaf(split_key).0.wf_children());
                ::builtin::assert_(self.split_leaf(split_key).1.wf_children());
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn split_index_wf(self, pivot_idx: nat) {
                ::builtin::requires([self.can_split_index(pivot_idx)]);
                ::builtin::ensures([self.split_index(pivot_idx).0.wf(),
                            self.split_index(pivot_idx).1.wf()]);
                let (new_left, new_right) = self.split_index(pivot_idx);
                {
                    ::builtin::assert_forall_by(|i|
                            {
                                ::builtin::ensures(::builtin::imply(new_left.valid_child_index(i),
                                        self.valid_child_index(i)));
                            });
                }
                {
                    ::builtin::assert_forall_by(|i|
                            {
                                ::builtin::ensures(::builtin::imply(new_right.valid_child_index(i),
                                        self.valid_child_index((i).spec_add(pivot_idx))));
                            });
                }
                ::builtin::assert_(new_left.wf_children());
                ::builtin::assert_(new_right.wf_children());
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn split_parent_wf(self, request: SplitRequest) {
                ::builtin::requires([self.can_split_parent(request)]);
                ::builtin::ensures([self.split_parent(request).wf()]);
                let child_idx = request.get_child_idx();
                let old_child =
                    self.get_Node_children().spec_index(::builtin::spec_cast_integer::<_,
                                int>(child_idx));
                let new_parent = self.split_parent(request);
                self.get_Node_pivots().insert_wf((::builtin::spec_cast_integer::<_,
                                    int>(child_idx)).spec_add(::builtin::spec_literal_nat("1")),
                    self.split_element(request));
                {
                    ::builtin::assert_forall_by(|i|
                            {
                                ::builtin::ensures(::builtin::imply(#[verus::internal(trigger)] new_parent.valid_child_index(i),
                                        ({
                                                (::builtin::imply((i).spec_lt(child_idx),
                                                            self.valid_child_index(i))) &&
                                                    (::builtin::imply((i).spec_gt((child_idx).spec_add(::builtin::spec_literal_nat("1"))),
                                                            self.valid_child_index(::builtin::spec_cast_integer::<_,
                                                                        nat>(((i).spec_sub(::builtin::spec_literal_nat("1")))))))
                                            })));
                            });
                }
                match request {
                    SplitRequest::SplitLeaf { child_idx, split_key } =>
                        old_child.split_leaf_wf(split_key),
                    SplitRequest::SplitIndex { child_idx, child_pivot_idx } =>
                        old_child.split_index_wf(child_pivot_idx),
                }
                ::builtin::assert_(new_parent.wf_children());
                ::builtin::assert_(new_parent.linked_children());
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split_keys(self, request: SplitRequest)
                -> (Set<Key>, Set<Key>) {
                ::builtin::recommends([self.can_split_parent(request)]);
                let child_idx = request.get_child_idx();
                let child_domain = self.child_domain(child_idx);
                let split_element = self.split_element(request);
                let left_keys =
                    Set::new(::builtin::closure_to_fn_spec(|k|
                                child_domain.contains(k) &&
                                    Element::lt(to_element(k), split_element)));
                let right_keys =
                    Set::new(::builtin::closure_to_fn_spec(|k|
                                child_domain.contains(k) && !left_keys.contains(k)));
                (left_keys, right_keys)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn split_keys_agrees_with_domains(self,
                request: SplitRequest) {
                ::builtin::requires([self.can_split_parent(request)]);
                ::builtin::ensures([({
                                    let child_domain =
                                        self.child_domain(request.get_child_idx());
                                    let split_element = self.split_element(request);
                                    let left_domain =
                                        Domain::Domain {
                                            start: child_domain.get_Domain_start(),
                                            end: split_element,
                                        };
                                    let right_domain =
                                        Domain::Domain {
                                            start: split_element,
                                            end: child_domain.get_Domain_end(),
                                        };
                                    (::builtin::spec_eq(left_domain.key_set(),
                                                self.split_keys(request).0)) &&
                                        (::builtin::spec_eq(right_domain.key_set(),
                                                self.split_keys(request).1))
                                })]);
                let child_domain = self.child_domain(request.get_child_idx());
                let split_element = self.split_element(request);
                let left_domain =
                    Domain::Domain {
                        start: child_domain.get_Domain_start(),
                        end: split_element,
                    };
                let right_domain =
                    Domain::Domain {
                        start: split_element,
                        end: child_domain.get_Domain_end(),
                    };
                let (left_keys, right_keys) = self.split_keys(request);
                ::builtin::assert_(Element::lt(split_element,
                        child_domain.get_Domain_end()));
                {
                    ::builtin::assert_forall_by(|k: Key|
                            {
                                ::builtin::ensures(::builtin::spec_eq((#[verus::internal(trigger)] left_keys.contains(k)),
                                        (left_domain.contains(k))));
                                if left_domain.contains(k) {
                                        ::builtin::assert_(::builtin::spec_eq(left_domain.get_Domain_start(),
                                                child_domain.get_Domain_start()));
                                        ::builtin::assert_(child_domain.contains(k));
                                        ::builtin::assert_(left_keys.contains(k));
                                    }
                            });
                }
                ::builtin::assert_(::builtin::ext_equal(left_keys,
                        left_domain.key_set()));
                if request.is_SplitIndex() {
                        ::builtin::assert_(Element::lt(child_domain.get_Domain_start(),
                                split_element));
                    }
                ::builtin::assert_(Element::lte(child_domain.get_Domain_start(),
                        split_element));
                {
                    ::builtin::assert_forall_by(|k: Key|
                            {
                                ::builtin::ensures(::builtin::spec_eq((#[verus::internal(trigger)] right_keys.contains(k)),
                                        (right_domain.contains(k))));
                                if right_domain.contains(k) {
                                        ::builtin::assert_(!left_keys.contains(k));
                                        ::builtin::assert_(child_domain.contains(k));
                                        ::builtin::assert_(right_keys.contains(k));
                                    }
                            });
                }
                ::builtin::assert_(::builtin::ext_equal(right_keys,
                        right_domain.key_set()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn split_commutes_with_i_left(self, request: SplitRequest,
                key: Key) {
                ::builtin::requires([self.can_split_parent(request),
                            self.my_domain().contains(key),
                            self.split_keys(request).0.contains(key)]);
                ::builtin::ensures([::builtin::spec_eq(self.split_parent(request).i_children().map.spec_index(key),
                                self.i().split(self.split_keys(request).0,
                                        self.split_keys(request).1).child(key))]);
                self.split_parent_wf(request);
                let (left_keys, _) = self.split_keys(request);
                let split_element = self.split_element(request);
                self.split_keys_agrees_with_domains(request);
                self.i_children_lemma();
                self.split_parent(request).i_children_lemma();
                PivotTable::route_lemma_auto();
                self.split_parent(request).get_Node_pivots().route_is_lemma(key,
                    ::builtin::spec_cast_integer::<_,
                            int>(request.get_child_idx()));
                let a =
                    self.child(key).i().filter_buffer_and_children(left_keys);
                if request.is_SplitLeaf() {
                        let split_key = to_key(split_element);
                        let b = self.child(key).split_leaf(split_key).0;
                        PivotTable::route_is_lemma_auto();
                        self.child(key).split_leaf_wf(split_key);
                        {
                            ::builtin::assert_forall_by(|k|
                                    {
                                        ::builtin::ensures(::builtin::spec_eq(#[verus::internal(trigger)] a.get_Node_children().map.spec_index(k),
                                                b.i().get_Node_children().map.spec_index(k)));
                                    });
                        }
                        ::builtin::assert_(::builtin::ext_equal(a.get_Node_children().map,
                                b.i().get_Node_children().map));
                    } else {
                       let child_pivot_idx =
                           request.get_SplitIndex_child_pivot_idx();
                       let b = self.child(key).split_index(child_pivot_idx).0;
                       PivotTable::route_is_lemma_auto();
                       self.child(key).split_index_wf(child_pivot_idx);
                       b.i_children_lemma();
                       self.child(key).i_children_lemma();
                       ::builtin::assert_(::builtin::ext_equal(a.get_Node_children().map,
                               b.i().get_Node_children().map));
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn split_commutes_with_i_right(self, request: SplitRequest,
                key: Key) {
                ::builtin::requires([self.can_split_parent(request),
                            self.my_domain().contains(key),
                            self.split_keys(request).1.contains(key)]);
                ::builtin::ensures([::builtin::spec_eq(self.split_parent(request).i_children().map.spec_index(key),
                                self.i().split(self.split_keys(request).0,
                                        self.split_keys(request).1).child(key))]);
                self.split_parent_wf(request);
                let (_, right_keys) = self.split_keys(request);
                let split_element = self.split_element(request);
                self.split_keys_agrees_with_domains(request);
                self.i_children_lemma();
                self.split_parent(request).i_children_lemma();
                PivotTable::route_lemma_auto();
                self.split_parent(request).get_Node_pivots().route_is_lemma(key,
                    (::builtin::spec_cast_integer::<_,
                                    int>(request.get_child_idx())).spec_add(::builtin::spec_literal_nat("1")));
                let a =
                    self.child(key).i().filter_buffer_and_children(right_keys);
                if request.is_SplitLeaf() {
                        let split_key = to_key(split_element);
                        let b = self.child(key).split_leaf(split_key).1;
                        PivotTable::route_is_lemma_auto();
                        self.child(key).split_leaf_wf(split_key);
                        {
                            ::builtin::assert_forall_by(|k|
                                    {
                                        ::builtin::ensures(::builtin::spec_eq(#[verus::internal(trigger)] a.get_Node_children().map.spec_index(k),
                                                b.i().get_Node_children().map.spec_index(k)));
                                    });
                        }
                        ::builtin::assert_(::builtin::ext_equal(a.get_Node_children().map,
                                b.i().get_Node_children().map));
                    } else {
                       let child_pivot_idx =
                           request.get_SplitIndex_child_pivot_idx();
                       let b = self.child(key).split_index(child_pivot_idx).1;
                       PivotTable::route_is_lemma_auto();
                       self.child(key).split_index_wf(child_pivot_idx);
                       b.i_children_lemma();
                       self.child(key).i_children_lemma();
                       {
                           ::builtin::assert_forall_by(|k|
                                   {
                                       ::builtin::ensures(::builtin::spec_eq(#[verus::internal(trigger)] a.get_Node_children().map.spec_index(k),
                                               b.i().get_Node_children().map.spec_index(k)));
                                       if right_keys.contains(k) {
                                               let r = b.get_Node_pivots().route(k);
                                               self.child(key).get_Node_pivots().route_is_lemma(k,
                                                   (r).spec_add(child_pivot_idx));
                                           }
                                   });
                       }
                       ::builtin::assert_(::builtin::ext_equal(a.get_Node_children().map,
                               b.i().get_Node_children().map));
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn split_commutes_with_i_nonsplit(self, request: SplitRequest,
                key: Key) {
                ::builtin::requires([self.can_split_parent(request),
                            self.my_domain().contains(key),
                            !self.split_keys(request).0.contains(key),
                            !self.split_keys(request).1.contains(key)]);
                ::builtin::ensures([({
                                    let (left_keys, right_keys) = self.split_keys(request);
                                    ::builtin::spec_eq(self.split_parent(request).i_children().map.spec_index(key),
                                        self.i().split(left_keys, right_keys).child(key))
                                })]);
                self.split_parent_wf(request);
                let child_idx = request.get_child_idx();
                let r = self.get_Node_pivots().route(key);
                PivotTable::route_lemma_auto();
                if (r).spec_lt(child_idx) {
                        self.split_parent(request).get_Node_pivots().route_is_lemma(key,
                            r);
                    } else {
                       self.split_parent(request).get_Node_pivots().route_is_lemma(key,
                           (r).spec_add(::builtin::spec_literal_nat("1")));
                   }
                self.i_children_lemma();
                self.split_parent(request).i_children_lemma();
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn split_commutes_with_i(self, request: SplitRequest) {
                ::builtin::requires([self.can_split_parent(request)]);
                ::builtin::ensures([({
                                    let (left_keys, right_keys) = self.split_keys(request);
                                    ::builtin::spec_eq(self.split_parent(request).i(),
                                        self.i().split(left_keys, right_keys))
                                })]);
                self.split_parent_wf(request);
                let (left_keys, right_keys) = self.split_keys(request);
                {
                    ::builtin::assert_forall_by(|k: Key|
                            {
                                ::builtin::requires(self.my_domain().contains(k));
                                ::builtin::ensures(::builtin::spec_eq((#[verus::internal(trigger)] self.i().split(left_keys,
                                                            right_keys).get_Node_children().map.spec_index(k)),
                                        self.split_parent(request).i_children().map.spec_index(k)));
                                if left_keys.contains(k) {
                                        self.split_commutes_with_i_left(request, k);
                                    } else if right_keys.contains(k) {
                                       self.split_commutes_with_i_right(request, k);
                                   } else { self.split_commutes_with_i_nonsplit(request, k); }
                            });
                }
                ::builtin::assert_(::builtin::ext_equal(self.i().split(left_keys,
                                    right_keys).get_Node_children().map,
                        self.split_parent(request).i_children().map));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn promote_and_merge_wf(self, domain: Domain,
                buffer: Buffer) {
                ::builtin::requires([self.wf(), domain.wf(),
                            domain.is_Domain()]);
                ::builtin::ensures([self.promote(domain).merge_buffer(buffer).wf()]);
                let result = self.promote(domain).merge_buffer(buffer);
                ::builtin::assert_(self.promote(domain).wf());
                {
                    ::builtin::assert_forall_by(|i|
                            {
                                ::builtin::ensures(::builtin::imply(#[verus::internal(trigger)] result.valid_child_index(i),
                                        self.promote(domain).valid_child_index(i)));
                            });
                }
                ::builtin::assert_(result.wf());
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn flush_wf(self, child_idx: nat) {
                ::builtin::requires([self.can_flush(child_idx)]);
                ::builtin::ensures([self.flush(child_idx).wf()]);
                let result = self.flush(child_idx);
                let child_domain = self.child_domain(child_idx);
                let moved_buffer =
                    self.get_Node_buffer().apply_filter(child_domain.key_set());
                let old_child =
                    self.get_Node_children().spec_index(::builtin::spec_cast_integer::<_,
                                int>(child_idx));
                let new_child =
                    old_child.promote(child_domain).merge_buffer(moved_buffer);
                old_child.promote_and_merge_wf(child_domain, moved_buffer);
                {
                    ::builtin::assert_forall_by(|i|
                            {
                                ::builtin::ensures(::builtin::imply(#[verus::internal(trigger)] result.valid_child_index(i),
                                        self.valid_child_index(i)));
                            });
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn promote_and_merge_commutes_with_i(self, domain: Domain,
                new_buffer: Buffer) {
                ::builtin::requires([self.wf(), domain.wf(),
                            domain.is_Domain()]);
                ::builtin::ensures([::builtin::spec_eq(self.promote(domain).merge_buffer(new_buffer).i(),
                                self.i().promote().merge_buffer(new_buffer))]);
                self.i_wf();
                let a = self.promote(domain).merge_buffer(new_buffer);
                let b = self.i().promote().merge_buffer(new_buffer);
                if self.is_Node() {
                        {
                            ::builtin::assert_forall_by(|i|
                                    {
                                        ::builtin::ensures(::builtin::imply(#[verus::internal(trigger)] a.valid_child_index(i),
                                                self.promote(domain).valid_child_index(i)));
                                    });
                        }
                        self.i_children_seq_same(a,
                            ::builtin::spec_literal_integer("0"));
                    } else {
                       a.i_children_lemma();
                       PivotTable::route_lemma_auto();
                   }
                ::builtin::assert_(::builtin::ext_equal(a.i().get_Node_children().map,
                        b.get_Node_children().map));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn flush_commutes_with_i(self, child_idx: nat) {
                ::builtin::requires([self.can_flush(child_idx)]);
                ::builtin::ensures([::builtin::spec_eq(self.i().flush(self.child_domain(child_idx).key_set()),
                                self.flush(child_idx).i())]);
                self.flush_wf(child_idx);
                let child =
                    self.get_Node_children().spec_index(::builtin::spec_cast_integer::<_,
                                int>(child_idx));
                let child_domain = self.child_domain(child_idx);
                let moved_buffer =
                    self.get_Node_buffer().apply_filter(child_domain.key_set());
                child.promote_and_merge_commutes_with_i(child_domain,
                    moved_buffer);
                PivotTable::route_lemma_auto();
                PivotTable::route_is_lemma_auto();
                self.i_children_lemma();
                self.flush(child_idx).i_children_lemma();
                ::builtin::assert_(::builtin::ext_equal(self.flush(child_idx).i().get_Node_children().map,
                        self.i().flush(child_domain.key_set()).get_Node_children().map));
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn i_stamped_betree(stamped: StampedBetree)
            -> PagedBetree_v::StampedBetree {
            Stamped { value: stamped.value.i(), seq_end: stamped.seq_end }
        }
        #[verus::internal(verus_macro)]
        impl QueryReceiptLine {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> PagedBetree_v::QueryReceiptLine {
                ::builtin::recommends([self.wf()]);
                PagedBetree_v::QueryReceiptLine {
                    node: self.node.i(),
                    result: self.result,
                }
            }
        }
        #[verus::internal(verus_macro)]
        impl QueryReceipt {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> PagedBetree_v::QueryReceipt {
                ::builtin::recommends([self.valid()]);
                PagedBetree_v::QueryReceipt {
                    key: self.key,
                    root: self.root.i(),
                    lines: Seq::new(self.lines.len(),
                        ::builtin::closure_to_fn_spec(|i: int|
                                self.lines.spec_index(i).i())),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn i_valid(self) {
                ::builtin::requires([self.valid()]);
                ::builtin::ensures([self.i().valid()]);
                let i_receipt = self.i();
                {
                    ::builtin::assert_forall_by(|i: int|
                            {
                                ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                i), i_receipt.lines.len())));
                                ::builtin::ensures(#[verus::internal(trigger)] i_receipt.lines.spec_index(i).wf());
                                self.lines.spec_index(i).node.i_wf();
                            });
                }
                {
                    ::builtin::assert_forall_by(|i: int|
                            {
                                ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                i),
                                            (i_receipt.lines.len()).spec_sub(::builtin::spec_literal_nat("1")))));
                                ::builtin::ensures(#[verus::internal(trigger)] i_receipt.child_linked_at(i));
                                ::builtin::assert_(self.child_linked_at(i));
                                self.lines.spec_index(i).node.i_children_lemma();
                            });
                }
                {
                    ::builtin::assert_forall_by(|i: int|
                            {
                                ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                i),
                                            (i_receipt.lines.len()).spec_sub(::builtin::spec_literal_nat("1")))));
                                ::builtin::ensures(#[verus::internal(trigger)] i_receipt.result_linked_at(i));
                                ::builtin::assert_(self.result_linked_at(i));
                            });
                }
            }
        }
        #[verus::internal(verus_macro)]
        impl Path {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn routing(self) -> Seq<Set<Key>> {
                ::builtin::recommends([self.valid()]);
                ::builtin::decreases((self.depth));
                if ::builtin::spec_eq(self.depth,
                            ::builtin::spec_literal_nat("0")) {
                        ::vstd::seq::Seq::empty()
                    } else {
                       let pivots = self.node.get_Node_pivots();
                       let keys =
                           pivots.pivot_range_keyset(pivots.route(self.key));
                       (::vstd::seq::Seq::empty().push(keys)).spec_add(self.subpath().routing())
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn routing_lemma(self) {
                ::builtin::requires([self.valid()]);
                ::builtin::ensures([::builtin::spec_eq(self.routing().len(),
                                self.depth)]);
                ::builtin::decreases((self.depth));
                if (::builtin::spec_literal_nat("0")).spec_lt(self.depth) {
                        self.subpath().routing_lemma();
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn i(self) -> PagedBetree_v::Path {
                PagedBetree_v::Path {
                    node: self.node.i(),
                    key: self.key,
                    routing: self.routing(),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn subpath_commutes_with_i(self) {
                ::builtin::requires([self.valid(),
                            (::builtin::spec_literal_nat("0")).spec_lt(self.depth)]);
                ::builtin::ensures([::builtin::spec_eq(self.subpath().i(),
                                self.i().subpath())]);
                self.node.i_wf();
                self.node.i_children_lemma();
                self.routing_lemma();
                ::builtin::assert_(::builtin::ext_equal(self.subpath().i().routing,
                        self.i().subpath().routing));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn i_valid(self) {
                ::builtin::requires([self.valid()]);
                ::builtin::ensures([self.i().valid()]);
                ::builtin::decreases((self.depth));
                self.node.i_children_lemma();
                if (::builtin::spec_literal_nat("0")).spec_lt(self.depth) {
                        self.subpath_commutes_with_i();
                        self.subpath().i_valid();
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn target_wf(self) {
                ::builtin::requires([self.valid()]);
                ::builtin::ensures([self.target().wf(),
                            self.target().is_Node()]);
                ::builtin::decreases((self.depth));
                if (self.depth).spec_gt(::builtin::spec_literal_nat("0")) {
                        self.subpath().target_wf();
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn target_commutes_with_i(self) {
                ::builtin::requires([self.valid()]);
                ::builtin::ensures([self.i().valid(),
                            ::builtin::spec_eq(self.i().target(), self.target().i())]);
                ::builtin::decreases((self.depth));
                self.i_valid();
                if (::builtin::spec_literal_nat("0")).spec_lt(self.depth) {
                        self.subpath().target_commutes_with_i();
                        self.subpath_commutes_with_i();
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn substitute_preserves_wf(self, replacement: BetreeNode) {
                ::builtin::requires([self.can_substitute(replacement)]);
                ::builtin::ensures([self.substitute(replacement).wf()]);
                ::builtin::decreases((self.depth,
                        ::builtin::spec_literal_nat("1")));
                if (::builtin::spec_literal_nat("0")).spec_lt(self.depth) {
                        self.subpath().substitute_preserves_wf(replacement);
                        let result = self.substitute(replacement);
                        if result.is_Node() {
                                self.replaced_children_matching_domains(replacement);
                                ::builtin::assert_(self.node.wf_children());
                                {
                                    ::builtin::assert_forall_by(|i|
                                            {
                                                ::builtin::ensures(::builtin::imply(#[verus::internal(trigger)] result.valid_child_index(i),
                                                        self.node.valid_child_index(i)));
                                            });
                                }
                                ::builtin::assert_(result.wf_children());
                            }
                    }
            }
            #[verifier::spinoff_prover]
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn replaced_children_matching_domains(self,
                replacement: BetreeNode) {
                ::builtin::requires([self.can_substitute(replacement),
                            (::builtin::spec_literal_nat("0")).spec_lt(self.depth)]);
                ::builtin::ensures([self.node.children_have_matching_domains(self.replaced_children(replacement))]);
                ::builtin::decreases((self.depth,
                        ::builtin::spec_literal_nat("0")));
                PivotTable::route_lemma_auto();
                self.subpath().substitute_preserves_wf(replacement);
                let old_children = self.node.get_Node_children();
                let new_children = self.replaced_children(replacement);
                if (::builtin::spec_literal_nat("0")).spec_lt(self.subpath().depth)
                        {
                        self.subpath().replaced_children_matching_domains(replacement);
                    } else {
                       {
                           ::builtin::assert_forall_by(|i|
                                   {
                                       ::builtin::ensures(::builtin::imply(#[verus::internal(trigger)] self.node.valid_child_index(i),
                                               new_children.spec_index(::builtin::spec_cast_integer::<_,
                                                               int>(i)).wf()));
                                   });
                       }
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn substitute_commutes_with_i(self, replacement: BetreeNode) {
                ::builtin::requires([self.can_substitute(replacement)]);
                ::builtin::ensures([self.substitute(replacement).wf(),
                            self.i().valid(), replacement.i().wf(),
                            ::builtin::spec_eq(self.substitute(replacement).i(),
                                self.i().substitute(replacement.i()))]);
                ::builtin::decreases((self.depth));
                self.i_valid();
                self.substitute_preserves_wf(replacement);
                replacement.i_wf();
                PivotTable::route_lemma_auto();
                if (::builtin::spec_literal_nat("0")).spec_lt(self.depth) {
                        self.substitute(replacement).i_children_lemma();
                        ::builtin::assert_(self.substitute(replacement).i_children().wf());
                        self.i().substitute_preserves_wf(replacement.i());
                        ::builtin::assert_(self.i().replaced_children(replacement.i()).wf());
                        self.subpath().substitute_commutes_with_i(replacement);
                        self.subpath_commutes_with_i();
                        self.node.i_children_lemma();
                        ::builtin::assert_(::builtin::ext_equal(self.substitute(replacement).i().get_Node_children().map,
                                self.i().substitute(replacement.i()).get_Node_children().map));
                    }
            }
        }
        #[verus::internal(verus_macro)]
        impl PivotBetree::Label {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> PagedBetree::Label {
                match self {
                    PivotBetree::Label::Query { end_lsn, key, value } =>
                        PagedBetree::Label::Query {
                            end_lsn: end_lsn,
                            key: key,
                            value: value,
                        },
                    PivotBetree::Label::Put { puts } =>
                        PagedBetree::Label::Put { puts: puts },
                    PivotBetree::Label::FreezeAs { stamped_betree } =>
                        PagedBetree::Label::FreezeAs {
                            stamped_betree: i_stamped_betree(stamped_betree),
                        },
                    PivotBetree::Label::Internal {} =>
                        PagedBetree::Label::Internal {},
                }
            }
        }
        #[verus::internal(verus_macro)]
        impl PivotBetree::State {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn inv(self) -> bool {
                (self.wf()) &&
                    ((::builtin::imply(self.root.is_Node(),
                                ::builtin::spec_eq(self.root.my_domain(), total_domain()))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> PagedBetree::State {
                PagedBetree::State {
                    root: self.root.i(),
                    memtable: self.memtable,
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn init_refines(self, stamped_betree: StampedBetree) {
                ::builtin::requires([PivotBetree::State::initialize(self,
                                stamped_betree)]);
                ::builtin::ensures([PagedBetree::State::initialize(self.i(),
                                i_stamped_betree(stamped_betree))]);
                stamped_betree.value.i_wf();
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn query_refines(self, post: Self, lbl: PivotBetree::Label,
                receipt: QueryReceipt) {
                ::builtin::requires([self.inv(),
                            PivotBetree::State::query(self, post, lbl, receipt)]);
                ::builtin::ensures([post.inv(),
                            PagedBetree::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PagedBetree::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PagedBetree::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                receipt.i_valid();
                ::builtin::assert_(PagedBetree::State::next_by(self.i(),
                        post.i(), lbl.i(), PagedBetree::Step::query(receipt.i())));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn put_refines(self, post: Self, lbl: PivotBetree::Label) {
                ::builtin::requires([self.inv(),
                            PivotBetree::State::put(self, post, lbl)]);
                ::builtin::ensures([post.inv(),
                            PagedBetree::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PagedBetree::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PagedBetree::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::assert_(PagedBetree::State::next_by(self.i(),
                        post.i(), lbl.i(), PagedBetree::Step::put()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn freeze_as_refines(self, post: Self,
                lbl: PivotBetree::Label) {
                ::builtin::requires([self.inv(),
                            PivotBetree::State::freeze_as(self, post, lbl)]);
                ::builtin::ensures([post.inv(),
                            PagedBetree::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PagedBetree::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PagedBetree::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                self.root.i_wf();
                ::builtin::assert_(PagedBetree::State::next_by(self.i(),
                        post.i(), lbl.i(), PagedBetree::Step::freeze_as()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn internal_flush_memtable_refines(self, post: Self,
                lbl: PivotBetree::Label) {
                ::builtin::requires([self.inv(),
                            PivotBetree::State::internal_flush_memtable(self, post,
                                lbl)]);
                ::builtin::ensures([post.inv(),
                            PagedBetree::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PagedBetree::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PagedBetree::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                self.root.i_wf();
                self.root.promote_and_merge_wf(total_domain(),
                    self.memtable.buffer);
                let a = self.root.push_memtable(self.memtable).i();
                let b = self.root.i().push_memtable(self.memtable).value;
                BetreeNode::empty_root_refines();
                let equiv_children_node =
                    if self.root.is_Node() {
                            self.root
                        } else { BetreeNode::empty_root(total_domain()) };
                equiv_children_node.i_children_seq_same(self.root.push_memtable(self.memtable),
                    ::builtin::spec_literal_integer("0"));
                ::builtin::assert_(::builtin::ext_equal(a.get_Node_buffer(),
                        b.get_Node_buffer()));
                ::builtin::assert_(::builtin::ext_equal(a.get_Node_children().map,
                        b.get_Node_children().map));
                ::builtin::assert_(PagedBetree::State::next_by(self.i(),
                        post.i(), lbl.i(),
                        PagedBetree::Step::internal_flush_memtable()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn internal_grow_refines(self, post: Self,
                lbl: PivotBetree::Label) {
                ::builtin::requires([self.inv(),
                            PivotBetree::State::internal_grow(self, post, lbl)]);
                ::builtin::ensures([post.inv(),
                            PagedBetree::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PagedBetree::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PagedBetree::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                self.root.i_wf();
                post.root.i_wf();
                PivotTable::route_lemma_auto();
                post.root.i_children_lemma();
                ::builtin::assert_(::builtin::ext_equal(post.i().root.get_Node_children().map,
                        PagedBetree_v::constant_child_map(self.root.i()).map));
                ::builtin::assert_(PagedBetree::State::next_by(self.i(),
                        post.i(), lbl.i(), PagedBetree::Step::internal_grow()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn internal_split_refines(self, post: Self,
                lbl: PivotBetree::Label, path: Path, request: SplitRequest) {
                ::builtin::requires([self.inv(),
                            PivotBetree::State::internal_split(self, post, lbl, path,
                                request)]);
                ::builtin::ensures([post.inv(),
                            PagedBetree::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PagedBetree::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PagedBetree::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                self.root.i_wf();
                path.target().i_wf();
                path.target().split_parent_wf(request);
                path.substitute_commutes_with_i(path.target().split_parent(request));
                post.root.i_wf();
                path.i_valid();
                path.target_commutes_with_i();
                path.target().split_commutes_with_i(request);
                let (left_keys, right_keys) =
                    path.target().split_keys(request);
                ::builtin::assert_(PagedBetree::State::next_by(self.i(),
                        post.i(), lbl.i(),
                        PagedBetree::Step::internal_split(path.i(), left_keys,
                            right_keys)));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn internal_flush_refines(self, post: Self,
                lbl: PivotBetree::Label, path: Path, child_idx: nat) {
                ::builtin::requires([self.inv(),
                            PivotBetree::State::internal_flush(self, post, lbl, path,
                                child_idx)]);
                ::builtin::ensures([post.inv(),
                            PagedBetree::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PagedBetree::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PagedBetree::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                self.root.i_wf();
                path.target_wf();
                path.target().flush_wf(child_idx);
                path.substitute_commutes_with_i(path.target().flush(child_idx));
                post.root.i_wf();
                path.i_valid();
                path.target_commutes_with_i();
                path.target().flush_commutes_with_i(child_idx);
                let flushed_keys =
                    path.target().child_domain(child_idx).key_set();
                ::builtin::assert_(PagedBetree::State::next_by(self.i(),
                        post.i(), lbl.i(),
                        PagedBetree::Step::internal_flush(path.i(), flushed_keys)));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn internal_noop_noop(self, post: Self,
                lbl: PivotBetree::Label) {
                ::builtin::requires([self.inv(),
                            PivotBetree::State::internal_noop(self, post, lbl)]);
                ::builtin::ensures([post.inv(),
                            PagedBetree::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PagedBetree::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PagedBetree::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                self.root.i_wf();
                post.root.i_wf();
                ::builtin::assert_(PagedBetree::State::next_by(self.i(),
                        post.i(), lbl.i(), PagedBetree::Step::internal_noop()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn next_refines(self, post: Self, lbl: PivotBetree::Label) {
                ::builtin::requires([self.inv(),
                            PivotBetree::State::next(self, post, lbl)]);
                ::builtin::ensures([post.inv(),
                            PagedBetree::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PivotBetree::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PivotBetree::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                match ::builtin::choose(|step|
                            PivotBetree::State::next_by(self, post, lbl, step)) {
                    PivotBetree::Step::query(receipt) => {
                        self.query_refines(post, lbl, receipt);
                    }
                    PivotBetree::Step::put() => { self.put_refines(post, lbl); }
                    PivotBetree::Step::freeze_as() => {
                        self.freeze_as_refines(post, lbl);
                    }
                    PivotBetree::Step::internal_flush_memtable() => {
                        self.internal_flush_memtable_refines(post, lbl);
                    }
                    PivotBetree::Step::internal_grow() => {
                        self.internal_grow_refines(post, lbl);
                    }
                    PivotBetree::Step::internal_split(path, split_request) => {
                        self.internal_split_refines(post, lbl, path, split_request);
                    }
                    PivotBetree::Step::internal_flush(path, child_idx) => {
                        self.internal_flush_refines(post, lbl, path, child_idx);
                    }
                    PivotBetree::Step::internal_noop() => {
                        self.internal_noop_noop(post, lbl);
                    }
                    _ => { ::builtin::assert_(false); }
                }
            }
        }
    }
    pub mod SplitRequest_v {
        #[allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use crate::spec::KeyType_t::*;
        #[verus::internal(verus_macro)]
        pub enum SplitRequest {
            SplitLeaf {
                child_idx: nat,
                split_key: Key,
            },
            SplitIndex {
                child_idx: nat,
                child_pivot_idx: nat,
            },
        }
        #[verus::internal(verus_macro)]
        #[cfg(verus_keep_ghost)]
        #[automatically_derived]
        impl SplitRequest {
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_SplitLeaf(&self) -> bool {
                ::builtin::is_variant(self, "SplitLeaf")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_SplitLeaf_child_idx(self) -> nat {
                ::builtin::get_variant_field(self, "SplitLeaf", "child_idx")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_SplitLeaf_split_key(self) -> Key {
                ::builtin::get_variant_field(self, "SplitLeaf", "split_key")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_SplitIndex(&self) -> bool {
                ::builtin::is_variant(self, "SplitIndex")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_SplitIndex_child_idx(self) -> nat {
                ::builtin::get_variant_field(self, "SplitIndex", "child_idx")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_SplitIndex_child_pivot_idx(self) -> nat {
                ::builtin::get_variant_field(self, "SplitIndex",
                    "child_pivot_idx")
            }
        }
        #[verus::internal(verus_macro)]
        impl SplitRequest {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn get_child_idx(self) -> nat {
                match self {
                    Self::SplitLeaf { child_idx, .. } => child_idx,
                    Self::SplitIndex { child_idx, .. } => child_idx,
                }
            }
        }
    }
    pub mod BufferOffsets_v {
        use builtin::*;
        use builtin_macros::*;
        use vstd::seq::*;
        #[verus::internal(verus_macro)]
        pub struct BufferOffsets {
            pub offsets: Seq<nat>,
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn empty_bufer_offsets() -> BufferOffsets {
            BufferOffsets { offsets: ::vstd::seq::Seq::empty() }
        }
        #[verus::internal(verus_macro)]
        impl BufferOffsets {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn len(self) -> nat { self.offsets.len() }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn slice(self, start: int, end: int) -> BufferOffsets {
                ::builtin::recommends([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            start), end), self.len()))]);
                BufferOffsets { offsets: self.offsets.subrange(start, end) }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn dup(self, idx: int) -> BufferOffsets {
                ::builtin::recommends([::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        idx), self.len()))]);
                BufferOffsets {
                    offsets: self.offsets.insert(idx,
                        self.offsets.spec_index(idx)),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn update(self, idx: int, value: nat) -> BufferOffsets {
                ::builtin::recommends([::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        idx), self.len()))]);
                BufferOffsets { offsets: self.offsets.update(idx, value) }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn all_lte(self, target: nat) -> bool {
                ::builtin::forall(|i: int|
                        ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        i), self.len())),
                            (self.offsets.spec_index(i)).spec_le(target)))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn all_gte(self, target: nat) -> bool {
                ::builtin::forall(|i: int|
                        ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        i), self.len())),
                            (self.offsets.spec_index(i)).spec_ge(target)))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn shift_left(self, target: nat) -> BufferOffsets {
                ::builtin::recommends([self.all_gte(target)]);
                BufferOffsets {
                    offsets: Seq::new(self.len(),
                        ::builtin::closure_to_fn_spec(|i: int|
                                ::builtin::spec_cast_integer::<_,
                                        nat>(((self.offsets.spec_index(i)).spec_sub(target))))),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn shift_left_preserves_lte(self, target: nat, limit: nat) {
                ::builtin::requires([self.all_gte(target),
                            self.all_lte(limit), (limit).spec_ge(target)]);
                ::builtin::ensures([self.shift_left(target).all_lte(::builtin::spec_cast_integer::<_,
                                        nat>(((limit).spec_sub(target))))]);
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn adjust_compact(self, start: int, end: int)
                -> BufferOffsets {
                ::builtin::recommends([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            start), end), self.len()))]);
                BufferOffsets {
                    offsets: Seq::new(self.len(),
                        ::builtin::closure_to_fn_spec(|i: int|
                                if (self.offsets.spec_index(i)).spec_le(start) {
                                        self.offsets.spec_index(i)
                                    } else if (self.offsets.spec_index(i)).spec_lt(end) {
                                       ::builtin::spec_cast_integer::<_, nat>(start)
                                   } else {
                                       ::builtin::spec_cast_integer::<_,
                                               nat>((((self.offsets.spec_index(i)).spec_sub(((end).spec_sub(start)))).spec_add(::builtin::spec_literal_nat("1"))))
                                   })),
                }
            }
        }
    }
    pub mod FilteredBetree_v {
        use builtin::*;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        use vstd::prelude::*;
        use crate::spec::KeyType_t::*;
        use crate::spec::Messages_t::*;
        use crate::betree::Buffer_v::*;
        use crate::betree::BufferSeq_v::*;
        use crate::betree::BufferOffsets_v::*;
        use crate::betree::OffsetMap_v::*;
        use crate::betree::Memtable_v::*;
        use crate::betree::Domain_v::*;
        use crate::betree::PivotTable_v::*;
        use crate::betree::SplitRequest_v::*;
        use crate::abstract_system::StampedMap_v::*;
        use crate::abstract_system::MsgHistory_v::*;
        pub type StampedBetree = Stamped<BetreeNode>;
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn empty_image() -> StampedBetree {
            Stamped {
                value: BetreeNode::Nil,
                seq_end: ::builtin::spec_literal_integer("0"),
            }
        }
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub enum BetreeNode {
            Nil,
            Node {
                buffers: BufferSeq,
                pivots: PivotTable,
                children: Seq<BetreeNode>,
                flushed: BufferOffsets,
            },
        }
        #[verus::internal(verus_macro)]
        #[cfg(verus_keep_ghost)]
        #[automatically_derived]
        impl BetreeNode {
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_Nil(&self) -> bool {
                ::builtin::is_variant(self, "Nil")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_Node(&self) -> bool {
                ::builtin::is_variant(self, "Node")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_Node_buffers(self) -> BufferSeq {
                ::builtin::get_variant_field(self, "Node", "buffers")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_Node_pivots(self) -> PivotTable {
                ::builtin::get_variant_field(self, "Node", "pivots")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_Node_children(self) -> Seq<BetreeNode> {
                ::builtin::get_variant_field(self, "Node", "children")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_Node_flushed(self) -> BufferOffsets {
                ::builtin::get_variant_field(self, "Node", "flushed")
            }
        }
        #[verus::internal(verus_macro)]
        impl BetreeNode {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn local_structure(self) -> bool {
                ::builtin::imply(self.is_Node(),
                    {
                        (((self.get_Node_pivots().wf()) &&
                                            (::builtin::spec_eq(self.get_Node_children().len(),
                                                    self.get_Node_pivots().num_ranges()))) &&
                                    (::builtin::spec_eq(self.get_Node_children().len(),
                                            self.get_Node_flushed().len()))) &&
                            (self.get_Node_flushed().all_lte(self.get_Node_buffers().len()))
                    })
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid_child_index(self, child_idx: nat) -> bool {
                (self.is_Node()) &&
                    ((child_idx).spec_lt(self.get_Node_children().len()))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn my_domain(self) -> Domain {
                ::builtin::recommends([self.local_structure(),
                            self.is_Node()]);
                Domain::Domain {
                    start: self.get_Node_pivots().pivots.spec_index(::builtin::spec_literal_integer("0")),
                    end: self.get_Node_pivots().pivots.last(),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn child_domain(self, child_idx: nat) -> Domain {
                ::builtin::recommends([self.local_structure(), self.is_Node(),
                            self.valid_child_index(child_idx)]);
                Domain::Domain {
                    start: self.get_Node_pivots().pivots.spec_index(::builtin::spec_cast_integer::<_,
                                int>(child_idx)),
                    end: self.get_Node_pivots().pivots.spec_index((::builtin::spec_cast_integer::<_,
                                        int>(child_idx)).spec_add(::builtin::spec_literal_nat("1"))),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn linked_children(self) -> bool {
                ::builtin::recommends([self.local_structure(),
                            self.is_Node()]);
                ::builtin::forall(|i|
                        ::builtin::imply(((#[verus::internal(trigger)] self.valid_child_index(i))
                                        &&
                                        self.get_Node_children().spec_index(::builtin::spec_cast_integer::<_,
                                                        int>(i)).is_Node() &&
                                    self.get_Node_children().spec_index(::builtin::spec_cast_integer::<_,
                                                    int>(i)).local_structure()),
                            {
                                ::builtin::spec_eq(self.get_Node_children().spec_index(::builtin::spec_cast_integer::<_,
                                                    int>(i)).my_domain(), self.child_domain(i))
                            }))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf_children(self) -> bool {
                ::builtin::recommends([self.is_Node()]);
                ::builtin::decreases((self,
                        ::builtin::spec_literal_nat("0")));
                ::builtin::decreases_when(self.is_Node());
                (::builtin::forall(|i|
                            ::builtin::imply((#[verus::internal(trigger)] self.valid_child_index(i)),
                                self.get_Node_children().spec_index(::builtin::spec_cast_integer::<_,
                                                int>(i)).wf())))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                ::builtin::decreases((self,
                        ::builtin::spec_literal_nat("1")));
                (self.local_structure()) &&
                    (::builtin::imply(self.is_Node(),
                            { (self.wf_children()) && (self.linked_children()) }))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn push_memtable(self, memtable: Memtable) -> BetreeNode {
                ::builtin::recommends([self.wf()]);
                let buffers =
                    BufferSeq {
                        buffers: ::vstd::seq::Seq::empty().push(memtable.buffer),
                    };
                self.promote(total_domain()).extend_buffer_seq(buffers)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn extend_buffer_seq(self, buffers: BufferSeq) -> BetreeNode {
                ::builtin::recommends([self.is_Node()]);
                BetreeNode::Node {
                    buffers: self.get_Node_buffers().extend(buffers),
                    pivots: self.get_Node_pivots(),
                    children: self.get_Node_children(),
                    flushed: self.get_Node_flushed(),
                }
            }
            #[verifier::recommends_by]
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn flushed_ofs_inline_lemma(self, key: Key) {
                self.get_Node_pivots().route_lemma(key);
                ::builtin::assert_(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                self.get_Node_pivots().route(key)),
                            self.get_Node_flushed().offsets.len())));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn flushed_ofs(self, key: Key) -> nat {
                ::builtin::recommends([self.key_in_domain(key)]);
                recommends_by(Self::flushed_ofs_inline_lemma);
                let r = self.get_Node_pivots().route(key);
                self.get_Node_flushed().offsets.spec_index(r)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_leaf(self) -> bool {
                ((((self.is_Node()) &&
                                            (::builtin::spec_eq(self.get_Node_children().len(),
                                                    ::builtin::spec_literal_nat("1")))) &&
                                    (self.get_Node_children().spec_index(::builtin::spec_literal_integer("0")).is_Nil()))
                            &&
                            (::builtin::spec_eq(self.get_Node_flushed().len(),
                                    ::builtin::spec_literal_nat("1")))) &&
                    (::builtin::spec_eq(self.get_Node_flushed().offsets.spec_index(::builtin::spec_literal_integer("0")),
                            ::builtin::spec_literal_nat("0")))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_index(self) -> bool {
                (self.is_Node()) &&
                    (::builtin::forall(|i|
                                ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                i), self.get_Node_children().len())),
                                    (#[verus::internal(trigger)] self.get_Node_children().spec_index(i)).is_Node())))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_split_leaf(self, split_key: Key) -> bool {
                (((self.wf()) && (self.is_leaf())) &&
                            (self.my_domain().contains(split_key))) &&
                    (!::builtin::spec_eq(self.my_domain().get_Domain_start(),
                                to_element(split_key)))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split_leaf(self, split_key: Key)
                -> (BetreeNode, BetreeNode) {
                ::builtin::recommends([self.can_split_leaf(split_key)]);
                let new_left =
                    BetreeNode::Node {
                        buffers: self.get_Node_buffers(),
                        pivots: self.get_Node_pivots().update(::builtin::spec_literal_integer("1"),
                            to_element(split_key)),
                        children: self.get_Node_children(),
                        flushed: self.get_Node_flushed(),
                    };
                let new_right =
                    BetreeNode::Node {
                        buffers: self.get_Node_buffers(),
                        pivots: self.get_Node_pivots().update(::builtin::spec_literal_integer("0"),
                            to_element(split_key)),
                        children: self.get_Node_children(),
                        flushed: self.get_Node_flushed(),
                    };
                (new_left, new_right)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_split_index(self, pivot_idx: nat) -> bool {
                ((self.wf()) && (self.is_index())) &&
                    (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_lt(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                    pivot_idx), self.get_Node_pivots().num_ranges())))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split_index(self, pivot_idx: nat)
                -> (BetreeNode, BetreeNode) {
                ::builtin::recommends([self.can_split_index(pivot_idx)]);
                let idx = ::builtin::spec_cast_integer::<_, int>(pivot_idx);
                let new_left =
                    BetreeNode::Node {
                        buffers: self.get_Node_buffers(),
                        pivots: self.get_Node_pivots().subrange(::builtin::spec_literal_integer("0"),
                            (idx).spec_add(::builtin::spec_literal_nat("1"))),
                        children: self.get_Node_children().subrange(::builtin::spec_literal_integer("0"),
                            idx),
                        flushed: self.get_Node_flushed().slice(::builtin::spec_literal_integer("0"),
                            idx),
                    };
                let new_right =
                    BetreeNode::Node {
                        buffers: self.get_Node_buffers(),
                        pivots: self.get_Node_pivots().subrange(idx,
                            ::builtin::spec_cast_integer::<_,
                                    int>(self.get_Node_pivots().len())),
                        children: self.get_Node_children().subrange(idx,
                            ::builtin::spec_cast_integer::<_,
                                    int>(self.get_Node_children().len())),
                        flushed: self.get_Node_flushed().slice(idx,
                            ::builtin::spec_cast_integer::<_,
                                    int>(self.get_Node_flushed().len())),
                    };
                (new_left, new_right)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_split_parent(self, request: SplitRequest) -> bool {
                ((self.wf()) && (self.is_Node())) &&
                    (match request {
                            SplitRequest::SplitLeaf { child_idx, split_key } => {
                                (self.valid_child_index(child_idx)) &&
                                    (self.get_Node_children().spec_index(::builtin::spec_cast_integer::<_,
                                                        int>(child_idx)).can_split_leaf(split_key))
                            }
                            SplitRequest::SplitIndex { child_idx, child_pivot_idx } => {
                                (self.valid_child_index(child_idx)) &&
                                    (self.get_Node_children().spec_index(::builtin::spec_cast_integer::<_,
                                                        int>(child_idx)).can_split_index(child_pivot_idx))
                            }
                        })
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split_parent(self, request: SplitRequest) -> BetreeNode {
                ::builtin::recommends([self.can_split_parent(request)]);
                match request {
                    SplitRequest::SplitLeaf { child_idx, split_key } => {
                        let idx = ::builtin::spec_cast_integer::<_, int>(child_idx);
                        let old_child = self.get_Node_children().spec_index(idx);
                        let (new_left_child, new_right_child) =
                            old_child.split_leaf(split_key);
                        BetreeNode::Node {
                            buffers: self.get_Node_buffers(),
                            pivots: self.get_Node_pivots().insert((idx).spec_add(::builtin::spec_literal_nat("1")),
                                to_element(split_key)),
                            children: self.get_Node_children().update(idx,
                                    new_left_child).insert((idx).spec_add(::builtin::spec_literal_nat("1")),
                                new_right_child),
                            flushed: self.get_Node_flushed().dup(idx),
                        }
                    }
                    SplitRequest::SplitIndex { child_idx, child_pivot_idx } => {
                        let idx = ::builtin::spec_cast_integer::<_, int>(child_idx);
                        let old_child = self.get_Node_children().spec_index(idx);
                        let (new_left_child, new_right_child) =
                            old_child.split_index(child_pivot_idx);
                        let split_element =
                            old_child.get_Node_pivots().pivots.spec_index(::builtin::spec_cast_integer::<_,
                                        int>(child_pivot_idx));
                        BetreeNode::Node {
                            buffers: self.get_Node_buffers(),
                            pivots: self.get_Node_pivots().insert((idx).spec_add(::builtin::spec_literal_nat("1")),
                                split_element),
                            children: self.get_Node_children().update(idx,
                                    new_left_child).insert((idx).spec_add(::builtin::spec_literal_nat("1")),
                                new_right_child),
                            flushed: self.get_Node_flushed().dup(idx),
                        }
                    }
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn empty_root(domain: Domain) -> BetreeNode {
                ::builtin::recommends([domain.wf(), domain.is_Domain()]);
                BetreeNode::Node {
                    buffers: BufferSeq::empty(),
                    pivots: domain_to_pivots(domain),
                    children: ::vstd::seq::Seq::empty().push(BetreeNode::Nil),
                    flushed: BufferOffsets {
                        offsets: ::vstd::seq::Seq::empty().push(::builtin::spec_literal_integer("0")),
                    },
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn grow(self) -> BetreeNode {
                BetreeNode::Node {
                    buffers: BufferSeq::empty(),
                    pivots: domain_to_pivots(total_domain()),
                    children: ::vstd::seq::Seq::empty().push(self),
                    flushed: BufferOffsets {
                        offsets: ::vstd::seq::Seq::empty().push(::builtin::spec_literal_integer("0")),
                    },
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn promote(self, domain: Domain) -> BetreeNode {
                ::builtin::recommends([self.wf(), domain.wf(),
                            domain.is_Domain()]);
                if self.is_Nil() {
                        BetreeNode::empty_root(domain)
                    } else { self }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_flush(self, child_idx: nat, buffer_gc: nat) -> bool {
                (((self.wf()) && (self.is_Node())) &&
                            (self.valid_child_index(child_idx))) &&
                    (self.get_Node_flushed().update(::builtin::spec_cast_integer::<_,
                                        int>(child_idx),
                                self.get_Node_buffers().len()).all_gte(buffer_gc))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn flush(self, child_idx: nat, buffer_gc: nat) -> BetreeNode {
                ::builtin::recommends([self.can_flush(child_idx, buffer_gc)]);
                let idx = ::builtin::spec_cast_integer::<_, int>(child_idx);
                let flush_upto = self.get_Node_buffers().len();
                let flushed_ofs =
                    self.get_Node_flushed().offsets.spec_index(idx);
                let buffers_to_child =
                    self.get_Node_buffers().slice(::builtin::spec_cast_integer::<_,
                                int>(flushed_ofs),
                        ::builtin::spec_cast_integer::<_, int>(flush_upto));
                let new_child =
                    self.get_Node_children().spec_index(idx).promote(self.child_domain(child_idx)).extend_buffer_seq(buffers_to_child);
                let bfrs = self.get_Node_buffers();
                let start = ::builtin::spec_cast_integer::<_, int>(buffer_gc);
                let end = ::builtin::spec_cast_integer::<_, int>(flush_upto);
                let gc_buffers =
                    self.get_Node_buffers().slice(::builtin::spec_cast_integer::<_,
                                int>(buffer_gc),
                        ::builtin::spec_cast_integer::<_, int>(flush_upto));
                let gc_flushed =
                    self.get_Node_flushed().update(idx,
                            flush_upto).shift_left(buffer_gc);
                BetreeNode::Node {
                    buffers: gc_buffers,
                    pivots: self.get_Node_pivots(),
                    children: self.get_Node_children().update(idx, new_child),
                    flushed: gc_flushed,
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn compact_key_range(self, start: nat, end: nat, k: Key)
                -> bool {
                ::builtin::recommends([self.wf(), self.is_Node(),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_lt(::builtin::spec_chained_value(start),
                                        end), self.get_Node_buffers().len()))]);
                ((self.key_in_domain(k)) &&
                            ((self.flushed_ofs(k)).spec_le(end))) &&
                    (::builtin::exists(|buffer_idx|
                                self.get_Node_buffers().slice(::builtin::spec_cast_integer::<_,
                                                int>(start),
                                        ::builtin::spec_cast_integer::<_,
                                                int>(end)).key_in_buffer_filtered(self.make_offset_map().decrement(start),
                                    ::builtin::spec_literal_integer("0"), k, buffer_idx)))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn can_compact(self, start: nat, end: nat,
                compacted_buffer: Buffer) -> bool {
                ((((self.wf()) && (self.is_Node())) &&
                                    (::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_lt(::builtin::spec_chained_value(start),
                                                    end), self.get_Node_buffers().len())))) &&
                            (::builtin::forall(|k|
                                        #[verus::internal(auto_trigger)] (::builtin::spec_eq((compacted_buffer.map.contains_key(k)),
                                                (self.compact_key_range(start, end, k))))))) &&
                    (::builtin::forall(|k|
                                #[verus::internal(auto_trigger)] (::builtin::imply(compacted_buffer.map.contains_key(k),
                                        ({
                                                let from =
                                                    if (self.flushed_ofs(k)).spec_le(start) {
                                                            ::builtin::spec_literal_integer("0")
                                                        } else { (self.flushed_ofs(k)).spec_sub(start) };
                                                ::builtin::spec_eq(compacted_buffer.query(k),
                                                    self.get_Node_buffers().slice(::builtin::spec_cast_integer::<_,
                                                                    int>(start),
                                                            ::builtin::spec_cast_integer::<_,
                                                                    int>(end)).query_from(k, from))
                                            })))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn compact(self, start: nat, end: nat,
                compacted_buffer: Buffer) -> BetreeNode {
                ::builtin::recommends([self.can_compact(start, end,
                                compacted_buffer)]);
                BetreeNode::Node {
                    buffers: self.get_Node_buffers().update_subrange(::builtin::spec_cast_integer::<_,
                                int>(start), ::builtin::spec_cast_integer::<_, int>(end),
                        compacted_buffer),
                    pivots: self.get_Node_pivots(),
                    children: self.get_Node_children(),
                    flushed: self.get_Node_flushed().adjust_compact(::builtin::spec_cast_integer::<_,
                                int>(start), ::builtin::spec_cast_integer::<_, int>(end)),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn key_in_domain(self, key: Key) -> bool {
                ((self.wf()) && (self.is_Node())) &&
                    (self.get_Node_pivots().bounded_key(key))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn child(self, key: Key) -> BetreeNode {
                ::builtin::recommends([self.wf(), self.is_Node(),
                            self.key_in_domain(key)]);
                let _ = spec_affirm(self.wf_children());
                self.get_Node_children().spec_index(self.get_Node_pivots().route(key))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn make_offset_map(self) -> OffsetMap {
                OffsetMap {
                    offsets: Map::new(::builtin::closure_to_fn_spec(|k| true),
                        ::builtin::closure_to_fn_spec(|k|
                                if self.key_in_domain(k) {
                                        self.flushed_ofs(k)
                                    } else { self.get_Node_buffers().len() })),
                }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct QueryReceiptLine {
            pub node: BetreeNode,
            pub result: Message,
        }
        #[verus::internal(verus_macro)]
        impl QueryReceiptLine {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                (self.node.wf()) && (self.result.is_Define())
            }
        }
        #[verus::internal(verus_macro)]
        pub struct QueryReceipt {
            pub key: Key,
            pub root: BetreeNode,
            pub lines: Seq<QueryReceiptLine>,
        }
        #[verus::internal(verus_macro)]
        impl QueryReceipt {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn structure(self) -> bool {
                ((((::builtin::spec_literal_nat("0")).spec_lt(self.lines.len()))
                                    &&
                                    (::builtin::spec_eq(self.lines.spec_index(::builtin::spec_literal_integer("0")).node,
                                            self.root))) &&
                            ((::builtin::forall(|i: nat|
                                            #[verus::internal(auto_trigger)] (::builtin::imply((i).spec_lt(self.lines.len()),
                                                    {
                                                        ::builtin::spec_eq((self.lines.spec_index(::builtin::spec_cast_integer::<_,
                                                                                    int>(i)).node.is_Node()),
                                                            ((i).spec_lt((self.lines.len()).spec_sub(::builtin::spec_literal_nat("1")))))
                                                    })))))) &&
                    (::builtin::spec_eq(self.lines.last().result,
                            Message::Define { value: default_value() }))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn all_lines_wf(self) -> bool {
                ((::builtin::forall(|i: nat|
                                    #[verus::internal(auto_trigger)] (::builtin::imply((i).spec_lt(self.lines.len()),
                                            self.lines.spec_index(::builtin::spec_cast_integer::<_,
                                                            int>(i)).wf()))))) &&
                    ((::builtin::forall(|i: nat|
                                    #[verus::internal(auto_trigger)] (::builtin::imply((i).spec_lt((self.lines.len()).spec_sub(::builtin::spec_literal_nat("1"))),
                                            self.lines.spec_index(::builtin::spec_cast_integer::<_,
                                                                int>(i)).node.key_in_domain(self.key))))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn child_at(self, i: int) -> BetreeNode {
                ::builtin::recommends([self.all_lines_wf(), self.structure(),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        i),
                                    (self.lines.len()).spec_sub(::builtin::spec_literal_nat("1"))))]);
                self.lines.spec_index(i).node.child(self.key)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn child_linked_at(self, i: int) -> bool {
                ::builtin::recommends([self.all_lines_wf(), self.structure(),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        i),
                                    (self.lines.len()).spec_sub(::builtin::spec_literal_nat("1"))))]);
                ::builtin::spec_eq(self.lines.spec_index((i).spec_add(::builtin::spec_literal_nat("1"))).node,
                    self.child_at(i))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn result_at(self, i: int) -> Message {
                ::builtin::recommends([::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        i), self.lines.len()))]);
                self.lines.spec_index(i).result
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn result_linked_at(self, i: int) -> bool {
                ::builtin::recommends([self.structure(), self.all_lines_wf(),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        i),
                                    (self.lines.len()).spec_sub(::builtin::spec_literal_nat("1"))))]);
                let start =
                    self.lines.spec_index(i).node.flushed_ofs(self.key);
                let msg =
                    self.lines.spec_index(i).node.get_Node_buffers().query_from(self.key,
                        ::builtin::spec_cast_integer::<_, int>(start));
                ::builtin::spec_eq(self.lines.spec_index(i).result,
                    self.result_at((i).spec_add(::builtin::spec_literal_nat("1"))).merge(msg))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid(self) -> bool {
                (((self.structure()) && (self.all_lines_wf())) &&
                            ((::builtin::forall(|i|
                                            #[verus::internal(auto_trigger)] (::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                i),
                                                            (self.lines.len()).spec_sub(::builtin::spec_literal_nat("1")))),
                                                    self.child_linked_at(i))))))) &&
                    ((::builtin::forall(|i|
                                    #[verus::internal(auto_trigger)] (::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                        i),
                                                    (self.lines.len()).spec_sub(::builtin::spec_literal_nat("1")))),
                                            self.result_linked_at(i))))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn result(self) -> Message {
                ::builtin::recommends([self.structure()]);
                self.result_at(::builtin::spec_literal_integer("0"))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid_for(self, root: BetreeNode, key: Key) -> bool {
                ((self.valid()) && (::builtin::spec_eq(self.root, root))) &&
                    (::builtin::spec_eq(self.key, key))
            }
        }
        #[verus::internal(verus_macro)]
        pub struct Path {
            pub node: BetreeNode,
            pub key: Key,
            pub depth: nat,
        }
        #[verus::internal(verus_macro)]
        impl Path {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn subpath(self) -> Path {
                ::builtin::recommends([(::builtin::spec_literal_nat("0")).spec_lt(self.depth),
                            self.node.key_in_domain(self.key)]);
                let depth =
                    ::builtin::spec_cast_integer::<_,
                            nat>(((self.depth).spec_sub(::builtin::spec_literal_nat("1"))));
                Path {
                    node: self.node.child(self.key),
                    key: self.key,
                    depth: depth,
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid(self) -> bool {
                ::builtin::decreases((self.depth));
                (((self.node.wf()) && (self.node.key_in_domain(self.key))) &&
                            ((::builtin::imply((::builtin::spec_literal_nat("0")).spec_lt(self.depth),
                                        self.node.is_index())))) &&
                    ((::builtin::imply((::builtin::spec_literal_nat("0")).spec_lt(self.depth),
                                self.subpath().valid())))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn target(self) -> BetreeNode {
                ::builtin::recommends([self.valid()]);
                ::builtin::decreases((self.depth));
                if ::builtin::spec_eq(self.depth,
                            ::builtin::spec_literal_nat("0")) {
                        self.node
                    } else { self.subpath().target() }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn can_substitute(self, replacement: BetreeNode) -> bool {
                (((self.valid()) && (replacement.wf())) &&
                            (replacement.is_Node())) &&
                    (::builtin::spec_eq(replacement.my_domain(),
                            self.target().my_domain()))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn replaced_children(self, replacement: BetreeNode)
                -> Seq<BetreeNode> {
                ::builtin::recommends([self.can_substitute(replacement),
                            (::builtin::spec_literal_nat("0")).spec_lt(self.depth)]);
                ::builtin::decreases((self.subpath().depth));
                let new_child = self.subpath().substitute(replacement);
                let r = self.node.get_Node_pivots().route(self.key);
                self.node.get_Node_children().update(r, new_child)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn substitute(self, replacement: BetreeNode) -> BetreeNode {
                ::builtin::recommends([self.can_substitute(replacement)]);
                ::builtin::decreases((self.depth,
                        ::builtin::spec_literal_nat("1")));
                if ::builtin::spec_eq(self.depth,
                            ::builtin::spec_literal_nat("0")) {
                        replacement
                    } else {
                       BetreeNode::Node {
                           buffers: self.node.get_Node_buffers(),
                           pivots: self.node.get_Node_pivots(),
                           children: self.replaced_children(replacement),
                           flushed: self.node.get_Node_flushed(),
                       }
                   }
            }
        }
        #[allow(unused_parens)]
        pub mod FilteredBetree {
            use super::*;
            #[verus::internal(verus_macro)]
            pub struct State {
                pub memtable: Memtable,
                pub root: BetreeNode,
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Step {
                query(QueryReceipt),
                put(),
                freeze_as(),
                internal_flush_memtable(),
                internal_grow(),
                internal_split(Path, SplitRequest),
                internal_flush(Path, nat, nat),
                internal_compact(Path, nat, nat, Buffer),
                internal_noop(),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Step {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_query(&self) -> bool {
                    ::builtin::is_variant(self, "query")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_query_0(self) -> QueryReceipt {
                    ::builtin::get_variant_field(self, "query", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_put(&self) -> bool {
                    ::builtin::is_variant(self, "put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_freeze_as(&self) -> bool {
                    ::builtin::is_variant(self, "freeze_as")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_internal_flush_memtable(&self) -> bool {
                    ::builtin::is_variant(self, "internal_flush_memtable")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_internal_grow(&self) -> bool {
                    ::builtin::is_variant(self, "internal_grow")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_internal_split(&self) -> bool {
                    ::builtin::is_variant(self, "internal_split")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_split_0(self) -> Path {
                    ::builtin::get_variant_field(self, "internal_split", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_split_1(self) -> SplitRequest {
                    ::builtin::get_variant_field(self, "internal_split", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_internal_flush(&self) -> bool {
                    ::builtin::is_variant(self, "internal_flush")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_flush_0(self) -> Path {
                    ::builtin::get_variant_field(self, "internal_flush", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_flush_1(self) -> nat {
                    ::builtin::get_variant_field(self, "internal_flush", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_flush_2(self) -> nat {
                    ::builtin::get_variant_field(self, "internal_flush", "2")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_internal_compact(&self) -> bool {
                    ::builtin::is_variant(self, "internal_compact")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_compact_0(self) -> Path {
                    ::builtin::get_variant_field(self, "internal_compact", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_compact_1(self) -> nat {
                    ::builtin::get_variant_field(self, "internal_compact", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_compact_2(self) -> nat {
                    ::builtin::get_variant_field(self, "internal_compact", "2")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_compact_3(self) -> Buffer {
                    ::builtin::get_variant_field(self, "internal_compact", "3")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_internal_noop(&self) -> bool {
                    ::builtin::is_variant(self, "internal_noop")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Config {
                initialize(StampedBetree),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Config {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_initialize(&self) -> bool {
                    ::builtin::is_variant(self, "initialize")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_initialize_0(self) -> StampedBetree {
                    ::builtin::get_variant_field(self, "initialize", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[verus::internal(verus_macro)]
            pub enum Label {
                Query {
                    end_lsn: LSN,
                    key: Key,
                    value: Value,
                },
                Put {
                    puts: MsgHistory,
                },
                FreezeAs {
                    stamped_betree: StampedBetree,
                },
                Internal {},
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Label {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_Query(&self) -> bool {
                    ::builtin::is_variant(self, "Query")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_Query_end_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "Query", "end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_Query_key(self) -> Key {
                    ::builtin::get_variant_field(self, "Query", "key")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_Query_value(self) -> Value {
                    ::builtin::get_variant_field(self, "Query", "value")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_Put(&self) -> bool {
                    ::builtin::is_variant(self, "Put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_Put_puts(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "Put", "puts")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_FreezeAs(&self) -> bool {
                    ::builtin::is_variant(self, "FreezeAs")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_FreezeAs_stamped_betree(self) -> StampedBetree {
                    ::builtin::get_variant_field(self, "FreezeAs",
                        "stamped_betree")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_Internal(&self) -> bool {
                    ::builtin::is_variant(self, "Internal")
                }
            }
            pub mod show {
                use super::*;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn query(pre: super::State, post: super::State,
                    lbl: Label, receipt: QueryReceipt) {
                    ::builtin::requires(super::State::query(pre, post, lbl,
                            receipt));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as query;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn put(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::put(pre, post, lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as put;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn freeze_as(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::freeze_as(pre, post,
                            lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as freeze_as;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn internal_flush_memtable(pre: super::State,
                    post: super::State, lbl: Label) {
                    ::builtin::requires(super::State::internal_flush_memtable(pre,
                            post, lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as internal_flush_memtable;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn internal_grow(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::internal_grow(pre, post,
                            lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as internal_grow;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn internal_split(pre: super::State, post: super::State,
                    lbl: Label, path: Path, request: SplitRequest) {
                    ::builtin::requires(super::State::internal_split(pre, post,
                            lbl, path, request));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as internal_split;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn internal_flush(pre: super::State, post: super::State,
                    lbl: Label, path: Path, child_idx: nat, buffer_gc: nat) {
                    ::builtin::requires(super::State::internal_flush(pre, post,
                            lbl, path, child_idx, buffer_gc));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as internal_flush;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn internal_compact(pre: super::State, post: super::State,
                    lbl: Label, path: Path, start: nat, end: nat,
                    compacted_buffer: Buffer) {
                    ::builtin::requires(super::State::internal_compact(pre,
                            post, lbl, path, start, end, compacted_buffer));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as internal_compact;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn internal_noop(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::internal_noop(pre, post,
                            lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as internal_noop;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn initialize(post: super::State,
                    stamped_betree: StampedBetree) {
                    ::builtin::requires(super::State::initialize(post,
                            stamped_betree));
                    ::builtin::ensures(super::State::init(post));
                }
                use bool as initialize;
            }
            pub mod take_step {
                use super::*;
            }
            #[verus::internal(verus_macro)]
            impl State {
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query(pre: Self, post: Self, lbl: Label,
                    receipt: QueryReceipt) -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        let update_tmp_root: BetreeNode = pre.root;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Query { end_lsn, key, value } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let (end_lsn, key, value) =
                                                        match tmp_for_match_0 {
                                                            Label::Query { end_lsn, key, value } =>
                                                                (end_lsn, key, value),
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(end_lsn,
                                                                    pre.memtable.seq_end)) &&
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (receipt.valid_for(pre.root,
                                                                            key)) &&
                                                                    #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(Message::Define {
                                                                                value,
                                                                            }, receipt.result().merge(pre.memtable.query(key))))))
                                                })
                                    }) &&
                                ((#[verifier::custom_err("cannot prove that the field `root` is preserved")] (::builtin::equal(post.root,
                                                    update_tmp_root)) &&
                                            #[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                                    update_tmp_memtable)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_strong(pre: Self, post: Self, lbl: Label,
                    receipt: QueryReceipt) -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        let update_tmp_root: BetreeNode = pre.root;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Query { end_lsn, key, value } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let (end_lsn, key, value) =
                                                        match tmp_for_match_0 {
                                                            Label::Query { end_lsn, key, value } =>
                                                                (end_lsn, key, value),
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(end_lsn,
                                                                    pre.memtable.seq_end)) &&
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (receipt.valid_for(pre.root,
                                                                            key)) &&
                                                                    #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(Message::Define {
                                                                                value,
                                                                            }, receipt.result().merge(pre.memtable.query(key))))))
                                                })
                                    }) &&
                                ((#[verifier::custom_err("cannot prove that the field `root` is preserved")] (::builtin::equal(post.root,
                                                    update_tmp_root)) &&
                                            #[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                                    update_tmp_memtable)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_enabled(pre: Self, lbl: Label,
                    receipt: QueryReceipt) -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Query { end_lsn, key, value } => true,
                                        _ => false,
                                    }) &&
                                {
                                    let (end_lsn, key, value) =
                                        match tmp_for_match_0 {
                                            Label::Query { end_lsn, key, value } =>
                                                (end_lsn, key, value),
                                            _ => ::vstd::pervasive::arbitrary(),
                                        };
                                    (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(end_lsn,
                                                    pre.memtable.seq_end)) &&
                                            (#[verifier::custom_err("cannot prove this condition holds")] (receipt.valid_for(pre.root,
                                                            key)) &&
                                                    #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(Message::Define {
                                                                value,
                                                            }, receipt.result().merge(pre.memtable.query(key))))))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_root: BetreeNode = pre.root;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Put { puts } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let puts =
                                                        match tmp_for_match_0 {
                                                            Label::Put { puts } => puts,
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (puts.wf())
                                                            &&
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(puts.seq_start,
                                                                            pre.memtable.seq_end)) &&
                                                                    {
                                                                        let update_tmp_memtable: Memtable =
                                                                            pre.memtable.apply_puts(puts);

                                                                        #[verifier::custom_err("cannot prove that final value of field `memtable` has this updated value")]
                                                                        (::builtin::equal(post.memtable, update_tmp_memtable))
                                                                    }))
                                                })
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `root` is preserved")] (::builtin::equal(post.root,
                                            update_tmp_root))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put_strong(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_root: BetreeNode = pre.root;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Put { puts } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let puts =
                                                        match tmp_for_match_0 {
                                                            Label::Put { puts } => puts,
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (puts.wf())
                                                            &&
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(puts.seq_start,
                                                                            pre.memtable.seq_end)) &&
                                                                    {
                                                                        let update_tmp_memtable: Memtable =
                                                                            pre.memtable.apply_puts(puts);

                                                                        #[verifier::custom_err("cannot prove that final value of field `memtable` has this updated value")]
                                                                        (::builtin::equal(post.memtable, update_tmp_memtable))
                                                                    }))
                                                })
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `root` is preserved")] (::builtin::equal(post.root,
                                            update_tmp_root))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Put { puts } => true,
                                        _ => false,
                                    }) &&
                                {
                                    let puts =
                                        match tmp_for_match_0 {
                                            Label::Put { puts } => puts,
                                            _ => ::vstd::pervasive::arbitrary(),
                                        };
                                    (#[verifier::custom_err("cannot prove this condition holds")] (puts.wf())
                                            &&
                                            #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(puts.seq_start,
                                                    pre.memtable.seq_end)))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn freeze_as(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        let update_tmp_root: BetreeNode = pre.root;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::FreezeAs { stamped_betree } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let stamped_betree =
                                                        match tmp_for_match_0 {
                                                            Label::FreezeAs { stamped_betree } => stamped_betree,
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                                            &&
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (pre.memtable.is_empty())
                                                                    &&
                                                                    #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(stamped_betree,
                                                                            Stamped {
                                                                                value: pre.root,
                                                                                seq_end: pre.memtable.seq_end,
                                                                            }))))
                                                })
                                    }) &&
                                ((#[verifier::custom_err("cannot prove that the field `root` is preserved")] (::builtin::equal(post.root,
                                                    update_tmp_root)) &&
                                            #[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                                    update_tmp_memtable)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn freeze_as_strong(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        let update_tmp_root: BetreeNode = pre.root;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::FreezeAs { stamped_betree } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let stamped_betree =
                                                        match tmp_for_match_0 {
                                                            Label::FreezeAs { stamped_betree } => stamped_betree,
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                                            &&
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (pre.memtable.is_empty())
                                                                    &&
                                                                    #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(stamped_betree,
                                                                            Stamped {
                                                                                value: pre.root,
                                                                                seq_end: pre.memtable.seq_end,
                                                                            }))))
                                                })
                                    }) &&
                                ((#[verifier::custom_err("cannot prove that the field `root` is preserved")] (::builtin::equal(post.root,
                                                    update_tmp_root)) &&
                                            #[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                                    update_tmp_memtable)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn freeze_as_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::FreezeAs { stamped_betree } => true,
                                        _ => false,
                                    }) &&
                                {
                                    let stamped_betree =
                                        match tmp_for_match_0 {
                                            Label::FreezeAs { stamped_betree } => stamped_betree,
                                            _ => ::vstd::pervasive::arbitrary(),
                                        };
                                    (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                            &&
                                            (#[verifier::custom_err("cannot prove this condition holds")] (pre.memtable.is_empty())
                                                    &&
                                                    #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(stamped_betree,
                                                            Stamped {
                                                                value: pre.root,
                                                                seq_end: pre.memtable.seq_end,
                                                            }))))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_flush_memtable(pre: Self, post: Self,
                    lbl: Label) -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Internal {} => true,
                                        _ => false,
                                    }) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                        &&
                                        {
                                            let update_tmp_memtable: Memtable = pre.memtable.drain();
                                            let update_tmp_root: BetreeNode =
                                                pre.root.push_memtable(pre.memtable);
                                            (#[verifier::custom_err("cannot prove that final value of field `root` has this updated value")] (::builtin::equal(post.root,
                                                            update_tmp_root)) &&
                                                    #[verifier::custom_err("cannot prove that final value of field `memtable` has this updated value")] (::builtin::equal(post.memtable,
                                                            update_tmp_memtable)))
                                        }))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_flush_memtable_strong(pre: Self, post: Self,
                    lbl: Label) -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Internal {} => true,
                                        _ => false,
                                    }) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                        &&
                                        {
                                            let update_tmp_memtable: Memtable = pre.memtable.drain();
                                            let update_tmp_root: BetreeNode =
                                                pre.root.push_memtable(pre.memtable);
                                            (#[verifier::custom_err("cannot prove that final value of field `root` has this updated value")] (::builtin::equal(post.root,
                                                            update_tmp_root)) &&
                                                    #[verifier::custom_err("cannot prove that final value of field `memtable` has this updated value")] (::builtin::equal(post.memtable,
                                                            update_tmp_memtable)))
                                        }))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_flush_memtable_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Internal {} => true,
                                        _ => false,
                                    }) &&
                                #[verifier::custom_err("cannot prove this condition holds")] (pre.wf()))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_grow(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Internal {} => true,
                                                        _ => false,
                                                    }) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                                        &&
                                                        {
                                                            let update_tmp_root: BetreeNode = pre.root.grow();

                                                            #[verifier::custom_err("cannot prove that final value of field `root` has this updated value")]
                                                            (::builtin::equal(post.root, update_tmp_root))
                                                        }))
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                            update_tmp_memtable))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_grow_strong(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Internal {} => true,
                                                        _ => false,
                                                    }) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                                        &&
                                                        {
                                                            let update_tmp_root: BetreeNode = pre.root.grow();

                                                            #[verifier::custom_err("cannot prove that final value of field `root` has this updated value")]
                                                            (::builtin::equal(post.root, update_tmp_root))
                                                        }))
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                            update_tmp_memtable))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_grow_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Internal {} => true,
                                        _ => false,
                                    }) &&
                                #[verifier::custom_err("cannot prove this condition holds")] (pre.wf()))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_split(pre: Self, post: Self, lbl: Label,
                    path: Path, request: SplitRequest)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Internal {} => true,
                                                        _ => false,
                                                    }) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (path.valid())
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (path.target().can_split_parent(request))
                                                                &&
                                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.node,
                                                                                pre.root)) &&
                                                                        {
                                                                            let update_tmp_root: BetreeNode =
                                                                                path.substitute(path.target().split_parent(request));

                                                                            #[verifier::custom_err("cannot prove that final value of field `root` has this updated value")]
                                                                            (::builtin::equal(post.root, update_tmp_root))
                                                                        }))))
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                            update_tmp_memtable))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_split_strong(pre: Self, post: Self,
                    lbl: Label, path: Path, request: SplitRequest)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Internal {} => true,
                                                        _ => false,
                                                    }) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (path.valid())
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (path.target().can_split_parent(request))
                                                                &&
                                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.node,
                                                                                pre.root)) &&
                                                                        {
                                                                            let update_tmp_root: BetreeNode =
                                                                                path.substitute(path.target().split_parent(request));

                                                                            #[verifier::custom_err("cannot prove that final value of field `root` has this updated value")]
                                                                            (::builtin::equal(post.root, update_tmp_root))
                                                                        }))))
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                            update_tmp_memtable))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_split_enabled(pre: Self, lbl: Label,
                    path: Path, request: SplitRequest)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Internal {} => true,
                                        _ => false,
                                    }) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (path.valid())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (path.target().can_split_parent(request))
                                                &&
                                                #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.node,
                                                        pre.root)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_flush(pre: Self, post: Self, lbl: Label,
                    path: Path, child_idx: nat, buffer_gc: nat)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Internal {} => true,
                                                        _ => false,
                                                    }) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (path.valid())
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (path.target().can_flush(child_idx,
                                                                        buffer_gc)) &&
                                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.node,
                                                                                pre.root)) &&
                                                                        {
                                                                            let update_tmp_root: BetreeNode =
                                                                                path.substitute(path.target().flush(child_idx, buffer_gc));

                                                                            #[verifier::custom_err("cannot prove that final value of field `root` has this updated value")]
                                                                            (::builtin::equal(post.root, update_tmp_root))
                                                                        }))))
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                            update_tmp_memtable))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_flush_strong(pre: Self, post: Self,
                    lbl: Label, path: Path, child_idx: nat, buffer_gc: nat)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Internal {} => true,
                                                        _ => false,
                                                    }) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (path.valid())
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (path.target().can_flush(child_idx,
                                                                        buffer_gc)) &&
                                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.node,
                                                                                pre.root)) &&
                                                                        {
                                                                            let update_tmp_root: BetreeNode =
                                                                                path.substitute(path.target().flush(child_idx, buffer_gc));

                                                                            #[verifier::custom_err("cannot prove that final value of field `root` has this updated value")]
                                                                            (::builtin::equal(post.root, update_tmp_root))
                                                                        }))))
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                            update_tmp_memtable))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_flush_enabled(pre: Self, lbl: Label,
                    path: Path, child_idx: nat, buffer_gc: nat)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Internal {} => true,
                                        _ => false,
                                    }) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (path.valid())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (path.target().can_flush(child_idx,
                                                        buffer_gc)) &&
                                                #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.node,
                                                        pre.root)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_compact(pre: Self, post: Self, lbl: Label,
                    path: Path, start: nat, end: nat, compacted_buffer: Buffer)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Internal {} => true,
                                                        _ => false,
                                                    }) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (path.valid())
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (path.target().can_compact(start,
                                                                        end, compacted_buffer)) &&
                                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.node,
                                                                                pre.root)) &&
                                                                        {
                                                                            let update_tmp_root: BetreeNode =
                                                                                path.substitute(path.target().compact(start, end,
                                                                                        compacted_buffer));

                                                                            #[verifier::custom_err("cannot prove that final value of field `root` has this updated value")]
                                                                            (::builtin::equal(post.root, update_tmp_root))
                                                                        }))))
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                            update_tmp_memtable))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_compact_strong(pre: Self, post: Self,
                    lbl: Label, path: Path, start: nat, end: nat,
                    compacted_buffer: Buffer) -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Internal {} => true,
                                                        _ => false,
                                                    }) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (path.valid())
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (path.target().can_compact(start,
                                                                        end, compacted_buffer)) &&
                                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.node,
                                                                                pre.root)) &&
                                                                        {
                                                                            let update_tmp_root: BetreeNode =
                                                                                path.substitute(path.target().compact(start, end,
                                                                                        compacted_buffer));

                                                                            #[verifier::custom_err("cannot prove that final value of field `root` has this updated value")]
                                                                            (::builtin::equal(post.root, update_tmp_root))
                                                                        }))))
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                            update_tmp_memtable))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_compact_enabled(pre: Self, lbl: Label,
                    path: Path, start: nat, end: nat, compacted_buffer: Buffer)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Internal {} => true,
                                        _ => false,
                                    }) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (path.valid())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (path.target().can_compact(start,
                                                        end, compacted_buffer)) &&
                                                #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.node,
                                                        pre.root)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_noop(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        let update_tmp_root: BetreeNode = pre.root;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Internal {} => true,
                                                        _ => false,
                                                    }) &&
                                                #[verifier::custom_err("cannot prove this condition holds")] (pre.wf()))
                                    }) &&
                                ((#[verifier::custom_err("cannot prove that the field `root` is preserved")] (::builtin::equal(post.root,
                                                    update_tmp_root)) &&
                                            #[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                                    update_tmp_memtable)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_noop_strong(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        let update_tmp_root: BetreeNode = pre.root;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Internal {} => true,
                                                        _ => false,
                                                    }) &&
                                                #[verifier::custom_err("cannot prove this condition holds")] (pre.wf()))
                                    }) &&
                                ((#[verifier::custom_err("cannot prove that the field `root` is preserved")] (::builtin::equal(post.root,
                                                    update_tmp_root)) &&
                                            #[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                                    update_tmp_memtable)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_noop_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Internal {} => true,
                                        _ => false,
                                    }) &&
                                #[verifier::custom_err("cannot prove this condition holds")] (pre.wf()))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn initialize(post: Self, stamped_betree: StampedBetree)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (stamped_betree.value.wf())
                                &&
                                {
                                    let update_tmp_memtable: Memtable =
                                        Memtable::empty_memtable(stamped_betree.seq_end);
                                    let update_tmp_root: BetreeNode = stamped_betree.value;
                                    (#[verifier::custom_err("cannot prove that final value of field `root` has this updated value")] (::builtin::equal(post.root,
                                                    update_tmp_root)) &&
                                            #[verifier::custom_err("cannot prove that final value of field `memtable` has this updated value")] (::builtin::equal(post.memtable,
                                                    update_tmp_memtable)))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn initialize_enabled(stamped_betree: StampedBetree)
                    -> ::core::primitive::bool {
                    {

                        #[verifier::custom_err("cannot prove this condition holds")]
                        (stamped_betree.value.wf())
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_by(pre: State, post: State, label: Label,
                    step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::query(receipt) =>
                            Self::query(pre, post, label, receipt),
                        Step::put() => Self::put(pre, post, label),
                        Step::freeze_as() => Self::freeze_as(pre, post, label),
                        Step::internal_flush_memtable() =>
                            Self::internal_flush_memtable(pre, post, label),
                        Step::internal_grow() =>
                            Self::internal_grow(pre, post, label),
                        Step::internal_split(path, request) =>
                            Self::internal_split(pre, post, label, path, request),
                        Step::internal_flush(path, child_idx, buffer_gc) =>
                            Self::internal_flush(pre, post, label, path, child_idx,
                                buffer_gc),
                        Step::internal_compact(path, start, end, compacted_buffer)
                            =>
                            Self::internal_compact(pre, post, label, path, start, end,
                                compacted_buffer),
                        Step::internal_noop() =>
                            Self::internal_noop(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next(pre: State, post: State, label: Label)
                    -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                            Self::next_by(pre, post, label, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_strong_by(pre: State, post: State, label: Label,
                    step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::query(receipt) =>
                            Self::query_strong(pre, post, label, receipt),
                        Step::put() => Self::put_strong(pre, post, label),
                        Step::freeze_as() =>
                            Self::freeze_as_strong(pre, post, label),
                        Step::internal_flush_memtable() =>
                            Self::internal_flush_memtable_strong(pre, post, label),
                        Step::internal_grow() =>
                            Self::internal_grow_strong(pre, post, label),
                        Step::internal_split(path, request) =>
                            Self::internal_split_strong(pre, post, label, path,
                                request),
                        Step::internal_flush(path, child_idx, buffer_gc) =>
                            Self::internal_flush_strong(pre, post, label, path,
                                child_idx, buffer_gc),
                        Step::internal_compact(path, start, end, compacted_buffer)
                            =>
                            Self::internal_compact_strong(pre, post, label, path, start,
                                end, compacted_buffer),
                        Step::internal_noop() =>
                            Self::internal_noop_strong(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_strong(pre: State, post: State, label: Label)
                    -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                            Self::next_strong_by(pre, post, label, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn init_by(post: State, step: Config)
                    -> ::core::primitive::bool {
                    match step {
                        Config::initialize(stamped_betree) =>
                            Self::initialize(post, stamped_betree),
                        Config::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn init(post: State) -> ::core::primitive::bool {
                    ::builtin::exists(|step: Config| Self::init_by(post, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::spec]
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                pub fn invariant(&self) -> ::core::primitive::bool { true }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn wf(self) -> bool { self.root.wf() }
            }
        }
    }
    pub mod FilteredBetreeRefinement_v {
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use vstd::map::*;
        use vstd::seq_lib::*;
        use crate::spec::KeyType_t::*;
        use crate::spec::Messages_t::*;
        use crate::abstract_system::StampedMap_v::*;
        use crate::betree::Domain_v::*;
        use crate::betree::PivotTable_v::*;
        use crate::betree::Buffer_v::*;
        use crate::betree::BufferSeq_v::*;
        use crate::betree::BufferOffsets_v::*;
        use crate::betree::OffsetMap_v::*;
        use crate::betree::PivotBetree_v;
        use crate::betree::PivotBetree_v::PivotBetree;
        use crate::betree::FilteredBetree_v::*;
        use crate::betree::SplitRequest_v::*;
        #[verus::internal(verus_macro)]
        impl BetreeNode {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i_buffer(self) -> Buffer {
                ::builtin::recommends([self.wf(), self.is_Node()]);
                let offset_map = self.make_offset_map();
                self.get_Node_buffers().i_filtered(offset_map)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn i_children_seq(self, start: int)
                -> Seq<PivotBetree_v::BetreeNode> {
                ::builtin::recommends([self.is_Node(),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        start), self.get_Node_children().len()))]);
                ::builtin::decreases((self, ::builtin::spec_literal_nat("0"),
                        (self.get_Node_children().len()).spec_sub(start)));
                ::builtin::decreases_when(self.is_Node() &&
                        ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                    start), self.get_Node_children().len())));
                if ::builtin::spec_eq(start, self.get_Node_children().len()) {
                        ::vstd::seq::Seq::empty()
                    } else {
                       let child = self.get_Node_children().spec_index(start).i();
                       (::vstd::seq::Seq::empty().push(child)).spec_add(self.i_children_seq((start).spec_add(::builtin::spec_literal_nat("1"))))
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i_children(self) -> Seq<PivotBetree_v::BetreeNode> {
                ::builtin::recommends([self.is_Node()]);
                ::builtin::decreases((self,
                        ::builtin::spec_literal_nat("1")));
                self.i_children_seq(::builtin::spec_literal_integer("0"))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> PivotBetree_v::BetreeNode {
                ::builtin::recommends([self.wf()]);
                ::builtin::decreases((self));
                if self.is_Nil() {
                        PivotBetree_v::BetreeNode::Nil {}
                    } else {
                       PivotBetree_v::BetreeNode::Node {
                           pivots: self.get_Node_pivots(),
                           buffer: self.i_buffer(),
                           children: self.i_children(),
                       }
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn i_children_seq_lemma(self, start: int) {
                ::builtin::requires([self.wf(), self.is_Node(),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        start), self.get_Node_children().len()))]);
                ::builtin::ensures([::builtin::spec_eq(self.i_children_seq(start).len(),
                                (self.get_Node_children().len()).spec_sub(start)),
                            ::builtin::forall(|i: int|
                                    ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                    i), self.i_children_seq(start).len())),
                                        {
                                            ((#[verus::internal(trigger)] self.i_children_seq(start).spec_index(i)).wf())
                                                &&
                                                (::builtin::spec_eq(self.i_children_seq(start).spec_index(i),
                                                        self.get_Node_children().spec_index((i).spec_add(start)).i()))
                                        }))]);
                ::builtin::decreases((self, ::builtin::spec_literal_nat("0"),
                        (self.get_Node_children().len()).spec_sub(start)));
                if (start).spec_lt(self.get_Node_children().len()) {
                        let result = self.i_children_seq(start);
                        let child = self.get_Node_children().spec_index(start);
                        let sub_seq =
                            self.i_children_seq((start).spec_add(::builtin::spec_literal_nat("1")));
                        ::builtin::assert_(self.valid_child_index(::builtin::spec_cast_integer::<_,
                                        nat>(start)));
                        child.i_wf();
                        self.i_children_seq_lemma((start).spec_add(::builtin::spec_literal_nat("1")));
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn i_children_lemma(self) {
                ::builtin::requires([self.is_Node(), self.wf()]);
                ::builtin::ensures([self.i().wf_children(),
                            ::builtin::spec_eq(self.get_Node_children().len(),
                                self.i_children().len()),
                            ::builtin::forall(|i|
                                    ::builtin::imply((#[verus::internal(trigger)] self.valid_child_index(i)),
                                        ::builtin::spec_eq(self.i_children().spec_index(::builtin::spec_cast_integer::<_,
                                                        int>(i)),
                                            self.get_Node_children().spec_index(::builtin::spec_cast_integer::<_,
                                                            int>(i)).i())))]);
                ::builtin::decreases((self,
                        ::builtin::spec_literal_nat("1")));
                self.i_children_seq_lemma(::builtin::spec_literal_integer("0"));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn i_children_lemma_auto() {
                ::builtin::ensures([::builtin::forall(|node: Self|
                                    ::builtin::imply(node.wf() && node.is_Node(),
                                        {
                                            ((node.i().wf_children()) &&
                                                        (::builtin::spec_eq((#[verus::internal(trigger)] node.get_Node_children()).len(),
                                                                node.i_children().len()))) &&
                                                (::builtin::forall(|i|
                                                            ::builtin::imply(node.valid_child_index(i),
                                                                ::builtin::spec_eq((#[verus::internal(trigger)] node.i_children().spec_index(::builtin::spec_cast_integer::<_,
                                                                                    int>(i))),
                                                                    node.get_Node_children().spec_index(::builtin::spec_cast_integer::<_,
                                                                                    int>(i)).i()))))
                                        }))]);
                {
                    ::builtin::assert_forall_by(|node: Self|
                            {
                                ::builtin::requires(node.wf() && node.is_Node());
                                ::builtin::ensures({
                                        ((node.i().wf_children()) &&
                                                    (::builtin::spec_eq((#[verus::internal(trigger)] node.get_Node_children()).len(),
                                                            node.i_children().len()))) &&
                                            (::builtin::forall(|i|
                                                        ::builtin::imply((#[verus::internal(trigger)] node.valid_child_index(i)),
                                                            ::builtin::spec_eq(node.i_children().spec_index(::builtin::spec_cast_integer::<_,
                                                                            int>(i)),
                                                                node.get_Node_children().spec_index(::builtin::spec_cast_integer::<_,
                                                                                int>(i)).i()))))
                                    });
                                node.i_children_lemma();
                            });
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn i_wf(self) {
                ::builtin::requires([self.wf()]);
                ::builtin::ensures([self.i().wf(),
                            ::builtin::imply(self.is_Node(),
                                ::builtin::spec_eq(self.my_domain(),
                                    self.i().my_domain()))]);
                ::builtin::decreases((self,
                        ::builtin::spec_literal_nat("2")));
                if self.is_Node() {
                        self.i_children_lemma();
                        ::builtin::assert_(self.wf_children());
                        {
                            ::builtin::assert_forall_by(|i|
                                    {
                                        ::builtin::requires(((#[verus::internal(trigger)] self.i().valid_child_index(i))
                                                        &&
                                                        self.i().get_Node_children().spec_index(::builtin::spec_cast_integer::<_,
                                                                        int>(i)).is_Node() &&
                                                    self.i().get_Node_children().spec_index(::builtin::spec_cast_integer::<_,
                                                                    int>(i)).local_structure()));
                                        ::builtin::ensures({
                                                ::builtin::spec_eq(self.i().get_Node_children().spec_index(::builtin::spec_cast_integer::<_,
                                                                    int>(i)).my_domain(), self.child_domain(i))
                                            });
                                        ::builtin::assert_(self.valid_child_index(i));
                                    });
                        }
                        ::builtin::assert_(self.i().wf_children());
                        ::builtin::assert_(self.i().linked_children());
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn i_wf_auto() {
                ::builtin::ensures([::builtin::forall(|node: Self|
                                    ::builtin::imply(node.wf(),
                                        {
                                            ((#[verus::internal(trigger)] node.i()).wf()) &&
                                                (::builtin::imply(node.is_Node(),
                                                        ::builtin::spec_eq(node.my_domain(), node.i().my_domain())))
                                        }))]);
                {
                    ::builtin::assert_forall_by(|node: Self|
                            {
                                ::builtin::requires(node.wf());
                                ::builtin::ensures({
                                        ((#[verus::internal(trigger)] node.i()).wf()) &&
                                            (::builtin::imply(node.is_Node(),
                                                    ::builtin::spec_eq(node.my_domain(), node.i().my_domain())))
                                    });
                                node.i_wf();
                            });
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn i_buffer_domain(self) {
                ::builtin::requires([self.wf(), self.is_Node()]);
                ::builtin::ensures([::builtin::forall(|k|
                                    ::builtin::spec_eq((#[verus::internal(trigger)] self.i_buffer().map.contains_key(k)),
                                        (::builtin::exists(|idx|
                                                    self.get_Node_buffers().key_in_buffer_filtered(self.make_offset_map(),
                                                        ::builtin::spec_literal_integer("0"), k, idx)))))]);
                self.get_Node_buffers().i_filtered_from_domain(self.make_offset_map(),
                    ::builtin::spec_literal_integer("0"));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn query_from_refines(self, key: Key) {
                ::builtin::requires([self.wf(), self.is_Node(),
                            self.key_in_domain(key)]);
                ::builtin::ensures([::builtin::spec_eq(self.get_Node_buffers().query_from(key,
                                    ::builtin::spec_cast_integer::<_,
                                            int>(self.flushed_ofs(key))),
                                self.i().get_Node_buffer().query(key))]);
                PivotTable::route_lemma_auto();
                let offset_map = self.make_offset_map();
                self.get_Node_buffers().query_from_same_as_i_filtered(key,
                    ::builtin::spec_literal_integer("0"), offset_map);
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn query_from_refines_auto() {
                ::builtin::ensures([::builtin::forall(|k: Key,
                                    node: BetreeNode|
                                    #[verus::internal(auto_trigger)] (::builtin::imply(node.wf()
                                                    && node.is_Node() && node.key_in_domain(k),
                                            ::builtin::spec_eq(node.get_Node_buffers().query_from(k,
                                                    ::builtin::spec_cast_integer::<_,
                                                            int>(node.flushed_ofs(k))),
                                                node.i().get_Node_buffer().query(k)))))]);
                {
                    ::builtin::assert_forall_by(|k: Key, node: BetreeNode|
                            {
                                ::builtin::requires(#[verus::internal(auto_trigger)] node.wf()
                                            && node.is_Node() && node.key_in_domain(k));
                                ::builtin::ensures(::builtin::spec_eq(node.get_Node_buffers().query_from(k,
                                            ::builtin::spec_cast_integer::<_,
                                                    int>(node.flushed_ofs(k))),
                                        node.i().get_Node_buffer().query(k)));
                                node.query_from_refines(k);
                            });
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn children_have_matching_domains(self,
                other_children: Seq<BetreeNode>) -> bool {
                ::builtin::recommends([self.wf(), self.is_index()]);
                (::builtin::spec_eq(other_children.len(),
                            self.get_Node_children().len())) &&
                    ((::builtin::forall(|i|
                                    ::builtin::imply((#[verus::internal(trigger)] self.valid_child_index(i)),
                                        {
                                            ((other_children.spec_index(::builtin::spec_cast_integer::<_,
                                                                            int>(i)).wf()) &&
                                                        (other_children.spec_index(::builtin::spec_cast_integer::<_,
                                                                            int>(i)).is_Node())) &&
                                                (::builtin::spec_eq(other_children.spec_index(::builtin::spec_cast_integer::<_,
                                                                        int>(i)).my_domain(),
                                                        self.get_Node_children().spec_index(::builtin::spec_cast_integer::<_,
                                                                        int>(i)).my_domain()))
                                        }))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn i_preserves_domain(self, other: BetreeNode, k: Key) {
                ::builtin::requires([self.key_in_domain(k),
                            other.key_in_domain(k),
                            ::builtin::spec_eq(self.flushed_ofs(k),
                                other.flushed_ofs(k)),
                            ::builtin::spec_eq(self.get_Node_buffers(),
                                other.get_Node_buffers())]);
                ::builtin::ensures([::builtin::spec_eq(self.i().get_Node_buffer().map.contains_key(k),
                                other.i().get_Node_buffer().map.contains_key(k)),
                            ::builtin::imply(self.i().get_Node_buffer().map.contains_key(k),
                                ::builtin::spec_eq(self.i().get_Node_buffer().map.spec_index(k),
                                    other.i().get_Node_buffer().map.spec_index(k)))]);
                self.i_buffer_domain();
                other.i_buffer_domain();
                if self.i().get_Node_buffer().map.contains_key(k) {
                        let idx =
                            ::builtin::choose(|idx|
                                    self.get_Node_buffers().key_in_buffer_filtered(self.make_offset_map(),
                                        ::builtin::spec_literal_integer("0"), k, idx));
                        ::builtin::assert_(other.get_Node_buffers().key_in_buffer_filtered(other.make_offset_map(),
                                ::builtin::spec_literal_integer("0"), k, idx));
                        ::builtin::assert_(other.i().get_Node_buffer().map.contains_key(k));
                    }
                if other.i().get_Node_buffer().map.contains_key(k) {
                        let idx =
                            ::builtin::choose(|idx|
                                    other.get_Node_buffers().key_in_buffer_filtered(other.make_offset_map(),
                                        ::builtin::spec_literal_integer("0"), k, idx));
                        ::builtin::assert_(self.get_Node_buffers().key_in_buffer_filtered(self.make_offset_map(),
                                ::builtin::spec_literal_integer("0"), k, idx));
                        ::builtin::assert_(self.i().get_Node_buffer().map.contains_key(k));
                    }
                BetreeNode::query_from_refines_auto();
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn i_preserves_domain_auto(self) {
                ::builtin::ensures([::builtin::forall(|other: Self, k: Key|
                                    #[verus::internal(auto_trigger)] (::builtin::imply(self.key_in_domain(k)
                                                        && other.key_in_domain(k) &&
                                                    ::builtin::spec_eq(self.flushed_ofs(k),
                                                        other.flushed_ofs(k)) &&
                                                ::builtin::spec_eq(self.get_Node_buffers(),
                                                    other.get_Node_buffers()),
                                            ({
                                                    (::builtin::spec_eq(self.i().get_Node_buffer().map.contains_key(k),
                                                                other.i().get_Node_buffer().map.contains_key(k))) &&
                                                        (::builtin::imply(self.i().get_Node_buffer().map.contains_key(k),
                                                                ::builtin::spec_eq(self.i().get_Node_buffer().map.spec_index(k),
                                                                    other.i().get_Node_buffer().map.spec_index(k))))
                                                }))))]);
                {
                    ::builtin::assert_forall_by(|other: Self, k: Key|
                            {
                                ::builtin::requires(#[verus::internal(auto_trigger)] self.key_in_domain(k)
                                                && other.key_in_domain(k) &&
                                            ::builtin::spec_eq(self.flushed_ofs(k),
                                                other.flushed_ofs(k)) &&
                                        ::builtin::spec_eq(self.get_Node_buffers(),
                                            other.get_Node_buffers()));
                                ::builtin::ensures(({
                                            (::builtin::spec_eq(self.i().get_Node_buffer().map.contains_key(k),
                                                        other.i().get_Node_buffer().map.contains_key(k))) &&
                                                (::builtin::imply(self.i().get_Node_buffer().map.contains_key(k),
                                                        ::builtin::spec_eq(self.i().get_Node_buffer().map.spec_index(k),
                                                            other.i().get_Node_buffer().map.spec_index(k))))
                                        }));
                                self.i_preserves_domain(other, k);
                            });
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn child_domain_implies_key_in_domain(self, child_idx: nat) {
                ::builtin::requires([self.wf(), self.is_Node(),
                            (child_idx).spec_lt(self.get_Node_children().len())]);
                ::builtin::ensures([::builtin::forall(|k: Key|
                                    #[verus::internal(auto_trigger)] (::builtin::imply(self.child_domain(child_idx).contains(k),
                                            self.key_in_domain(k))))]);
                let child_domain = self.child_domain(child_idx);
                {
                    ::builtin::assert_forall_by(|k: Key|
                            {
                                ::builtin::requires(#[verus::internal(auto_trigger)] child_domain.contains(k));
                                ::builtin::ensures(self.key_in_domain(k));
                                if ::builtin::spec_eq(self.get_Node_pivots().num_ranges(),
                                            ::builtin::spec_literal_nat("1")) {
                                        ::builtin::assert_(::builtin::spec_eq(child_domain,
                                                self.my_domain()));
                                    } else {
                                       if ::builtin::spec_eq(child_idx,
                                                   ::builtin::spec_literal_nat("0")) {
                                               ::builtin::assert_(Element::lt(child_domain.get_Domain_end(),
                                                       self.my_domain().get_Domain_end()));
                                           } else if ::builtin::spec_eq((child_idx).spec_add(::builtin::spec_literal_nat("1")),
                                                  self.get_Node_pivots().num_ranges()) {
                                              ::builtin::assert_(Element::lt(self.my_domain().get_Domain_start(),
                                                      child_domain.get_Domain_start()));
                                          } else {
                                              ::builtin::assert_(Element::lt(self.my_domain().get_Domain_start(),
                                                      child_domain.get_Domain_start()));
                                              ::builtin::assert_(Element::lt(child_domain.get_Domain_end(),
                                                      self.my_domain().get_Domain_end()));
                                          }
                                   }
                            });
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn extend_buffer_seq_wf(self, buffers: BufferSeq) {
                ::builtin::requires([self.wf(), self.is_Node()]);
                ::builtin::ensures([self.extend_buffer_seq(buffers).wf()]);
                let result = self.extend_buffer_seq(buffers);
                ::builtin::assert_(self.wf_children());
                {
                    ::builtin::assert_forall_by(|i|
                            {
                                ::builtin::ensures(::builtin::imply(#[verus::internal(trigger)] result.valid_child_index(i),
                                        self.valid_child_index(i)));
                            });
                }
                ::builtin::assert_(result.wf_children());
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn extend_buffer_seq_refines_merge_buffer(self,
                buffers: BufferSeq) {
                ::builtin::requires([self.wf(), self.is_Node()]);
                ::builtin::ensures([::builtin::spec_eq(self.extend_buffer_seq(buffers).i(),
                                self.i().merge_buffer(buffers.i().apply_filter(self.my_domain().key_set())))]);
                let filter = self.my_domain().key_set();
                let a = self.extend_buffer_seq(buffers);
                self.extend_buffer_seq_wf(buffers);
                let b =
                    self.i().merge_buffer(buffers.i().apply_filter(filter));
                BetreeNode::i_children_lemma_auto();
                ::builtin::assert_(::builtin::ext_equal(a.i().get_Node_children(),
                        b.get_Node_children()));
                let offset_map = self.make_offset_map();
                let a_offset_map = a.make_offset_map();
                self.i_buffer_domain();
                a.i_buffer_domain();
                {
                    ::builtin::assert_forall_by(|k|
                            {
                                ::builtin::ensures(({
                                            (::builtin::spec_eq((a.i().get_Node_buffer().map.contains_key(k)),
                                                        (#[verus::internal(trigger)] b.get_Node_buffer().map.contains_key(k))))
                                                &&
                                                (::builtin::imply(a.i().get_Node_buffer().map.contains_key(k),
                                                        ::builtin::spec_eq(a.i().get_Node_buffer().map.spec_index(k),
                                                            b.get_Node_buffer().map.spec_index(k))))
                                        }));
                                PivotTable::route_lemma_auto();
                                if a.i().get_Node_buffer().map.contains_key(k) {
                                        let idx =
                                            ::builtin::choose(|idx|
                                                    a.get_Node_buffers().key_in_buffer_filtered(a_offset_map,
                                                        ::builtin::spec_literal_integer("0"), k, idx));
                                        ::builtin::assert_(a.get_Node_buffers().key_in_buffer_filtered(offset_map,
                                                ::builtin::spec_literal_integer("0"), k, idx));
                                        if (idx).spec_lt(self.get_Node_buffers().len()) {
                                                ::builtin::assert_(self.get_Node_buffers().key_in_buffer_filtered(offset_map,
                                                        ::builtin::spec_literal_integer("0"), k, idx));
                                            } else {
                                               let buffer_idx =
                                                   (idx).spec_sub(self.get_Node_buffers().len());
                                               ::builtin::assert_(a.get_Node_buffers().spec_index(idx).map.contains_key(k));
                                               ::builtin::assert_(::builtin::spec_eq(a.get_Node_buffers().spec_index(idx),
                                                       buffers.spec_index(buffer_idx)));
                                               ::builtin::assert_(buffers.key_in_buffer(::builtin::spec_literal_integer("0"),
                                                       k, buffer_idx));
                                               buffers.i_from_domain(::builtin::spec_literal_integer("0"));
                                           }
                                        {
                                            ::builtin::assert_by(::builtin::spec_eq(a.i().get_Node_buffer().map.spec_index(k),
                                                    b.get_Node_buffer().map.spec_index(k)),
                                                {
                                                    a.query_from_refines(k);
                                                    self.query_from_refines(k);
                                                    buffers.query_agrees_with_i(k,
                                                        ::builtin::spec_literal_integer("0"));
                                                    ::builtin::assert_(::builtin::spec_eq(buffers.query(k),
                                                            buffers.i().query(k)));
                                                    BufferSeq::extend_buffer_seq_lemma(buffers,
                                                        self.get_Node_buffers(), k,
                                                        ::builtin::spec_cast_integer::<_,
                                                                int>(offset_map.offsets.spec_index(k)));
                                                });
                                        }
                                    }
                                if b.get_Node_buffer().map.contains_key(k) {
                                        if buffers.i().map.contains_key(k) {
                                                buffers.i_from_domain(::builtin::spec_literal_integer("0"));
                                                let buffer_idx =
                                                    ::builtin::choose(|buffer_idx|
                                                            buffers.key_in_buffer(::builtin::spec_literal_integer("0"),
                                                                k, buffer_idx));
                                                let idx =
                                                    (buffer_idx).spec_add(self.get_Node_buffers().len());
                                                ::builtin::assert_(a.get_Node_buffers().key_in_buffer_filtered(a_offset_map,
                                                        ::builtin::spec_literal_integer("0"), k, idx));
                                            } else {
                                               ::builtin::assert_(self.i().get_Node_buffer().map.contains_key(k));
                                               let idx =
                                                   ::builtin::choose(|idx|
                                                           self.get_Node_buffers().key_in_buffer_filtered(offset_map,
                                                               ::builtin::spec_literal_integer("0"), k, idx));
                                               ::builtin::assert_(a.get_Node_buffers().key_in_buffer_filtered(a_offset_map,
                                                       ::builtin::spec_literal_integer("0"), k, idx));
                                           }
                                    }
                            });
                }
                ::builtin::assert_(::builtin::ext_equal(a.i().get_Node_buffer().map.dom(),
                        b.get_Node_buffer().map.dom()));
                ::builtin::assert_(::builtin::ext_equal(a.i().get_Node_buffer(),
                        b.get_Node_buffer()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn promote_commutes_with_i(self, domain: Domain) {
                ::builtin::requires([self.wf(), domain.wf(),
                            domain.is_Domain()]);
                ::builtin::ensures([::builtin::spec_eq(self.promote(domain).i(),
                                self.i().promote(domain))]);
                BetreeNode::i_wf_auto();
                BetreeNode::i_children_lemma_auto();
                PivotTable::route_lemma_auto();
                ::builtin::assert_(::builtin::ext_equal(self.promote(domain).i().get_Node_buffer(),
                        self.i().promote(domain).get_Node_buffer()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split_element(self, request: SplitRequest) -> Element {
                ::builtin::recommends([self.can_split_parent(request)]);
                let child =
                    self.get_Node_children().spec_index(::builtin::spec_cast_integer::<_,
                                int>(request.get_child_idx()));
                match request {
                    SplitRequest::SplitLeaf { child_idx, split_key } =>
                        to_element(split_key),
                    SplitRequest::SplitIndex { child_idx, child_pivot_idx } =>
                        child.get_Node_pivots().pivots.spec_index(::builtin::spec_cast_integer::<_,
                                    int>(child_pivot_idx)),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn split_leaf_wf(self, split_key: Key) {
                ::builtin::requires([self.can_split_leaf(split_key)]);
                ::builtin::ensures([self.split_leaf(split_key).0.wf(),
                            self.split_leaf(split_key).1.wf()]);
                ::builtin::assert_(self.split_leaf(split_key).0.wf_children());
                ::builtin::assert_(self.split_leaf(split_key).1.wf_children());
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn split_index_wf(self, pivot_idx: nat) {
                ::builtin::requires([self.can_split_index(pivot_idx)]);
                ::builtin::ensures([self.split_index(pivot_idx).0.wf(),
                            self.split_index(pivot_idx).1.wf()]);
                let (new_left, new_right) = self.split_index(pivot_idx);
                {
                    ::builtin::assert_forall_by(|i|
                            {
                                ::builtin::ensures(::builtin::imply(new_left.valid_child_index(i),
                                        self.valid_child_index(i)));
                            });
                }
                {
                    ::builtin::assert_forall_by(|i|
                            {
                                ::builtin::ensures(::builtin::imply(new_right.valid_child_index(i),
                                        self.valid_child_index((i).spec_add(pivot_idx))));
                            });
                }
                ::builtin::assert_(new_left.wf_children());
                ::builtin::assert_(new_right.wf_children());
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn split_parent_wf(self, request: SplitRequest) {
                ::builtin::requires([self.can_split_parent(request)]);
                ::builtin::ensures([self.split_parent(request).wf()]);
                let child_idx = request.get_child_idx();
                let old_child =
                    self.get_Node_children().spec_index(::builtin::spec_cast_integer::<_,
                                int>(child_idx));
                let new_parent = self.split_parent(request);
                self.get_Node_pivots().insert_wf((::builtin::spec_cast_integer::<_,
                                    int>(child_idx)).spec_add(::builtin::spec_literal_nat("1")),
                    self.split_element(request));
                {
                    ::builtin::assert_forall_by(|i|
                            {
                                ::builtin::ensures(::builtin::imply(#[verus::internal(trigger)] new_parent.valid_child_index(i),
                                        ({
                                                (::builtin::imply((i).spec_lt(child_idx),
                                                            self.valid_child_index(i))) &&
                                                    (::builtin::imply((i).spec_gt((child_idx).spec_add(::builtin::spec_literal_nat("1"))),
                                                            self.valid_child_index(::builtin::spec_cast_integer::<_,
                                                                        nat>(((i).spec_sub(::builtin::spec_literal_nat("1")))))))
                                            })));
                            });
                }
                match request {
                    SplitRequest::SplitLeaf { child_idx, split_key } =>
                        old_child.split_leaf_wf(split_key),
                    SplitRequest::SplitIndex { child_idx, child_pivot_idx } =>
                        old_child.split_index_wf(child_pivot_idx),
                }
                ::builtin::assert_(new_parent.wf_children());
                ::builtin::assert_(new_parent.linked_children());
            }
            #[verifier::spinoff_prover]
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn split_leaf_commutes_with_i(self, split_key: Key) {
                ::builtin::requires([self.can_split_leaf(split_key)]);
                ::builtin::ensures([::builtin::spec_eq(self.split_leaf(split_key).0.i(),
                                self.i().split_leaf(split_key).0),
                            ::builtin::spec_eq(self.split_leaf(split_key).1.i(),
                                self.i().split_leaf(split_key).1)]);
                BetreeNode::i_wf_auto();
                PivotTable::route_lemma_auto();
                let (left, right) = self.split_leaf(split_key);
                let (i_left, i_right) = self.i().split_leaf(split_key);
                self.split_leaf_wf(split_key);
                self.i_buffer_domain();
                self.i_preserves_domain_auto();
                left.i_buffer_domain();
                right.i_buffer_domain();
                ::builtin::assert_(::builtin::ext_equal(left.i().get_Node_buffer(),
                        i_left.get_Node_buffer()));
                ::builtin::assert_(::builtin::ext_equal(right.i().get_Node_buffer(),
                        i_right.get_Node_buffer()));
                ::builtin::assert_(::builtin::ext_equal(left.i().get_Node_children(),
                        i_left.get_Node_children()));
                ::builtin::assert_(::builtin::ext_equal(right.i().get_Node_children(),
                        i_right.get_Node_children()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn split_index_commutes_with_i(self, pivot_idx: nat) {
                ::builtin::requires([self.can_split_index(pivot_idx)]);
                ::builtin::ensures([::builtin::spec_eq(self.split_index(pivot_idx).0.i(),
                                self.i().split_index(pivot_idx).0),
                            ::builtin::spec_eq(self.split_index(pivot_idx).1.i(),
                                self.i().split_index(pivot_idx).1)]);
                BetreeNode::i_wf_auto();
                PivotTable::route_lemma_auto();
                PivotTable::route_is_lemma_auto();
                Element::lt_transitive_forall();
                Element::lte_transitive_forall();
                let (left, right) = self.split_index(pivot_idx);
                let (i_left, i_right) = self.i().split_index(pivot_idx);
                self.split_index_wf(pivot_idx);
                self.i_buffer_domain();
                left.i_buffer_domain();
                right.i_buffer_domain();
                {
                    ::builtin::assert_by(::builtin::ext_equal(left.i().get_Node_buffer(),
                            i_left.get_Node_buffer()),
                        {
                            self.i_preserves_domain_auto();
                            left.i_preserves_domain_auto();
                        });
                }
                {
                    ::builtin::assert_by(::builtin::ext_equal(right.i().get_Node_buffer(),
                            i_right.get_Node_buffer()),
                        {
                            self.i_preserves_domain_auto();
                            right.i_preserves_domain_auto();
                        });
                }
                BetreeNode::i_children_lemma_auto();
                ::builtin::assert_(::builtin::ext_equal(left.i().get_Node_children(),
                        i_left.get_Node_children()));
                ::builtin::assert_(::builtin::ext_equal(right.i().get_Node_children(),
                        i_right.get_Node_children()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn split_parent_buffers_commutes_with_i(self,
                request: SplitRequest) {
                ::builtin::requires([self.can_split_parent(request),
                            self.i().can_split_parent(request)]);
                ::builtin::ensures([::builtin::spec_eq(self.i().split_parent(request).get_Node_buffer(),
                                self.split_parent(request).i().get_Node_buffer())]);
                self.split_parent_wf(request);
                self.i().split_parent_wf(request);
                BetreeNode::i_wf_auto();
                let new_parent = self.split_parent(request);
                let i_new_parent = self.i().split_parent(request);
                let split_child_idx =
                    ::builtin::spec_cast_integer::<_,
                            int>(request.get_child_idx());
                self.i_buffer_domain();
                new_parent.i_buffer_domain();
                {
                    ::builtin::assert_forall_by(|k|
                            {
                                ::builtin::ensures(({
                                            (::builtin::spec_eq((new_parent.i().get_Node_buffer().map.contains_key(k)),
                                                        (#[verus::internal(trigger)] i_new_parent.get_Node_buffer().map.contains_key(k))))
                                                &&
                                                (::builtin::imply(new_parent.i().get_Node_buffer().map.contains_key(k),
                                                        ::builtin::spec_eq(new_parent.i().get_Node_buffer().map.spec_index(k),
                                                            i_new_parent.get_Node_buffer().map.spec_index(k))))
                                        }));
                                if new_parent.i().get_Node_buffer().map.contains_key(k) {
                                        let r = new_parent.get_Node_pivots().route(k);
                                        new_parent.get_Node_pivots().route_lemma(k);
                                        if (r).spec_le(split_child_idx) {
                                                if ::builtin::spec_eq(r, split_child_idx) {
                                                        ::builtin::assert_(Element::lt(new_parent.get_Node_pivots().spec_index((r).spec_add(::builtin::spec_literal_nat("1"))),
                                                                self.get_Node_pivots().pivots.spec_index((r).spec_add(::builtin::spec_literal_nat("1")))));
                                                    }
                                                self.get_Node_pivots().route_is_lemma(k, r);
                                            } else {
                                               ::builtin::assert_(Element::lt(new_parent.get_Node_pivots().pivots.spec_index((r).spec_sub(::builtin::spec_literal_nat("1"))),
                                                       new_parent.get_Node_pivots().pivots.spec_index(r)));
                                               self.get_Node_pivots().route_is_lemma(k,
                                                   (r).spec_sub(::builtin::spec_literal_nat("1")));
                                           }
                                        ::builtin::assert_(::builtin::spec_eq(self.flushed_ofs(k),
                                                new_parent.flushed_ofs(k)));
                                        new_parent.i_preserves_domain(self, k);
                                    }
                                if i_new_parent.get_Node_buffer().map.contains_key(k) {
                                        ::builtin::assert_(self.i().get_Node_buffer().map.contains_key(k));
                                        ::builtin::assert_(self.key_in_domain(k));
                                        ::builtin::assert_(new_parent.key_in_domain(k));
                                        let r = self.get_Node_pivots().route(k);
                                        self.get_Node_pivots().route_lemma(k);
                                        if (r).spec_lt(split_child_idx) {
                                                new_parent.get_Node_pivots().route_is_lemma(k, r);
                                            } else if ::builtin::spec_eq(r, split_child_idx) {
                                               if Element::lt(to_element(k),
                                                           new_parent.get_Node_pivots().pivots.spec_index((r).spec_add(::builtin::spec_literal_nat("1"))))
                                                       {
                                                       new_parent.get_Node_pivots().route_is_lemma(k, r);
                                                   } else {
                                                      new_parent.get_Node_pivots().route_is_lemma(k,
                                                          (r).spec_add(::builtin::spec_literal_nat("1")));
                                                  }
                                           } else {
                                               new_parent.get_Node_pivots().route_is_lemma(k,
                                                   (r).spec_add(::builtin::spec_literal_nat("1")));
                                           }
                                        ::builtin::assert_(::builtin::spec_eq(self.flushed_ofs(k),
                                                new_parent.flushed_ofs(k)));
                                        self.i_preserves_domain(new_parent, k);
                                    }
                            });
                }
                ::builtin::assert_(::builtin::ext_equal(new_parent.i().get_Node_buffer().map.dom(),
                        i_new_parent.get_Node_buffer().map.dom()));
                ::builtin::assert_(::builtin::ext_equal(new_parent.i().get_Node_buffer(),
                        i_new_parent.get_Node_buffer()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn split_parent_commutes_with_i(self, request: SplitRequest) {
                ::builtin::requires([self.can_split_parent(request)]);
                ::builtin::ensures([self.i().can_split_parent(request),
                            ::builtin::spec_eq(self.i().split_parent(request),
                                self.split_parent(request).i())]);
                self.split_parent_wf(request);
                BetreeNode::i_wf_auto();
                BetreeNode::i_children_lemma_auto();
                let split_child_idx =
                    ::builtin::spec_cast_integer::<_,
                            int>(request.get_child_idx());
                let child =
                    self.get_Node_children().spec_index(::builtin::spec_cast_integer::<_,
                                int>(request.get_child_idx()));
                if request.is_SplitLeaf() {
                        child.split_leaf_commutes_with_i(request.get_SplitLeaf_split_key());
                    } else {
                       child.split_index_commutes_with_i(request.get_SplitIndex_child_pivot_idx());
                   }
                self.split_parent_buffers_commutes_with_i(request);
                ::builtin::assert_(::builtin::ext_equal(self.split_parent(request).i().get_Node_children(),
                        self.i().split_parent(request).get_Node_children()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn flush_wf(self, child_idx: nat, buffer_gc: nat) {
                ::builtin::requires([self.can_flush(child_idx, buffer_gc)]);
                ::builtin::ensures([self.flush(child_idx, buffer_gc).wf()]);
                let result = self.flush(child_idx, buffer_gc);
                let idx = ::builtin::spec_cast_integer::<_, int>(child_idx);
                let flush_upto = self.get_Node_buffers().len();
                let updated_flushed =
                    self.get_Node_flushed().update(idx, flush_upto);
                ::builtin::assert_(::builtin::spec_eq(updated_flushed.offsets.spec_index(idx),
                        flush_upto));
                updated_flushed.shift_left_preserves_lte(buffer_gc,
                    flush_upto);
                ::builtin::assert_(result.local_structure());
                let flushed_ofs =
                    self.get_Node_flushed().offsets.spec_index(idx);
                let buffers_to_child =
                    self.get_Node_buffers().slice(::builtin::spec_cast_integer::<_,
                                int>(flushed_ofs),
                        ::builtin::spec_cast_integer::<_, int>(flush_upto));
                let child = self.get_Node_children().spec_index(idx);
                let child_domain = self.child_domain(child_idx);
                let new_child =
                    child.promote(child_domain).extend_buffer_seq(buffers_to_child);
                ::builtin::assert_(child.wf());
                child.promote(child_domain).extend_buffer_seq_wf(buffers_to_child);
                ::builtin::assert_(new_child.wf());
                {
                    ::builtin::assert_forall_by(|i|
                            {
                                ::builtin::ensures(::builtin::imply(#[verus::internal(trigger)] result.valid_child_index(i),
                                        self.valid_child_index(i)));
                            });
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn flush_commutes_with_i(self, child_idx: nat,
                buffer_gc: nat) {
                ::builtin::requires([self.can_flush(child_idx, buffer_gc)]);
                ::builtin::ensures([::builtin::spec_eq(self.flush(child_idx,
                                        buffer_gc).i(), self.i().flush(child_idx))]);
                self.flush_wf(child_idx, buffer_gc);
                BetreeNode::i_wf_auto();
                BetreeNode::i_children_lemma_auto();
                PivotTable::route_lemma_auto();
                let idx = ::builtin::spec_cast_integer::<_, int>(child_idx);
                let flush_upto = self.get_Node_buffers().len();
                let flushed_ofs =
                    self.get_Node_flushed().offsets.spec_index(idx);
                let buffers_to_child =
                    self.get_Node_buffers().slice(::builtin::spec_cast_integer::<_,
                                int>(flushed_ofs),
                        ::builtin::spec_cast_integer::<_, int>(flush_upto));
                let child = self.get_Node_children().spec_index(idx);
                let child_domain = self.child_domain(child_idx);
                let new_child =
                    child.promote(child_domain).extend_buffer_seq(buffers_to_child);
                ::builtin::assert_(child.wf());
                child.promote_commutes_with_i(child_domain);
                ::builtin::assert_(::builtin::spec_eq(child.promote(child_domain).i(),
                        child.i().promote(child_domain)));
                child.promote(child_domain).extend_buffer_seq_refines_merge_buffer(buffers_to_child);
                ::builtin::assert_(::builtin::spec_eq(new_child.i(),
                        child.i().promote(child_domain).merge_buffer(buffers_to_child.i().apply_filter(child_domain.key_set()))));
                self.i_buffer_domain();
                self.child_domain_implies_key_in_domain(child_idx);
                {
                    ::builtin::assert_forall_by(|k|
                            {
                                ::builtin::requires(#[verus::internal(auto_trigger)] child_domain.contains(k));
                                ::builtin::ensures(({
                                            (::builtin::spec_eq((buffers_to_child.i().map.contains_key(k)),
                                                        (self.i_buffer().map.contains_key(k)))) &&
                                                (::builtin::spec_eq(buffers_to_child.i().query(k),
                                                        self.i_buffer().query(k)))
                                        }));
                                self.get_Node_pivots().route_is_lemma(k, idx);
                                ::builtin::assert_(::builtin::spec_eq(self.flushed_ofs(k),
                                        flushed_ofs));
                                if buffers_to_child.i().map.contains_key(k) {
                                        buffers_to_child.i_from_domain(::builtin::spec_literal_integer("0"));
                                        let buffer_idx =
                                            ::builtin::choose(|buffer_idx|
                                                    buffers_to_child.key_in_buffer(::builtin::spec_literal_integer("0"),
                                                        k, buffer_idx));
                                        ::builtin::assert_(self.get_Node_buffers().key_in_buffer(::builtin::spec_cast_integer::<_,
                                                        int>(flushed_ofs), k, (buffer_idx).spec_add(flushed_ofs)));
                                        ::builtin::assert_(self.get_Node_buffers().key_in_buffer_filtered(self.make_offset_map(),
                                                ::builtin::spec_literal_integer("0"), k,
                                                (buffer_idx).spec_add(flushed_ofs)));
                                        ::builtin::assert_(self.i_buffer().map.contains_key(k));
                                    }
                                if self.i_buffer().map.contains_key(k) {
                                        let buffer_idx =
                                            ::builtin::choose(|buffer_idx|
                                                    self.get_Node_buffers().key_in_buffer_filtered(self.make_offset_map(),
                                                        ::builtin::spec_literal_integer("0"), k, buffer_idx));
                                        ::builtin::assert_(buffers_to_child.key_in_buffer(::builtin::spec_literal_integer("0"),
                                                k, (buffer_idx).spec_sub(flushed_ofs)));
                                        buffers_to_child.i_from_domain(::builtin::spec_literal_integer("0"));
                                        ::builtin::assert_(buffers_to_child.i().map.contains_key(k));
                                    }
                                buffers_to_child.query_agrees_with_i(k,
                                    ::builtin::spec_literal_integer("0"));
                                self.query_from_refines(k);
                                ::builtin::assert_(::builtin::spec_eq(buffers_to_child.query(k),
                                        buffers_to_child.i().query(k)));
                                ::builtin::assert_(::builtin::spec_eq(self.i_buffer().query(k),
                                        self.get_Node_buffers().query_from(k,
                                            ::builtin::spec_cast_integer::<_, int>(flushed_ofs))));
                                BufferSeq::common_buffer_seqs(buffers_to_child,
                                    self.get_Node_buffers(),
                                    ::builtin::spec_literal_integer("0"),
                                    ::builtin::spec_cast_integer::<_, int>(flushed_ofs), k);
                            });
                }
                ::builtin::assert_(::builtin::ext_equal(buffers_to_child.i().apply_filter(child_domain.key_set()),
                        self.i_buffer().apply_filter(child_domain.key_set())));
                ::builtin::assert_(::builtin::ext_equal(self.flush(child_idx,
                                    buffer_gc).i().get_Node_children(),
                        self.i().flush(child_idx).get_Node_children()));
                let a = self.flush(child_idx, buffer_gc);
                let b = self.i().flush(child_idx);
                let keep_keys = all_keys().difference(child_domain.key_set());
                a.i_buffer_domain();
                {
                    ::builtin::assert_forall_by(|k|
                            {
                                ::builtin::ensures(({
                                            (::builtin::spec_eq((#[verus::internal(trigger)] a.i().get_Node_buffer().map.contains_key(k)),
                                                        (b.get_Node_buffer().map.contains_key(k)))) &&
                                                (::builtin::imply(a.i().get_Node_buffer().map.contains_key(k),
                                                        ::builtin::spec_eq(a.i().get_Node_buffer().map.spec_index(k),
                                                            b.get_Node_buffer().map.spec_index(k))))
                                        }));
                                if a.i().get_Node_buffer().map.contains_key(k) {
                                        if child_domain.contains(k) {
                                                a.get_Node_pivots().route_is_lemma(k,
                                                    ::builtin::spec_cast_integer::<_, int>(child_idx));
                                                ::builtin::assert_(::builtin::spec_eq(a.flushed_ofs(k),
                                                        a.get_Node_buffers().len()));
                                                ::builtin::assert_(false);
                                            }
                                        ::builtin::assert_(keep_keys.contains(k));
                                        let idx =
                                            ::builtin::choose(|idx|
                                                    a.get_Node_buffers().key_in_buffer_filtered(a.make_offset_map(),
                                                        ::builtin::spec_literal_integer("0"), k, idx));
                                        let r = a.get_Node_pivots().route(k);
                                        ::builtin::assert_(!::builtin::spec_eq(r, child_idx));
                                        ::builtin::assert_(::builtin::spec_eq(a.flushed_ofs(k),
                                                (self.flushed_ofs(k)).spec_sub(buffer_gc)));
                                        ::builtin::assert_(self.get_Node_buffers().key_in_buffer_filtered(self.make_offset_map(),
                                                ::builtin::spec_literal_integer("0"), k,
                                                (idx).spec_add(buffer_gc)));
                                        ::builtin::assert_(b.get_Node_buffer().map.contains_key(k));
                                        self.query_from_refines(k);
                                        a.query_from_refines(k);
                                        BufferSeq::common_buffer_seqs(a.get_Node_buffers(),
                                            self.get_Node_buffers(),
                                            ::builtin::spec_cast_integer::<_, int>(a.flushed_ofs(k)),
                                            ::builtin::spec_cast_integer::<_, int>(buffer_gc), k);
                                    }
                                if b.get_Node_buffer().map.contains_key(k) {
                                        ::builtin::assert_(keep_keys.contains(k));
                                        ::builtin::assert_(self.key_in_domain(k));
                                        ::builtin::assert_(::builtin::spec_eq(a.flushed_ofs(k),
                                                (self.flushed_ofs(k)).spec_sub(buffer_gc)));
                                        let idx =
                                            ::builtin::choose(|idx|
                                                    self.get_Node_buffers().key_in_buffer_filtered(self.make_offset_map(),
                                                        ::builtin::spec_literal_integer("0"), k, idx));
                                        ::builtin::assert_(a.get_Node_buffers().key_in_buffer_filtered(a.make_offset_map(),
                                                ::builtin::spec_literal_integer("0"), k,
                                                (idx).spec_sub(buffer_gc)));
                                        ::builtin::assert_(a.i().get_Node_buffer().map.contains_key(k));
                                    }
                            });
                }
                ::builtin::assert_(::builtin::ext_equal(a.i().get_Node_buffer().map.dom(),
                        b.get_Node_buffer().map.dom()));
                ::builtin::assert_(::builtin::ext_equal(a.i().get_Node_buffer(),
                        b.get_Node_buffer()));
            }
            #[verifier::spinoff_prover]
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn compact_wf(self, start: nat, end: nat,
                compacted_buffer: Buffer) {
                ::builtin::requires([self.can_compact(start, end,
                                compacted_buffer)]);
                ::builtin::ensures([self.compact(start, end,
                                    compacted_buffer).wf()]);
                let result = self.compact(start, end, compacted_buffer);
                {
                    ::builtin::assert_forall_by(|i|
                            {
                                ::builtin::ensures(::builtin::imply(#[verus::internal(trigger)] result.valid_child_index(i),
                                        self.valid_child_index(i)));
                            });
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn compact_buffer_property(self, start: nat, end: nat,
                compacted_buffer: Buffer) {
                ::builtin::requires([self.can_compact(start, end,
                                compacted_buffer)]);
                ::builtin::ensures([::builtin::spec_eq(compacted_buffer,
                                self.get_Node_buffers().slice(::builtin::spec_cast_integer::<_,
                                                int>(start),
                                        ::builtin::spec_cast_integer::<_,
                                                int>(end)).i_filtered(self.make_offset_map().decrement(start)))]);
                let slice_ofs_map = self.make_offset_map().decrement(start);
                let compact_slice =
                    self.get_Node_buffers().slice(::builtin::spec_cast_integer::<_,
                                int>(start), ::builtin::spec_cast_integer::<_, int>(end));
                let compact_slice_i = compact_slice.i_filtered(slice_ofs_map);
                compact_slice.i_filtered_from_domain(slice_ofs_map,
                    ::builtin::spec_literal_integer("0"));
                {
                    ::builtin::assert_forall_by(|k|
                            {
                                ::builtin::requires(#[verus::internal(trigger)] compacted_buffer.map.contains_key(k));
                                ::builtin::ensures(::builtin::spec_eq(compacted_buffer.map.spec_index(k),
                                        compact_slice_i.map.spec_index(k)));
                                compact_slice.query_from_same_as_i_filtered(k,
                                    ::builtin::spec_literal_integer("0"), slice_ofs_map);
                            });
                }
                ::builtin::assert_(::builtin::ext_equal(compacted_buffer,
                        compact_slice_i));
            }
            #[verifier::spinoff_prover]
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn compact_commutes_with_i(self, start: nat, end: nat,
                compacted_buffer: Buffer) {
                ::builtin::requires([self.can_compact(start, end,
                                compacted_buffer)]);
                ::builtin::ensures([::builtin::spec_eq(self.compact(start,
                                        end, compacted_buffer).i(), self.i())]);
                let result = self.compact(start, end, compacted_buffer);
                self.compact_wf(start, end, compacted_buffer);
                BetreeNode::i_wf_auto();
                BetreeNode::i_children_lemma_auto();
                ::builtin::assert_(::builtin::ext_equal(result.i().get_Node_children(),
                        self.i().get_Node_children()));
                let ofs_map = self.make_offset_map();
                let slice_ofs_map = ofs_map.decrement(start);
                let result_ofs_map = result.make_offset_map();
                let compact_slice =
                    self.get_Node_buffers().slice(::builtin::spec_cast_integer::<_,
                                int>(start), ::builtin::spec_cast_integer::<_, int>(end));
                self.compact_buffer_property(start, end, compacted_buffer);
                {
                    ::builtin::assert_forall_by(|k|
                            {
                                ::builtin::ensures(({
                                            (::builtin::spec_eq((#[verus::internal(trigger)] result.i().get_Node_buffer().map.contains_key(k)),
                                                        (self.i().get_Node_buffer().map.contains_key(k)))) &&
                                                (::builtin::imply(result.i().get_Node_buffer().map.contains_key(k),
                                                        ::builtin::spec_eq(result.i().get_Node_buffer().map.spec_index(k),
                                                            self.i().get_Node_buffer().map.spec_index(k))))
                                        }));
                                result.i_buffer_domain();
                                self.i_buffer_domain();
                                compact_slice.i_filtered_from_domain(slice_ofs_map,
                                    ::builtin::spec_literal_integer("0"));
                                if result.i().get_Node_buffer().map.contains_key(k) {
                                        ::builtin::assert_(self.key_in_domain(k));
                                        self.get_Node_pivots().route_lemma(k);
                                        let idx =
                                            ::builtin::choose(|idx|
                                                    result.get_Node_buffers().key_in_buffer_filtered(result_ofs_map,
                                                        ::builtin::spec_literal_integer("0"), k, idx));
                                        if (idx).spec_lt(start) {
                                                ::builtin::assert_(self.get_Node_buffers().key_in_buffer_filtered(ofs_map,
                                                        ::builtin::spec_literal_integer("0"), k, idx));
                                            } else if (idx).spec_lt((start).spec_add(::builtin::spec_literal_nat("1")))
                                               {
                                               let slice_idx =
                                                   ::builtin::choose(|slice_idx|
                                                           compact_slice.key_in_buffer_filtered(slice_ofs_map,
                                                               ::builtin::spec_literal_integer("0"), k, slice_idx));
                                               ::builtin::assert_(self.get_Node_buffers().key_in_buffer_filtered(ofs_map,
                                                       ::builtin::spec_literal_integer("0"), k,
                                                       (start).spec_add(slice_idx)));
                                           } else {
                                               ::builtin::assert_(self.get_Node_buffers().key_in_buffer_filtered(ofs_map,
                                                       ::builtin::spec_literal_integer("0"), k,
                                                       (idx).spec_add((((end).spec_sub(start)).spec_sub(::builtin::spec_literal_nat("1"))))));
                                           }
                                        ::builtin::assert_(self.i().get_Node_buffer().map.contains_key(k));
                                        self.query_from_refines(k);
                                        result.query_from_refines(k);
                                        let ofs =
                                            ::builtin::spec_cast_integer::<_, int>(self.flushed_ofs(k));
                                        let compacted_bufferseq =
                                            BufferSeq {
                                                buffers: ::vstd::seq::Seq::empty().push(compacted_buffer),
                                            };
                                        ::builtin::assert_(::builtin::spec_eq(compacted_bufferseq.query_from(k,
                                                    ::builtin::spec_literal_integer("1")),
                                                Message::Update { delta: nop_delta() }));
                                        ::builtin::assert_(::builtin::spec_eq(compacted_buffer.query(k),
                                                compacted_bufferseq.query_from(k,
                                                    ::builtin::spec_literal_integer("0"))));
                                        if (ofs).spec_lt(start) {
                                                if !compacted_buffer.map.contains_key(k) {
                                                        {
                                                            ::builtin::assert_forall_by(|i|
                                                                    {
                                                                        ::builtin::requires(#[verus::internal(auto_trigger)] ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                        i), compact_slice.len())));
                                                                        ::builtin::ensures(!compact_slice.spec_index(i).map.contains_key(k));
                                                                        if compact_slice.spec_index(i).map.contains_key(k) {
                                                                                ::builtin::assert_(compact_slice.key_in_buffer_filtered(slice_ofs_map,
                                                                                        ::builtin::spec_literal_integer("0"), k, i));
                                                                                ::builtin::assert_(false);
                                                                            }
                                                                    });
                                                        }
                                                        compact_slice.not_present_query_lemma(k,
                                                            ::builtin::spec_literal_integer("0"));
                                                    }
                                                ::builtin::assert_(::builtin::spec_eq(compact_slice.query(k),
                                                        compacted_buffer.query(k)));
                                                let left =
                                                    self.get_Node_buffers().slice(::builtin::spec_literal_integer("0"),
                                                        ::builtin::spec_cast_integer::<_, int>(start));
                                                BufferSeq::extend_buffer_seq_lemma(compact_slice, left, k,
                                                    ofs);
                                                BufferSeq::extend_buffer_seq_lemma(compacted_bufferseq,
                                                    left, k, ofs);
                                                ::builtin::assert_(::builtin::ext_equal(left.extend(compact_slice),
                                                        self.get_Node_buffers().slice(::builtin::spec_literal_integer("0"),
                                                            ::builtin::spec_cast_integer::<_, int>(end))));
                                                ::builtin::assert_(::builtin::ext_equal(left.extend(compacted_bufferseq),
                                                        result.get_Node_buffers().slice(::builtin::spec_literal_integer("0"),
                                                            (::builtin::spec_cast_integer::<_,
                                                                            int>(start)).spec_add(::builtin::spec_literal_nat("1")))));
                                                let right =
                                                    self.get_Node_buffers().slice(::builtin::spec_cast_integer::<_,
                                                                int>(end),
                                                        ::builtin::spec_cast_integer::<_,
                                                                int>(self.get_Node_buffers().len()));
                                                BufferSeq::extend_buffer_seq_lemma(right,
                                                    self.get_Node_buffers().slice(::builtin::spec_literal_integer("0"),
                                                        ::builtin::spec_cast_integer::<_, int>(end)), k, ofs);
                                                BufferSeq::extend_buffer_seq_lemma(right,
                                                    result.get_Node_buffers().slice(::builtin::spec_literal_integer("0"),
                                                        (::builtin::spec_cast_integer::<_,
                                                                        int>(start)).spec_add(::builtin::spec_literal_nat("1"))), k,
                                                    ofs);
                                                ::builtin::assert_(::builtin::ext_equal(self.get_Node_buffers().slice(::builtin::spec_literal_integer("0"),
                                                                ::builtin::spec_cast_integer::<_, int>(end)).extend(right),
                                                        self.get_Node_buffers()));
                                                ::builtin::assert_(::builtin::ext_equal(result.get_Node_buffers().slice(::builtin::spec_literal_integer("0"),
                                                                (::builtin::spec_cast_integer::<_,
                                                                                int>(start)).spec_add(::builtin::spec_literal_nat("1"))).extend(right),
                                                        result.get_Node_buffers()));
                                                ::builtin::assert_(::builtin::spec_eq(result.i().get_Node_buffer().map.spec_index(k),
                                                        self.i().get_Node_buffer().map.spec_index(k)));
                                            } else if (ofs).spec_lt(end) {
                                               if !compacted_buffer.map.contains_key(k) {
                                                       {
                                                           ::builtin::assert_forall_by(|i|
                                                                   {
                                                                       ::builtin::requires(#[verus::internal(auto_trigger)] ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value((ofs).spec_sub(start)),
                                                                                       i), compact_slice.len())));
                                                                       ::builtin::ensures(!compact_slice.spec_index(i).map.contains_key(k));
                                                                       if compact_slice.spec_index(i).map.contains_key(k) {
                                                                               ::builtin::assert_(compact_slice.key_in_buffer_filtered(slice_ofs_map,
                                                                                       ::builtin::spec_literal_integer("0"), k, i));
                                                                               ::builtin::assert_(false);
                                                                           }
                                                                   });
                                                       }
                                                       compact_slice.not_present_query_lemma(k,
                                                           (ofs).spec_sub(start));
                                                   }
                                               ::builtin::assert_(::builtin::spec_eq(compact_slice.query_from(k,
                                                           (ofs).spec_sub(start)), compacted_buffer.query(k)));
                                               let right =
                                                   self.get_Node_buffers().slice(::builtin::spec_cast_integer::<_,
                                                               int>(end),
                                                       ::builtin::spec_cast_integer::<_,
                                                               int>(self.get_Node_buffers().len()));
                                               BufferSeq::extend_buffer_seq_lemma(right,
                                                   compacted_bufferseq, k,
                                                   ::builtin::spec_literal_integer("0"));
                                               BufferSeq::extend_buffer_seq_lemma(right, compact_slice, k,
                                                   (ofs).spec_sub(start));
                                               BufferSeq::common_buffer_seqs(compact_slice.extend(right),
                                                   self.get_Node_buffers(), (ofs).spec_sub(start),
                                                   ::builtin::spec_cast_integer::<_, int>(start), k);
                                               BufferSeq::common_buffer_seqs(compacted_bufferseq.extend(right),
                                                   result.get_Node_buffers(),
                                                   ::builtin::spec_literal_integer("0"),
                                                   ::builtin::spec_cast_integer::<_, int>(start), k);
                                               ::builtin::assert_(::builtin::spec_eq(result.i().get_Node_buffer().map.spec_index(k),
                                                       self.i().get_Node_buffer().map.spec_index(k)));
                                           } else {
                                               BufferSeq::common_buffer_seqs(self.get_Node_buffers(),
                                                   result.get_Node_buffers(), ofs,
                                                   ((start).spec_add(::builtin::spec_literal_nat("1"))).spec_sub(end),
                                                   k);
                                           }
                                    }
                                if self.i().get_Node_buffer().map.contains_key(k) {
                                        let idx =
                                            ::builtin::choose(|idx|
                                                    self.get_Node_buffers().key_in_buffer_filtered(ofs_map,
                                                        ::builtin::spec_literal_integer("0"), k, idx));
                                        result.get_Node_pivots().route_lemma(k);
                                        if (idx).spec_lt(start) {
                                                ::builtin::assert_(result.get_Node_buffers().key_in_buffer_filtered(result_ofs_map,
                                                        ::builtin::spec_literal_integer("0"), k, idx));
                                            } else if (idx).spec_lt(end) {
                                               ::builtin::assert_(compact_slice.key_in_buffer_filtered(slice_ofs_map,
                                                       ::builtin::spec_literal_integer("0"), k,
                                                       (idx).spec_sub(start)));
                                               ::builtin::assert_(result.get_Node_buffers().key_in_buffer_filtered(result_ofs_map,
                                                       ::builtin::spec_literal_integer("0"), k,
                                                       ::builtin::spec_cast_integer::<_, int>(start)));
                                           } else {
                                               ::builtin::assert_(result.get_Node_buffers().key_in_buffer_filtered(result_ofs_map,
                                                       ::builtin::spec_literal_integer("0"), k,
                                                       (idx).spec_sub((((end).spec_sub(start)).spec_sub(::builtin::spec_literal_nat("1"))))));
                                           }
                                        ::builtin::assert_(result.i().get_Node_buffer().map.contains_key(k));
                                    }
                            });
                }
                ::builtin::assert_(::builtin::ext_equal(result.i().get_Node_buffer().map.dom(),
                        self.i().get_Node_buffer().map.dom()));
                ::builtin::assert_(::builtin::ext_equal(result.i().get_Node_buffer(),
                        self.i().get_Node_buffer()));
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn i_stamped_betree(stamped: StampedBetree)
            -> PivotBetree_v::StampedBetree {
            ::builtin::recommends([stamped.value.wf()]);
            Stamped { value: stamped.value.i(), seq_end: stamped.seq_end }
        }
        #[verus::internal(verus_macro)]
        impl QueryReceiptLine {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> PivotBetree_v::QueryReceiptLine {
                ::builtin::recommends([self.wf()]);
                PivotBetree_v::QueryReceiptLine {
                    node: self.node.i(),
                    result: self.result,
                }
            }
        }
        #[verus::internal(verus_macro)]
        impl QueryReceipt {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> PivotBetree_v::QueryReceipt {
                ::builtin::recommends([self.valid()]);
                PivotBetree_v::QueryReceipt {
                    key: self.key,
                    root: self.root.i(),
                    lines: Seq::new(self.lines.len(),
                        ::builtin::closure_to_fn_spec(|i: int|
                                self.lines.spec_index(i).i())),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn i_valid(self) {
                ::builtin::requires([self.valid()]);
                ::builtin::ensures([self.i().valid()]);
                BetreeNode::i_wf_auto();
                BetreeNode::i_children_lemma_auto();
                PivotTable::route_lemma_auto();
                let i_receipt = self.i();
                {
                    ::builtin::assert_forall_by(|i|
                            {
                                ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                i),
                                            (i_receipt.lines.len()).spec_sub(::builtin::spec_literal_nat("1")))));
                                ::builtin::ensures({
                                        (#[verus::internal(trigger)] i_receipt.lines.spec_index(i).node.key_in_domain(self.key))
                                            && (i_receipt.child_linked_at(i))
                                    });
                                ::builtin::assert_(i_receipt.lines.spec_index(i).wf());
                                ::builtin::assert_(self.child_linked_at(i));
                            });
                }
                {
                    ::builtin::assert_forall_by(|i: int|
                            {
                                ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                i),
                                            (i_receipt.lines.len()).spec_sub(::builtin::spec_literal_nat("1")))));
                                ::builtin::ensures(#[verus::internal(trigger)] i_receipt.result_linked_at(i));
                                ::builtin::assert_(self.result_linked_at(i));
                                self.lines.spec_index(i).node.query_from_refines(self.key);
                            });
                }
                ::builtin::assert_(i_receipt.all_lines_wf());
            }
        }
        #[verus::internal(verus_macro)]
        impl Path {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> PivotBetree_v::Path {
                ::builtin::recommends([self.valid()]);
                PivotBetree_v::Path {
                    node: self.node.i(),
                    key: self.key,
                    depth: self.depth,
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn subpath_commutes_with_i(self) {
                ::builtin::requires([self.valid(),
                            (::builtin::spec_literal_nat("0")).spec_lt(self.depth)]);
                ::builtin::ensures([::builtin::spec_eq(self.subpath().i(),
                                self.i().subpath())]);
                self.node.i_wf();
                self.node.i_children_lemma();
                self.node.get_Node_pivots().route_lemma(self.key);
                ::builtin::assert_(self.node.valid_child_index(::builtin::spec_cast_integer::<_,
                                nat>(self.node.get_Node_pivots().route(self.key))));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn i_valid(self) {
                ::builtin::requires([self.valid()]);
                ::builtin::ensures([self.i().valid()]);
                ::builtin::decreases((self.depth));
                self.node.i_wf();
                self.node.i_children_lemma();
                if (::builtin::spec_literal_nat("0")).spec_lt(self.depth) {
                        self.subpath_commutes_with_i();
                        self.subpath().i_valid();
                        self.node.get_Node_pivots().route_lemma(self.key);
                        {
                            ::builtin::assert_forall_by(|i|
                                    {
                                        ::builtin::requires(#[verus::internal(trigger)] self.i().node.valid_child_index(i));
                                        ::builtin::ensures(self.i().node.get_Node_children().spec_index(::builtin::spec_cast_integer::<_,
                                                            int>(i)).is_Node());
                                        ::builtin::assert_(self.node.valid_child_index(i));
                                    });
                        }
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn target_wf(self) {
                ::builtin::requires([self.valid()]);
                ::builtin::ensures([self.target().wf(),
                            self.target().is_Node()]);
                ::builtin::decreases((self.depth));
                if (self.depth).spec_gt(::builtin::spec_literal_nat("0")) {
                        self.subpath().target_wf();
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn target_commutes_with_i(self) {
                ::builtin::requires([self.valid()]);
                ::builtin::ensures([self.i().valid(),
                            ::builtin::spec_eq(self.i().target(), self.target().i())]);
                ::builtin::decreases((self.depth));
                self.i_valid();
                if (::builtin::spec_literal_nat("0")).spec_lt(self.depth) {
                        self.subpath().target_commutes_with_i();
                        self.subpath_commutes_with_i();
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn substitute_preserves_wf(self, replacement: BetreeNode) {
                ::builtin::requires([self.can_substitute(replacement)]);
                ::builtin::ensures([self.substitute(replacement).wf()]);
                ::builtin::decreases((self.depth,
                        ::builtin::spec_literal_nat("1")));
                if (::builtin::spec_literal_nat("0")).spec_lt(self.depth) {
                        self.subpath().substitute_preserves_wf(replacement);
                        let result = self.substitute(replacement);
                        if result.is_Node() {
                                self.replaced_children_matching_domains(replacement);
                                ::builtin::assert_(self.node.wf_children());
                                {
                                    ::builtin::assert_forall_by(|i|
                                            {
                                                ::builtin::ensures(::builtin::imply(#[verus::internal(trigger)] result.valid_child_index(i),
                                                        self.node.valid_child_index(i)));
                                            });
                                }
                                ::builtin::assert_(result.wf_children());
                            }
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn replaced_children_matching_domains(self,
                replacement: BetreeNode) {
                ::builtin::requires([self.can_substitute(replacement),
                            (::builtin::spec_literal_nat("0")).spec_lt(self.depth)]);
                ::builtin::ensures([self.node.children_have_matching_domains(self.replaced_children(replacement))]);
                ::builtin::decreases((self.depth,
                        ::builtin::spec_literal_nat("0")));
                PivotTable::route_lemma_auto();
                self.subpath().substitute_preserves_wf(replacement);
                let old_children = self.node.get_Node_children();
                let new_children = self.replaced_children(replacement);
                ::builtin::assert_(::builtin::spec_eq(old_children.len(),
                        new_children.len()));
                if (::builtin::spec_literal_nat("0")).spec_lt(self.subpath().depth)
                        {
                        self.subpath().replaced_children_matching_domains(replacement);
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn substitute_commutes_with_i(self, replacement: BetreeNode) {
                ::builtin::requires([self.can_substitute(replacement)]);
                ::builtin::ensures([self.substitute(replacement).wf(),
                            self.i().valid(), replacement.i().wf(),
                            ::builtin::spec_eq(self.substitute(replacement).i(),
                                self.i().substitute(replacement.i()))]);
                ::builtin::decreases((self.depth));
                self.i_valid();
                self.target_wf();
                self.substitute_preserves_wf(replacement);
                replacement.i_wf();
                PivotTable::route_lemma_auto();
                BetreeNode::i_children_lemma_auto();
                if (::builtin::spec_literal_nat("0")).spec_lt(self.depth) {
                        ::builtin::assert_(self.substitute(replacement).i().wf_children());
                        self.target_commutes_with_i();
                        self.i().substitute_preserves_wf(replacement.i());
                        ::builtin::assert_(self.substitute(replacement).i().wf_children());
                        self.subpath_commutes_with_i();
                        self.subpath().substitute_commutes_with_i(replacement);
                        ::builtin::assert_(::builtin::ext_equal(self.substitute(replacement).i().get_Node_children(),
                                self.i().substitute(replacement.i()).get_Node_children()));
                        ::builtin::assert_(::builtin::ext_equal(self.substitute(replacement).make_offset_map(),
                                self.node.make_offset_map()));
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn substitute_noop(self, replacement: BetreeNode) {
                ::builtin::requires([self.valid(), replacement.wf(),
                            ::builtin::spec_eq(self.target().i(), replacement.i())]);
                ::builtin::ensures([self.substitute(replacement).wf(),
                            ::builtin::spec_eq(self.substitute(replacement).i(),
                                self.node.i())]);
                ::builtin::decreases((self.depth));
                self.target_wf();
                self.substitute_preserves_wf(replacement);
                PivotTable::route_lemma_auto();
                BetreeNode::i_children_lemma_auto();
                if (::builtin::spec_literal_nat("0")).spec_lt(self.depth) {
                        self.subpath().substitute_noop(replacement);
                        ::builtin::assert_(::builtin::ext_equal(self.substitute(replacement).i().get_Node_children(),
                                self.node.i().get_Node_children()));
                        ::builtin::assert_(::builtin::ext_equal(self.substitute(replacement).make_offset_map(),
                                self.node.make_offset_map()));
                    }
            }
        }
        #[verus::internal(verus_macro)]
        impl FilteredBetree::Label {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> PivotBetree::Label {
                match self {
                    FilteredBetree::Label::Query { end_lsn, key, value } =>
                        PivotBetree::Label::Query {
                            end_lsn: end_lsn,
                            key: key,
                            value: value,
                        },
                    FilteredBetree::Label::Put { puts } =>
                        PivotBetree::Label::Put { puts: puts },
                    FilteredBetree::Label::FreezeAs { stamped_betree } =>
                        PivotBetree::Label::FreezeAs {
                            stamped_betree: if stamped_betree.value.wf() {
                                    i_stamped_betree(stamped_betree)
                                } else { arbitrary() },
                        },
                    FilteredBetree::Label::Internal {} =>
                        PivotBetree::Label::Internal {},
                }
            }
        }
        #[verus::internal(verus_macro)]
        impl FilteredBetree::State {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn inv(self) -> bool {
                (self.wf()) &&
                    ((::builtin::imply(self.root.is_Node(),
                                ::builtin::spec_eq(self.root.my_domain(), total_domain()))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> PivotBetree::State {
                ::builtin::recommends([self.wf()]);
                PivotBetree::State {
                    root: self.root.i(),
                    memtable: self.memtable,
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn init_refines(self, stamped_betree: StampedBetree) {
                ::builtin::requires([FilteredBetree::State::initialize(self,
                                stamped_betree)]);
                ::builtin::ensures([PivotBetree::State::initialize(self.i(),
                                i_stamped_betree(stamped_betree))]);
                stamped_betree.value.i_wf();
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn query_refines(self, post: Self, lbl: FilteredBetree::Label,
                receipt: QueryReceipt) {
                ::builtin::requires([self.inv(),
                            FilteredBetree::State::query(self, post, lbl, receipt)]);
                ::builtin::ensures([post.inv(),
                            PivotBetree::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PivotBetree::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PivotBetree::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                receipt.i_valid();
                ::builtin::assert_(PivotBetree::State::next_by(self.i(),
                        post.i(), lbl.i(), PivotBetree::Step::query(receipt.i())));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn put_refines(self, post: Self, lbl: FilteredBetree::Label) {
                ::builtin::requires([self.inv(),
                            FilteredBetree::State::put(self, post, lbl)]);
                ::builtin::ensures([post.inv(),
                            PivotBetree::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PivotBetree::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PivotBetree::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::assert_(PivotBetree::State::next_by(self.i(),
                        post.i(), lbl.i(), PivotBetree::Step::put()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn freeze_as_refines(self, post: Self,
                lbl: FilteredBetree::Label) {
                ::builtin::requires([self.inv(),
                            FilteredBetree::State::freeze_as(self, post, lbl)]);
                ::builtin::ensures([post.inv(),
                            PivotBetree::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PivotBetree::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PivotBetree::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                self.root.i_wf();
                ::builtin::assert_(PivotBetree::State::next_by(self.i(),
                        post.i(), lbl.i(), PivotBetree::Step::freeze_as()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn internal_flush_memtable_refines(self, post: Self,
                lbl: FilteredBetree::Label) {
                ::builtin::requires([self.inv(),
                            FilteredBetree::State::internal_flush_memtable(self, post,
                                lbl)]);
                ::builtin::ensures([post.inv(),
                            PivotBetree::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PivotBetree::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PivotBetree::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                self.root.i_wf();
                self.root.promote_commutes_with_i(total_domain());
                let promote = self.root.promote(total_domain());
                let buffers =
                    BufferSeq {
                        buffers: ::vstd::seq::Seq::empty().push(self.memtable.buffer),
                    };
                promote.extend_buffer_seq_wf(buffers);
                promote.extend_buffer_seq_refines_merge_buffer(buffers);
                let a = self.root.push_memtable(self.memtable).i();
                let b = self.root.i().push_memtable(self.memtable);
                BetreeNode::i_children_lemma_auto();
                ::builtin::assert_(::builtin::ext_equal(a.get_Node_children(),
                        b.get_Node_children()));
                ::builtin::assert_(::builtin::ext_equal(buffers.i().apply_filter(total_domain().key_set()),
                        buffers.i()));
                ::builtin::assert_(::builtin::spec_eq(buffers.i_from(::builtin::spec_literal_integer("1")),
                        Buffer::empty()));
                ::builtin::assert_(::builtin::ext_equal(buffers.i(),
                        buffers.spec_index(::builtin::spec_literal_integer("0"))));
                ::builtin::assert_(::builtin::spec_eq(a.get_Node_buffer(),
                        b.get_Node_buffer()));
                ::builtin::assert_(PivotBetree::State::next_by(self.i(),
                        post.i(), lbl.i(),
                        PivotBetree::Step::internal_flush_memtable()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn internal_grow_refines(self, post: Self,
                lbl: FilteredBetree::Label) {
                ::builtin::requires([self.inv(),
                            FilteredBetree::State::internal_grow(self, post, lbl)]);
                ::builtin::ensures([post.inv(),
                            PivotBetree::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PivotBetree::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PivotBetree::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                BetreeNode::i_wf_auto();
                PivotTable::route_lemma_auto();
                post.root.i_children_lemma();
                ::builtin::assert_(::builtin::ext_equal(post.i().root,
                        self.i().root.grow()));
                ::builtin::assert_(PivotBetree::State::next_by(self.i(),
                        post.i(), lbl.i(), PivotBetree::Step::internal_grow()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn internal_split_refines(self, post: Self,
                lbl: FilteredBetree::Label, path: Path,
                request: SplitRequest) {
                ::builtin::requires([self.inv(),
                            FilteredBetree::State::internal_split(self, post, lbl, path,
                                request)]);
                ::builtin::ensures([post.inv(),
                            PivotBetree::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PivotBetree::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PivotBetree::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                BetreeNode::i_wf_auto();
                path.target().split_parent_wf(request);
                path.substitute_commutes_with_i(path.target().split_parent(request));
                path.i_valid();
                path.target_commutes_with_i();
                path.target().split_parent_commutes_with_i(request);
                ::builtin::assert_(PivotBetree::State::next_by(self.i(),
                        post.i(), lbl.i(),
                        PivotBetree::Step::internal_split(path.i(), request)));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn internal_flush_refines(self, post: Self,
                lbl: FilteredBetree::Label, path: Path, child_idx: nat,
                buffer_gc: nat) {
                ::builtin::requires([self.inv(),
                            FilteredBetree::State::internal_flush(self, post, lbl, path,
                                child_idx, buffer_gc)]);
                ::builtin::ensures([post.inv(),
                            PivotBetree::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PivotBetree::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PivotBetree::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                BetreeNode::i_wf_auto();
                path.target().flush_wf(child_idx, buffer_gc);
                path.substitute_commutes_with_i(path.target().flush(child_idx,
                        buffer_gc));
                path.i_valid();
                path.target_commutes_with_i();
                path.target().flush_commutes_with_i(child_idx, buffer_gc);
                ::builtin::assert_(PivotBetree::State::next_by(self.i(),
                        post.i(), lbl.i(),
                        PivotBetree::Step::internal_flush(path.i(), child_idx)));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn internal_compact_refines(self, post: Self,
                lbl: FilteredBetree::Label, path: Path, start: nat, end: nat,
                compacted_buffer: Buffer) {
                ::builtin::requires([self.inv(),
                            FilteredBetree::State::internal_compact(self, post, lbl,
                                path, start, end, compacted_buffer)]);
                ::builtin::ensures([post.inv(),
                            PivotBetree::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PivotBetree::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PivotBetree::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                BetreeNode::i_wf_auto();
                path.target().compact_wf(start, end, compacted_buffer);
                path.target().compact_commutes_with_i(start, end,
                    compacted_buffer);
                path.substitute_noop(path.target().compact(start, end,
                        compacted_buffer));
                ::builtin::assert_(PivotBetree::State::next_by(self.i(),
                        post.i(), lbl.i(), PivotBetree::Step::internal_noop()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn internal_noop_noop(self, post: Self,
                lbl: FilteredBetree::Label) {
                ::builtin::requires([self.inv(),
                            FilteredBetree::State::internal_noop(self, post, lbl)]);
                ::builtin::ensures([post.inv(),
                            PivotBetree::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PivotBetree::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PivotBetree::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                BetreeNode::i_wf_auto();
                ::builtin::assert_(PivotBetree::State::next_by(self.i(),
                        post.i(), lbl.i(), PivotBetree::Step::internal_noop()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn next_refines(self, post: Self,
                lbl: FilteredBetree::Label) {
                ::builtin::requires([self.inv(),
                            FilteredBetree::State::next(self, post, lbl)]);
                ::builtin::ensures([post.inv(),
                            PivotBetree::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(FilteredBetree::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(FilteredBetree::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                match ::builtin::choose(|step|
                            FilteredBetree::State::next_by(self, post, lbl, step)) {
                    FilteredBetree::Step::query(receipt) => {
                        self.query_refines(post, lbl, receipt);
                    }
                    FilteredBetree::Step::put() => {
                        self.put_refines(post, lbl);
                    }
                    FilteredBetree::Step::freeze_as() => {
                        self.freeze_as_refines(post, lbl);
                    }
                    FilteredBetree::Step::internal_flush_memtable() => {
                        self.internal_flush_memtable_refines(post, lbl);
                    }
                    FilteredBetree::Step::internal_grow() => {
                        self.internal_grow_refines(post, lbl);
                    }
                    FilteredBetree::Step::internal_split(path, split_request) =>
                        {
                        self.internal_split_refines(post, lbl, path, split_request);
                    }
                    FilteredBetree::Step::internal_flush(path, child_idx,
                        buffer_gc) => {
                        self.internal_flush_refines(post, lbl, path, child_idx,
                            buffer_gc);
                    }
                    FilteredBetree::Step::internal_compact(path, start, end,
                        compacted_buffer) => {
                        self.internal_compact_refines(post, lbl, path, start, end,
                            compacted_buffer);
                    }
                    FilteredBetree::Step::internal_noop() => {
                        self.internal_noop_noop(post, lbl);
                    }
                    _ => { ::builtin::assert_(false); }
                }
            }
        }
    }
    pub mod LinkedBetree_v {
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        use vstd::prelude::*;
        use crate::spec::KeyType_t::*;
        use crate::spec::Messages_t::*;
        use crate::disk::GenericDisk_v::*;
        use crate::betree::Buffer_v::*;
        use crate::betree::LinkedBufferSeq_v;
        use crate::betree::LinkedBufferSeq_v::BufferSeq;
        use crate::betree::BufferOffsets_v::*;
        use crate::betree::OffsetMap_v::*;
        use crate::betree::Memtable_v::*;
        use crate::betree::Domain_v::*;
        use crate::betree::PivotTable_v::*;
        use crate::betree::SplitRequest_v::*;
        use crate::abstract_system::StampedMap_v::*;
        use crate::abstract_system::MsgHistory_v::*;
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct BetreeNode {
            pub buffers: BufferSeq,
            pub pivots: PivotTable,
            pub children: Seq<Pointer>,
            pub flushed: BufferOffsets,
        }
        pub type BufferDiskView = LinkedBufferSeq_v::DiskView;
        #[verus::internal(verus_macro)]
        impl BetreeNode {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                (((self.pivots.wf()) &&
                                    (::builtin::spec_eq(self.children.len(),
                                            self.pivots.num_ranges()))) &&
                            (::builtin::spec_eq(self.children.len(),
                                    self.flushed.len()))) &&
                    (self.flushed.all_lte(self.buffers.len()))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid_child_index(self, child_idx: nat) -> bool {
                (child_idx).spec_lt(self.children.len())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn occupied_child_index(self, child_idx: nat) -> bool {
                ::builtin::recommends([self.wf()]);
                (self.valid_child_index(child_idx)) &&
                    (self.children.spec_index(::builtin::spec_cast_integer::<_,
                                        int>(child_idx)).is_Some())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn my_domain(self) -> Domain {
                ::builtin::recommends([self.wf()]);
                Domain::Domain {
                    start: self.pivots.spec_index(::builtin::spec_literal_integer("0")),
                    end: self.pivots.pivots.last(),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn child_domain(self, child_idx: nat) -> Domain {
                ::builtin::recommends([self.wf(),
                            self.valid_child_index(child_idx)]);
                Domain::Domain {
                    start: self.pivots.spec_index(::builtin::spec_cast_integer::<_,
                                int>(child_idx)),
                    end: self.pivots.spec_index((::builtin::spec_cast_integer::<_,
                                        int>(child_idx)).spec_add(::builtin::spec_literal_nat("1"))),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn extend_buffer_seq(self, buffers: BufferSeq) -> BetreeNode {
                ::builtin::recommends([self.wf()]);
                BetreeNode {
                    buffers: self.buffers.extend(buffers),
                    pivots: self.pivots,
                    children: self.children,
                    flushed: self.flushed,
                }
            }
            #[verifier::recommends_by]
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn flushed_ofs_inline_lemma(self, key: Key) {
                self.pivots.route_lemma(key);
                ::builtin::assert_(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                self.pivots.route(key)), self.flushed.offsets.len())));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn flushed_ofs(self, key: Key) -> nat {
                ::builtin::recommends([self.key_in_domain(key)]);
                recommends_by(Self::flushed_ofs_inline_lemma);
                let r = self.pivots.route(key);
                self.flushed.offsets.spec_index(r)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_leaf(self) -> bool {
                ((::builtin::spec_eq(self.children.len(),
                                    ::builtin::spec_literal_nat("1"))) &&
                            (self.children.spec_index(::builtin::spec_literal_integer("0")).is_None()))
                    &&
                    (::builtin::spec_eq(self.flushed.offsets,
                            ::vstd::seq::Seq::empty().push(::builtin::spec_literal_nat("0"))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_index(self) -> bool {
                ::builtin::forall(|i|
                        #[verus::internal(auto_trigger)] (::builtin::imply(self.valid_child_index(i),
                                self.children.spec_index(::builtin::spec_cast_integer::<_,
                                                int>(i)).is_Some())))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_split_leaf(self, split_key: Key) -> bool {
                (((self.wf()) && (self.is_leaf())) &&
                            (self.my_domain().contains(split_key))) &&
                    (!::builtin::spec_eq(self.my_domain().get_Domain_start(),
                                to_element(split_key)))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split_leaf(self, split_key: Key)
                -> (BetreeNode, BetreeNode) {
                ::builtin::recommends([self.can_split_leaf(split_key)]);
                let new_left =
                    BetreeNode {
                        buffers: self.buffers,
                        pivots: self.pivots.update(::builtin::spec_literal_integer("1"),
                            to_element(split_key)),
                        children: self.children,
                        flushed: self.flushed,
                    };
                let new_right =
                    BetreeNode {
                        buffers: self.buffers,
                        pivots: self.pivots.update(::builtin::spec_literal_integer("0"),
                            to_element(split_key)),
                        children: self.children,
                        flushed: self.flushed,
                    };
                (new_left, new_right)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_split_index(self, pivot_idx: nat) -> bool {
                ((self.wf()) && (self.is_index())) &&
                    (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_lt(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                    pivot_idx), self.pivots.num_ranges())))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split_index(self, pivot_idx: nat)
                -> (BetreeNode, BetreeNode) {
                ::builtin::recommends([self.can_split_index(pivot_idx)]);
                let idx = ::builtin::spec_cast_integer::<_, int>(pivot_idx);
                let new_left =
                    BetreeNode {
                        buffers: self.buffers,
                        pivots: self.pivots.subrange(::builtin::spec_literal_integer("0"),
                            (idx).spec_add(::builtin::spec_literal_nat("1"))),
                        children: self.children.subrange(::builtin::spec_literal_integer("0"),
                            idx),
                        flushed: self.flushed.slice(::builtin::spec_literal_integer("0"),
                            idx),
                    };
                let new_right =
                    BetreeNode {
                        buffers: self.buffers,
                        pivots: self.pivots.subrange(idx,
                            ::builtin::spec_cast_integer::<_, int>(self.pivots.len())),
                        children: self.children.subrange(idx,
                            ::builtin::spec_cast_integer::<_,
                                    int>(self.children.len())),
                        flushed: self.flushed.slice(idx,
                            ::builtin::spec_cast_integer::<_, int>(self.flushed.len())),
                    };
                (new_left, new_right)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn empty_root(domain: Domain) -> BetreeNode {
                ::builtin::recommends([domain.wf(), domain.is_Domain()]);
                BetreeNode {
                    buffers: BufferSeq::empty(),
                    pivots: domain_to_pivots(domain),
                    children: ::vstd::seq::Seq::empty().push(None),
                    flushed: BufferOffsets {
                        offsets: ::vstd::seq::Seq::empty().push(::builtin::spec_literal_integer("0")),
                    },
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn compact_key_range(self, start: nat, end: nat, k: Key,
                buffer_dv: BufferDiskView) -> bool {
                ::builtin::recommends([self.wf(),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_lt(::builtin::spec_chained_value(start),
                                        end), self.buffers.len()))]);
                ((self.key_in_domain(k)) &&
                            ((self.flushed_ofs(k)).spec_le(end))) &&
                    (::builtin::exists(|buffer_idx|
                                self.buffers.slice(::builtin::spec_cast_integer::<_,
                                                int>(start),
                                        ::builtin::spec_cast_integer::<_,
                                                int>(end)).key_in_buffer_filtered(buffer_dv,
                                    self.make_offset_map().decrement(start),
                                    ::builtin::spec_literal_integer("0"), k, buffer_idx)))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn compact_key_value(self, start: nat, end: nat, k: Key,
                buffer_dv: BufferDiskView) -> Message {
                ::builtin::recommends([self.wf(),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_lt(::builtin::spec_chained_value(start),
                                        end), self.buffers.len())),
                            self.compact_key_range(start, end, k, buffer_dv)]);
                let from =
                    if (self.flushed_ofs(k)).spec_le(start) {
                            ::builtin::spec_literal_integer("0")
                        } else { (self.flushed_ofs(k)).spec_sub(start) };
                self.buffers.slice(::builtin::spec_cast_integer::<_,
                                int>(start),
                        ::builtin::spec_cast_integer::<_,
                                int>(end)).query_from(buffer_dv, k, from)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn key_in_domain(self, key: Key) -> bool {
                (self.wf()) && (self.pivots.bounded_key(key))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn child_ptr(self, key: Key) -> Pointer {
                ::builtin::recommends([self.key_in_domain(key)]);
                self.children.spec_index(self.pivots.route(key))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn make_offset_map(self) -> OffsetMap {
                ::builtin::recommends([self.wf()]);
                OffsetMap {
                    offsets: Map::new(::builtin::closure_to_fn_spec(|k| true),
                        ::builtin::closure_to_fn_spec(|k|
                                if self.key_in_domain(k) {
                                        self.flushed_ofs(k)
                                    } else { self.buffers.len() })),
                }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct DiskView {
            pub entries: Map<Address, BetreeNode>,
        }
        #[verus::internal(verus_macro)]
        impl DiskView {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn entries_wf(self) -> bool {
                ::builtin::forall(|addr|
                        ::builtin::imply(#[verus::internal(trigger)] self.entries.contains_key(addr),
                            self.entries.spec_index(addr).wf()))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_nondangling_ptr(self, ptr: Pointer) -> bool {
                ::builtin::imply(ptr.is_Some(),
                    self.entries.contains_key(ptr.unwrap()))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn node_has_nondangling_child_ptrs(self, node: BetreeNode)
                -> bool {
                ::builtin::recommends([self.entries_wf(), node.wf()]);
                ::builtin::forall(|i|
                        ::builtin::imply(#[verus::internal(trigger)] node.valid_child_index(i),
                            self.is_nondangling_ptr(node.children.spec_index(::builtin::spec_cast_integer::<_,
                                            int>(i)))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn child_linked(self, node: BetreeNode, idx: nat) -> bool {
                ::builtin::recommends([self.entries_wf(), node.wf(),
                            node.valid_child_index(idx),
                            self.node_has_nondangling_child_ptrs(node)]);
                let child_ptr =
                    node.children.spec_index(::builtin::spec_cast_integer::<_,
                                int>(idx));
                ::builtin::imply(child_ptr.is_Some(),
                    ::builtin::spec_eq(self.entries.spec_index(child_ptr.unwrap()).my_domain(),
                        node.child_domain(idx)))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn node_has_linked_children(self, node: BetreeNode) -> bool {
                ::builtin::recommends([self.entries_wf(), node.wf(),
                            self.node_has_nondangling_child_ptrs(node)]);
                ::builtin::forall(|i|
                        ::builtin::imply(#[verus::internal(trigger)] node.valid_child_index(i),
                            self.child_linked(node, i)))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn healthy_child_ptrs(self) -> bool {
                ::builtin::recommends([self.entries_wf()]);
                ::builtin::forall(|addr|
                        ::builtin::imply(#[verus::internal(trigger)] self.entries.contains_key(addr),
                            ({
                                    (self.node_has_nondangling_child_ptrs(self.entries.spec_index(addr)))
                                        &&
                                        (self.node_has_linked_children(self.entries.spec_index(addr)))
                                })))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                ((self.entries_wf()) && (self.healthy_child_ptrs())) &&
                    (self.entries.dom().finite())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn get(self, ptr: Pointer) -> BetreeNode {
                ::builtin::recommends([self.is_nondangling_ptr(ptr),
                            ptr.is_Some()]);
                self.entries.spec_index(ptr.unwrap())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn agrees_with_disk(self, other: DiskView) -> bool {
                self.entries.agrees(other.entries)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_subdisk(self, bigger: DiskView) -> bool {
                (self.entries).spec_le(bigger.entries)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn node_children_respects_rank(self, ranking: Ranking,
                addr: Address) -> bool {
                ::builtin::recommends([self.wf(),
                            self.entries.contains_key(addr),
                            ranking.contains_key(addr)]);
                let node = self.entries.spec_index(addr);
                ::builtin::forall(|idx|
                        ::builtin::imply(#[verus::internal(trigger)] node.valid_child_index(idx)
                                &&
                                node.children.spec_index(::builtin::spec_cast_integer::<_,
                                                int>(idx)).is_Some(),
                            ({
                                    let child_addr =
                                        node.children.spec_index(::builtin::spec_cast_integer::<_,
                                                        int>(idx)).unwrap();
                                    (ranking.contains_key(child_addr)) &&
                                        ((ranking.spec_index(child_addr)).spec_lt(ranking.spec_index(addr)))
                                })))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid_ranking(self, ranking: Ranking) -> bool {
                (self.wf()) &&
                    (::builtin::forall(|addr|
                                ::builtin::imply(self.entries.contains_key(addr) &&
                                        #[verus::internal(trigger)] ranking.contains_key(addr),
                                    self.node_children_respects_rank(ranking, addr))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_fresh(self, addrs: Set<Address>) -> bool {
                self.entries.dom().disjoint(addrs)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn modify_disk(self, addr: Address, node: BetreeNode)
                -> DiskView {
                DiskView { entries: self.entries.insert(addr, node) }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn no_dangling_buffer_ptr(self, buffer_dv: BufferDiskView)
                -> bool {
                ::builtin::forall(|addr|
                        ::builtin::imply(self.entries.contains_key(addr),
                            #[verus::internal(trigger)] self.entries.spec_index(addr).buffers.valid(buffer_dv)))
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn empty_disk() -> DiskView { DiskView { entries: Map::empty() } }
        #[verus::internal(verus_macro)]
        pub struct TwoAddrs {
            pub addr1: Address,
            pub addr2: Address,
        }
        #[verus::internal(verus_macro)]
        impl TwoAddrs {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn no_duplicates(self) -> bool {
                !::builtin::spec_eq(self.addr1, self.addr2)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn repr(self) -> Set<Address> {
                ::builtin::recommends([self.no_duplicates()]);
                ::vstd::set::Set::empty().insert(self.addr1).insert(self.addr2)
            }
        }
        #[verus::internal(verus_macro)]
        pub struct SplitAddrs {
            pub left: Address,
            pub right: Address,
            pub parent: Address,
        }
        #[verus::internal(verus_macro)]
        impl SplitAddrs {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn no_duplicates(self) -> bool {
                ((!::builtin::spec_eq(self.left, self.right)) &&
                            (!::builtin::spec_eq(self.right, self.parent))) &&
                    (!::builtin::spec_eq(self.parent, self.left))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn repr(self) -> Set<Address> {
                ::builtin::recommends([self.no_duplicates()]);
                ::vstd::set::Set::empty().insert(self.left).insert(self.right).insert(self.parent)
            }
        }
        #[verus::internal(verus_macro)]
        pub struct LinkedBetree {
            pub root: Pointer,
            pub dv: DiskView,
            pub buffer_dv: BufferDiskView,
        }
        pub type StampedBetree = Stamped<LinkedBetree>;
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn empty_linked_betree() -> LinkedBetree {
            LinkedBetree {
                root: None,
                dv: empty_disk(),
                buffer_dv: LinkedBufferSeq_v::empty_disk(),
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn empty_image() -> StampedBetree {
            Stamped {
                value: empty_linked_betree(),
                seq_end: ::builtin::spec_literal_integer("0"),
            }
        }
        #[verus::internal(verus_macro)]
        impl LinkedBetree {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                ((((self.dv.wf()) && (self.buffer_dv.wf())) &&
                                    (self.dv.is_nondangling_ptr(self.root))) &&
                            (self.dv.is_fresh(self.buffer_dv.repr()))) &&
                    (self.dv.no_dangling_buffer_ptr(self.buffer_dv))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn has_root(self) -> bool {
                (self.root.is_Some()) &&
                    (self.dv.is_nondangling_ptr(self.root))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn root(self) -> BetreeNode {
                ::builtin::recommends([self.has_root()]);
                self.dv.get(self.root)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid_ranking(self, ranking: Ranking) -> bool {
                ((self.wf()) && (self.dv.valid_ranking(ranking))) &&
                    (::builtin::imply(self.has_root(),
                            ranking.contains_key(self.root.unwrap())))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn acyclic(self) -> bool {
                (self.wf()) &&
                    (::builtin::exists(|ranking| self.valid_ranking(ranking)))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn the_ranking(self) -> Ranking {
                ::builtin::recommends([self.acyclic()]);
                let ranking =
                    ::builtin::choose(|ranking| self.valid_ranking(ranking));
                ranking
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_fresh(self, addrs: Set<Address>) -> bool {
                (self.dv.is_fresh(addrs)) && (self.buffer_dv.is_fresh(addrs))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn child_at_idx(self, idx: nat) -> LinkedBetree {
                ::builtin::recommends([self.wf(), self.has_root(),
                            self.root().valid_child_index(idx)]);
                LinkedBetree {
                    root: self.root().children.spec_index(::builtin::spec_cast_integer::<_,
                                int>(idx)),
                    dv: self.dv,
                    buffer_dv: self.buffer_dv,
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn child_for_key(self, k: Key) -> LinkedBetree {
                ::builtin::recommends([self.has_root(),
                            self.root().key_in_domain(k)]);
                LinkedBetree {
                    root: self.root().child_ptr(k),
                    dv: self.dv,
                    buffer_dv: self.buffer_dv,
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn get_rank(self, ranking: Ranking) -> nat {
                ::builtin::recommends([self.wf()]);
                if self.has_root() && ranking.contains_key(self.root.unwrap())
                        {
                        (ranking.spec_index(self.root.unwrap())).spec_add(::builtin::spec_literal_nat("1"))
                    } else { ::builtin::spec_literal_integer("0") }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn child_count(self) -> nat {
                ::builtin::recommends([self.wf()]);
                if self.has_root() {
                        self.root().children.len()
                    } else { ::builtin::spec_literal_integer("0") }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_recurse_for_reachable(self, ranking: Ranking,
                child_idx: nat) -> bool {
                (((self.wf()) && (self.has_root())) &&
                            (self.valid_ranking(ranking))) &&
                    ((child_idx).spec_le(self.child_count()))
            }
            #[verifier::decreases_by]
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn reachable_addrs_using_ranking_recur_proof(self,
                ranking: Ranking, child_idx: nat) {
                if (child_idx).spec_lt(self.child_count()) {
                        ::builtin::assert_(self.root().valid_child_index(child_idx));
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn reachable_addrs_using_ranking_recur(self, ranking: Ranking,
                child_idx: nat) -> Set<Address> {
                ::builtin::recommends([self.can_recurse_for_reachable(ranking,
                                child_idx)]);
                ::builtin::decreases((self.get_rank(ranking),
                        (self.child_count()).spec_sub(child_idx)));
                ::builtin::decreases_when(self.can_recurse_for_reachable(ranking,
                        child_idx));
                ::builtin::decreases_by(Self::reachable_addrs_using_ranking_recur_proof);
                if ::builtin::spec_eq(child_idx, self.child_count()) {
                        ::vstd::set::Set::empty()
                    } else {
                       let child_addrs =
                           self.child_at_idx(child_idx).reachable_addrs_using_ranking(ranking);
                       let right_subtree_addrs =
                           self.reachable_addrs_using_ranking_recur(ranking,
                               (child_idx).spec_add(::builtin::spec_literal_nat("1")));
                       (child_addrs).spec_add(right_subtree_addrs)
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn reachable_addrs_using_ranking(self, ranking: Ranking)
                -> Set<Address> {
                ::builtin::recommends([self.wf(),
                            self.valid_ranking(ranking)]);
                ::builtin::decreases((self.get_rank(ranking)));
                ::builtin::decreases_when(self.wf() &&
                        self.valid_ranking(ranking));
                if self.has_root() {
                        let sub_tree_addrs =
                            self.reachable_addrs_using_ranking_recur(ranking,
                                ::builtin::spec_literal_integer("0"));
                        let root_addr =
                            ::vstd::set::Set::empty().insert(self.root.unwrap());
                        (root_addr).spec_add(sub_tree_addrs)
                    } else { ::vstd::set::Set::empty() }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn reachable_betree_addrs(self) -> Set<Address> {
                ::builtin::recommends([self.acyclic()]);
                self.reachable_addrs_using_ranking(self.the_ranking())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn reachable_buffer(self, addr: Address, buffer_addr: Address)
                -> bool {
                ::builtin::recommends([self.acyclic()]);
                (self.reachable_betree_addrs().contains(addr)) &&
                    (self.dv.get(Some(addr)).buffers.repr().contains(buffer_addr))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn reachable_buffer_addrs(self) -> Set<Address> {
                ::builtin::recommends([self.acyclic()]);
                let betree_addrs = self.reachable_betree_addrs();
                Set::new(::builtin::closure_to_fn_spec(|buffer_addr|
                            ::builtin::exists(|addr|
                                    self.reachable_buffer(addr, buffer_addr))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn build_tight_tree(self) -> LinkedBetree {
                if self.acyclic() {
                        let tight_dv =
                            DiskView {
                                entries: self.dv.entries.restrict(self.reachable_betree_addrs()),
                            };
                        let tight_buffer_dv =
                            BufferDiskView {
                                entries: self.buffer_dv.entries.restrict(self.reachable_buffer_addrs()),
                            };
                        LinkedBetree {
                            root: self.root,
                            dv: tight_dv,
                            buffer_dv: tight_buffer_dv,
                        }
                    } else { self }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn push_memtable(self, memtable: Memtable,
                new_addrs: TwoAddrs) -> LinkedBetree {
                ::builtin::recommends([self.wf(), new_addrs.no_duplicates(),
                            self.is_fresh(new_addrs.repr())]);
                let memtable_buffer =
                    BufferSeq {
                        buffers: ::vstd::seq::Seq::empty().push(new_addrs.addr2),
                    };
                let new_root =
                    if self.has_root() {
                            self.root().extend_buffer_seq(memtable_buffer)
                        } else {
                           BetreeNode::empty_root(total_domain()).extend_buffer_seq(memtable_buffer)
                       };
                let new_dv = self.dv.modify_disk(new_addrs.addr1, new_root);
                let new_buffer_dv =
                    self.buffer_dv.modify_disk(new_addrs.addr2,
                        memtable.buffer);
                LinkedBetree {
                    root: Some(new_addrs.addr1),
                    dv: new_dv,
                    buffer_dv: new_buffer_dv,
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn grow(self, new_root_addr: Address) -> LinkedBetree {
                ::builtin::recommends([self.wf(),
                            self.is_fresh(Set::empty().insert(new_root_addr))]);
                let new_root =
                    BetreeNode {
                        buffers: BufferSeq::empty(),
                        pivots: domain_to_pivots(total_domain()),
                        children: ::vstd::seq::Seq::empty().push(self.root),
                        flushed: BufferOffsets {
                            offsets: ::vstd::seq::Seq::empty().push(::builtin::spec_literal_integer("0")),
                        },
                    };
                let new_dv = self.dv.modify_disk(new_root_addr, new_root);
                LinkedBetree {
                    root: Some(new_root_addr),
                    dv: new_dv,
                    buffer_dv: self.buffer_dv,
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_split_parent(self, request: SplitRequest) -> bool {
                ((((self.wf()) && (self.has_root())) &&
                                    (self.root().valid_child_index(request.get_child_idx()))) &&
                            (self.child_at_idx(request.get_child_idx()).has_root())) &&
                    (match request {
                            SplitRequest::SplitLeaf { child_idx, split_key } => {
                                self.child_at_idx(child_idx).root().can_split_leaf(split_key)
                            }
                            SplitRequest::SplitIndex { child_idx, child_pivot_idx } => {
                                self.child_at_idx(child_idx).root().can_split_index(child_pivot_idx)
                            }
                        })
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split_parent(self, request: SplitRequest,
                new_addrs: SplitAddrs) -> LinkedBetree {
                ::builtin::recommends([self.can_split_parent(request)]);
                match request {
                    SplitRequest::SplitLeaf { child_idx, split_key } => {
                        let (new_left_child, new_right_child) =
                            self.child_at_idx(child_idx).root().split_leaf(split_key);
                        let new_children =
                            self.root().children.update(::builtin::spec_cast_integer::<_,
                                            int>(child_idx),
                                    Some(new_addrs.left)).insert((::builtin::spec_cast_integer::<_,
                                                int>(child_idx)).spec_add(::builtin::spec_literal_nat("1")),
                                Some(new_addrs.right));
                        let new_parent =
                            BetreeNode {
                                buffers: self.root().buffers,
                                pivots: self.root().pivots.insert((::builtin::spec_cast_integer::<_,
                                                    int>(child_idx)).spec_add(::builtin::spec_literal_nat("1")),
                                    to_element(split_key)),
                                children: new_children,
                                flushed: self.root().flushed.dup(::builtin::spec_cast_integer::<_,
                                            int>(child_idx)),
                            };
                        let new_dv =
                            self.dv.modify_disk(new_addrs.left,
                                        new_left_child).modify_disk(new_addrs.right,
                                    new_right_child).modify_disk(new_addrs.parent, new_parent);
                        LinkedBetree {
                            root: Some(new_addrs.parent),
                            dv: new_dv,
                            buffer_dv: self.buffer_dv,
                        }
                    }
                    SplitRequest::SplitIndex { child_idx, child_pivot_idx } => {
                        let (new_left_child, new_right_child) =
                            self.child_at_idx(child_idx).root().split_index(child_pivot_idx);
                        let new_children =
                            self.root().children.update(::builtin::spec_cast_integer::<_,
                                            int>(child_idx),
                                    Some(new_addrs.left)).insert((::builtin::spec_cast_integer::<_,
                                                int>(child_idx)).spec_add(::builtin::spec_literal_nat("1")),
                                Some(new_addrs.right));
                        let new_parent =
                            BetreeNode {
                                buffers: self.root().buffers,
                                pivots: self.root().pivots.insert((::builtin::spec_cast_integer::<_,
                                                    int>(child_idx)).spec_add(::builtin::spec_literal_nat("1")),
                                    self.child_at_idx(child_idx).root().pivots.spec_index(::builtin::spec_cast_integer::<_,
                                                int>(child_pivot_idx))),
                                children: new_children,
                                flushed: self.root().flushed.dup(::builtin::spec_cast_integer::<_,
                                            int>(child_idx)),
                            };
                        let new_dv =
                            self.dv.modify_disk(new_addrs.left,
                                        new_left_child).modify_disk(new_addrs.right,
                                    new_right_child).modify_disk(new_addrs.parent, new_parent);
                        LinkedBetree {
                            root: Some(new_addrs.parent),
                            dv: new_dv,
                            buffer_dv: self.buffer_dv,
                        }
                    }
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_flush(self, child_idx: nat, buffer_gc: nat) -> bool {
                (((self.wf()) && (self.has_root())) &&
                            (self.root().occupied_child_index(child_idx))) &&
                    (self.root().flushed.update(::builtin::spec_cast_integer::<_,
                                        int>(child_idx),
                                self.root().buffers.len()).all_gte(buffer_gc))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn flush(self, child_idx: nat, buffer_gc: nat,
                new_addrs: TwoAddrs) -> LinkedBetree {
                ::builtin::recommends([self.can_flush(child_idx, buffer_gc),
                            self.is_fresh(new_addrs.repr())]);
                let root = self.root();
                let flush_upto = root.buffers.len();
                let flushed_ofs =
                    root.flushed.offsets.spec_index(::builtin::spec_cast_integer::<_,
                                int>(child_idx));
                let buffers_to_child =
                    root.buffers.slice(::builtin::spec_cast_integer::<_,
                                int>(flushed_ofs),
                        ::builtin::spec_cast_integer::<_, int>(flush_upto));
                let child =
                    self.dv.get(root.children.spec_index(::builtin::spec_cast_integer::<_,
                                    int>(child_idx)));
                let new_child = child.extend_buffer_seq(buffers_to_child);
                let new_root =
                    BetreeNode {
                        buffers: root.buffers.slice(::builtin::spec_cast_integer::<_,
                                    int>(buffer_gc),
                            ::builtin::spec_cast_integer::<_, int>(flush_upto)),
                        pivots: root.pivots,
                        children: root.children.update(::builtin::spec_cast_integer::<_,
                                    int>(child_idx), Some(new_addrs.addr2)),
                        flushed: root.flushed.update(::builtin::spec_cast_integer::<_,
                                        int>(child_idx), flush_upto).shift_left(buffer_gc),
                    };
                let new_dv =
                    self.dv.modify_disk(new_addrs.addr1,
                            new_root).modify_disk(new_addrs.addr2, new_child);
                LinkedBetree {
                    root: Some(new_addrs.addr1),
                    dv: new_dv,
                    buffer_dv: self.buffer_dv,
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_compact(self, start: nat, end: nat,
                compacted_buffer: Buffer) -> bool {
                ((((self.wf()) && (self.has_root())) &&
                                    (::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_lt(::builtin::spec_chained_value(start),
                                                    end), self.root().buffers.len())))) &&
                            (::builtin::forall(|k|
                                        #[verus::internal(auto_trigger)] (::builtin::spec_eq((compacted_buffer.map.contains_key(k)),
                                                (self.root().compact_key_range(start, end, k,
                                                        self.buffer_dv))))))) &&
                    (::builtin::forall(|k|
                                #[verus::internal(auto_trigger)] (::builtin::imply(compacted_buffer.map.contains_key(k),
                                        ::builtin::spec_eq(compacted_buffer.query(k),
                                            self.root().compact_key_value(start, end, k,
                                                self.buffer_dv))))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn compact(self, start: nat, end: nat,
                compacted_buffer: Buffer, new_addrs: TwoAddrs)
                -> LinkedBetree {
                ::builtin::recommends([new_addrs.no_duplicates(),
                            self.is_fresh(new_addrs.repr()),
                            self.can_compact(start, end, compacted_buffer)]);
                let new_root =
                    BetreeNode {
                        buffers: self.root().buffers.update_subrange(::builtin::spec_cast_integer::<_,
                                    int>(start), ::builtin::spec_cast_integer::<_, int>(end),
                            new_addrs.addr2),
                        pivots: self.root().pivots,
                        children: self.root().children,
                        flushed: self.root().flushed.adjust_compact(::builtin::spec_cast_integer::<_,
                                    int>(start), ::builtin::spec_cast_integer::<_, int>(end)),
                    };
                let new_dv = self.dv.modify_disk(new_addrs.addr1, new_root);
                let new_buffer_dv =
                    self.buffer_dv.modify_disk(new_addrs.addr2,
                        compacted_buffer);
                LinkedBetree {
                    root: Some(new_addrs.addr1),
                    dv: new_dv,
                    buffer_dv: new_buffer_dv,
                }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct QueryReceiptLine {
            pub linked: LinkedBetree,
            pub result: Message,
        }
        #[verus::internal(verus_macro)]
        impl QueryReceiptLine {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool { self.result.is_Define() }
        }
        #[verus::internal(verus_macro)]
        pub struct QueryReceipt {
            pub key: Key,
            pub linked: LinkedBetree,
            pub lines: Seq<QueryReceiptLine>,
        }
        #[verus::internal(verus_macro)]
        impl QueryReceipt {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn structure(self) -> bool {
                (((((((::builtin::spec_literal_nat("0")).spec_lt(self.lines.len()))
                                                            && (self.linked.wf())) &&
                                                    (::builtin::spec_eq(self.lines.spec_index(::builtin::spec_literal_integer("0")).linked,
                                                            self.linked))) &&
                                            (::builtin::forall(|i: nat|
                                                        #[verus::internal(auto_trigger)] (::builtin::imply((i).spec_lt(self.lines.len()),
                                                                ::builtin::spec_eq(self.lines.spec_index(::builtin::spec_cast_integer::<_,
                                                                                        int>(i)).linked.dv, self.linked.dv)))))) &&
                                    (::builtin::forall(|i: nat|
                                                #[verus::internal(auto_trigger)] (::builtin::imply((i).spec_lt(self.lines.len()),
                                                        ::builtin::spec_eq(self.lines.spec_index(::builtin::spec_cast_integer::<_,
                                                                                int>(i)).linked.buffer_dv, self.linked.buffer_dv)))))) &&
                            (::builtin::forall(|i: nat|
                                        #[verus::internal(auto_trigger)] (::builtin::spec_eq((::builtin::imply((i).spec_lt(self.lines.len()),
                                                        self.lines.spec_index(::builtin::spec_cast_integer::<_,
                                                                            int>(i)).linked.has_root())),
                                                ((i).spec_lt((self.lines.len()).spec_sub(::builtin::spec_literal_nat("1")))))))))
                    &&
                    (::builtin::spec_eq(self.lines.last().result,
                            Message::Define { value: default_value() }))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn node(self, i: int) -> BetreeNode {
                ::builtin::recommends([self.structure(),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        i),
                                    (self.lines.len()).spec_sub(::builtin::spec_literal_nat("1"))))]);
                self.lines.spec_index(i).linked.root()
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn all_lines_wf(self) -> bool {
                ::builtin::recommends([self.structure()]);
                (((::builtin::forall(|i: nat|
                                                #[verus::internal(auto_trigger)] (::builtin::imply((i).spec_lt(self.lines.len()),
                                                        self.lines.spec_index(::builtin::spec_cast_integer::<_,
                                                                        int>(i)).wf())))) &&
                                    (::builtin::forall(|i: nat|
                                                #[verus::internal(auto_trigger)] (::builtin::imply((i).spec_lt(self.lines.len()),
                                                        self.lines.spec_index(::builtin::spec_cast_integer::<_,
                                                                            int>(i)).linked.acyclic()))))) &&
                            (::builtin::forall(|i: nat|
                                        #[verus::internal(auto_trigger)] (::builtin::imply((i).spec_lt((self.lines.len()).spec_sub(::builtin::spec_literal_nat("1"))),
                                                self.lines.spec_index(::builtin::spec_cast_integer::<_,
                                                                            int>(i)).linked.root().buffers.valid(self.linked.buffer_dv))))))
                    &&
                    (::builtin::forall(|i: nat|
                                #[verus::internal(auto_trigger)] (::builtin::imply((i).spec_lt((self.lines.len()).spec_sub(::builtin::spec_literal_nat("1"))),
                                        self.node(::builtin::spec_cast_integer::<_,
                                                        int>(i)).key_in_domain(self.key)))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn child_linked_at(self, i: int) -> bool {
                ::builtin::recommends([self.structure(), self.all_lines_wf(),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        i),
                                    (self.lines.len()).spec_sub(::builtin::spec_literal_nat("1"))))]);
                ::builtin::spec_eq(self.lines.spec_index((i).spec_add(::builtin::spec_literal_nat("1"))).linked.root,
                    self.node(i).child_ptr(self.key))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn result_at(self, i: int) -> Message {
                ::builtin::recommends([::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        i), self.lines.len()))]);
                self.lines.spec_index(i).result
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn result_linked_at(self, i: int) -> bool {
                ::builtin::recommends([self.structure(), self.all_lines_wf(),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        i),
                                    (self.lines.len()).spec_sub(::builtin::spec_literal_nat("1"))))]);
                let start = self.node(i).flushed_ofs(self.key);
                let msg =
                    self.node(i).buffers.query_from(self.linked.buffer_dv,
                        self.key, ::builtin::spec_cast_integer::<_, int>(start));
                ::builtin::spec_eq(self.lines.spec_index(i).result,
                    self.result_at((i).spec_add(::builtin::spec_literal_nat("1"))).merge(msg))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn result(self) -> Message {
                ::builtin::recommends([self.structure()]);
                self.result_at(::builtin::spec_literal_integer("0"))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid(self) -> bool {
                (((self.structure()) && (self.all_lines_wf())) &&
                            ((::builtin::forall(|i|
                                            #[verus::internal(auto_trigger)] (::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                i),
                                                            (self.lines.len()).spec_sub(::builtin::spec_literal_nat("1")))),
                                                    self.child_linked_at(i))))))) &&
                    ((::builtin::forall(|i|
                                    #[verus::internal(auto_trigger)] (::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                        i),
                                                    (self.lines.len()).spec_sub(::builtin::spec_literal_nat("1")))),
                                            self.result_linked_at(i))))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid_for(self, linked: LinkedBetree, key: Key) -> bool {
                ((self.valid()) && (::builtin::spec_eq(self.linked, linked)))
                    && (::builtin::spec_eq(self.key, key))
            }
        }
        pub type PathAddrs = Seq<Address>;
        #[verus::internal(verus_macro)]
        pub struct Path {
            pub linked: LinkedBetree,
            pub key: Key,
            pub depth: nat,
        }
        #[verus::internal(verus_macro)]
        impl Path {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn subpath(self) -> Path {
                ::builtin::recommends([(::builtin::spec_literal_nat("0")).spec_lt(self.depth),
                            self.linked.has_root(),
                            self.linked.root().key_in_domain(self.key)]);
                Path {
                    linked: self.linked.child_for_key(self.key),
                    key: self.key,
                    depth: ::builtin::spec_cast_integer::<_,
                            nat>(((self.depth).spec_sub(::builtin::spec_literal_nat("1")))),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid(self) -> bool {
                ::builtin::decreases((self.depth));
                ((((self.linked.has_root()) && (self.linked.acyclic())) &&
                                    (self.linked.root().key_in_domain(self.key))) &&
                            ((::builtin::imply((::builtin::spec_literal_nat("0")).spec_lt(self.depth),
                                        self.linked.root().is_index())))) &&
                    ((::builtin::imply((::builtin::spec_literal_nat("0")).spec_lt(self.depth),
                                self.subpath().valid())))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn target(self) -> LinkedBetree {
                ::builtin::recommends([self.valid()]);
                ::builtin::decreases((self.depth));
                if ::builtin::spec_eq(self.depth,
                            ::builtin::spec_literal_nat("0")) {
                        self.linked
                    } else { self.subpath().target() }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn addrs_on_path(self) -> Set<Address> {
                ::builtin::recommends([self.valid()]);
                ::builtin::decreases((self.depth));
                if ::builtin::spec_eq(self.depth,
                            ::builtin::spec_literal_nat("0")) {
                        ::vstd::set::Set::empty().insert(self.linked.root.unwrap())
                    } else {
                       (self.subpath().addrs_on_path()).spec_add(::vstd::set::Set::empty().insert(self.linked.root.unwrap()))
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn can_substitute(self, replacement: LinkedBetree,
                path_addrs: PathAddrs) -> bool {
                (((((((self.valid()) && (self.target().has_root())) &&
                                                            (replacement.wf())) && (replacement.has_root())) &&
                                            (::builtin::spec_eq(replacement.root().my_domain(),
                                                    self.target().root().my_domain()))) &&
                                    (::builtin::spec_eq(self.depth, path_addrs.len()))) &&
                            (self.linked.dv.is_subdisk(replacement.dv))) &&
                    (self.linked.buffer_dv.is_subdisk(replacement.buffer_dv))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn substitute(self, replacement: LinkedBetree,
                path_addrs: PathAddrs) -> LinkedBetree {
                ::builtin::recommends([self.can_substitute(replacement,
                                path_addrs)]);
                ::builtin::decreases((self.depth,
                        ::builtin::spec_literal_nat("1")));
                if ::builtin::spec_eq(self.depth,
                            ::builtin::spec_literal_nat("0")) {
                        replacement
                    } else {
                       let node = self.linked.root();
                       let subtree =
                           self.subpath().substitute(replacement,
                               path_addrs.subrange(::builtin::spec_literal_integer("1"),
                                   ::builtin::spec_cast_integer::<_, int>(path_addrs.len())));
                       let new_children =
                           node.children.update(node.pivots.route(self.key),
                               subtree.root);
                       let new_node =
                           BetreeNode {
                               buffers: node.buffers,
                               pivots: node.pivots,
                               children: new_children,
                               flushed: node.flushed,
                           };
                       let new_dv =
                           subtree.dv.modify_disk(path_addrs.spec_index(::builtin::spec_literal_integer("0")),
                               new_node);
                       LinkedBetree {
                           root: Some(path_addrs.spec_index(::builtin::spec_literal_integer("0"))),
                           dv: new_dv,
                           buffer_dv: replacement.buffer_dv,
                       }
                   }
            }
        }
        #[allow(unused_parens)]
        pub mod LinkedBetreeVars {
            use super::*;
            #[verus::internal(verus_macro)]
            pub struct State {
                pub memtable: Memtable,
                pub linked: LinkedBetree,
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Step {
                query(QueryReceipt),
                put(),
                freeze_as(),
                internal_flush_memtable(TwoAddrs),
                internal_grow(Address),
                internal_split(Path, SplitRequest, SplitAddrs, PathAddrs),
                internal_flush(Path, nat, nat, TwoAddrs, PathAddrs),
                internal_compact(Path, nat, nat, Buffer, TwoAddrs, PathAddrs),
                internal_noop(),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Step {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_query(&self) -> bool {
                    ::builtin::is_variant(self, "query")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_query_0(self) -> QueryReceipt {
                    ::builtin::get_variant_field(self, "query", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_put(&self) -> bool {
                    ::builtin::is_variant(self, "put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_freeze_as(&self) -> bool {
                    ::builtin::is_variant(self, "freeze_as")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_internal_flush_memtable(&self) -> bool {
                    ::builtin::is_variant(self, "internal_flush_memtable")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_flush_memtable_0(self) -> TwoAddrs {
                    ::builtin::get_variant_field(self,
                        "internal_flush_memtable", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_internal_grow(&self) -> bool {
                    ::builtin::is_variant(self, "internal_grow")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_grow_0(self) -> Address {
                    ::builtin::get_variant_field(self, "internal_grow", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_internal_split(&self) -> bool {
                    ::builtin::is_variant(self, "internal_split")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_split_0(self) -> Path {
                    ::builtin::get_variant_field(self, "internal_split", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_split_1(self) -> SplitRequest {
                    ::builtin::get_variant_field(self, "internal_split", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_split_2(self) -> SplitAddrs {
                    ::builtin::get_variant_field(self, "internal_split", "2")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_split_3(self) -> PathAddrs {
                    ::builtin::get_variant_field(self, "internal_split", "3")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_internal_flush(&self) -> bool {
                    ::builtin::is_variant(self, "internal_flush")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_flush_0(self) -> Path {
                    ::builtin::get_variant_field(self, "internal_flush", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_flush_1(self) -> nat {
                    ::builtin::get_variant_field(self, "internal_flush", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_flush_2(self) -> nat {
                    ::builtin::get_variant_field(self, "internal_flush", "2")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_flush_3(self) -> TwoAddrs {
                    ::builtin::get_variant_field(self, "internal_flush", "3")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_flush_4(self) -> PathAddrs {
                    ::builtin::get_variant_field(self, "internal_flush", "4")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_internal_compact(&self) -> bool {
                    ::builtin::is_variant(self, "internal_compact")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_compact_0(self) -> Path {
                    ::builtin::get_variant_field(self, "internal_compact", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_compact_1(self) -> nat {
                    ::builtin::get_variant_field(self, "internal_compact", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_compact_2(self) -> nat {
                    ::builtin::get_variant_field(self, "internal_compact", "2")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_compact_3(self) -> Buffer {
                    ::builtin::get_variant_field(self, "internal_compact", "3")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_compact_4(self) -> TwoAddrs {
                    ::builtin::get_variant_field(self, "internal_compact", "4")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_compact_5(self) -> PathAddrs {
                    ::builtin::get_variant_field(self, "internal_compact", "5")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_internal_noop(&self) -> bool {
                    ::builtin::is_variant(self, "internal_noop")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Config {
                initialize(StampedBetree),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Config {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_initialize(&self) -> bool {
                    ::builtin::is_variant(self, "initialize")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_initialize_0(self) -> StampedBetree {
                    ::builtin::get_variant_field(self, "initialize", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[verus::internal(verus_macro)]
            pub enum Label {
                Query {
                    end_lsn: LSN,
                    key: Key,
                    value: Value,
                },
                Put {
                    puts: MsgHistory,
                },
                FreezeAs {
                    stamped_betree: StampedBetree,
                },
                Internal {},
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Label {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_Query(&self) -> bool {
                    ::builtin::is_variant(self, "Query")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_Query_end_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "Query", "end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_Query_key(self) -> Key {
                    ::builtin::get_variant_field(self, "Query", "key")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_Query_value(self) -> Value {
                    ::builtin::get_variant_field(self, "Query", "value")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_Put(&self) -> bool {
                    ::builtin::is_variant(self, "Put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_Put_puts(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "Put", "puts")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_FreezeAs(&self) -> bool {
                    ::builtin::is_variant(self, "FreezeAs")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_FreezeAs_stamped_betree(self) -> StampedBetree {
                    ::builtin::get_variant_field(self, "FreezeAs",
                        "stamped_betree")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_Internal(&self) -> bool {
                    ::builtin::is_variant(self, "Internal")
                }
            }
            pub mod show {
                use super::*;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn query(pre: super::State, post: super::State,
                    lbl: Label, receipt: QueryReceipt) {
                    ::builtin::requires(super::State::query(pre, post, lbl,
                            receipt));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as query;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn put(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::put(pre, post, lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as put;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn freeze_as(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::freeze_as(pre, post,
                            lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as freeze_as;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn internal_flush_memtable(pre: super::State,
                    post: super::State, lbl: Label, new_addrs: TwoAddrs) {
                    ::builtin::requires(super::State::internal_flush_memtable(pre,
                            post, lbl, new_addrs));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as internal_flush_memtable;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn internal_grow(pre: super::State, post: super::State,
                    lbl: Label, new_root_addr: Address) {
                    ::builtin::requires(super::State::internal_grow(pre, post,
                            lbl, new_root_addr));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as internal_grow;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn internal_split(pre: super::State, post: super::State,
                    lbl: Label, path: Path, request: SplitRequest,
                    new_addrs: SplitAddrs, path_addrs: PathAddrs) {
                    ::builtin::requires(super::State::internal_split(pre, post,
                            lbl, path, request, new_addrs, path_addrs));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as internal_split;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn internal_flush(pre: super::State, post: super::State,
                    lbl: Label, path: Path, child_idx: nat, buffer_gc: nat,
                    new_addrs: TwoAddrs, path_addrs: PathAddrs) {
                    ::builtin::requires(super::State::internal_flush(pre, post,
                            lbl, path, child_idx, buffer_gc, new_addrs, path_addrs));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as internal_flush;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn internal_compact(pre: super::State, post: super::State,
                    lbl: Label, path: Path, start: nat, end: nat,
                    compacted_buffer: Buffer, new_addrs: TwoAddrs,
                    path_addrs: PathAddrs) {
                    ::builtin::requires(super::State::internal_compact(pre,
                            post, lbl, path, start, end, compacted_buffer, new_addrs,
                            path_addrs));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as internal_compact;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn internal_noop(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::internal_noop(pre, post,
                            lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as internal_noop;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn initialize(post: super::State,
                    stamped_betree: StampedBetree) {
                    ::builtin::requires(super::State::initialize(post,
                            stamped_betree));
                    ::builtin::ensures(super::State::init(post));
                }
                use bool as initialize;
            }
            pub mod take_step {
                use super::*;
            }
            #[verus::internal(verus_macro)]
            impl State {
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query(pre: Self, post: Self, lbl: Label,
                    receipt: QueryReceipt) -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        let update_tmp_linked: LinkedBetree = pre.linked;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Query { end_lsn, key, value } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let (end_lsn, key, value) =
                                                        match tmp_for_match_0 {
                                                            Label::Query { end_lsn, key, value } =>
                                                                (end_lsn, key, value),
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(end_lsn,
                                                                    pre.memtable.seq_end)) &&
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (receipt.valid_for(pre.linked,
                                                                            key)) &&
                                                                    #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(Message::Define {
                                                                                value,
                                                                            }, receipt.result().merge(pre.memtable.query(key))))))
                                                })
                                    }) &&
                                ((#[verifier::custom_err("cannot prove that the field `linked` is preserved")] (::builtin::equal(post.linked,
                                                    update_tmp_linked)) &&
                                            #[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                                    update_tmp_memtable)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_strong(pre: Self, post: Self, lbl: Label,
                    receipt: QueryReceipt) -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        let update_tmp_linked: LinkedBetree = pre.linked;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Query { end_lsn, key, value } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let (end_lsn, key, value) =
                                                        match tmp_for_match_0 {
                                                            Label::Query { end_lsn, key, value } =>
                                                                (end_lsn, key, value),
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(end_lsn,
                                                                    pre.memtable.seq_end)) &&
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (receipt.valid_for(pre.linked,
                                                                            key)) &&
                                                                    #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(Message::Define {
                                                                                value,
                                                                            }, receipt.result().merge(pre.memtable.query(key))))))
                                                })
                                    }) &&
                                ((#[verifier::custom_err("cannot prove that the field `linked` is preserved")] (::builtin::equal(post.linked,
                                                    update_tmp_linked)) &&
                                            #[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                                    update_tmp_memtable)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_enabled(pre: Self, lbl: Label,
                    receipt: QueryReceipt) -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Query { end_lsn, key, value } => true,
                                        _ => false,
                                    }) &&
                                {
                                    let (end_lsn, key, value) =
                                        match tmp_for_match_0 {
                                            Label::Query { end_lsn, key, value } =>
                                                (end_lsn, key, value),
                                            _ => ::vstd::pervasive::arbitrary(),
                                        };
                                    (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(end_lsn,
                                                    pre.memtable.seq_end)) &&
                                            (#[verifier::custom_err("cannot prove this condition holds")] (receipt.valid_for(pre.linked,
                                                            key)) &&
                                                    #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(Message::Define {
                                                                value,
                                                            }, receipt.result().merge(pre.memtable.query(key))))))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_linked: LinkedBetree = pre.linked;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Put { puts } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let puts =
                                                        match tmp_for_match_0 {
                                                            Label::Put { puts } => puts,
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (puts.wf())
                                                            &&
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(puts.seq_start,
                                                                            pre.memtable.seq_end)) &&
                                                                    {
                                                                        let update_tmp_memtable: Memtable =
                                                                            pre.memtable.apply_puts(puts);

                                                                        #[verifier::custom_err("cannot prove that final value of field `memtable` has this updated value")]
                                                                        (::builtin::equal(post.memtable, update_tmp_memtable))
                                                                    }))
                                                })
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `linked` is preserved")] (::builtin::equal(post.linked,
                                            update_tmp_linked))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put_strong(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_linked: LinkedBetree = pre.linked;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Put { puts } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let puts =
                                                        match tmp_for_match_0 {
                                                            Label::Put { puts } => puts,
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (puts.wf())
                                                            &&
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(puts.seq_start,
                                                                            pre.memtable.seq_end)) &&
                                                                    {
                                                                        let update_tmp_memtable: Memtable =
                                                                            pre.memtable.apply_puts(puts);

                                                                        #[verifier::custom_err("cannot prove that final value of field `memtable` has this updated value")]
                                                                        (::builtin::equal(post.memtable, update_tmp_memtable))
                                                                    }))
                                                })
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `linked` is preserved")] (::builtin::equal(post.linked,
                                            update_tmp_linked))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Put { puts } => true,
                                        _ => false,
                                    }) &&
                                {
                                    let puts =
                                        match tmp_for_match_0 {
                                            Label::Put { puts } => puts,
                                            _ => ::vstd::pervasive::arbitrary(),
                                        };
                                    (#[verifier::custom_err("cannot prove this condition holds")] (puts.wf())
                                            &&
                                            #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(puts.seq_start,
                                                    pre.memtable.seq_end)))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn freeze_as(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        let update_tmp_linked: LinkedBetree = pre.linked;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::FreezeAs { stamped_betree } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let stamped_betree =
                                                        match tmp_for_match_0 {
                                                            Label::FreezeAs { stamped_betree } => stamped_betree,
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (pre.memtable.is_empty())
                                                            &&
                                                            #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(stamped_betree,
                                                                    Stamped {
                                                                        value: pre.linked,
                                                                        seq_end: pre.memtable.seq_end,
                                                                    })))
                                                })
                                    }) &&
                                ((#[verifier::custom_err("cannot prove that the field `linked` is preserved")] (::builtin::equal(post.linked,
                                                    update_tmp_linked)) &&
                                            #[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                                    update_tmp_memtable)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn freeze_as_strong(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        let update_tmp_linked: LinkedBetree = pre.linked;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::FreezeAs { stamped_betree } => true,
                                                        _ => false,
                                                    }) &&
                                                {
                                                    let stamped_betree =
                                                        match tmp_for_match_0 {
                                                            Label::FreezeAs { stamped_betree } => stamped_betree,
                                                            _ => ::vstd::pervasive::arbitrary(),
                                                        };
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (pre.memtable.is_empty())
                                                            &&
                                                            #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(stamped_betree,
                                                                    Stamped {
                                                                        value: pre.linked,
                                                                        seq_end: pre.memtable.seq_end,
                                                                    })))
                                                })
                                    }) &&
                                ((#[verifier::custom_err("cannot prove that the field `linked` is preserved")] (::builtin::equal(post.linked,
                                                    update_tmp_linked)) &&
                                            #[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                                    update_tmp_memtable)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn freeze_as_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::FreezeAs { stamped_betree } => true,
                                        _ => false,
                                    }) &&
                                {
                                    let stamped_betree =
                                        match tmp_for_match_0 {
                                            Label::FreezeAs { stamped_betree } => stamped_betree,
                                            _ => ::vstd::pervasive::arbitrary(),
                                        };
                                    (#[verifier::custom_err("cannot prove this condition holds")] (pre.memtable.is_empty())
                                            &&
                                            #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(stamped_betree,
                                                    Stamped {
                                                        value: pre.linked,
                                                        seq_end: pre.memtable.seq_end,
                                                    })))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_flush_memtable(pre: Self, post: Self,
                    lbl: Label, new_addrs: TwoAddrs)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Internal {} => true,
                                        _ => false,
                                    }) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (new_addrs.no_duplicates())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.linked.is_fresh(new_addrs.repr()))
                                                &&
                                                {
                                                    let update_tmp_memtable: Memtable = pre.memtable.drain();
                                                    let update_tmp_linked: LinkedBetree =
                                                        pre.linked.push_memtable(pre.memtable,
                                                                new_addrs).build_tight_tree();
                                                    (#[verifier::custom_err("cannot prove that final value of field `linked` has this updated value")] (::builtin::equal(post.linked,
                                                                    update_tmp_linked)) &&
                                                            #[verifier::custom_err("cannot prove that final value of field `memtable` has this updated value")] (::builtin::equal(post.memtable,
                                                                    update_tmp_memtable)))
                                                })))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_flush_memtable_strong(pre: Self, post: Self,
                    lbl: Label, new_addrs: TwoAddrs)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Internal {} => true,
                                        _ => false,
                                    }) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (new_addrs.no_duplicates())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.linked.is_fresh(new_addrs.repr()))
                                                &&
                                                {
                                                    let update_tmp_memtable: Memtable = pre.memtable.drain();
                                                    let update_tmp_linked: LinkedBetree =
                                                        pre.linked.push_memtable(pre.memtable,
                                                                new_addrs).build_tight_tree();
                                                    (#[verifier::custom_err("cannot prove that final value of field `linked` has this updated value")] (::builtin::equal(post.linked,
                                                                    update_tmp_linked)) &&
                                                            #[verifier::custom_err("cannot prove that final value of field `memtable` has this updated value")] (::builtin::equal(post.memtable,
                                                                    update_tmp_memtable)))
                                                })))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_flush_memtable_enabled(pre: Self, lbl: Label,
                    new_addrs: TwoAddrs) -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Internal {} => true,
                                        _ => false,
                                    }) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (new_addrs.no_duplicates())
                                        &&
                                        #[verifier::custom_err("cannot prove this condition holds")] (pre.linked.is_fresh(new_addrs.repr()))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_grow(pre: Self, post: Self, lbl: Label,
                    new_root_addr: Address) -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Internal {} => true,
                                                        _ => false,
                                                    }) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.linked.is_fresh(Set::empty().insert(new_root_addr)))
                                                        &&
                                                        {
                                                            let update_tmp_linked: LinkedBetree =
                                                                pre.linked.grow(new_root_addr);

                                                            #[verifier::custom_err("cannot prove that final value of field `linked` has this updated value")]
                                                            (::builtin::equal(post.linked, update_tmp_linked))
                                                        }))
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                            update_tmp_memtable))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_grow_strong(pre: Self, post: Self, lbl: Label,
                    new_root_addr: Address) -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Internal {} => true,
                                                        _ => false,
                                                    }) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.linked.is_fresh(Set::empty().insert(new_root_addr)))
                                                        &&
                                                        {
                                                            let update_tmp_linked: LinkedBetree =
                                                                pre.linked.grow(new_root_addr);

                                                            #[verifier::custom_err("cannot prove that final value of field `linked` has this updated value")]
                                                            (::builtin::equal(post.linked, update_tmp_linked))
                                                        }))
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                            update_tmp_memtable))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_grow_enabled(pre: Self, lbl: Label,
                    new_root_addr: Address) -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Internal {} => true,
                                        _ => false,
                                    }) &&
                                #[verifier::custom_err("cannot prove this condition holds")] (pre.linked.is_fresh(Set::empty().insert(new_root_addr))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_split(pre: Self, post: Self, lbl: Label,
                    path: Path, request: SplitRequest, new_addrs: SplitAddrs,
                    path_addrs: PathAddrs) -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Internal {} => true,
                                                        _ => false,
                                                    }) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (path.valid())
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (path_addrs.no_duplicates())
                                                                &&
                                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.depth,
                                                                                path_addrs.len())) &&
                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (path.target().can_split_parent(request))
                                                                                &&
                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (new_addrs.no_duplicates())
                                                                                        &&
                                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (new_addrs.repr().disjoint(path_addrs.to_set()))
                                                                                                &&
                                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.linked,
                                                                                                                pre.linked)) &&
                                                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.linked.is_fresh(new_addrs.repr()))
                                                                                                                &&
                                                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.linked.is_fresh(path_addrs.to_set()))
                                                                                                                        &&
                                                                                                                        {
                                                                                                                            let update_tmp_linked: LinkedBetree =
                                                                                                                                path.substitute(path.target().split_parent(request,
                                                                                                                                            new_addrs), path_addrs).build_tight_tree();

                                                                                                                            #[verifier::custom_err("cannot prove that final value of field `linked` has this updated value")]
                                                                                                                            (::builtin::equal(post.linked, update_tmp_linked))
                                                                                                                        }))))))))))
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                            update_tmp_memtable))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_split_strong(pre: Self, post: Self,
                    lbl: Label, path: Path, request: SplitRequest,
                    new_addrs: SplitAddrs, path_addrs: PathAddrs)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Internal {} => true,
                                                        _ => false,
                                                    }) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (path.valid())
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (path_addrs.no_duplicates())
                                                                &&
                                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.depth,
                                                                                path_addrs.len())) &&
                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (path.target().can_split_parent(request))
                                                                                &&
                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (new_addrs.no_duplicates())
                                                                                        &&
                                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (new_addrs.repr().disjoint(path_addrs.to_set()))
                                                                                                &&
                                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.linked,
                                                                                                                pre.linked)) &&
                                                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.linked.is_fresh(new_addrs.repr()))
                                                                                                                &&
                                                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.linked.is_fresh(path_addrs.to_set()))
                                                                                                                        &&
                                                                                                                        {
                                                                                                                            let update_tmp_linked: LinkedBetree =
                                                                                                                                path.substitute(path.target().split_parent(request,
                                                                                                                                            new_addrs), path_addrs).build_tight_tree();

                                                                                                                            #[verifier::custom_err("cannot prove that final value of field `linked` has this updated value")]
                                                                                                                            (::builtin::equal(post.linked, update_tmp_linked))
                                                                                                                        }))))))))))
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                            update_tmp_memtable))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_split_enabled(pre: Self, lbl: Label,
                    path: Path, request: SplitRequest, new_addrs: SplitAddrs,
                    path_addrs: PathAddrs) -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Internal {} => true,
                                        _ => false,
                                    }) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (path.valid())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (path_addrs.no_duplicates())
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.depth,
                                                                path_addrs.len())) &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (path.target().can_split_parent(request))
                                                                &&
                                                                (#[verifier::custom_err("cannot prove this condition holds")] (new_addrs.no_duplicates())
                                                                        &&
                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (new_addrs.repr().disjoint(path_addrs.to_set()))
                                                                                &&
                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.linked,
                                                                                                pre.linked)) &&
                                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.linked.is_fresh(new_addrs.repr()))
                                                                                                &&
                                                                                                #[verifier::custom_err("cannot prove this condition holds")] (pre.linked.is_fresh(path_addrs.to_set())))))))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_flush(pre: Self, post: Self, lbl: Label,
                    path: Path, child_idx: nat, buffer_gc: nat,
                    new_addrs: TwoAddrs, path_addrs: PathAddrs)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Internal {} => true,
                                                        _ => false,
                                                    }) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (path.valid())
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (path_addrs.no_duplicates())
                                                                &&
                                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.depth,
                                                                                path_addrs.len())) &&
                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (path.target().can_flush(child_idx,
                                                                                        buffer_gc)) &&
                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (new_addrs.no_duplicates())
                                                                                        &&
                                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (new_addrs.repr().disjoint(path_addrs.to_set()))
                                                                                                &&
                                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.linked,
                                                                                                                pre.linked)) &&
                                                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.linked.is_fresh(new_addrs.repr()))
                                                                                                                &&
                                                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.linked.is_fresh(path_addrs.to_set()))
                                                                                                                        &&
                                                                                                                        {
                                                                                                                            let update_tmp_linked: LinkedBetree =
                                                                                                                                path.substitute(path.target().flush(child_idx, buffer_gc,
                                                                                                                                            new_addrs), path_addrs).build_tight_tree();

                                                                                                                            #[verifier::custom_err("cannot prove that final value of field `linked` has this updated value")]
                                                                                                                            (::builtin::equal(post.linked, update_tmp_linked))
                                                                                                                        }))))))))))
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                            update_tmp_memtable))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_flush_strong(pre: Self, post: Self,
                    lbl: Label, path: Path, child_idx: nat, buffer_gc: nat,
                    new_addrs: TwoAddrs, path_addrs: PathAddrs)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Internal {} => true,
                                                        _ => false,
                                                    }) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (path.valid())
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (path_addrs.no_duplicates())
                                                                &&
                                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.depth,
                                                                                path_addrs.len())) &&
                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (path.target().can_flush(child_idx,
                                                                                        buffer_gc)) &&
                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (new_addrs.no_duplicates())
                                                                                        &&
                                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (new_addrs.repr().disjoint(path_addrs.to_set()))
                                                                                                &&
                                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.linked,
                                                                                                                pre.linked)) &&
                                                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.linked.is_fresh(new_addrs.repr()))
                                                                                                                &&
                                                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.linked.is_fresh(path_addrs.to_set()))
                                                                                                                        &&
                                                                                                                        {
                                                                                                                            let update_tmp_linked: LinkedBetree =
                                                                                                                                path.substitute(path.target().flush(child_idx, buffer_gc,
                                                                                                                                            new_addrs), path_addrs).build_tight_tree();

                                                                                                                            #[verifier::custom_err("cannot prove that final value of field `linked` has this updated value")]
                                                                                                                            (::builtin::equal(post.linked, update_tmp_linked))
                                                                                                                        }))))))))))
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                            update_tmp_memtable))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_flush_enabled(pre: Self, lbl: Label,
                    path: Path, child_idx: nat, buffer_gc: nat,
                    new_addrs: TwoAddrs, path_addrs: PathAddrs)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Internal {} => true,
                                        _ => false,
                                    }) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (path.valid())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (path_addrs.no_duplicates())
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.depth,
                                                                path_addrs.len())) &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (path.target().can_flush(child_idx,
                                                                        buffer_gc)) &&
                                                                (#[verifier::custom_err("cannot prove this condition holds")] (new_addrs.no_duplicates())
                                                                        &&
                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (new_addrs.repr().disjoint(path_addrs.to_set()))
                                                                                &&
                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.linked,
                                                                                                pre.linked)) &&
                                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.linked.is_fresh(new_addrs.repr()))
                                                                                                &&
                                                                                                #[verifier::custom_err("cannot prove this condition holds")] (pre.linked.is_fresh(path_addrs.to_set())))))))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_compact(pre: Self, post: Self, lbl: Label,
                    path: Path, start: nat, end: nat, compacted_buffer: Buffer,
                    new_addrs: TwoAddrs, path_addrs: PathAddrs)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Internal {} => true,
                                                        _ => false,
                                                    }) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (path.valid())
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (path_addrs.no_duplicates())
                                                                &&
                                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.depth,
                                                                                path_addrs.len())) &&
                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (path.target().can_compact(start,
                                                                                        end, compacted_buffer)) &&
                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (new_addrs.no_duplicates())
                                                                                        &&
                                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (new_addrs.repr().disjoint(path_addrs.to_set()))
                                                                                                &&
                                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.linked,
                                                                                                                pre.linked)) &&
                                                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.linked.is_fresh(new_addrs.repr()))
                                                                                                                &&
                                                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.linked.is_fresh(path_addrs.to_set()))
                                                                                                                        &&
                                                                                                                        {
                                                                                                                            let update_tmp_linked: LinkedBetree =
                                                                                                                                path.substitute(path.target().compact(start, end,
                                                                                                                                            compacted_buffer, new_addrs),
                                                                                                                                        path_addrs).build_tight_tree();

                                                                                                                            #[verifier::custom_err("cannot prove that final value of field `linked` has this updated value")]
                                                                                                                            (::builtin::equal(post.linked, update_tmp_linked))
                                                                                                                        }))))))))))
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                            update_tmp_memtable))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_compact_strong(pre: Self, post: Self,
                    lbl: Label, path: Path, start: nat, end: nat,
                    compacted_buffer: Buffer, new_addrs: TwoAddrs,
                    path_addrs: PathAddrs) -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        (({
                                        let tmp_for_match_0 = lbl;
                                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                                        {
                                                        Label::Internal {} => true,
                                                        _ => false,
                                                    }) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (path.valid())
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (path_addrs.no_duplicates())
                                                                &&
                                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.depth,
                                                                                path_addrs.len())) &&
                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (path.target().can_compact(start,
                                                                                        end, compacted_buffer)) &&
                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (new_addrs.no_duplicates())
                                                                                        &&
                                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (new_addrs.repr().disjoint(path_addrs.to_set()))
                                                                                                &&
                                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.linked,
                                                                                                                pre.linked)) &&
                                                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.linked.is_fresh(new_addrs.repr()))
                                                                                                                &&
                                                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.linked.is_fresh(path_addrs.to_set()))
                                                                                                                        &&
                                                                                                                        {
                                                                                                                            let update_tmp_linked: LinkedBetree =
                                                                                                                                path.substitute(path.target().compact(start, end,
                                                                                                                                            compacted_buffer, new_addrs),
                                                                                                                                        path_addrs).build_tight_tree();

                                                                                                                            #[verifier::custom_err("cannot prove that final value of field `linked` has this updated value")]
                                                                                                                            (::builtin::equal(post.linked, update_tmp_linked))
                                                                                                                        }))))))))))
                                    }) &&
                                (#[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                            update_tmp_memtable))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_compact_enabled(pre: Self, lbl: Label,
                    path: Path, start: nat, end: nat, compacted_buffer: Buffer,
                    new_addrs: TwoAddrs, path_addrs: PathAddrs)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;
                        (#[verifier::custom_err("cannot prove this condition holds")] (match tmp_for_match_0
                                        {
                                        Label::Internal {} => true,
                                        _ => false,
                                    }) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (path.valid())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (path_addrs.no_duplicates())
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.depth,
                                                                path_addrs.len())) &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (path.target().can_compact(start,
                                                                        end, compacted_buffer)) &&
                                                                (#[verifier::custom_err("cannot prove this condition holds")] (new_addrs.no_duplicates())
                                                                        &&
                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (new_addrs.repr().disjoint(path_addrs.to_set()))
                                                                                &&
                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(path.linked,
                                                                                                pre.linked)) &&
                                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.linked.is_fresh(new_addrs.repr()))
                                                                                                &&
                                                                                                #[verifier::custom_err("cannot prove this condition holds")] (pre.linked.is_fresh(path_addrs.to_set())))))))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_noop(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        let update_tmp_linked: LinkedBetree = pre.linked;
                        (({
                                        let tmp_for_match_0 = lbl;

                                        #[verifier::custom_err("cannot prove this condition holds")]
                                        (match tmp_for_match_0 {
                                                Label::Internal {} => true,
                                                _ => false,
                                            })
                                    }) &&
                                ((#[verifier::custom_err("cannot prove that the field `linked` is preserved")] (::builtin::equal(post.linked,
                                                    update_tmp_linked)) &&
                                            #[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                                    update_tmp_memtable)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_noop_strong(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_memtable: Memtable = pre.memtable;
                        let update_tmp_linked: LinkedBetree = pre.linked;
                        (({
                                        let tmp_for_match_0 = lbl;

                                        #[verifier::custom_err("cannot prove this condition holds")]
                                        (match tmp_for_match_0 {
                                                Label::Internal {} => true,
                                                _ => false,
                                            })
                                    }) &&
                                ((#[verifier::custom_err("cannot prove that the field `linked` is preserved")] (::builtin::equal(post.linked,
                                                    update_tmp_linked)) &&
                                            #[verifier::custom_err("cannot prove that the field `memtable` is preserved")] (::builtin::equal(post.memtable,
                                                    update_tmp_memtable)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_noop_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let tmp_for_match_0 = lbl;

                        #[verifier::custom_err("cannot prove this condition holds")]
                        (match tmp_for_match_0 {
                                Label::Internal {} => true,
                                _ => false,
                            })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn initialize(post: Self, stamped_betree: StampedBetree)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (stamped_betree.value.wf())
                                &&
                                {
                                    let update_tmp_memtable: Memtable =
                                        Memtable::empty_memtable(stamped_betree.seq_end);
                                    let update_tmp_linked: LinkedBetree = stamped_betree.value;
                                    (#[verifier::custom_err("cannot prove that final value of field `linked` has this updated value")] (::builtin::equal(post.linked,
                                                    update_tmp_linked)) &&
                                            #[verifier::custom_err("cannot prove that final value of field `memtable` has this updated value")] (::builtin::equal(post.memtable,
                                                    update_tmp_memtable)))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn initialize_enabled(stamped_betree: StampedBetree)
                    -> ::core::primitive::bool {
                    {

                        #[verifier::custom_err("cannot prove this condition holds")]
                        (stamped_betree.value.wf())
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_by(pre: State, post: State, label: Label,
                    step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::query(receipt) =>
                            Self::query(pre, post, label, receipt),
                        Step::put() => Self::put(pre, post, label),
                        Step::freeze_as() => Self::freeze_as(pre, post, label),
                        Step::internal_flush_memtable(new_addrs) =>
                            Self::internal_flush_memtable(pre, post, label, new_addrs),
                        Step::internal_grow(new_root_addr) =>
                            Self::internal_grow(pre, post, label, new_root_addr),
                        Step::internal_split(path, request, new_addrs, path_addrs)
                            =>
                            Self::internal_split(pre, post, label, path, request,
                                new_addrs, path_addrs),
                        Step::internal_flush(path, child_idx, buffer_gc, new_addrs,
                            path_addrs) =>
                            Self::internal_flush(pre, post, label, path, child_idx,
                                buffer_gc, new_addrs, path_addrs),
                        Step::internal_compact(path, start, end, compacted_buffer,
                            new_addrs, path_addrs) =>
                            Self::internal_compact(pre, post, label, path, start, end,
                                compacted_buffer, new_addrs, path_addrs),
                        Step::internal_noop() =>
                            Self::internal_noop(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next(pre: State, post: State, label: Label)
                    -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                            Self::next_by(pre, post, label, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_strong_by(pre: State, post: State, label: Label,
                    step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::query(receipt) =>
                            Self::query_strong(pre, post, label, receipt),
                        Step::put() => Self::put_strong(pre, post, label),
                        Step::freeze_as() =>
                            Self::freeze_as_strong(pre, post, label),
                        Step::internal_flush_memtable(new_addrs) =>
                            Self::internal_flush_memtable_strong(pre, post, label,
                                new_addrs),
                        Step::internal_grow(new_root_addr) =>
                            Self::internal_grow_strong(pre, post, label, new_root_addr),
                        Step::internal_split(path, request, new_addrs, path_addrs)
                            =>
                            Self::internal_split_strong(pre, post, label, path, request,
                                new_addrs, path_addrs),
                        Step::internal_flush(path, child_idx, buffer_gc, new_addrs,
                            path_addrs) =>
                            Self::internal_flush_strong(pre, post, label, path,
                                child_idx, buffer_gc, new_addrs, path_addrs),
                        Step::internal_compact(path, start, end, compacted_buffer,
                            new_addrs, path_addrs) =>
                            Self::internal_compact_strong(pre, post, label, path, start,
                                end, compacted_buffer, new_addrs, path_addrs),
                        Step::internal_noop() =>
                            Self::internal_noop_strong(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_strong(pre: State, post: State, label: Label)
                    -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                            Self::next_strong_by(pre, post, label, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn init_by(post: State, step: Config)
                    -> ::core::primitive::bool {
                    match step {
                        Config::initialize(stamped_betree) =>
                            Self::initialize(post, stamped_betree),
                        Config::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn init(post: State) -> ::core::primitive::bool {
                    ::builtin::exists(|step: Config| Self::init_by(post, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::spec]
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                pub fn invariant(&self) -> ::core::primitive::bool { true }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn wf(self) -> bool { self.linked.wf() }
            }
        }
    }
    pub mod LinkedBufferSeq_v {
        use builtin::*;
        use builtin_macros::*;
        use vstd::{map::*, seq::*, set::*};
        use crate::spec::KeyType_t::*;
        use crate::spec::Messages_t::*;
        use crate::betree::Buffer_v::*;
        use crate::betree::BufferSeq_v;
        use crate::betree::OffsetMap_v::*;
        use crate::disk::GenericDisk_v::*;
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct DiskView {
            pub entries: Map<Address, Buffer>,
        }
        #[verus::internal(verus_macro)]
        impl DiskView {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool { self.entries.dom().finite() }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn repr(self) -> Set<Address> { self.entries.dom() }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn get(self, addr: Address) -> Buffer {
                ::builtin::recommends([self.entries.contains_key(addr)]);
                self.entries.spec_index(addr)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn modify_disk(self, addr: Address, buffer: Buffer)
                -> DiskView {
                DiskView { entries: self.entries.insert(addr, buffer) }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_fresh(self, addrs: Set<Address>) -> bool {
                self.entries.dom().disjoint(addrs)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_subdisk(self, bigger: DiskView) -> bool {
                (self.entries).spec_le(bigger.entries)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn merge_disk(self, other: DiskView) -> DiskView {
                DiskView {
                    entries: self.entries.union_prefer_right(other.entries),
                }
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn empty_disk() -> DiskView { DiskView { entries: Map::empty() } }
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct BufferSeq {
            pub buffers: Seq<Address>,
        }
        #[verus::internal(verus_macro)]
        impl BufferSeq {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn empty() -> BufferSeq {
                BufferSeq { buffers: ::vstd::seq::Seq::empty() }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn len(self) -> nat { self.buffers.len() }
            #[verifier::inline]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn spec_index(self, i: int) -> Address {
                ::builtin::recommends([::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        i), self.len()))]);
                self.buffers.spec_index(i)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid(self, dv: DiskView) -> bool {
                ::builtin::forall(|i|
                        #[verus::internal(auto_trigger)] (::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            i), self.len())),
                                dv.repr().contains(self.buffers.spec_index(i)))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn repr(self) -> Set<Address> { self.buffers.to_set() }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn slice(self, start: int, end: int) -> BufferSeq {
                ::builtin::recommends([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            start), end), self.len()))]);
                BufferSeq { buffers: self.buffers.subrange(start, end) }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn extend(self, new_buffers: BufferSeq) -> BufferSeq {
                BufferSeq {
                    buffers: (self.buffers).spec_add(new_buffers.buffers),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn query_from(self, dv: DiskView, k: Key, start: int)
                -> Message {
                ::builtin::recommends([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        start), self.len()))]);
                ::builtin::decreases(((self.len()).spec_sub(start)));
                ::builtin::decreases_when((start).spec_le(self.len()));
                if ::builtin::spec_eq(start, self.len()) {
                        Message::Update { delta: nop_delta() }
                    } else {
                       if dv.entries.contains_key(self.spec_index(start)) {
                               dv.get(self.spec_index(start)).query(k).merge(self.query_from(dv,
                                       k, (start).spec_add(::builtin::spec_literal_nat("1"))))
                           } else {
                              self.query_from(dv, k,
                                  (start).spec_add(::builtin::spec_literal_nat("1")))
                          }
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn update_subrange(self, start: int, end: int,
                new_buffer_addr: Address) -> BufferSeq {
                ::builtin::recommends([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            start), end), self.len()))]);
                let s = ::vstd::seq::Seq::empty().push(new_buffer_addr);
                BufferSeq {
                    buffers: ((self.buffers.subrange(::builtin::spec_literal_integer("0"),
                                        start)).spec_add(s)).spec_add(self.buffers.subrange(end,
                            ::builtin::spec_cast_integer::<_, int>(self.len()))),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self, dv: DiskView) -> BufferSeq_v::BufferSeq {
                ::builtin::recommends([self.valid(dv)]);
                let buffers =
                    Seq::new(self.len(),
                        ::builtin::closure_to_fn_spec(|i|
                                dv.get(self.spec_index(i))));
                BufferSeq_v::BufferSeq { buffers: buffers }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn subdisk_implies_same_i(self, small: DiskView,
                big: DiskView) {
                ::builtin::requires([self.valid(small),
                            small.is_subdisk(big)]);
                ::builtin::ensures([self.valid(big),
                            ::builtin::spec_eq(self.i(small), self.i(big))]);
                {
                    ::builtin::assert_forall_by(|i|
                            {
                                ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                i), self.len())));
                                ::builtin::ensures(::builtin::spec_eq(self.i(small).spec_index(i),
                                        self.i(big).spec_index(i)));
                                ::builtin::assert_(big.entries.dom().contains(self.spec_index(i)));
                            });
                }
                ::builtin::assert_(::builtin::ext_equal(self.i(small),
                        self.i(big)));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn key_in_buffer(self, dv: DiskView, from_idx: int, k: Key,
                buffer_idx: int) -> bool {
                ((::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(from_idx),
                                            buffer_idx), self.len()))) &&
                            (dv.entries.contains_key(self.spec_index(buffer_idx)))) &&
                    (dv.get(self.spec_index(buffer_idx)).map.contains_key(k))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn key_in_buffer_filtered(self, dv: DiskView,
                offset_map: OffsetMap, from_idx: int, k: Key, buffer_idx: int)
                -> bool {
                ::builtin::recommends([(::builtin::spec_literal_nat("0")).spec_le(from_idx),
                            offset_map.is_total()]);
                (self.key_in_buffer(dv, from_idx, k, buffer_idx)) &&
                    ((offset_map.offsets.spec_index(k)).spec_le(buffer_idx))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn query_from_commutes_with_i(self, dv: DiskView, k: Key,
                start: int) {
                ::builtin::requires([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        start), self.len())), self.valid(dv)]);
                ::builtin::ensures([::builtin::spec_eq(self.query_from(dv, k,
                                    start), self.i(dv).query_from(k, start))]);
                ::builtin::decreases(((self.len()).spec_sub(start)));
                if (start).spec_lt(self.len()) {
                        self.query_from_commutes_with_i(dv, k,
                            (start).spec_add(::builtin::spec_literal_nat("1")));
                    }
            }
        }
    }
    pub mod LinkedBetreeRefinement_v {
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use vstd::map::*;
        use vstd::seq_lib::*;
        use vstd::set_lib::*;
        use crate::spec::KeyType_t::*;
        use crate::spec::Messages_t::*;
        use crate::abstract_system::StampedMap_v::*;
        use crate::disk::GenericDisk_v::*;
        use crate::betree::Domain_v::*;
        use crate::betree::PivotTable_v::*;
        use crate::betree::Buffer_v::*;
        use crate::betree::Memtable_v::*;
        use crate::betree::LinkedBufferSeq_v;
        use crate::betree::BufferOffsets_v::*;
        use crate::betree::OffsetMap_v::*;
        use crate::betree::FilteredBetree_v;
        use crate::betree::FilteredBetree_v::FilteredBetree;
        use crate::betree::LinkedBetree_v::*;
        use crate::betree::SplitRequest_v::*;
        pub type LinkedBufferSeq = LinkedBufferSeq_v::BufferSeq;
        #[verus::internal(verus_macro)]
        impl DiskView {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn fresh_ranking_extension(self, r1: Ranking, r2: Ranking)
                -> bool {
                ((r1).spec_le(r2)) &&
                    (::builtin::forall(|addr|
                                #[verus::internal(auto_trigger)] (::builtin::imply(!r1.contains_key(addr)
                                            && r2.contains_key(addr),
                                        !self.entries.contains_key(addr)))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn subdisk_implies_ranking_validity(self, big: DiskView,
                ranking: Ranking) {
                ::builtin::requires([self.wf(), self.is_subdisk(big),
                            big.valid_ranking(ranking)]);
                ::builtin::ensures([self.valid_ranking(ranking)]);
                {
                    ::builtin::assert_forall_by(|addr|
                            {
                                ::builtin::requires(self.entries.contains_key(addr) &&
                                        #[verus::internal(trigger)] ranking.contains_key(addr));
                                ::builtin::ensures(self.node_children_respects_rank(ranking,
                                        addr));
                                ::builtin::assert_(big.entries.dom().contains(addr));
                                ::builtin::assert_(self.entries.dom().contains(addr));
                            });
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn ranking_is_tight(self, ranking: Ranking) -> bool {
                ranking.dom().subset_of(self.entries.dom())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn tight_ranking_is_finite(self, ranking: Ranking) {
                ::builtin::requires([self.wf(),
                            self.ranking_is_tight(ranking)]);
                ::builtin::ensures([ranking.dom().finite()]);
                lemma_len_subset(ranking.dom(), self.entries.dom());
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn get_max_rank(ranking: Ranking) -> nat {
            ::builtin::requires([ranking.dom().finite()]);
            ::builtin::ensures(|max: nat|
                    [::builtin::forall(|addr|
                                    ::builtin::imply(#[verus::internal(trigger)] ranking.contains_key(addr),
                                        (ranking.spec_index(addr)).spec_le(max)))]);
            ::builtin::decreases((ranking.dom().len()));
            if ranking.dom().is_empty() {
                    {
                        ::builtin::assert_forall_by(|addr|
                                {
                                    ::builtin::requires(#[verus::internal(trigger)] ranking.contains_key(addr));
                                    ::builtin::ensures((ranking.spec_index(addr)).spec_le(::builtin::spec_literal_nat("0")));
                                    ::builtin::assert_(false);
                                });
                    }
                    ::builtin::spec_literal_integer("0")
                } else {
                   let addr = ranking.dom().choose();
                   let other_max = get_max_rank(ranking.remove(addr));
                   if (ranking.spec_index(addr)).spec_gt(other_max) {
                           ranking.spec_index(addr)
                       } else { other_max }
               }
        }
        #[verus::internal(verus_macro)]
        impl LinkedBetree {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn disk_tight_wrt_reachable_betree_addrs(self) -> bool {
                ::builtin::recommends([self.acyclic()]);
                ::builtin::ext_equal(self.dv.entries.dom(),
                    self.reachable_betree_addrs())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn disk_tight_wrt_reachable_buffer_addrs(self) -> bool {
                ::builtin::recommends([self.acyclic()]);
                ::builtin::ext_equal(self.buffer_dv.entries.dom(),
                    self.reachable_buffer_addrs())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn i_children_seq(self, ranking: Ranking, start: nat)
                -> Seq<FilteredBetree_v::BetreeNode> {
                ::builtin::recommends([self.has_root(),
                            self.valid_ranking(ranking),
                            (start).spec_le(self.root().children.len())]);
                ::builtin::decreases((self.get_rank(ranking),
                        ::builtin::spec_literal_nat("0"),
                        (self.root().children.len()).spec_sub(start)));
                ::builtin::decreases_when((start).spec_le(self.root().children.len())
                        &&
                        (::builtin::imply(self.root().valid_child_index(start),
                                (self.child_at_idx(start).get_rank(ranking)).spec_lt(self.get_rank(ranking)))));
                if ::builtin::spec_eq(start, self.root().children.len()) {
                        ::vstd::seq::Seq::empty()
                    } else {
                       let child = self.child_at_idx(start).i_node(ranking);
                       (::vstd::seq::Seq::empty().push(child)).spec_add(self.i_children_seq(ranking,
                               (start).spec_add(::builtin::spec_literal_nat("1"))))
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn i_children(self, ranking: Ranking)
                -> Seq<FilteredBetree_v::BetreeNode> {
                ::builtin::recommends([self.has_root(),
                            self.valid_ranking(ranking)]);
                ::builtin::decreases((self.get_rank(ranking),
                        ::builtin::spec_literal_nat("1")));
                self.i_children_seq(ranking,
                    ::builtin::spec_literal_integer("0"))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn i_node(self, ranking: Ranking)
                -> FilteredBetree_v::BetreeNode {
                ::builtin::recommends([self.valid_ranking(ranking)]);
                ::builtin::decreases((self.get_rank(ranking),
                        ::builtin::spec_literal_nat("2")));
                if !self.has_root() {
                        FilteredBetree_v::BetreeNode::Nil {}
                    } else {
                       let root = self.root();
                       FilteredBetree_v::BetreeNode::Node {
                           buffers: root.buffers.i(self.buffer_dv),
                           pivots: root.pivots,
                           children: self.i_children(ranking),
                           flushed: root.flushed,
                       }
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> FilteredBetree_v::BetreeNode {
                ::builtin::recommends([self.acyclic()]);
                self.i_node(self.the_ranking())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn i_children_seq_lemma(self, ranking: Ranking, start: nat) {
                ::builtin::requires([self.has_root(),
                            self.valid_ranking(ranking),
                            (start).spec_le(self.root().children.len())]);
                ::builtin::ensures([::builtin::spec_eq(self.i_children_seq(ranking,
                                        start).len(), (self.root().children.len()).spec_sub(start)),
                            ::builtin::forall(|i|
                                    ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                    i), self.i_children_seq(ranking, start).len())),
                                        {
                                            ((#[verus::internal(trigger)] self.i_children_seq(ranking,
                                                                    start).spec_index(i)).wf()) &&
                                                (::builtin::spec_eq(self.i_children_seq(ranking,
                                                                start).spec_index(i),
                                                        self.child_at_idx(::builtin::spec_cast_integer::<_,
                                                                        nat>(((i).spec_add(start)))).i_node(ranking)))
                                        }))]);
                ::builtin::decreases((self.get_rank(ranking),
                        ::builtin::spec_literal_nat("0"),
                        (self.root().children.len()).spec_sub(start)));
                if (start).spec_lt(self.root().children.len()) {
                        ::builtin::assert_(self.root().valid_child_index(start));
                        self.child_at_idx(start).i_node_wf(ranking);
                        self.i_children_seq_lemma(ranking,
                            (start).spec_add(::builtin::spec_literal_nat("1")));
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn i_children_lemma(self, ranking: Ranking) {
                ::builtin::requires([self.has_root(),
                            self.valid_ranking(ranking)]);
                ::builtin::ensures([self.i_node(ranking).wf_children(),
                            ::builtin::spec_eq(self.i_children(ranking).len(),
                                self.root().children.len()),
                            ::builtin::forall(|i|
                                    ::builtin::imply((#[verus::internal(trigger)] self.root().valid_child_index(i)),
                                        ::builtin::spec_eq(self.i_children(ranking).spec_index(::builtin::spec_cast_integer::<_,
                                                        int>(i)), self.child_at_idx(i).i_node(ranking))))]);
                ::builtin::decreases((self.get_rank(ranking),
                        ::builtin::spec_literal_nat("1")));
                self.i_children_seq_lemma(ranking,
                    ::builtin::spec_literal_integer("0"));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn i_node_wf(self, ranking: Ranking) {
                ::builtin::requires([self.wf(), self.valid_ranking(ranking)]);
                ::builtin::ensures([self.i_node(ranking).wf()]);
                ::builtin::decreases((self.get_rank(ranking),
                        ::builtin::spec_literal_nat("2")));
                if self.has_root() {
                        self.i_children_lemma(ranking);
                        let out = self.i_node(ranking);
                        {
                            ::builtin::assert_forall_by(|i|
                                    {
                                        ::builtin::requires((#[verus::internal(trigger)] out.valid_child_index(i)
                                                        &&
                                                        out.get_Node_children().spec_index(::builtin::spec_cast_integer::<_,
                                                                        int>(i)).is_Node() &&
                                                    out.get_Node_children().spec_index(::builtin::spec_cast_integer::<_,
                                                                    int>(i)).local_structure()));
                                        ::builtin::ensures((::builtin::spec_eq(out.get_Node_children().spec_index(::builtin::spec_cast_integer::<_,
                                                                    int>(i)).my_domain(), out.child_domain(i))));
                                        ::builtin::assert_(self.root().valid_child_index(i));
                                    });
                        }
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn i_wf(self) {
                ::builtin::requires([self.acyclic()]);
                ::builtin::ensures([self.i().wf()]);
                self.i_node_wf(self.the_ranking());
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn child_at_idx_acyclic(self, idx: nat) {
                ::builtin::requires([self.acyclic(), self.has_root(),
                            self.root().valid_child_index(idx)]);
                ::builtin::ensures([self.child_at_idx(idx).acyclic()]);
                ::builtin::assert_(self.child_at_idx(idx).valid_ranking(self.the_ranking()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn child_at_idx_valid_ranking(self, idx: nat) {
                ::builtin::requires([self.acyclic(), self.has_root(),
                            self.root().valid_child_index(idx)]);
                ::builtin::ensures([::builtin::forall(|ranking: Ranking|
                                    ::builtin::imply(self.valid_ranking(ranking),
                                        #[verus::internal(trigger)] self.child_at_idx(idx).valid_ranking(ranking)))]);
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn child_for_key_valid_index(self, k: Key) {
                ::builtin::requires([self.wf(), self.has_root(),
                            self.root().key_in_domain(k)]);
                ::builtin::ensures([(::builtin::spec_literal_nat("0")).spec_le(self.root().pivots.route(k)),
                            self.root().valid_child_index(::builtin::spec_cast_integer::<_,
                                        nat>(self.root().pivots.route(k)))]);
                self.root().pivots.route_lemma(k);
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn child_for_key_acyclic(self, k: Key) {
                ::builtin::requires([self.acyclic(), self.has_root(),
                            self.root().key_in_domain(k)]);
                ::builtin::ensures([self.child_for_key(k).acyclic()]);
                self.child_for_key_valid_index(k);
                ::builtin::assert_(self.child_for_key(k).valid_ranking(self.the_ranking()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn i_children_ignores_ranking(self, r1: Ranking,
                r2: Ranking) {
                ::builtin::requires([self.wf(), self.has_root(),
                            self.valid_ranking(r1), self.valid_ranking(r2)]);
                ::builtin::ensures([::builtin::spec_eq(self.i_children(r1),
                                self.i_children(r2))]);
                ::builtin::decreases((self.get_rank(r1),
                        ::builtin::spec_literal_nat("0")));
                let a = self.i_children(r1);
                let b = self.i_children(r2);
                self.i_children_lemma(r1);
                self.i_children_lemma(r2);
                {
                    ::builtin::assert_forall_by(|i|
                            {
                                ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                i), a.len())));
                                ::builtin::ensures(::builtin::spec_eq(a.spec_index(i),
                                        b.spec_index(i)));
                                ::builtin::assert_(self.root().valid_child_index(::builtin::spec_cast_integer::<_,
                                                nat>(i)));
                                ::builtin::assert_(::builtin::spec_eq(a.spec_index(i),
                                        self.child_at_idx(::builtin::spec_cast_integer::<_,
                                                        nat>(i)).i_node(r1)));
                                self.child_at_idx(::builtin::spec_cast_integer::<_,
                                                nat>(i)).i_node_ignores_ranking(r1, r2);
                            });
                }
                ::builtin::assert_(::builtin::ext_equal(a, b));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn i_node_ignores_ranking(self, r1: Ranking, r2: Ranking) {
                ::builtin::requires([self.wf(), self.valid_ranking(r1),
                            self.valid_ranking(r2)]);
                ::builtin::ensures([::builtin::spec_eq(self.i_node(r1),
                                self.i_node(r2))]);
                ::builtin::decreases((self.get_rank(r1),
                        ::builtin::spec_literal_nat("1")));
                if self.has_root() {
                        self.i_children_ignores_ranking(r1, r2);
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn child_at_idx_commutes_with_i(self, idx: nat) {
                ::builtin::requires([self.acyclic(), self.has_root(),
                            self.root().valid_child_index(idx)]);
                ::builtin::ensures([self.i().valid_child_index(idx),
                            ::builtin::spec_eq(self.child_at_idx(idx).i(),
                                self.i().get_Node_children().spec_index(::builtin::spec_cast_integer::<_,
                                            int>(idx)))]);
                let child = self.child_at_idx(idx);
                self.child_at_idx_acyclic(idx);
                self.i_children_lemma(self.the_ranking());
                child.i_node_ignores_ranking(self.the_ranking(),
                    child.the_ranking());
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn child_for_key_commutes_with_i(self, k: Key) {
                ::builtin::requires([self.acyclic(), self.has_root(),
                            self.root().key_in_domain(k)]);
                ::builtin::ensures([self.child_for_key(k).acyclic(),
                            ::builtin::spec_eq(self.child_for_key(k).i(),
                                self.i().child(k))]);
                PivotTable::route_lemma_auto();
                self.child_for_key_acyclic(k);
                self.child_for_key_valid_index(k);
                self.i_children_lemma(self.the_ranking());
                self.child_at_idx_commutes_with_i(::builtin::spec_cast_integer::<_,
                            nat>(self.root().pivots.route(k)));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn indexiness_commutes_with_i(self) {
                ::builtin::requires([self.acyclic(), self.has_root()]);
                ::builtin::ensures([::builtin::imply(self.root().is_index(),
                                self.i().is_index()),
                            ::builtin::imply(self.root().is_leaf(),
                                self.i().is_leaf())]);
                self.i_wf();
                self.i_children_lemma(self.the_ranking());
                if self.root().is_index() {
                        {
                            ::builtin::assert_forall_by(|i: nat|
                                    {
                                        ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                        i), self.i().get_Node_children().len())));
                                        ::builtin::ensures(#[verus::internal(trigger)] self.i().get_Node_children().spec_index(::builtin::spec_cast_integer::<_,
                                                            int>(i)).is_Node());
                                        ::builtin::assert_(self.root().valid_child_index(i));
                                    });
                        }
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn betree_subdisk_preserves_i_with_ranking(self,
                big: LinkedBetree, ranking: Ranking) {
                ::builtin::requires([self.wf(), big.wf(),
                            ::builtin::spec_eq(self.root, big.root),
                            self.dv.is_subdisk(big.dv),
                            self.buffer_dv.is_subdisk(big.buffer_dv),
                            big.valid_ranking(ranking)]);
                ::builtin::ensures([self.valid_ranking(ranking),
                            ::builtin::spec_eq(self.i_node(ranking),
                                big.i_node(ranking))]);
                ::builtin::decreases((self.get_rank(ranking),
                        big.get_rank(ranking)));
                self.dv.subdisk_implies_ranking_validity(big.dv, ranking);
                ::builtin::assert_(self.valid_ranking(ranking));
                if self.has_root() {
                        self.root().buffers.subdisk_implies_same_i(self.buffer_dv,
                            big.buffer_dv);
                        self.i_children_lemma(ranking);
                        big.i_children_lemma(ranking);
                        let a = self.i_node(ranking).get_Node_children();
                        let b = big.i_node(ranking).get_Node_children();
                        ::builtin::assert_(::builtin::spec_eq(a.len(), b.len()));
                        {
                            ::builtin::assert_forall_by(|i|
                                    {
                                        ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                        i), a.len())));
                                        ::builtin::ensures(::builtin::spec_eq(a.spec_index(i),
                                                b.spec_index(i)));
                                        ::builtin::assert_(self.root().valid_child_index(::builtin::spec_cast_integer::<_,
                                                        nat>(i)));
                                        ::builtin::assert_(big.root().valid_child_index(::builtin::spec_cast_integer::<_,
                                                        nat>(i)));
                                        self.child_at_idx_acyclic(::builtin::spec_cast_integer::<_,
                                                    nat>(i));
                                        big.child_at_idx_acyclic(::builtin::spec_cast_integer::<_,
                                                    nat>(i));
                                        self.child_at_idx(::builtin::spec_cast_integer::<_,
                                                        nat>(i)).betree_subdisk_preserves_i_with_ranking(big.child_at_idx(::builtin::spec_cast_integer::<_,
                                                        nat>(i)), ranking);
                                    });
                        }
                        ::builtin::assert_(::builtin::ext_equal(a, b));
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn reachable_addrs_using_ranking_recur_body_lemma(self,
                ranking: Ranking, child_idx: nat) {
                ::builtin::requires([self.can_recurse_for_reachable(ranking,
                                child_idx)]);
                ::builtin::ensures([::builtin::forall(|i|
                                    ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(child_idx),
                                                    i), self.child_count())),
                                        (#[verus::internal(trigger)] self.child_at_idx(i).reachable_addrs_using_ranking(ranking)).subset_of(self.reachable_addrs_using_ranking_recur(ranking,
                                                child_idx))))]);
                ::builtin::decreases(((self.child_count()).spec_sub(child_idx)));
                if (child_idx).spec_lt(self.child_count()) {
                        ::builtin::assert_(self.root().valid_child_index(child_idx));
                        self.reachable_addrs_using_ranking_recur_body_lemma(ranking,
                            (child_idx).spec_add(::builtin::spec_literal_nat("1")));
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn child_subtree_contains_addr(self, ranking: Ranking,
                addr: Address, start: nat, i: nat) -> bool {
                ::builtin::recommends([self.wf(),
                            self.valid_ranking(ranking)]);
                ((::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(start),
                                            i), self.child_count()))) &&
                            (self.child_at_idx(i).valid_ranking(ranking))) &&
                    (self.child_at_idx(i).reachable_addrs_using_ranking(ranking).contains(addr))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn reachable_addrs_using_ranking_recur_closed(self,
                ranking: Ranking, child_idx: nat) {
                ::builtin::requires([self.can_recurse_for_reachable(ranking,
                                child_idx)]);
                ::builtin::ensures([::builtin::forall(|addr|
                                    ::builtin::imply(#[verus::internal(trigger)] self.reachable_addrs_using_ranking_recur(ranking,
                                                child_idx).contains(addr),
                                        (::builtin::exists(|i|
                                                    self.child_subtree_contains_addr(ranking, addr, child_idx,
                                                        i)))))]);
                ::builtin::decreases((self.get_rank(ranking),
                        (self.child_count()).spec_sub(child_idx)));
                if (child_idx).spec_lt(self.child_count()) {
                        ::builtin::assert_(self.root().valid_child_index(child_idx));
                        self.child_at_idx_acyclic(child_idx);
                        let child = self.child_at_idx(child_idx);
                        ::builtin::assert_(child.valid_ranking(ranking));
                        let child_addrs =
                            self.child_at_idx(child_idx).reachable_addrs_using_ranking(ranking);
                        let right_subtree_addrs =
                            self.reachable_addrs_using_ranking_recur(ranking,
                                (child_idx).spec_add(::builtin::spec_literal_nat("1")));
                        self.child_at_idx(child_idx).reachable_addrs_using_ranking_closed(ranking);
                        self.reachable_addrs_using_ranking_recur_closed(ranking,
                            (child_idx).spec_add(::builtin::spec_literal_nat("1")));
                        {
                            ::builtin::assert_forall_by(|addr|
                                    {
                                        ::builtin::requires(#[verus::internal(trigger)] self.reachable_addrs_using_ranking_recur(ranking,
                                                    child_idx).contains(addr));
                                        ::builtin::ensures((::builtin::exists(|i|
                                                        #[verus::internal(trigger)] self.child_subtree_contains_addr(ranking,
                                                            addr, child_idx, i))));
                                        if right_subtree_addrs.contains(addr) {
                                                let i =
                                                    ::builtin::choose(|i|
                                                            #[verus::internal(trigger)] self.child_subtree_contains_addr(ranking,
                                                                addr,
                                                                (child_idx).spec_add(::builtin::spec_literal_nat("1")), i));
                                                ::builtin::assert_(self.child_subtree_contains_addr(ranking,
                                                        addr, child_idx, i));
                                            } else {
                                               ::builtin::assert_(child_addrs.contains(addr));
                                               ::builtin::assert_(::builtin::imply(child.has_root(),
                                                       child_addrs.contains(child.root.unwrap())));
                                               ::builtin::assert_(self.child_subtree_contains_addr(ranking,
                                                       addr, child_idx, child_idx));
                                           }
                                    });
                        }
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn reachable_addrs_using_ranking_closed(self,
                ranking: Ranking) {
                ::builtin::requires([self.wf(), self.valid_ranking(ranking)]);
                ::builtin::ensures([::builtin::imply(self.has_root(),
                                self.reachable_addrs_using_ranking(ranking).contains(self.root.unwrap())),
                            ::builtin::forall(|addr|
                                    ::builtin::imply(#[verus::internal(trigger)] self.reachable_addrs_using_ranking(ranking).contains(addr)
                                            && !::builtin::spec_eq(Some(addr), self.root),
                                        (::builtin::exists(|i|
                                                    self.child_subtree_contains_addr(ranking, addr,
                                                        ::builtin::spec_literal_integer("0"), i)))))]);
                ::builtin::decreases((self.get_rank(ranking)));
                if self.has_root() {
                        let sub_tree_addrs =
                            self.reachable_addrs_using_ranking_recur(ranking,
                                ::builtin::spec_literal_integer("0"));
                        self.reachable_addrs_using_ranking_recur_closed(ranking,
                            ::builtin::spec_literal_integer("0"));
                        ::builtin::assert_(::builtin::ext_equal(sub_tree_addrs.insert(self.root.unwrap()),
                                self.reachable_addrs_using_ranking(ranking)));
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn reachable_addrs_are_closed(self, ranking: Ranking,
                addr: Address) {
                ::builtin::requires([self.wf(), self.has_root(),
                            self.valid_ranking(ranking),
                            self.reachable_addrs_using_ranking(ranking).contains(addr),
                            self.dv.entries.dom().contains(addr)]);
                ::builtin::ensures([({
                                    let node = self.dv.entries.spec_index(addr);
                                    ::builtin::forall(|i|
                                            ::builtin::imply(#[verus::internal(trigger)] node.valid_child_index(i)
                                                    &&
                                                    node.children.spec_index(::builtin::spec_cast_integer::<_,
                                                                    int>(i)).is_Some(),
                                                self.reachable_addrs_using_ranking(ranking).contains(node.children.spec_index(::builtin::spec_cast_integer::<_,
                                                                    int>(i)).unwrap())))
                                })]);
                ::builtin::decreases((self.get_rank(ranking)));
                let node = self.dv.entries.spec_index(addr);
                let reachable_addrs =
                    self.reachable_addrs_using_ranking(ranking);
                self.reachable_addrs_using_ranking_closed(ranking);
                {
                    ::builtin::assert_forall_by(|i|
                            {
                                ::builtin::requires(#[verus::internal(trigger)] node.valid_child_index(i)
                                        &&
                                        node.children.spec_index(::builtin::spec_cast_integer::<_,
                                                        int>(i)).is_Some());
                                ::builtin::ensures(reachable_addrs.contains(node.children.spec_index(::builtin::spec_cast_integer::<_,
                                                        int>(i)).unwrap()));
                                if ::builtin::spec_eq(addr, self.root.unwrap()) {
                                        self.child_at_idx(i).reachable_addrs_using_ranking_closed(ranking);
                                        ::builtin::assert_(self.child_at_idx(i).has_root());
                                        self.reachable_addrs_using_ranking_recur_body_lemma(ranking,
                                            ::builtin::spec_literal_integer("0"));
                                        ::builtin::assert_(reachable_addrs.contains(node.children.spec_index(::builtin::spec_cast_integer::<_,
                                                                int>(i)).unwrap()));
                                    } else {
                                       ::builtin::assert_(self.reachable_addrs_using_ranking(ranking).contains(addr));
                                       let i =
                                           ::builtin::choose(|i|
                                                   self.child_subtree_contains_addr(ranking, addr,
                                                       ::builtin::spec_literal_integer("0"), i));
                                       ::builtin::assert_(self.root().valid_child_index(i));
                                       self.child_at_idx(i).reachable_addrs_are_closed(ranking,
                                           addr);
                                       self.reachable_addrs_using_ranking_recur_body_lemma(ranking,
                                           ::builtin::spec_literal_integer("0"));
                                   }
                            });
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn build_tight_preserves_wf(self, ranking: Ranking) {
                ::builtin::requires([self.wf(), self.valid_ranking(ranking)]);
                ::builtin::ensures([self.build_tight_tree().wf()]);
                ::builtin::decreases((self.get_rank(ranking)));
                let result = self.build_tight_tree();
                {
                    ::builtin::assert_forall_by(|addr|
                            {
                                ::builtin::requires(#[verus::internal(trigger)] result.dv.entries.contains_key(addr));
                                ::builtin::ensures({
                                        (result.dv.node_has_nondangling_child_ptrs(result.dv.entries.spec_index(addr)))
                                            &&
                                            (result.dv.node_has_linked_children(result.dv.entries.spec_index(addr)))
                                    });
                                self.reachable_addrs_are_closed(self.the_ranking(), addr);
                            });
                }
                {
                    ::builtin::assert_forall_by(|addr|
                            {
                                ::builtin::requires(result.dv.entries.contains_key(addr));
                                ::builtin::ensures(#[verus::internal(trigger)] result.dv.entries.spec_index(addr).buffers.valid(result.buffer_dv));
                                let node = result.dv.entries.spec_index(addr);
                                ::builtin::assert_(node.buffers.valid(self.buffer_dv));
                                {
                                    ::builtin::assert_forall_by(|i|
                                            {
                                                ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                i), node.buffers.len())));
                                                ::builtin::ensures(#[verus::internal(trigger)] result.buffer_dv.repr().contains(node.buffers.spec_index(i)));
                                                ::builtin::assert_(node.buffers.repr().contains(node.buffers.spec_index(i)));
                                                ::builtin::assert_(self.reachable_buffer(addr,
                                                        node.buffers.spec_index(i)));
                                            });
                                }
                                ::builtin::assert_(node.buffers.valid(result.buffer_dv));
                            });
                }
                lemma_len_subset(result.dv.entries.dom(),
                    self.dv.entries.dom());
                lemma_len_subset(result.buffer_dv.entries.dom(),
                    self.buffer_dv.entries.dom());
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn build_tight_preserves_i(self) {
                ::builtin::requires([self.acyclic()]);
                ::builtin::ensures([self.build_tight_tree().wf(),
                            self.build_tight_tree().valid_ranking(self.the_ranking()),
                            ::builtin::spec_eq(self.i(), self.build_tight_tree().i())]);
                let ranking = self.the_ranking();
                let result = self.build_tight_tree();
                self.build_tight_preserves_wf(ranking);
                ::builtin::assert_(result.valid_ranking(ranking));
                result.betree_subdisk_preserves_i_with_ranking(self, ranking);
                result.i_node_ignores_ranking(ranking, result.the_ranking());
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn build_tight_ranking(self, ranking: Ranking) -> Ranking {
                ranking.restrict(self.dv.entries.dom())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn identical_children_commutes_with_i(self, idx: nat,
                other: LinkedBetree, other_idx: nat, ranking: Ranking) {
                ::builtin::requires([self.wf(), self.has_root(),
                            self.root().valid_child_index(idx), other.wf(),
                            other.has_root(), other.root().valid_child_index(other_idx),
                            self.valid_ranking(ranking), other.valid_ranking(ranking),
                            self.dv.is_subdisk(other.dv),
                            self.buffer_dv.is_subdisk(other.buffer_dv),
                            ::builtin::spec_eq(self.root().children.spec_index(::builtin::spec_cast_integer::<_,
                                            int>(idx)),
                                other.root().children.spec_index(::builtin::spec_cast_integer::<_,
                                            int>(other_idx)))]);
                ::builtin::ensures([::builtin::spec_eq(self.i().get_Node_children().spec_index(::builtin::spec_cast_integer::<_,
                                            int>(idx)),
                                other.i().get_Node_children().spec_index(::builtin::spec_cast_integer::<_,
                                            int>(other_idx)))]);
                let child = self.child_at_idx(idx);
                let other_child = other.child_at_idx(other_idx);
                self.i_children_lemma(self.the_ranking());
                other.i_children_lemma(other.the_ranking());
                self.child_at_idx_commutes_with_i(idx);
                other.child_at_idx_commutes_with_i(other_idx);
                child.betree_subdisk_preserves_i_with_ranking(other_child,
                    ranking);
                child.i_node_ignores_ranking(self.the_ranking(), ranking);
                other_child.i_node_ignores_ranking(other.the_ranking(),
                    ranking);
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn push_memtable_wf(self, memtable: Memtable,
                new_addrs: TwoAddrs) {
                ::builtin::requires([self.wf(), new_addrs.no_duplicates(),
                            self.is_fresh(new_addrs.repr())]);
                ::builtin::ensures([self.push_memtable(memtable,
                                    new_addrs).wf()]);
                let result = self.push_memtable(memtable, new_addrs);
                if self.has_root() {
                        {
                            ::builtin::assert_forall_by(|i|
                                    {
                                        ::builtin::ensures(::builtin::imply(result.root().valid_child_index(i),
                                                self.root().valid_child_index(i)));
                                    });
                        }
                        ::builtin::assert_(result.dv.node_has_nondangling_child_ptrs(result.root()));
                        ::builtin::assert_(result.dv.node_has_linked_children(result.root()));
                    }
                ::builtin::assert_(result.dv.healthy_child_ptrs());
                ::builtin::assert_(result.dv.wf());
                {
                    ::builtin::assert_forall_by(|addr|
                            {
                                ::builtin::requires(result.dv.entries.contains_key(addr));
                                ::builtin::ensures(#[verus::internal(trigger)] result.dv.entries.spec_index(addr).buffers.valid(result.buffer_dv));
                                if ::builtin::spec_eq(addr, result.root.unwrap()) &&
                                            self.has_root() {
                                        let node = result.root();
                                        ::builtin::assert_(::builtin::spec_eq(node.buffers.len(),
                                                (self.root().buffers.len()).spec_add(::builtin::spec_literal_nat("1"))));
                                        ::builtin::assert_(self.root().buffers.valid(self.buffer_dv));
                                        {
                                            ::builtin::assert_forall_by(|i|
                                                    {
                                                        ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                        i), node.buffers.len())));
                                                        ::builtin::ensures(#[verus::internal(trigger)] result.buffer_dv.repr().contains(node.buffers.spec_index(i)));
                                                        if (i).spec_lt((node.buffers.len()).spec_sub(::builtin::spec_literal_nat("1")))
                                                                {
                                                                ::builtin::assert_(::builtin::spec_eq(self.root().buffers.spec_index(i),
                                                                        node.buffers.spec_index(i)));
                                                                ::builtin::assert_(self.buffer_dv.repr().contains(node.buffers.spec_index(i)));
                                                                ::builtin::assert_(result.buffer_dv.repr().contains(node.buffers.spec_index(i)));
                                                            } else {
                                                               ::builtin::assert_(::builtin::spec_eq(node.buffers.spec_index(i),
                                                                       new_addrs.addr2));
                                                           }
                                                    });
                                        }
                                    } else if !::builtin::spec_eq(addr, result.root.unwrap()) {
                                       ::builtin::assert_(result.dv.entries.spec_index(addr).buffers.valid(self.buffer_dv));
                                   }
                            });
                }
                ::builtin::assert_(result.dv.no_dangling_buffer_ptr(result.buffer_dv));
                ::builtin::assert_(result.wf());
            }
            #[verifier::spinoff_prover]
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn push_memtable_new_ranking(self, memtable: Memtable,
                new_addrs: TwoAddrs, old_ranking: Ranking) -> Ranking {
                ::builtin::requires([self.wf(), new_addrs.no_duplicates(),
                            self.is_fresh(new_addrs.repr()),
                            self.valid_ranking(old_ranking),
                            self.dv.ranking_is_tight(old_ranking)]);
                ::builtin::ensures(|new_ranking: Ranking|
                        [self.push_memtable(memtable,
                                        new_addrs).valid_ranking(new_ranking),
                                self.push_memtable(memtable,
                                            new_addrs).build_tight_tree().wf(),
                                self.push_memtable(memtable,
                                            new_addrs).build_tight_tree().valid_ranking(new_ranking),
                                ::builtin::spec_eq(new_ranking.dom(),
                                    old_ranking.dom().insert(new_addrs.addr1))]);
                let result = self.push_memtable(memtable, new_addrs);
                self.push_memtable_wf(memtable, new_addrs);
                let new_rank =
                    if self.has_root() {
                            (old_ranking.spec_index(self.root.unwrap())).spec_add(::builtin::spec_literal_nat("1"))
                        } else { ::builtin::spec_literal_integer("0") };
                let new_ranking =
                    old_ranking.insert(new_addrs.addr1, new_rank);
                if self.has_root() {
                        ::builtin::assert_(result.has_root());
                        {
                            ::builtin::assert_forall_by(|i|
                                    {
                                        ::builtin::ensures(::builtin::imply(result.root().valid_child_index(i),
                                                self.root().valid_child_index(i)));
                                    });
                        }
                    }
                ::builtin::assert_(result.dv.valid_ranking(new_ranking));
                ::builtin::assert_(result.valid_ranking(new_ranking));
                result.build_tight_preserves_wf(new_ranking);
                new_ranking
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn push_memtable_commutes_with_i(self, memtable: Memtable,
                new_addrs: TwoAddrs) {
                ::builtin::requires([self.acyclic(),
                            new_addrs.no_duplicates(),
                            self.is_fresh(new_addrs.repr())]);
                ::builtin::ensures([self.push_memtable(memtable,
                                        new_addrs).build_tight_tree().acyclic(),
                            ::builtin::spec_eq(self.push_memtable(memtable,
                                            new_addrs).build_tight_tree().i(),
                                self.i().push_memtable(memtable))]);
                let result = self.push_memtable(memtable, new_addrs);
                let old_ranking =
                    self.build_tight_ranking(self.the_ranking());
                let new_ranking =
                    self.push_memtable_new_ranking(memtable, new_addrs,
                        old_ranking);
                result.build_tight_preserves_i();
                ::builtin::assert_(::builtin::spec_eq(result.build_tight_tree().i(),
                        result.i()));
                result.i_node_ignores_ranking(result.the_ranking(),
                    new_ranking);
                result.i_children_lemma(result.the_ranking());
                if self.has_root() {
                        ::builtin::assert_(self.valid_ranking(new_ranking));
                        self.i_children_lemma(new_ranking);
                        result.i_children_lemma(new_ranking);
                        self.i_children_ignores_ranking(self.the_ranking(),
                            new_ranking);
                        result.i_node_ignores_ranking(result.the_ranking(),
                            new_ranking);
                        self.root().buffers.subdisk_implies_same_i(self.buffer_dv,
                            result.buffer_dv);
                        let a = self.i_children(new_ranking);
                        let b = result.i_children(new_ranking);
                        ::builtin::assert_(::builtin::spec_eq(a.len(), b.len()));
                        {
                            ::builtin::assert_forall_by(|i|
                                    {
                                        ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                        i), a.len())));
                                        ::builtin::ensures(::builtin::ext_equal(a.spec_index(i),
                                                b.spec_index(i)));
                                        self.identical_children_commutes_with_i(::builtin::spec_cast_integer::<_,
                                                    nat>(i), result, ::builtin::spec_cast_integer::<_, nat>(i),
                                            new_ranking);
                                    });
                        }
                    }
                ::builtin::assert_(::builtin::ext_equal(result.i().get_Node_children(),
                        self.i().push_memtable(memtable).get_Node_children()));
                ::builtin::assert_(::builtin::ext_equal(result.i().get_Node_buffers(),
                        self.i().push_memtable(memtable).get_Node_buffers()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn grow_new_ranking(self, new_root_addr: Address,
                old_ranking: Ranking) -> Ranking {
                ::builtin::requires([self.wf(),
                            ::builtin::imply(self.has_root(),
                                ::builtin::spec_eq(self.root().my_domain(),
                                    total_domain())), self.valid_ranking(old_ranking),
                            self.is_fresh(Set::empty().insert(new_root_addr)),
                            self.dv.ranking_is_tight(old_ranking)]);
                ::builtin::ensures(|new_ranking: Ranking|
                        [self.grow(new_root_addr).wf(),
                                self.grow(new_root_addr).valid_ranking(new_ranking),
                                ::builtin::spec_eq(new_ranking.dom(),
                                    old_ranking.dom().insert(new_root_addr))]);
                self.dv.tight_ranking_is_finite(old_ranking);
                let result = self.grow(new_root_addr);
                let new_rank =
                    if self.has_root() {
                            (old_ranking.spec_index(self.root.unwrap())).spec_add(::builtin::spec_literal_nat("1"))
                        } else if ::builtin::ext_equal(old_ranking,
                               ::vstd::map::Map::empty()) {
                           ::builtin::spec_literal_integer("1")
                       } else {
                           (get_max_rank(old_ranking)).spec_add(::builtin::spec_literal_nat("1"))
                       };
                old_ranking.insert(new_root_addr, new_rank)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn fresh_entry_preserves_i(self, other: LinkedBetree,
                ranking: Ranking, new_addr: Address) {
                ::builtin::requires([self.wf(), other.wf(),
                            ::builtin::spec_eq(self.root, other.root),
                            self.valid_ranking(ranking), other.valid_ranking(ranking),
                            self.dv.is_subdisk(other.dv),
                            ::builtin::ext_equal(self.dv.entries.dom().insert(new_addr),
                                other.dv.entries.dom()),
                            ::builtin::spec_eq(self.buffer_dv, other.buffer_dv),
                            self.is_fresh(Set::empty().insert(new_addr))]);
                ::builtin::ensures([::builtin::spec_eq(self.i_node(ranking),
                                other.i_node(ranking))]);
                ::builtin::decreases((self.get_rank(ranking)));
                if self.has_root() {
                        self.i_children_lemma(ranking);
                        other.i_children_lemma(ranking);
                        ::builtin::assert_(::builtin::spec_eq(self.i_children(ranking).len(),
                                other.i_children(ranking).len()));
                        {
                            ::builtin::assert_forall_by(|i|
                                    {
                                        ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                        i), self.i_children(ranking).len())));
                                        ::builtin::ensures(::builtin::spec_eq(self.i_children(ranking).spec_index(i),
                                                other.i_children(ranking).spec_index(i)));
                                        ::builtin::assert_(self.root().valid_child_index(::builtin::spec_cast_integer::<_,
                                                        nat>(i)));
                                        ::builtin::assert_(other.root().valid_child_index(::builtin::spec_cast_integer::<_,
                                                        nat>(i)));
                                        self.child_at_idx_acyclic(::builtin::spec_cast_integer::<_,
                                                    nat>(i));
                                        other.child_at_idx_acyclic(::builtin::spec_cast_integer::<_,
                                                    nat>(i));
                                        self.child_at_idx(::builtin::spec_cast_integer::<_,
                                                        nat>(i)).fresh_entry_preserves_i(other.child_at_idx(::builtin::spec_cast_integer::<_,
                                                        nat>(i)), ranking, new_addr);
                                    });
                        }
                        ::builtin::assert_(::builtin::ext_equal(self.i_node(ranking).get_Node_children(),
                                other.i_node(ranking).get_Node_children()));
                        ::builtin::assert_(::builtin::ext_equal(self.i_node(ranking).get_Node_buffers(),
                                other.i_node(ranking).get_Node_buffers()));
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn grow_commutes_with_i(self, new_root_addr: Address) {
                ::builtin::requires([self.acyclic(),
                            ::builtin::imply(self.has_root(),
                                ::builtin::spec_eq(self.root().my_domain(),
                                    total_domain())),
                            self.is_fresh(Set::empty().insert(new_root_addr))]);
                ::builtin::ensures([self.grow(new_root_addr).acyclic(),
                            ::builtin::spec_eq(self.grow(new_root_addr).i(),
                                self.i().grow())]);
                let result = self.grow(new_root_addr);
                let old_ranking =
                    self.build_tight_ranking(self.the_ranking());
                let new_ranking =
                    self.grow_new_ranking(new_root_addr, old_ranking);
                result.i_children_lemma(result.the_ranking());
                result.child_at_idx_acyclic(::builtin::spec_literal_integer("0"));
                let child =
                    result.child_at_idx(::builtin::spec_literal_integer("0"));
                result.child_at_idx_valid_ranking(::builtin::spec_literal_integer("0"));
                child.i_node_ignores_ranking(new_ranking,
                    result.the_ranking());
                self.i_node_ignores_ranking(self.the_ranking(), new_ranking);
                self.fresh_entry_preserves_i(child, new_ranking,
                    new_root_addr);
                ::builtin::assert_(::builtin::ext_equal(result.i().get_Node_children(),
                        self.i().grow().get_Node_children()));
                ::builtin::assert_(::builtin::ext_equal(result.i().get_Node_buffers(),
                        self.i().grow().get_Node_buffers()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split_element(self, request: SplitRequest) -> Element {
                ::builtin::recommends([self.can_split_parent(request)]);
                match request {
                    SplitRequest::SplitLeaf { child_idx, split_key } =>
                        to_element(split_key),
                    SplitRequest::SplitIndex { child_idx, child_pivot_idx } =>
                        self.child_at_idx(request.get_child_idx()).root().pivots.pivots.spec_index(::builtin::spec_cast_integer::<_,
                                    int>(child_pivot_idx)),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn split_new_ranking(self, request: SplitRequest,
                new_addrs: SplitAddrs, ranking: Ranking) -> Ranking {
                ::builtin::requires([self.wf(), self.has_root(),
                            self.valid_ranking(ranking), self.can_split_parent(request),
                            new_addrs.no_duplicates(),
                            self.is_fresh(new_addrs.repr())]);
                ::builtin::ensures(|new_ranking: Ranking|
                        [self.valid_ranking(new_ranking),
                                self.split_parent(request,
                                        new_addrs).valid_ranking(new_ranking),
                                ::builtin::spec_eq(new_ranking.dom(),
                                    (ranking.dom()).spec_add(new_addrs.repr()))]);
                let child_idx = request.get_child_idx();
                let old_child_addr =
                    self.root().children.spec_index(::builtin::spec_cast_integer::<_,
                                    int>(child_idx)).unwrap();
                let old_parent_rank = ranking.spec_index(self.root.unwrap());
                let old_child_rank = ranking.spec_index(old_child_addr);
                let new_ranking =
                    ranking.insert(new_addrs.left,
                                old_child_rank).insert(new_addrs.right,
                            old_child_rank).insert(new_addrs.parent, old_parent_rank);
                ::builtin::assert_(self.dv.valid_ranking(new_ranking));
                let result = self.split_parent(request, new_addrs);
                self.root().pivots.insert_wf((::builtin::spec_cast_integer::<_,
                                    int>(child_idx)).spec_add(::builtin::spec_literal_nat("1")),
                    self.split_element(request));
                ::builtin::assert_(result.root().wf());
                let old_child =
                    self.dv.entries.spec_index(self.root().children.spec_index(::builtin::spec_cast_integer::<_,
                                        int>(child_idx)).unwrap());
                let new_left_child =
                    result.dv.entries.spec_index(new_addrs.left);
                let new_right_child =
                    result.dv.entries.spec_index(new_addrs.right);
                {
                    ::builtin::assert_forall_by(|i|
                            {
                                ::builtin::ensures(::builtin::imply(new_left_child.valid_child_index(i),
                                        old_child.valid_child_index(i)));
                            });
                }
                {
                    ::builtin::assert_forall_by(|i|
                            {
                                ::builtin::ensures(::builtin::imply(request.is_SplitLeaf()
                                            && new_right_child.valid_child_index(i),
                                        old_child.valid_child_index(i)));
                            });
                }
                {
                    ::builtin::assert_forall_by(|i|
                            {
                                ::builtin::ensures(::builtin::imply(request.is_SplitIndex()
                                            && new_right_child.valid_child_index(i),
                                        old_child.valid_child_index((i).spec_add(request.get_SplitIndex_child_pivot_idx()))));
                            });
                }
                {
                    ::builtin::assert_forall_by(|i|
                            {
                                ::builtin::ensures(::builtin::imply(#[verus::internal(trigger)] result.root().valid_child_index(i),
                                        ({
                                                (::builtin::imply((i).spec_lt(child_idx),
                                                            self.root().valid_child_index(i))) &&
                                                    (::builtin::imply((i).spec_gt((child_idx).spec_add(::builtin::spec_literal_nat("1"))),
                                                            self.root().valid_child_index(::builtin::spec_cast_integer::<_,
                                                                        nat>(((i).spec_sub(::builtin::spec_literal_nat("1")))))))
                                            })));
                            });
                }
                ::builtin::assert_(result.dv.valid_ranking(new_ranking));
                ::builtin::assert_(::builtin::ext_equal(new_ranking.dom(),
                        (ranking.dom()).spec_add(new_addrs.repr())));
                new_ranking
            }
            #[verifier::spinoff_prover]
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn split_parent_commutes_with_i(self, request: SplitRequest,
                new_addrs: SplitAddrs) {
                ::builtin::requires([self.acyclic(),
                            self.can_split_parent(request), new_addrs.no_duplicates(),
                            self.is_fresh(new_addrs.repr())]);
                ::builtin::ensures([self.split_parent(request,
                                    new_addrs).acyclic(), self.i().can_split_parent(request),
                            ::builtin::spec_eq(self.split_parent(request,
                                        new_addrs).i(), self.i().split_parent(request))]);
                let result = self.split_parent(request, new_addrs);
                let new_ranking =
                    self.split_new_ranking(request, new_addrs,
                        self.the_ranking());
                let child_idx = request.get_child_idx();
                let old_child = self.child_at_idx(child_idx);
                self.i_wf();
                self.child_at_idx_acyclic(child_idx);
                self.child_at_idx_commutes_with_i(child_idx);
                old_child.i_node_ignores_ranking(self.the_ranking(),
                    old_child.the_ranking());
                old_child.indexiness_commutes_with_i();
                ::builtin::assert_(self.i().can_split_parent(request));
                let a = result.i_children(result.the_ranking());
                let b = self.i().split_parent(request).get_Node_children();
                {
                    ::builtin::assert_by(::builtin::spec_eq(a.len(), b.len()),
                        {
                            self.i_children_lemma(self.the_ranking());
                            result.i_children_lemma(result.the_ranking());
                        });
                }
                {
                    ::builtin::assert_forall_by(|i|
                            {
                                ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                i), a.len())));
                                ::builtin::ensures(::builtin::ext_equal(a.spec_index(i),
                                        b.spec_index(i)));
                                result.child_at_idx_acyclic(::builtin::spec_cast_integer::<_,
                                            nat>(i));
                                result.child_at_idx_commutes_with_i(::builtin::spec_cast_integer::<_,
                                            nat>(i));
                                if (i).spec_lt(child_idx) {
                                        self.identical_children_commutes_with_i(::builtin::spec_cast_integer::<_,
                                                    nat>(i), result, ::builtin::spec_cast_integer::<_, nat>(i),
                                            new_ranking);
                                    } else if ::builtin::spec_eq(i, child_idx) {
                                       let new_left_child =
                                           result.child_at_idx(::builtin::spec_cast_integer::<_,
                                                       nat>(i));
                                       new_left_child.i_children_lemma(new_ranking);
                                       {
                                           ::builtin::assert_forall_by(|j|
                                                   {
                                                       ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                       j), new_left_child.root().children.len())));
                                                       ::builtin::ensures(::builtin::spec_eq(#[verus::internal(trigger)] new_left_child.i_children(new_ranking).spec_index(j),
                                                               b.spec_index(i).get_Node_children().spec_index(j)));
                                                       ::builtin::assert_(new_left_child.root().valid_child_index(::builtin::spec_cast_integer::<_,
                                                                       nat>(j)));
                                                       ::builtin::assert_(old_child.root().valid_child_index(::builtin::spec_cast_integer::<_,
                                                                       nat>(j)));
                                                       let old_grand_child =
                                                           old_child.child_at_idx(::builtin::spec_cast_integer::<_,
                                                                       nat>(j));
                                                       let new_grand_child =
                                                           new_left_child.child_at_idx(::builtin::spec_cast_integer::<_,
                                                                       nat>(j));
                                                       old_child.i_children_lemma(self.the_ranking());
                                                       old_grand_child.betree_subdisk_preserves_i_with_ranking(new_grand_child,
                                                           new_ranking);
                                                       old_grand_child.i_node_ignores_ranking(self.the_ranking(),
                                                           new_ranking);
                                                   });
                                       }
                                       ::builtin::assert_(::builtin::ext_equal(new_left_child.i_children(new_ranking),
                                               b.spec_index(i).get_Node_children()));
                                       new_left_child.i_node_ignores_ranking(new_ranking,
                                           new_left_child.the_ranking());
                                   } else if ::builtin::spec_eq(i,
                                           (child_idx).spec_add(::builtin::spec_literal_nat("1"))) {
                                       let new_right_child =
                                           result.child_at_idx(::builtin::spec_cast_integer::<_,
                                                       nat>(i));
                                       new_right_child.i_children_lemma(new_ranking);
                                       {
                                           ::builtin::assert_forall_by(|j|
                                                   {
                                                       ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                       j), new_right_child.root().children.len())));
                                                       ::builtin::ensures(::builtin::spec_eq(#[verus::internal(trigger)] new_right_child.i_children(new_ranking).spec_index(j),
                                                               b.spec_index(i).get_Node_children().spec_index(j)));
                                                       ::builtin::assert_(new_right_child.root().valid_child_index(::builtin::spec_cast_integer::<_,
                                                                       nat>(j)));
                                                       if request.is_SplitIndex() {
                                                               let pivot_idx = request.get_SplitIndex_child_pivot_idx();
                                                               ::builtin::assert_(old_child.root().valid_child_index(::builtin::spec_cast_integer::<_,
                                                                               nat>(((j).spec_add(pivot_idx)))));
                                                               let old_grand_child =
                                                                   old_child.child_at_idx(::builtin::spec_cast_integer::<_,
                                                                               nat>(((j).spec_add(pivot_idx))));
                                                               let new_grand_child =
                                                                   new_right_child.child_at_idx(::builtin::spec_cast_integer::<_,
                                                                               nat>(j));
                                                               old_child.i_children_lemma(self.the_ranking());
                                                               old_grand_child.betree_subdisk_preserves_i_with_ranking(new_grand_child,
                                                                   new_ranking);
                                                               old_grand_child.i_node_ignores_ranking(self.the_ranking(),
                                                                   new_ranking);
                                                           } else {
                                                              ::builtin::assert_(old_child.root().valid_child_index(::builtin::spec_cast_integer::<_,
                                                                              nat>(j)));
                                                          }
                                                   });
                                       }
                                       ::builtin::assert_(::builtin::ext_equal(new_right_child.i_children(new_ranking),
                                               b.spec_index(i).get_Node_children()));
                                       new_right_child.i_node_ignores_ranking(new_ranking,
                                           new_right_child.the_ranking());
                                   } else {
                                       self.identical_children_commutes_with_i(::builtin::spec_cast_integer::<_,
                                                   nat>(((i).spec_sub(::builtin::spec_literal_nat("1")))),
                                           result, ::builtin::spec_cast_integer::<_, nat>(i),
                                           new_ranking);
                                   }
                            });
                }
                ::builtin::assert_(::builtin::ext_equal(a, b));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn flush_new_ranking(self, child_idx: nat, buffer_gc: nat,
                new_addrs: TwoAddrs, ranking: Ranking) -> Ranking {
                ::builtin::requires([self.wf(), self.has_root(),
                            self.valid_ranking(ranking),
                            self.can_flush(child_idx, buffer_gc),
                            new_addrs.no_duplicates(),
                            self.is_fresh(new_addrs.repr())]);
                ::builtin::ensures(|new_ranking: Ranking|
                        [self.valid_ranking(new_ranking),
                                self.flush(child_idx, buffer_gc,
                                        new_addrs).valid_ranking(new_ranking),
                                ::builtin::spec_eq(new_ranking.dom(),
                                    (ranking.dom()).spec_add(new_addrs.repr())),
                                (buffer_gc).spec_le(self.root().buffers.len())]);
                let result = self.flush(child_idx, buffer_gc, new_addrs);
                let old_child_addr =
                    self.child_at_idx(child_idx).root.unwrap();
                ::builtin::assert_(result.dv.entries.contains_key(new_addrs.addr1));
                ::builtin::assert_(result.dv.entries.contains_key(new_addrs.addr2));
                let old_child = self.dv.entries.spec_index(old_child_addr);
                let new_parent =
                    result.dv.entries.spec_index(new_addrs.addr1);
                let new_child = result.dv.entries.spec_index(new_addrs.addr2);
                let old_parent_rank = ranking.spec_index(self.root.unwrap());
                let old_child_rank = ranking.spec_index(old_child_addr);
                let new_ranking =
                    ranking.insert(new_addrs.addr1,
                            old_parent_rank).insert(new_addrs.addr2, old_child_rank);
                {
                    ::builtin::assert_forall_by(|i|
                            {
                                ::builtin::ensures(::builtin::imply(#[verus::internal(trigger)] new_child.valid_child_index(i),
                                        old_child.valid_child_index(i)));
                            });
                }
                {
                    ::builtin::assert_forall_by(|i|
                            {
                                ::builtin::ensures(::builtin::imply(#[verus::internal(trigger)] new_parent.valid_child_index(i),
                                        self.root().valid_child_index(i)));
                            });
                }
                ::builtin::assert_(result.dv.valid_ranking(new_ranking));
                {
                    ::builtin::assert_by((buffer_gc).spec_le(self.root().buffers.len()),
                        {
                            let updated_ofs =
                                self.root().flushed.update(::builtin::spec_cast_integer::<_,
                                            int>(child_idx), self.root().buffers.len());
                            ::builtin::assert_((updated_ofs.offsets.spec_index(::builtin::spec_cast_integer::<_,
                                                    int>(child_idx))).spec_ge(buffer_gc));
                        });
                }
                ::builtin::assert_(self.root().buffers.valid(self.buffer_dv));
                ::builtin::assert_(old_child.buffers.valid(self.buffer_dv));
                ::builtin::assert_(result.wf());
                ::builtin::assert_(::builtin::ext_equal(new_ranking.dom(),
                        (ranking.dom()).spec_add(new_addrs.repr())));
                new_ranking
            }
            #[verifier::spinoff_prover]
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn flush_commutes_with_i(self, child_idx: nat, buffer_gc: nat,
                new_addrs: TwoAddrs) {
                ::builtin::requires([self.acyclic(),
                            self.can_flush(child_idx, buffer_gc),
                            new_addrs.no_duplicates(),
                            self.is_fresh(new_addrs.repr())]);
                ::builtin::ensures([self.flush(child_idx, buffer_gc,
                                    new_addrs).acyclic(),
                            self.i().can_flush(child_idx, buffer_gc),
                            ::builtin::spec_eq(self.flush(child_idx, buffer_gc,
                                        new_addrs).i(), self.i().flush(child_idx, buffer_gc))]);
                let result = self.flush(child_idx, buffer_gc, new_addrs);
                let new_ranking =
                    self.flush_new_ranking(child_idx, buffer_gc, new_addrs,
                        self.the_ranking());
                self.i_wf();
                ::builtin::assert_(::builtin::ext_equal(result.i().get_Node_buffers(),
                        self.i().flush(child_idx, buffer_gc).get_Node_buffers()));
                let a = result.i_children(result.the_ranking());
                let b =
                    self.i().flush(child_idx, buffer_gc).get_Node_children();
                self.i_children_lemma(self.the_ranking());
                result.i_children_lemma(result.the_ranking());
                {
                    ::builtin::assert_forall_by(|i|
                            {
                                ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                i), a.len())));
                                ::builtin::ensures(::builtin::ext_equal(a.spec_index(i),
                                        b.spec_index(i)));
                                ::builtin::assert_(self.root().valid_child_index(::builtin::spec_cast_integer::<_,
                                                nat>(i)));
                                ::builtin::assert_(result.root().valid_child_index(::builtin::spec_cast_integer::<_,
                                                nat>(i)));
                                let old_child =
                                    self.child_at_idx(::builtin::spec_cast_integer::<_,
                                                nat>(i));
                                self.child_at_idx_acyclic(::builtin::spec_cast_integer::<_,
                                            nat>(i));
                                self.child_at_idx_commutes_with_i(::builtin::spec_cast_integer::<_,
                                            nat>(i));
                                self.child_at_idx_valid_ranking(::builtin::spec_cast_integer::<_,
                                            nat>(i));
                                let new_child =
                                    result.child_at_idx(::builtin::spec_cast_integer::<_,
                                                nat>(i));
                                result.child_at_idx_acyclic(::builtin::spec_cast_integer::<_,
                                            nat>(i));
                                result.child_at_idx_commutes_with_i(::builtin::spec_cast_integer::<_,
                                            nat>(i));
                                result.child_at_idx_valid_ranking(::builtin::spec_cast_integer::<_,
                                            nat>(i));
                                if ::builtin::spec_eq(i, child_idx) {
                                        ::builtin::assert_(::builtin::spec_eq(a.spec_index(i).get_Node_children(),
                                                new_child.i_children(result.the_ranking())));
                                        ::builtin::assert_(::builtin::spec_eq(b.spec_index(i).get_Node_children(),
                                                old_child.i_children(self.the_ranking())));
                                        {
                                            ::builtin::assert_forall_by(|j|
                                                    {
                                                        ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                        j), a.spec_index(i).get_Node_children().len())));
                                                        ::builtin::ensures(::builtin::spec_eq(a.spec_index(i).get_Node_children().spec_index(j),
                                                                b.spec_index(i).get_Node_children().spec_index(j)));
                                                        ::builtin::assert_(old_child.root().valid_child_index(::builtin::spec_cast_integer::<_,
                                                                        nat>(j)));
                                                        ::builtin::assert_(new_child.root().valid_child_index(::builtin::spec_cast_integer::<_,
                                                                        nat>(j)));
                                                        let old_grand_child =
                                                            old_child.child_at_idx(::builtin::spec_cast_integer::<_,
                                                                        nat>(j));
                                                        let new_grand_child =
                                                            new_child.child_at_idx(::builtin::spec_cast_integer::<_,
                                                                        nat>(j));
                                                        old_child.child_at_idx_acyclic(::builtin::spec_cast_integer::<_,
                                                                    nat>(j));
                                                        new_child.child_at_idx_acyclic(::builtin::spec_cast_integer::<_,
                                                                    nat>(j));
                                                        old_child.child_at_idx_valid_ranking(::builtin::spec_cast_integer::<_,
                                                                    nat>(j));
                                                        new_child.child_at_idx_valid_ranking(::builtin::spec_cast_integer::<_,
                                                                    nat>(j));
                                                        {
                                                            ::builtin::assert_by(::builtin::spec_eq(a.spec_index(i).get_Node_children().spec_index(j),
                                                                    new_grand_child.i_node(new_ranking)),
                                                                {
                                                                    new_child.i_children_lemma(result.the_ranking());
                                                                    new_grand_child.i_node_ignores_ranking(result.the_ranking(),
                                                                        new_ranking);
                                                                });
                                                        }
                                                        {
                                                            ::builtin::assert_by(::builtin::spec_eq(b.spec_index(i).get_Node_children().spec_index(j),
                                                                    old_grand_child.i_node(new_ranking)),
                                                                {
                                                                    old_child.i_children_lemma(self.the_ranking());
                                                                    old_grand_child.i_node_ignores_ranking(self.the_ranking(),
                                                                        new_ranking);
                                                                });
                                                        }
                                                        old_grand_child.betree_subdisk_preserves_i_with_ranking(new_grand_child,
                                                            new_ranking);
                                                        ::builtin::assert_(::builtin::spec_eq(new_grand_child.i_node(new_ranking),
                                                                old_grand_child.i_node(new_ranking)));
                                                    });
                                        }
                                        ::builtin::assert_(::builtin::ext_equal(a.spec_index(i).get_Node_children(),
                                                b.spec_index(i).get_Node_children()));
                                    } else {
                                       old_child.i_node_ignores_ranking(old_child.the_ranking(),
                                           new_ranking);
                                       new_child.i_node_ignores_ranking(new_child.the_ranking(),
                                           new_ranking);
                                       old_child.betree_subdisk_preserves_i_with_ranking(new_child,
                                           new_ranking);
                                   }
                            });
                }
                ::builtin::assert_(::builtin::ext_equal(a, b));
            }
            #[verifier::spinoff_prover]
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn compact_new_ranking(self, start: nat, end: nat,
                compacted_buffer: Buffer, new_addrs: TwoAddrs,
                ranking: Ranking) -> Ranking {
                ::builtin::requires([self.wf(), self.has_root(),
                            self.valid_ranking(ranking),
                            self.can_compact(start, end, compacted_buffer),
                            new_addrs.no_duplicates(),
                            self.is_fresh(new_addrs.repr())]);
                ::builtin::ensures(|new_ranking: Ranking|
                        [self.valid_ranking(new_ranking),
                                self.compact(start, end, compacted_buffer,
                                        new_addrs).valid_ranking(new_ranking),
                                ::builtin::spec_eq(new_ranking.dom(),
                                    ranking.dom().insert(new_addrs.addr1))]);
                let result =
                    self.compact(start, end, compacted_buffer, new_addrs);
                let new_ranking =
                    ranking.insert(new_addrs.addr1,
                        ranking.spec_index(self.root.unwrap()));
                ::builtin::assert_(::builtin::ext_equal(new_ranking.dom(),
                        ranking.dom().insert(new_addrs.addr1)));
                let new_root = result.dv.entries.spec_index(new_addrs.addr1);
                {
                    ::builtin::assert_forall_by(|i|
                            {
                                ::builtin::ensures(::builtin::imply(#[verus::internal(trigger)] new_root.valid_child_index(i),
                                        self.root().valid_child_index(i)));
                            });
                }
                ::builtin::assert_(result.dv.valid_ranking(new_ranking));
                {
                    ::builtin::assert_forall_by(|addr|
                            {
                                ::builtin::requires(result.dv.entries.contains_key(addr));
                                ::builtin::ensures(#[verus::internal(trigger)] result.dv.entries.spec_index(addr).buffers.valid(result.buffer_dv));
                                let node = result.dv.entries.spec_index(addr);
                                if ::builtin::spec_eq(addr, new_addrs.addr1) {
                                        ::builtin::assert_(self.root().buffers.valid(self.buffer_dv));
                                    } else {
                                       ::builtin::assert_(node.buffers.valid(self.buffer_dv));
                                       node.buffers.subdisk_implies_same_i(self.buffer_dv,
                                           result.buffer_dv);
                                   }
                            });
                }
                ::builtin::assert_(result.dv.no_dangling_buffer_ptr(result.buffer_dv));
                new_ranking
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn can_compact_commutes_with_i(self, start: nat, end: nat,
                compacted_buffer: Buffer, new_addrs: TwoAddrs) {
                ::builtin::requires([self.acyclic(),
                            self.can_compact(start, end, compacted_buffer),
                            new_addrs.no_duplicates(),
                            self.is_fresh(new_addrs.repr())]);
                ::builtin::ensures([self.i().can_compact(start, end,
                                compacted_buffer)]);
                self.i_wf();
                ::builtin::assert_(self.i().is_Node());
                ::builtin::assert_(::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_lt(::builtin::spec_chained_value(start),
                                end), self.i().get_Node_buffers().len())));
                let compact_slice =
                    self.root().buffers.slice(::builtin::spec_cast_integer::<_,
                                int>(start), ::builtin::spec_cast_integer::<_, int>(end));
                let i_compact_slice =
                    self.i().get_Node_buffers().slice(::builtin::spec_cast_integer::<_,
                                int>(start), ::builtin::spec_cast_integer::<_, int>(end));
                ::builtin::assert_(::builtin::ext_equal(compact_slice.i(self.buffer_dv),
                        i_compact_slice));
                ::builtin::assert_(self.root().buffers.valid(self.buffer_dv));
                let compact_ofs_map =
                    self.root().make_offset_map().decrement(start);
                let i_compact_ofs_map =
                    self.i().make_offset_map().decrement(start);
                ::builtin::assert_(::builtin::ext_equal(compact_ofs_map,
                        i_compact_ofs_map));
                {
                    ::builtin::assert_forall_by(|k|
                            {
                                ::builtin::ensures(#[verus::internal(auto_trigger)] ::builtin::spec_eq(self.root().compact_key_range(start,
                                            end, k, self.buffer_dv),
                                        self.i().compact_key_range(start, end, k)));
                                if self.root().compact_key_range(start, end, k,
                                            self.buffer_dv) {
                                        let buffer_idx =
                                            ::builtin::choose(|buffer_idx|
                                                    compact_slice.key_in_buffer_filtered(self.buffer_dv,
                                                        compact_ofs_map, ::builtin::spec_literal_integer("0"), k,
                                                        buffer_idx));
                                        ::builtin::assert_(i_compact_slice.key_in_buffer_filtered(i_compact_ofs_map,
                                                ::builtin::spec_literal_integer("0"), k, buffer_idx));
                                    }
                                if self.i().compact_key_range(start, end, k) {
                                        let buffer_idx =
                                            ::builtin::choose(|buffer_idx|
                                                    i_compact_slice.key_in_buffer_filtered(i_compact_ofs_map,
                                                        ::builtin::spec_literal_integer("0"), k, buffer_idx));
                                        ::builtin::assert_(::builtin::spec_eq(i_compact_ofs_map.offsets.spec_index(k),
                                                compact_ofs_map.offsets.spec_index(k)));
                                        ::builtin::assert_(::builtin::spec_eq(self.root().buffers.spec_index((buffer_idx).spec_add(start)),
                                                compact_slice.spec_index(buffer_idx)));
                                        ::builtin::assert_(self.buffer_dv.entries.contains_key(compact_slice.spec_index(buffer_idx)));
                                        ::builtin::assert_(::builtin::spec_eq(i_compact_slice.key_in_buffer(::builtin::spec_literal_integer("0"),
                                                    k, buffer_idx),
                                                compact_slice.key_in_buffer(self.buffer_dv,
                                                    ::builtin::spec_literal_integer("0"), k, buffer_idx)));
                                        ::builtin::assert_(compact_slice.key_in_buffer_filtered(self.buffer_dv,
                                                compact_ofs_map, ::builtin::spec_literal_integer("0"), k,
                                                buffer_idx));
                                    }
                            });
                }
                {
                    ::builtin::assert_forall_by(|k|
                            {
                                ::builtin::requires(#[verus::internal(auto_trigger)] compacted_buffer.map.contains_key(k));
                                ::builtin::ensures({
                                        let from =
                                            if (self.i().flushed_ofs(k)).spec_le(start) {
                                                    ::builtin::spec_literal_integer("0")
                                                } else { (self.i().flushed_ofs(k)).spec_sub(start) };
                                        ::builtin::spec_eq(compacted_buffer.query(k),
                                            self.i().get_Node_buffers().slice(::builtin::spec_cast_integer::<_,
                                                            int>(start),
                                                    ::builtin::spec_cast_integer::<_,
                                                            int>(end)).query_from(k, from))
                                    });
                                let from =
                                    if (self.i().flushed_ofs(k)).spec_le(start) {
                                            ::builtin::spec_literal_integer("0")
                                        } else { (self.i().flushed_ofs(k)).spec_sub(start) };
                                compact_slice.query_from_commutes_with_i(self.buffer_dv, k,
                                    from);
                            });
                }
            }
            #[verifier::spinoff_prover]
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn compact_commutes_with_i(self, start: nat, end: nat,
                compacted_buffer: Buffer, new_addrs: TwoAddrs) {
                ::builtin::requires([self.acyclic(),
                            self.can_compact(start, end, compacted_buffer),
                            new_addrs.no_duplicates(),
                            self.is_fresh(new_addrs.repr())]);
                ::builtin::ensures([self.compact(start, end, compacted_buffer,
                                    new_addrs).acyclic(),
                            self.i().can_compact(start, end, compacted_buffer),
                            ::builtin::spec_eq(self.compact(start, end,
                                        compacted_buffer, new_addrs).i(),
                                self.i().compact(start, end, compacted_buffer))]);
                let result =
                    self.compact(start, end, compacted_buffer, new_addrs);
                let new_ranking =
                    self.compact_new_ranking(start, end, compacted_buffer,
                        new_addrs, self.the_ranking());
                self.can_compact_commutes_with_i(start, end, compacted_buffer,
                    new_addrs);
                self.root().buffers.subdisk_implies_same_i(self.buffer_dv,
                    result.buffer_dv);
                ::builtin::assert_(::builtin::ext_equal(result.i().get_Node_buffers(),
                        self.i().compact(start, end,
                                compacted_buffer).get_Node_buffers()));
                let a = result.i_children(result.the_ranking());
                let b =
                    self.i().compact(start, end,
                            compacted_buffer).get_Node_children();
                result.i_children_lemma(result.the_ranking());
                ::builtin::assert_(::builtin::spec_eq(a.len(), b.len()));
                {
                    ::builtin::assert_forall_by(|i|
                            {
                                ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                i), a.len())));
                                ::builtin::ensures(::builtin::spec_eq(a.spec_index(i),
                                        b.spec_index(i)));
                                self.identical_children_commutes_with_i(::builtin::spec_cast_integer::<_,
                                            nat>(i), result, ::builtin::spec_cast_integer::<_, nat>(i),
                                    new_ranking);
                            });
                }
                ::builtin::assert_(::builtin::ext_equal(a, b));
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn i_stamped_betree(stamped: StampedBetree)
            -> FilteredBetree_v::StampedBetree {
            ::builtin::recommends([stamped.value.acyclic()]);
            Stamped { value: stamped.value.i(), seq_end: stamped.seq_end }
        }
        #[verus::internal(verus_macro)]
        impl QueryReceiptLine {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> FilteredBetree_v::QueryReceiptLine {
                ::builtin::recommends([self.linked.acyclic()]);
                FilteredBetree_v::QueryReceiptLine {
                    node: self.linked.i(),
                    result: self.result,
                }
            }
        }
        #[verus::internal(verus_macro)]
        impl QueryReceipt {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> FilteredBetree_v::QueryReceipt {
                ::builtin::recommends([self.valid()]);
                let ranking = self.linked.the_ranking();
                FilteredBetree_v::QueryReceipt {
                    key: self.key,
                    root: self.linked.i(),
                    lines: Seq::new(self.lines.len(),
                        ::builtin::closure_to_fn_spec(|i: int|
                                self.lines.spec_index(i).i())),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn i_valid(self) {
                ::builtin::requires([self.valid()]);
                ::builtin::ensures([self.i().valid()]);
                PivotTable::route_lemma_auto();
                let i_receipt = self.i();
                let ranking = self.linked.the_ranking();
                {
                    ::builtin::assert_forall_by(|i: int|
                            {
                                ::builtin::requires(#[verus::internal(auto_trigger)] ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                i), i_receipt.lines.len())));
                                ::builtin::ensures(i_receipt.lines.spec_index(i).wf());
                                self.lines.spec_index(i).linked.i_wf();
                            });
                }
                {
                    ::builtin::assert_forall_by(|i: int|
                            {
                                ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                i),
                                            (i_receipt.lines.len()).spec_sub(::builtin::spec_literal_nat("1")))));
                                ::builtin::ensures({
                                        (#[verus::internal(trigger)] i_receipt.lines.spec_index(i).node.key_in_domain(self.key))
                                            && (i_receipt.child_linked_at(i))
                                    });
                                ::builtin::assert_(self.node(i).key_in_domain(self.key));
                                self.lines.spec_index(i).linked.child_for_key_commutes_with_i(self.key);
                                ::builtin::assert_(self.child_linked_at(i));
                                ::builtin::assert_(self.result_linked_at(i));
                            });
                }
                {
                    ::builtin::assert_forall_by(|i: int|
                            {
                                ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                i),
                                            (i_receipt.lines.len()).spec_sub(::builtin::spec_literal_nat("1")))));
                                ::builtin::ensures(#[verus::internal(trigger)] i_receipt.result_linked_at(i));
                                ::builtin::assert_(self.result_linked_at(i));
                                let node = self.node(i);
                                let start =
                                    ::builtin::spec_cast_integer::<_,
                                            int>(node.flushed_ofs(self.key));
                                node.buffers.query_from_commutes_with_i(self.linked.buffer_dv,
                                    self.key, start);
                            });
                }
                ::builtin::assert_(i_receipt.all_lines_wf());
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn path_addrs_to_set_additive(path_addrs: PathAddrs) {
            ::builtin::requires([(path_addrs.len()).spec_gt(::builtin::spec_literal_nat("0"))]);
            ::builtin::ensures([::builtin::spec_eq(path_addrs.to_set(),
                            (::vstd::set::Set::empty().insert(path_addrs.spec_index(::builtin::spec_literal_integer("0")))).spec_add(path_addrs.subrange(::builtin::spec_literal_integer("1"),
                                        ::builtin::spec_cast_integer::<_,
                                                int>(path_addrs.len())).to_set()))]);
            let sub_path_addrs =
                path_addrs.subrange(::builtin::spec_literal_integer("1"),
                    ::builtin::spec_cast_integer::<_, int>(path_addrs.len()));
            let a =
                (::vstd::set::Set::empty().insert(path_addrs.spec_index(::builtin::spec_literal_integer("0")))).spec_add(sub_path_addrs.to_set());
            let b = path_addrs.to_set();
            {
                ::builtin::assert_forall_by(|addr|
                        {
                            ::builtin::ensures(::builtin::spec_eq((a.contains(addr)),
                                    (b.contains(addr))));
                            if a.contains(addr) {
                                    if sub_path_addrs.contains(addr) {
                                            let idx =
                                                ::builtin::choose(|idx|
                                                        ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                        idx), sub_path_addrs.len())) &&
                                                            ::builtin::spec_eq(sub_path_addrs.spec_index(idx), addr));
                                            ::builtin::assert_(::builtin::spec_eq(sub_path_addrs.spec_index(idx),
                                                    path_addrs.spec_index((idx).spec_add(::builtin::spec_literal_nat("1")))));
                                        }
                                }
                            if b.contains(addr) {
                                    let idx =
                                        ::builtin::choose(|idx|
                                                ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                idx), path_addrs.len())) &&
                                                    ::builtin::spec_eq(path_addrs.spec_index(idx), addr));
                                    if (idx).spec_gt(::builtin::spec_literal_nat("0")) {
                                            ::builtin::assert_(::builtin::spec_eq(sub_path_addrs.spec_index((idx).spec_sub(::builtin::spec_literal_nat("1"))),
                                                    path_addrs.spec_index(idx)));
                                        }
                                }
                        });
            }
            ::builtin::assert_(::builtin::ext_equal(a, b));
        }
        #[verus::internal(verus_macro)]
        impl Path {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> FilteredBetree_v::Path {
                ::builtin::recommends([self.valid()]);
                FilteredBetree_v::Path {
                    node: self.linked.i(),
                    key: self.key,
                    depth: self.depth,
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn valid_ranking_throughout(self, ranking: Ranking) {
                ::builtin::requires([self.valid(),
                            self.linked.valid_ranking(ranking)]);
                ::builtin::ensures([::builtin::imply((::builtin::spec_literal_nat("0")).spec_lt(self.depth),
                                self.subpath().linked.valid_ranking(ranking)),
                            self.target().valid_ranking(ranking)]);
                ::builtin::decreases((self.depth));
                if (::builtin::spec_literal_nat("0")).spec_lt(self.depth) {
                        self.linked.child_for_key_valid_index(self.key);
                        self.subpath().valid_ranking_throughout(ranking);
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn subpath_commutes_with_i(self) {
                ::builtin::requires([(::builtin::spec_literal_nat("0")).spec_lt(self.depth),
                            self.valid()]);
                ::builtin::ensures([self.subpath().linked.acyclic(),
                            ::builtin::spec_eq(self.subpath().i(),
                                self.i().subpath())]);
                self.valid_ranking_throughout(self.linked.the_ranking());
                self.linked.child_for_key_commutes_with_i(self.key);
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn i_valid(self) {
                ::builtin::requires([self.valid()]);
                ::builtin::ensures([self.i().valid()]);
                ::builtin::decreases((self.depth));
                self.linked.i_wf();
                if (::builtin::spec_literal_nat("0")).spec_lt(self.depth) {
                        self.valid_ranking_throughout(self.linked.the_ranking());
                        self.subpath().i_valid();
                        self.subpath_commutes_with_i();
                        self.linked.indexiness_commutes_with_i();
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn target_commutes_with_i(self) {
                ::builtin::requires([self.valid(), self.linked.acyclic()]);
                ::builtin::ensures([self.target().acyclic(),
                            ::builtin::spec_eq(self.target().dv, self.linked.dv),
                            ::builtin::spec_eq(self.target().buffer_dv,
                                self.linked.buffer_dv), self.i().valid(),
                            ::builtin::spec_eq(self.i().target(), self.target().i())]);
                ::builtin::decreases((self.depth));
                self.valid_ranking_throughout(self.linked.the_ranking());
                self.i_valid();
                if (::builtin::spec_literal_nat("0")).spec_lt(self.depth) {
                        self.subpath().target_commutes_with_i();
                        self.subpath_commutes_with_i();
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn betree_diskview_diff(self, replacement: LinkedBetree,
                path_addrs: PathAddrs) {
                ::builtin::requires([self.can_substitute(replacement,
                                path_addrs), path_addrs.no_duplicates()]);
                ::builtin::ensures([::builtin::ext_equal(self.substitute(replacement,
                                                path_addrs).dv.entries.dom(),
                                (replacement.dv.entries.dom()).spec_add(path_addrs.to_set()))]);
                ::builtin::decreases((self.depth));
                let result = self.substitute(replacement, path_addrs);
                if (::builtin::spec_literal_nat("0")).spec_lt(self.depth) {
                        let sub_path_addrs =
                            path_addrs.subrange(::builtin::spec_literal_integer("1"),
                                ::builtin::spec_cast_integer::<_, int>(path_addrs.len()));
                        let subtree =
                            self.subpath().substitute(replacement, sub_path_addrs);
                        self.subpath().betree_diskview_diff(replacement,
                            sub_path_addrs);
                        path_addrs_to_set_additive(path_addrs);
                    }
            }
            #[verifier::spinoff_prover]
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn substitute_preserves_wf(self, replacement: LinkedBetree,
                path_addrs: PathAddrs) {
                ::builtin::requires([self.can_substitute(replacement,
                                path_addrs), path_addrs.no_duplicates(),
                            self.linked.is_fresh(path_addrs.to_set()),
                            replacement.is_fresh(path_addrs.to_set())]);
                ::builtin::ensures([({
                                    let result = self.substitute(replacement, path_addrs);
                                    (((((result.wf()) && (result.has_root())) &&
                                                                (::builtin::spec_eq(result.root().my_domain(),
                                                                        self.linked.root().my_domain()))) &&
                                                        (self.linked.dv.is_subdisk(result.dv))) &&
                                                (self.linked.buffer_dv.is_subdisk(result.buffer_dv))) &&
                                        (::builtin::ext_equal(result.dv.entries.dom(),
                                                (((self.linked.dv.entries.dom()).spec_add(replacement.dv.entries.dom())).spec_add(path_addrs.to_set()))))
                                })]);
                ::builtin::decreases((self.depth,
                        ::builtin::spec_literal_nat("1")));
                if (::builtin::spec_literal_nat("0")).spec_lt(self.depth) {
                        let sub_path_addrs =
                            path_addrs.subrange(::builtin::spec_literal_integer("1"),
                                ::builtin::spec_cast_integer::<_, int>(path_addrs.len()));
                        let subtree =
                            self.subpath().substitute(replacement, sub_path_addrs);
                        self.subpath().substitute_preserves_wf(replacement,
                            sub_path_addrs);
                        path_addrs_to_set_additive(path_addrs);
                        let result = self.substitute(replacement, path_addrs);
                        let node =
                            result.dv.entries.spec_index(path_addrs.spec_index(::builtin::spec_literal_integer("0")));
                        let r = node.pivots.route(self.key);
                        PivotTable::route_lemma_auto();
                        ::builtin::assert_(self.linked.dv.entries.contains_key(self.linked.root.unwrap()));
                        {
                            ::builtin::assert_forall_by(|i|
                                    {
                                        ::builtin::requires(#[verus::internal(trigger)] node.valid_child_index(i));
                                        ::builtin::ensures({
                                                (result.dv.is_nondangling_ptr(node.children.spec_index(::builtin::spec_cast_integer::<_,
                                                                        int>(i)))) && (result.dv.child_linked(node, i))
                                            });
                                        ::builtin::assert_(self.linked.root().valid_child_index(i));
                                        if !::builtin::spec_eq(i, r) {
                                                ::builtin::assert_(self.linked.dv.is_nondangling_ptr(node.children.spec_index(::builtin::spec_cast_integer::<_,
                                                                    int>(i))));
                                                ::builtin::assert_(self.linked.dv.child_linked(self.linked.root(),
                                                        i));
                                                ::builtin::assert_(result.dv.is_nondangling_ptr(node.children.spec_index(::builtin::spec_cast_integer::<_,
                                                                    int>(i))));
                                                ::builtin::assert_(result.dv.child_linked(node, i));
                                            }
                                    });
                        }
                        self.betree_diskview_diff(replacement, path_addrs);
                        ::builtin::assert_(self.linked.root().buffers.valid(self.linked.buffer_dv));
                        ::builtin::assert_(result.root().buffers.valid(result.buffer_dv));
                    }
            }
            #[verifier::spinoff_prover]
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn ranking_after_substitution(self, replacement: LinkedBetree,
                path_addrs: PathAddrs, ranking: Ranking) -> Ranking {
                ::builtin::requires([self.can_substitute(replacement,
                                path_addrs), path_addrs.no_duplicates(),
                            replacement.valid_ranking(ranking),
                            ranking.contains_key(self.linked.root.unwrap()),
                            path_addrs.to_set().disjoint(ranking.dom()),
                            self.linked.is_fresh(path_addrs.to_set()),
                            replacement.is_fresh(path_addrs.to_set())]);
                ::builtin::ensures(|new_ranking: Ranking|
                        [self.substitute(replacement,
                                        path_addrs).valid_ranking(new_ranking),
                                self.linked.dv.fresh_ranking_extension(ranking,
                                    new_ranking),
                                ::builtin::ext_equal(new_ranking.dom(),
                                    (ranking.dom()).spec_add(path_addrs.to_set()))]);
                ::builtin::decreases((self.depth));
                self.substitute_preserves_wf(replacement, path_addrs);
                PivotTable::route_lemma_auto();
                if ::builtin::spec_eq(self.depth,
                            ::builtin::spec_literal_nat("0")) {
                        ranking
                    } else {
                       let sub_path_addrs =
                           path_addrs.subrange(::builtin::spec_literal_integer("1"),
                               ::builtin::spec_cast_integer::<_, int>(path_addrs.len()));
                       let subtree =
                           self.subpath().substitute(replacement, sub_path_addrs);
                       self.subpath().substitute_preserves_wf(replacement,
                           sub_path_addrs);
                       self.linked.dv.subdisk_implies_ranking_validity(replacement.dv,
                           ranking);
                       ::builtin::assert_(self.linked.valid_ranking(ranking));
                       self.valid_ranking_throughout(ranking);
                       let r = self.linked.root().pivots.route(self.key);
                       ::builtin::assert_(self.linked.root().valid_child_index(::builtin::spec_cast_integer::<_,
                                       nat>(r)));
                       ::builtin::assert_(self.subpath().linked.has_root());
                       let intermediate_ranking =
                           self.subpath().ranking_after_substitution(replacement,
                               sub_path_addrs, ranking);
                       let new_root_addr =
                           path_addrs.spec_index(::builtin::spec_literal_integer("0"));
                       let old_root_rank =
                           intermediate_ranking.spec_index(self.linked.root.unwrap());
                       let subtree_root_rank =
                           intermediate_ranking.spec_index(subtree.root.unwrap());
                       let new_root_rank =
                           ((old_root_rank).spec_add(subtree_root_rank)).spec_add(::builtin::spec_literal_nat("1"));
                       let new_ranking =
                           intermediate_ranking.insert(new_root_addr, new_root_rank);
                       let result = self.substitute(replacement, path_addrs);
                       {
                           ::builtin::assert_forall_by(|addr|
                                   {
                                       ::builtin::requires(#[verus::internal(trigger)] new_ranking.contains_key(addr)
                                               && result.dv.entries.contains_key(addr));
                                       ::builtin::ensures(result.dv.node_children_respects_rank(new_ranking,
                                               addr));
                                       self.betree_diskview_diff(replacement, path_addrs);
                                       if ::builtin::spec_eq(addr, new_root_addr) {
                                               let node = result.dv.entries.spec_index(addr);
                                               {
                                                   ::builtin::assert_forall_by(|i|
                                                           {
                                                               ::builtin::requires(#[verus::internal(trigger)] node.valid_child_index(i)
                                                                       &&
                                                                       node.children.spec_index(::builtin::spec_cast_integer::<_,
                                                                                       int>(i)).is_Some());
                                                               ::builtin::ensures({
                                                                       (new_ranking.contains_key(node.children.spec_index(::builtin::spec_cast_integer::<_,
                                                                                                   int>(i)).unwrap())) &&
                                                                           ((new_ranking.spec_index(node.children.spec_index(::builtin::spec_cast_integer::<_,
                                                                                                           int>(i)).unwrap())).spec_lt(new_ranking.spec_index(addr)))
                                                                   });
                                                               ::builtin::assert_(self.linked.root().valid_child_index(i));
                                                               if !::builtin::spec_eq(i, r) {
                                                                       ::builtin::assert_(intermediate_ranking.contains_key(node.children.spec_index(::builtin::spec_cast_integer::<_,
                                                                                               int>(i)).unwrap()));
                                                                       ::builtin::assert_(intermediate_ranking.contains_key(self.linked.root.unwrap()));
                                                                       ::builtin::assert_(self.linked.root().valid_child_index(i));
                                                                       ::builtin::assert_(new_ranking.contains_key(node.children.spec_index(::builtin::spec_cast_integer::<_,
                                                                                               int>(i)).unwrap()));
                                                                       ::builtin::assert_((new_ranking.spec_index(node.children.spec_index(::builtin::spec_cast_integer::<_,
                                                                                                       int>(i)).unwrap())).spec_lt(new_ranking.spec_index(addr)));
                                                                   }
                                                           });
                                               }
                                           }
                                   });
                       }
                       path_addrs_to_set_additive(path_addrs);
                       new_ranking
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn substitute_commutes_with_i(self, replacement: LinkedBetree,
                path_addrs: PathAddrs, ranking: Ranking) {
                ::builtin::requires([self.can_substitute(replacement,
                                path_addrs), path_addrs.no_duplicates(),
                            self.linked.valid_ranking(ranking),
                            replacement.valid_ranking(ranking),
                            ranking.contains_key(self.linked.root.unwrap()),
                            path_addrs.to_set().disjoint(ranking.dom()),
                            self.linked.is_fresh(path_addrs.to_set()),
                            replacement.is_fresh(path_addrs.to_set())]);
                ::builtin::ensures([self.substitute(replacement,
                                    path_addrs).acyclic(),
                            self.i().can_substitute(replacement.i()),
                            ::builtin::equal(self.substitute(replacement,
                                        path_addrs).i(), self.i().substitute(replacement.i()))]);
                ::builtin::decreases((self.depth));
                self.i_valid();
                replacement.i_wf();
                if (::builtin::spec_literal_nat("0")).spec_lt(self.depth) {
                        let new_ranking =
                            self.ranking_after_substitution(replacement, path_addrs,
                                ranking);
                        let result = self.substitute(replacement, path_addrs);
                        self.substitute_preserves_wf(replacement, path_addrs);
                        ::builtin::assert_(result.valid_ranking(new_ranking));
                        result.i_node_ignores_ranking(result.the_ranking(),
                            new_ranking);
                        self.target_commutes_with_i();
                        PivotTable::route_lemma_auto();
                        result.i_children_lemma(result.the_ranking());
                        self.linked.i_children_lemma(self.linked.the_ranking());
                        let r = self.linked.root().pivots.route(self.key);
                        let sub_path_addrs =
                            path_addrs.subrange(::builtin::spec_literal_integer("1"),
                                ::builtin::spec_cast_integer::<_, int>(path_addrs.len()));
                        let subtree =
                            self.subpath().substitute(replacement, sub_path_addrs);
                        let new_children =
                            self.linked.root().children.update(r, subtree.root);
                        {
                            ::builtin::assert_forall_by(|i|
                                    {
                                        ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                        i), result.i().get_Node_children().len())));
                                        ::builtin::ensures(::builtin::spec_eq(#[verus::internal(trigger)] result.i().get_Node_children().spec_index(i),
                                                self.i().substitute(replacement.i()).get_Node_children().spec_index(i)));
                                        ::builtin::assert_(self.linked.root().valid_child_index(::builtin::spec_cast_integer::<_,
                                                        nat>(i)));
                                        ::builtin::assert_(result.root().valid_child_index(::builtin::spec_cast_integer::<_,
                                                        nat>(i)));
                                        self.linked.child_at_idx_acyclic(::builtin::spec_cast_integer::<_,
                                                    nat>(i));
                                        result.child_at_idx_acyclic(::builtin::spec_cast_integer::<_,
                                                    nat>(i));
                                        let child =
                                            self.linked.child_at_idx(::builtin::spec_cast_integer::<_,
                                                        nat>(i));
                                        let new_child =
                                            result.child_at_idx(::builtin::spec_cast_integer::<_,
                                                        nat>(i));
                                        if ::builtin::spec_eq(i, r) {
                                                result.child_at_idx_commutes_with_i(::builtin::spec_cast_integer::<_,
                                                            nat>(i));
                                                new_child.i_node_ignores_ranking(result.the_ranking(),
                                                    new_child.the_ranking());
                                                self.subpath().substitute_commutes_with_i(replacement,
                                                    sub_path_addrs, ranking);
                                                self.subpath().betree_diskview_diff(replacement,
                                                    sub_path_addrs);
                                                self.betree_diskview_diff(replacement, path_addrs);
                                                self.subpath_commutes_with_i();
                                                subtree.dv.subdisk_implies_ranking_validity(new_child.dv,
                                                    new_child.the_ranking());
                                                subtree.betree_subdisk_preserves_i_with_ranking(new_child,
                                                    new_child.the_ranking());
                                                subtree.i_node_ignores_ranking(subtree.the_ranking(),
                                                    new_child.the_ranking());
                                            } else {
                                               child.dv.subdisk_implies_ranking_validity(new_child.dv,
                                                   new_ranking);
                                               child.betree_subdisk_preserves_i_with_ranking(new_child,
                                                   new_ranking);
                                               child.i_node_ignores_ranking(new_ranking,
                                                   self.linked.the_ranking());
                                               new_child.i_node_ignores_ranking(new_ranking,
                                                   result.the_ranking());
                                           }
                                    });
                        }
                        ::builtin::assert_(::builtin::ext_equal(result.i().get_Node_children(),
                                self.i().substitute(replacement.i()).get_Node_children()));
                        result.root().buffers.subdisk_implies_same_i(self.linked.buffer_dv,
                            result.buffer_dv);
                        ::builtin::assert_(::builtin::ext_equal(result.i().get_Node_buffers(),
                                self.i().substitute(replacement.i()).get_Node_buffers()));
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn fresh_substitution_implies_subdisk(self,
                replacement: LinkedBetree, path_addrs: PathAddrs) {
                ::builtin::requires([self.can_substitute(replacement,
                                path_addrs), self.linked.dv.is_subdisk(replacement.dv),
                            self.linked.buffer_dv.is_subdisk(replacement.buffer_dv),
                            self.linked.is_fresh(path_addrs.to_set())]);
                ::builtin::ensures([self.linked.dv.is_subdisk(self.substitute(replacement,
                                        path_addrs).dv),
                            self.linked.buffer_dv.is_subdisk(self.substitute(replacement,
                                        path_addrs).buffer_dv)]);
                ::builtin::decreases((self.depth));
                if (::builtin::spec_literal_nat("0")).spec_lt(self.depth) {
                        self.subpath().fresh_substitution_implies_subdisk(replacement,
                            path_addrs.subrange(::builtin::spec_literal_integer("1"),
                                ::builtin::spec_cast_integer::<_, int>(path_addrs.len())));
                    }
            }
        }
        #[verus::internal(verus_macro)]
        impl LinkedBetreeVars::Label {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> FilteredBetree::Label {
                match self {
                    LinkedBetreeVars::Label::Query { end_lsn, key, value } =>
                        FilteredBetree::Label::Query {
                            end_lsn: end_lsn,
                            key: key,
                            value: value,
                        },
                    LinkedBetreeVars::Label::Put { puts } =>
                        FilteredBetree::Label::Put { puts: puts },
                    LinkedBetreeVars::Label::FreezeAs { stamped_betree } =>
                        FilteredBetree::Label::FreezeAs {
                            stamped_betree: if stamped_betree.value.acyclic() {
                                    i_stamped_betree(stamped_betree)
                                } else { arbitrary() },
                        },
                    LinkedBetreeVars::Label::Internal {} =>
                        FilteredBetree::Label::Internal {},
                }
            }
        }
        #[verus::internal(verus_macro)]
        impl LinkedBetreeVars::State {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn inv(self) -> bool {
                ((self.wf()) && (self.linked.acyclic())) &&
                    (::builtin::imply(self.linked.has_root(),
                            ::builtin::spec_eq(self.linked.root().my_domain(),
                                total_domain())))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> FilteredBetree::State {
                ::builtin::recommends([self.wf(), self.linked.acyclic()]);
                FilteredBetree::State {
                    root: self.linked.i(),
                    memtable: self.memtable,
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn init_refines(self, stamped_betree: StampedBetree) {
                ::builtin::requires([LinkedBetreeVars::State::initialize(self,
                                stamped_betree), stamped_betree.value.acyclic()]);
                ::builtin::ensures([FilteredBetree::State::initialize(self.i(),
                                i_stamped_betree(stamped_betree))]);
                self.linked.i_wf();
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn query_refines(self, post: Self,
                lbl: LinkedBetreeVars::Label, receipt: QueryReceipt) {
                ::builtin::requires([self.inv(),
                            LinkedBetreeVars::State::query(self, post, lbl, receipt)]);
                ::builtin::ensures([post.inv(),
                            FilteredBetree::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(FilteredBetree::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(FilteredBetree::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                receipt.i_valid();
                ::builtin::assert_(FilteredBetree::State::next_by(self.i(),
                        post.i(), lbl.i(),
                        FilteredBetree::Step::query(receipt.i())));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn put_refines(self, post: Self,
                lbl: LinkedBetreeVars::Label) {
                ::builtin::requires([self.inv(),
                            LinkedBetreeVars::State::put(self, post, lbl)]);
                ::builtin::ensures([post.inv(),
                            FilteredBetree::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(FilteredBetree::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(FilteredBetree::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::assert_(FilteredBetree::State::next_by(self.i(),
                        post.i(), lbl.i(), FilteredBetree::Step::put()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn freeze_as_refines(self, post: Self,
                lbl: LinkedBetreeVars::Label) {
                ::builtin::requires([self.inv(),
                            LinkedBetreeVars::State::freeze_as(self, post, lbl)]);
                ::builtin::ensures([post.inv(),
                            FilteredBetree::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(FilteredBetree::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(FilteredBetree::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                self.linked.i_wf();
                ::builtin::assert_(FilteredBetree::State::next_by(self.i(),
                        post.i(), lbl.i(), FilteredBetree::Step::freeze_as()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn internal_flush_memtable_refines(self, post: Self,
                lbl: LinkedBetreeVars::Label, new_addrs: TwoAddrs) {
                ::builtin::requires([self.inv(),
                            LinkedBetreeVars::State::internal_flush_memtable(self, post,
                                lbl, new_addrs)]);
                ::builtin::ensures([post.inv(),
                            FilteredBetree::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(FilteredBetree::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(FilteredBetree::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                self.linked.push_memtable_commutes_with_i(self.memtable,
                    new_addrs);
                self.linked.i_wf();
                post.linked.i_wf();
                ::builtin::assert_(FilteredBetree::State::next_by(self.i(),
                        post.i(), lbl.i(),
                        FilteredBetree::Step::internal_flush_memtable()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn internal_grow_refines(self, post: Self,
                lbl: LinkedBetreeVars::Label, new_root_addr: Address) {
                ::builtin::requires([self.inv(),
                            LinkedBetreeVars::State::internal_grow(self, post, lbl,
                                new_root_addr)]);
                ::builtin::ensures([post.inv(),
                            FilteredBetree::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(FilteredBetree::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(FilteredBetree::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                self.linked.grow_commutes_with_i(new_root_addr);
                self.linked.i_wf();
                post.linked.i_wf();
                ::builtin::assert_(FilteredBetree::State::next_by(self.i(),
                        post.i(), lbl.i(), FilteredBetree::Step::internal_grow()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn internal_split_refines(self, post: Self,
                lbl: LinkedBetreeVars::Label, path: Path,
                request: SplitRequest, new_addrs: SplitAddrs,
                path_addrs: PathAddrs) {
                ::builtin::requires([self.inv(),
                            LinkedBetreeVars::State::internal_split(self, post, lbl,
                                path, request, new_addrs, path_addrs)]);
                ::builtin::ensures([post.inv(),
                            FilteredBetree::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(FilteredBetree::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(FilteredBetree::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                path.i_valid();
                path.target_commutes_with_i();
                path.target().split_parent_commutes_with_i(request,
                    new_addrs);
                let replacement =
                    path.target().split_parent(request, new_addrs);
                let old_ranking =
                    self.linked.build_tight_ranking(self.linked.the_ranking());
                path.valid_ranking_throughout(old_ranking);
                let new_ranking =
                    path.target().split_new_ranking(request, new_addrs,
                        old_ranking);
                path.fresh_substitution_implies_subdisk(replacement,
                    path_addrs);
                path.substitute_commutes_with_i(replacement, path_addrs,
                    new_ranking);
                path.substitute(replacement,
                        path_addrs).build_tight_preserves_i();
                ::builtin::assert_(FilteredBetree::State::next_by(self.i(),
                        post.i(), lbl.i(),
                        FilteredBetree::Step::internal_split(path.i(), request)));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn internal_flush_refines(self, post: Self,
                lbl: LinkedBetreeVars::Label, path: Path, child_idx: nat,
                buffer_gc: nat, new_addrs: TwoAddrs, path_addrs: PathAddrs) {
                ::builtin::requires([self.inv(),
                            LinkedBetreeVars::State::internal_flush(self, post, lbl,
                                path, child_idx, buffer_gc, new_addrs, path_addrs)]);
                ::builtin::ensures([post.inv(),
                            FilteredBetree::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(FilteredBetree::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(FilteredBetree::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                path.i_valid();
                path.target_commutes_with_i();
                path.target().flush_commutes_with_i(child_idx, buffer_gc,
                    new_addrs);
                let replacement =
                    path.target().flush(child_idx, buffer_gc, new_addrs);
                let old_ranking =
                    self.linked.build_tight_ranking(self.linked.the_ranking());
                path.valid_ranking_throughout(old_ranking);
                let new_ranking =
                    path.target().flush_new_ranking(child_idx, buffer_gc,
                        new_addrs, old_ranking);
                path.fresh_substitution_implies_subdisk(replacement,
                    path_addrs);
                path.substitute_commutes_with_i(replacement, path_addrs,
                    new_ranking);
                path.substitute(replacement,
                        path_addrs).build_tight_preserves_i();
                ::builtin::assert_(FilteredBetree::State::next_by(self.i(),
                        post.i(), lbl.i(),
                        FilteredBetree::Step::internal_flush(path.i(), child_idx,
                            buffer_gc)));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn internal_compact_refines(self, post: Self,
                lbl: LinkedBetreeVars::Label, path: Path, start: nat,
                end: nat, compacted_buffer: Buffer, new_addrs: TwoAddrs,
                path_addrs: PathAddrs) {
                ::builtin::requires([self.inv(),
                            LinkedBetreeVars::State::internal_compact(self, post, lbl,
                                path, start, end, compacted_buffer, new_addrs,
                                path_addrs)]);
                ::builtin::ensures([post.inv(),
                            FilteredBetree::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(FilteredBetree::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(FilteredBetree::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                path.i_valid();
                path.target_commutes_with_i();
                path.target().compact_commutes_with_i(start, end,
                    compacted_buffer, new_addrs);
                let replacement =
                    path.target().compact(start, end, compacted_buffer,
                        new_addrs);
                let old_ranking =
                    self.linked.build_tight_ranking(self.linked.the_ranking());
                path.valid_ranking_throughout(old_ranking);
                let new_ranking =
                    path.target().compact_new_ranking(start, end,
                        compacted_buffer, new_addrs, old_ranking);
                path.fresh_substitution_implies_subdisk(replacement,
                    path_addrs);
                path.substitute_commutes_with_i(replacement, path_addrs,
                    new_ranking);
                path.substitute(replacement,
                        path_addrs).build_tight_preserves_i();
                ::builtin::assert_(FilteredBetree::State::next_by(self.i(),
                        post.i(), lbl.i(),
                        FilteredBetree::Step::internal_compact(path.i(), start, end,
                            compacted_buffer)));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn internal_noop_noop(self, post: Self,
                lbl: LinkedBetreeVars::Label) {
                ::builtin::requires([self.inv(),
                            LinkedBetreeVars::State::internal_noop(self, post, lbl)]);
                ::builtin::ensures([post.inv(),
                            FilteredBetree::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(FilteredBetree::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(FilteredBetree::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                self.linked.i_wf();
                ::builtin::assert_(FilteredBetree::State::next_by(self.i(),
                        post.i(), lbl.i(), FilteredBetree::Step::internal_noop()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn next_refines(self, post: Self,
                lbl: LinkedBetreeVars::Label) {
                ::builtin::requires([self.inv(),
                            LinkedBetreeVars::State::next(self, post, lbl)]);
                ::builtin::ensures([post.inv(),
                            FilteredBetree::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(LinkedBetreeVars::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(LinkedBetreeVars::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                match ::builtin::choose(|step|
                            LinkedBetreeVars::State::next_by(self, post, lbl, step)) {
                    LinkedBetreeVars::Step::query(receipt) => {
                        self.query_refines(post, lbl, receipt);
                    }
                    LinkedBetreeVars::Step::put() => {
                        self.put_refines(post, lbl);
                    }
                    LinkedBetreeVars::Step::freeze_as() => {
                        self.freeze_as_refines(post, lbl);
                    }
                    LinkedBetreeVars::Step::internal_flush_memtable(new_addrs)
                        => {
                        self.internal_flush_memtable_refines(post, lbl, new_addrs);
                    }
                    LinkedBetreeVars::Step::internal_grow(new_root_addr) => {
                        self.internal_grow_refines(post, lbl, new_root_addr);
                    }
                    LinkedBetreeVars::Step::internal_split(path, split_request,
                        new_addrs, path_addrs) => {
                        self.internal_split_refines(post, lbl, path, split_request,
                            new_addrs, path_addrs);
                    }
                    LinkedBetreeVars::Step::internal_flush(path, child_idx,
                        buffer_gc, new_addrs, path_addrs) => {
                        self.internal_flush_refines(post, lbl, path, child_idx,
                            buffer_gc, new_addrs, path_addrs);
                    }
                    LinkedBetreeVars::Step::internal_compact(path, start, end,
                        compacted_buffer, new_addrs, path_addrs) => {
                        self.internal_compact_refines(post, lbl, path, start, end,
                            compacted_buffer, new_addrs, path_addrs);
                    }
                    LinkedBetreeVars::Step::internal_noop() => {
                        self.internal_noop_noop(post, lbl);
                    }
                    _ => { ::builtin::assert_(false); }
                }
            }
        }
    }
    pub mod PivotBranch_v {
        /// This file defines the PivotBranch data structure. Under the `betree/` folder, all "Branch" data structures are
        /// just B+-trees. They are called "Branches" to distinguish them from the Be-tree data structures, and because
        /// Be-tree nodes can point to B+-trees (thus making B+-trees "branches" of a Be-tree).
        /// 
        /// A PivotBranch is a B+-tree defined in its most natural form, where the pivots are Keys, and Index nodes directly
        /// contain sequences of their children (i.e.: in a concrete implementation its one massive nested data structure, instead
        /// of using pointers). AKA it's a "functional" tree (immutable, defined).
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use crate::spec::KeyType_t::*;
        use crate::spec::Messages_t::*;
        #[doc =
        " (x9du): A SplitArg is a value used for determining a pivot value at which to split"]
        #[doc =
        " a B+tree node into two nodes. Its an enum to handle the cases for splitting an index"]
        #[doc = " node vs. a Leaf node separately."]
        #[verus::internal(verus_macro)]
        pub enum SplitArg {
            SplitIndex {
                pivot: Key,
                pivot_index: int,
            },
            SplitLeaf {
                pivot: Key,
            },
        }
        #[verus::internal(verus_macro)]
        #[cfg(verus_keep_ghost)]
        #[automatically_derived]
        impl SplitArg {
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_SplitIndex(&self) -> bool {
                ::builtin::is_variant(self, "SplitIndex")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_SplitIndex_pivot(self) -> Key {
                ::builtin::get_variant_field(self, "SplitIndex", "pivot")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_SplitIndex_pivot_index(self) -> int {
                ::builtin::get_variant_field(self, "SplitIndex",
                    "pivot_index")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_SplitLeaf(&self) -> bool {
                ::builtin::is_variant(self, "SplitLeaf")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_SplitLeaf_pivot(self) -> Key {
                ::builtin::get_variant_field(self, "SplitLeaf", "pivot")
            }
        }
        #[verus::internal(verus_macro)]
        impl SplitArg {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self, split_node: Node) -> bool {
                match self {
                    Self::SplitLeaf { pivot } => {
                        ((::builtin::is_variant(split_node, "Leaf")) &&
                                    (::builtin::spec_eq(split_node.get_Leaf_keys().len(),
                                            split_node.get_Leaf_msgs().len()))) &&
                            (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_lt(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            (Key::largest_lt(split_node.get_Leaf_keys(),
                                                        pivot)).spec_add(::builtin::spec_literal_nat("1"))),
                                        split_node.get_Leaf_keys().len())))
                    }
                    Self::SplitIndex { pivot, pivot_index } => {
                        (((::builtin::is_variant(split_node, "Index")) &&
                                            (split_node.wf())) &&
                                    (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                    pivot_index), split_node.get_Index_pivots().len())))) &&
                            (::builtin::spec_eq(split_node.get_Index_pivots().spec_index(pivot_index),
                                    pivot))
                    }
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn get_pivot(self) -> Key {
                if ::builtin::is_variant(self, "SplitLeaf") {
                        self.get_SplitLeaf_pivot()
                    } else { self.get_SplitIndex_pivot() }
            }
        }
        #[verus::internal(verus_macro)]
        pub enum Node {
            Index {
                pivots: Seq<Key>,
                children: Seq<Node>,
            },
            Leaf {
                keys: Seq<Key>,
                msgs: Seq<Message>,
            },
        }
        #[verus::internal(verus_macro)]
        #[cfg(verus_keep_ghost)]
        #[automatically_derived]
        impl Node {
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_Index(&self) -> bool {
                ::builtin::is_variant(self, "Index")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_Index_pivots(self) -> Seq<Key> {
                ::builtin::get_variant_field(self, "Index", "pivots")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_Index_children(self) -> Seq<Node> {
                ::builtin::get_variant_field(self, "Index", "children")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_Leaf(&self) -> bool {
                ::builtin::is_variant(self, "Leaf")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_Leaf_keys(self) -> Seq<Key> {
                ::builtin::get_variant_field(self, "Leaf", "keys")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_Leaf_msgs(self) -> Seq<Message> {
                ::builtin::get_variant_field(self, "Leaf", "msgs")
            }
        }
        #[verus::internal(verus_macro)]
        impl Node {
            #[doc = " Returns a newly constructed empty leaf node."]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn empty_leaf() -> Node {
                Node::Leaf {
                    keys: ::vstd::seq::Seq::empty(),
                    msgs: ::vstd::seq::Seq::empty(),
                }
            }
            #[doc = " Returns the set of all keys contained under this node."]
            #[doc =
            " - For leaf nodes this is just all keys the leaf node contains."]
            #[doc =
            " - For index nodes, this is the set union of all pivot keys + keys contained"]
            #[doc = "   under all leaf nodes under this index node."]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn all_keys(self) -> Set<Key> {
                ::builtin::decreases((self));
                match self {
                    Node::Leaf { keys, msgs } => keys.to_set(),
                    Node::Index { pivots, children } => {
                        let pivotKeys = pivots.to_set();
                        let indexKeys =
                            Set::new(::builtin::closure_to_fn_spec(|key|
                                        ::builtin::exists(|i|
                                                ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                i), children.len())) &&
                                                    #[verus::internal(trigger)] children.spec_index(i).all_keys().contains(key))));
                        (pivotKeys).spec_add(indexKeys)
                    }
                }
            }
            #[doc = " Pre: self must be an Index node"]
            #[doc = ""]
            #[doc =
            " Returns true iff all keys under node child[i] are less than pivots[i] "]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn all_keys_below_bound(self, i: int) -> bool {
                ::builtin::recommends([::builtin::is_variant(self, "Index"),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        i),
                                    (self.get_Index_children().len()).spec_sub(::builtin::spec_literal_nat("1")))),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        i), self.get_Index_pivots().len()))]);
                ::builtin::forall(|key|
                        ::builtin::imply(self.get_Index_children().spec_index(i).all_keys().contains(key),
                            #[verus::internal(trigger)] Key::lt(key,
                                self.get_Index_pivots().spec_index(i))))
            }
            #[doc = " Pre: self must be an Index node"]
            #[doc = " "]
            #[doc =
            " Returns true iff all keys under node child[i] are >= pivots[i-1]."]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn all_keys_above_bound(self, i: int) -> bool {
                ::builtin::recommends([::builtin::is_variant(self, "Index"),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        i), self.get_Index_children().len())),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        (i).spec_sub(::builtin::spec_literal_nat("1"))),
                                    self.get_Index_pivots().len()))]);
                ::builtin::forall(|key|
                        ::builtin::imply(self.get_Index_children().spec_index(i).all_keys().contains(key),
                            #[verus::internal(trigger)] Key::lte(self.get_Index_pivots().spec_index((i).spec_sub(::builtin::spec_literal_nat("1"))),
                                key)))
            }
            #[doc = " Returns true iff self is a well-formed B+ tree node."]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                ::builtin::decreases((self));
                match self {
                    Node::Leaf { keys, msgs } => {
                        (::builtin::spec_eq(keys.len(), msgs.len())) &&
                            (Key::is_strictly_sorted(keys))
                    }
                    Node::Index { pivots, children } => {
                        ((((::builtin::spec_eq(pivots.len(),
                                                            (children.len()).spec_sub(::builtin::spec_literal_nat("1"))))
                                                    && (Key::is_strictly_sorted(pivots))) &&
                                            (::builtin::forall(|i|
                                                        ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                        i), children.len())),
                                                            (#[verus::internal(trigger)] children.spec_index(i)).wf()))))
                                    &&
                                    (::builtin::forall(|i|
                                                ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                i),
                                                            (children.len()).spec_sub(::builtin::spec_literal_nat("1")))),
                                                    self.all_keys_below_bound(i))))) &&
                            (::builtin::forall(|i|
                                        ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_lt(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                        i), children.len())), self.all_keys_above_bound(i))))
                    }
                }
            }
            #[doc =
            " Returns the index before where the key would be inserted into the given node."]
            #[doc = " Let `r` be the return value."]
            #[doc =
            " If self is Index, then `r + 1` is the index of the child node that `key` belongs"]
            #[doc = " to."]
            #[doc =
            " If self is Node, then `r + 1` is the index `key` would be inserted into. (Note that"]
            #[doc =
            " in practice we don\'t allow duplicate keys, so if `key` is already in the sequence,"]
            #[doc = " we\'d just update the value at `r`)."]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn route(self, key: Key) -> int {
                ::builtin::recommends([self.wf()]);
                let s =
                    if ::builtin::is_variant(self, "Leaf") {
                            self.get_Leaf_keys()
                        } else { self.get_Index_pivots() };
                Key::largest_lte(s, key)
            }
            #[doc = " Returns the Message mapped to the given key."]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn query(self, key: Key) -> Message {
                ::builtin::recommends([self.wf()]);
                ::builtin::decreases((self));
                ::builtin::decreases_when(::builtin::imply(::builtin::is_variant(self,
                            "Index"),
                        ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                    (self.route(key)).spec_add(::builtin::spec_literal_nat("1"))),
                                self.get_Index_children().len()))));
                let r = self.route(key);
                match self {
                    Node::Leaf { keys, msgs } => {
                        if (r).spec_ge(::builtin::spec_literal_nat("0")) &&
                                    ::builtin::spec_eq(keys.spec_index(r), key) {
                                msgs.spec_index(r)
                            } else { Message::Update { delta: nop_delta() } }
                    }
                    Node::Index { pivots, children } => {
                        children.spec_index((r).spec_add(::builtin::spec_literal_nat("1"))).query(key)
                    }
                }
            }
            #[doc = " Pre: self is a Leaf node."]
            #[doc =
            " Returns a new Leaf node where the key-message pair {key, msg} is inserted into"]
            #[doc = " self."]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn insert_leaf(self, key: Key, msg: Message) -> Node {
                ::builtin::recommends([::builtin::is_variant(self, "Leaf"),
                            self.wf()]);
                let llte = Key::largest_lte(self.get_Leaf_keys(), key);
                if (::builtin::spec_literal_nat("0")).spec_le(llte) &&
                            ::builtin::spec_eq(self.get_Leaf_keys().spec_index(llte),
                                key) {
                        Node::Leaf {
                            keys: self.get_Leaf_keys(),
                            msgs: self.get_Leaf_msgs().update(llte, msg),
                        }
                    } else {
                       Node::Leaf {
                           keys: self.get_Leaf_keys().insert((llte).spec_add(::builtin::spec_literal_nat("1")),
                               key),
                           msgs: self.get_Leaf_msgs().insert((llte).spec_add(::builtin::spec_literal_nat("1")),
                               msg),
                       }
                   }
            }
            #[doc = " Pre: path.node == self && path.target is Leaf"]
            #[doc = " "]
            #[doc =
            " Returns a new tree rooted at self where {key, msg} is inserted at the Leaf node"]
            #[doc = " targeted by `path`."]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn insert(self, key: Key, msg: Message, path: Path) -> Node {
                ::builtin::recommends([self.wf(), path.valid(),
                            ::builtin::spec_eq(path.node, self),
                            ::builtin::spec_eq(path.key, key),
                            ::builtin::is_variant(path.target(), "Leaf")]);
                path.substitute(path.target().insert_leaf(key, msg))
            }
            #[doc =
            " Returns a new tree formed by creating a new Index node who\'s only child is self."]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn grow(self) -> Node {
                ::builtin::recommends([self.wf()]);
                Node::Index {
                    pivots: ::vstd::seq::Seq::empty(),
                    children: ::vstd::seq::Seq::empty().push(self),
                }
            }
            #[doc =
            " Update the empty Leaf node targeted by the `path` (which starts at self) to have the key-value pairs"]
            #[doc = " specified by `keys` and `msgs`."]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn append(self, keys: Seq<Key>, msgs: Seq<Message>,
                path: Path) -> Node {
                ::builtin::recommends([self.wf(), path.valid(),
                            ::builtin::spec_eq(path.node, self),
                            ::builtin::spec_eq(path.target(), Node::empty_leaf()),
                            (keys.len()).spec_gt(::builtin::spec_literal_nat("0")),
                            ::builtin::spec_eq(keys.len(), msgs.len()),
                            Key::is_strictly_sorted(keys),
                            ::builtin::spec_eq(path.key,
                                keys.spec_index(::builtin::spec_literal_integer("0"))),
                            path.path_equiv(keys.last())]);
                path.substitute(Node::Leaf { keys: keys, msgs: msgs })
            }
            #[doc = " Pre: self is Leaf"]
            #[doc = " "]
            #[doc =
            " Returns two leaf nodes formed by splitting `self` into two Leaf nodes, where"]
            #[doc =
            " the left node contains all keys < `split_arg`, and right node contains all keys"]
            #[doc = " >= `split_arg`."]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split_leaf(self, split_arg: SplitArg) -> (Node, Node) {
                ::builtin::recommends([::builtin::is_variant(self, "Leaf"),
                            split_arg.wf(self)]);
                let pivot = split_arg.get_pivot();
                let split_index =
                    (Key::largest_lt(self.get_Leaf_keys(),
                                pivot)).spec_add(::builtin::spec_literal_nat("1"));
                let left_leaf =
                    Node::Leaf {
                        keys: self.get_Leaf_keys().take(split_index),
                        msgs: self.get_Leaf_msgs().take(split_index),
                    };
                let right_leaf =
                    Node::Leaf {
                        keys: self.get_Leaf_keys().skip(split_index),
                        msgs: self.get_Leaf_msgs().skip(split_index),
                    };
                (left_leaf, right_leaf)
            }
            #[doc = " Pre: self is Index"]
            #[doc = " "]
            #[doc =
            " Returns a new Index node formed by taking self.children[from:to] and all pivots that divide"]
            #[doc = " those children."]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn sub_index(self, from: int, to: int) -> Node {
                ::builtin::recommends([::builtin::is_variant(self, "Index"),
                            ::builtin::spec_eq(self.get_Index_children().len(),
                                (self.get_Index_pivots().len()).spec_add(::builtin::spec_literal_nat("1"))),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            from), to), self.get_Index_children().len()))]);
                Node::Index {
                    pivots: self.get_Index_pivots().subrange(from,
                        (to).spec_sub(::builtin::spec_literal_nat("1"))),
                    children: self.get_Index_children().subrange(from, to),
                }
            }
            #[doc = " Pre: self is Index"]
            #[doc = " "]
            #[doc =
            " Returns two new index nodes that partition `self.children` such that the left node only contains"]
            #[doc =
            " children with keys < split_arg.key, and right node only contains children with keys >= split_arg.key."]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn split_index(self, split_arg: SplitArg) -> (Node, Node) {
                ::builtin::recommends([::builtin::is_variant(self, "Index"),
                            split_arg.wf(self)]);
                let pivot_index = split_arg.get_SplitIndex_pivot_index();
                let left_index =
                    self.sub_index(::builtin::spec_literal_integer("0"),
                        (pivot_index).spec_add(::builtin::spec_literal_nat("1")));
                let right_index =
                    self.sub_index((pivot_index).spec_add(::builtin::spec_literal_nat("1")),
                        ::builtin::spec_cast_integer::<_,
                                int>(self.get_Index_children().len()));
                (left_index, right_index)
            }
            #[doc =
            " Return two nodes created by splitting self based on the `split_arg`."]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split_node(self, split_arg: SplitArg) -> (Node, Node) {
                ::builtin::recommends([split_arg.wf(self)]);
                if (::builtin::is_variant(self, "Leaf")) {
                        self.split_leaf(split_arg)
                    } else { self.split_index(split_arg) }
            }
            #[doc = " "]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn can_split_child_of_index(self, split_arg: SplitArg)
                -> bool {
                ((self.wf()) && (::builtin::is_variant(self, "Index"))) &&
                    ({
                            let child_idx =
                                (self.route(split_arg.get_pivot())).spec_add(::builtin::spec_literal_nat("1"));
                            split_arg.wf(self.get_Index_children().spec_index(child_idx))
                        })
            }
            #[doc = " Pre: self is Index"]
            #[doc = " "]
            #[doc =
            " Returns a new Index node where the child containing `split_arg.pivot` is split on said pivot."]
            #[doc =
            " The pivot arg can NOT be an existing pivot in the Index (because duh, otherwise you\'d have two"]
            #[doc =
            " pivots with the same value, the bucket between them would be empty which is dumb)."]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn split_child_of_index(self, split_arg: SplitArg) -> Node {
                ::builtin::recommends([self.can_split_child_of_index(split_arg)]);
                let pivot = split_arg.get_pivot();
                let child_idx =
                    (self.route(pivot)).spec_add(::builtin::spec_literal_nat("1"));
                let (left_node, right_node) =
                    self.get_Index_children().spec_index(child_idx).split_node(split_arg);
                Node::Index {
                    pivots: self.get_Index_pivots().insert(child_idx, pivot),
                    children: self.get_Index_children().update(child_idx,
                            left_node).insert((child_idx).spec_add(::builtin::spec_literal_nat("1")),
                        right_node),
                }
            }
            #[doc =
            " Returns a new tree formed by splitting the children of `path.target()` on split_arg."]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split(self, path: Path, split_arg: SplitArg) -> Node {
                ::builtin::recommends([self.wf(), path.valid(),
                            ::builtin::spec_eq(path.node, self),
                            ::builtin::spec_eq(path.key, split_arg.get_pivot()),
                            path.target().can_split_child_of_index(split_arg)]);
                path.substitute(path.target().split_child_of_index(split_arg))
            }
        }
        #[doc =
        " A `Path` describes a target node from a given starting node (using a key to target as well"]
        #[doc = " as a number of steps to take)."]
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct Path {
            #[doc = " The current node."]
            pub node: Node,
            #[doc =
            " The target key of the path (does change across subpaths)."]
            pub key: Key,
            #[doc =
            " How many steps remain. If 0, then `node` is the target node of the path."]
            pub depth: nat,
        }
        #[verus::internal(verus_macro)]
        impl Path {
            #[doc = " Returns the next `Path`."]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn subpath(self) -> Path {
                ::builtin::recommends([(::builtin::spec_literal_nat("0")).spec_lt(self.depth),
                            self.node.wf(), ::builtin::is_variant(self.node, "Index")]);
                Path {
                    node: self.node.get_Index_children().spec_index((self.node.route(self.key)).spec_add(::builtin::spec_literal_nat("1"))),
                    key: self.key,
                    depth: ::builtin::spec_cast_integer::<_,
                            nat>(((self.depth).spec_sub(::builtin::spec_literal_nat("1")))),
                }
            }
            #[doc = " Returns `true` iff self is a valid Path."]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid(self) -> bool {
                ::builtin::decreases((self.depth));
                ((self.node.wf()) &&
                            (::builtin::imply((::builtin::spec_literal_nat("0")).spec_lt(self.depth),
                                    ::builtin::is_variant(self.node, "Index")))) &&
                    (::builtin::imply((::builtin::spec_literal_nat("0")).spec_lt(self.depth),
                            self.subpath().valid()))
            }
            #[doc =
            " Returns Node targeted by a path (i.e.: the last path element)."]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn target(self) -> Node {
                ::builtin::recommends([self.valid()]);
                ::builtin::decreases((self.depth));
                if ::builtin::spec_eq(::builtin::spec_literal_nat("0"),
                            self.depth) {
                        self.node
                    } else { self.subpath().target() }
            }
            #[doc =
            " Returns the Seq of children for self.node when `self.target` is replaced with `replacement`."]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn replaced_children(self, replacement: Node) -> Seq<Node> {
                ::builtin::recommends([self.valid(),
                            (::builtin::spec_literal_nat("0")).spec_lt(self.depth)]);
                ::builtin::decreases((self.subpath().depth));
                let new_child = self.subpath().substitute(replacement);
                self.node.get_Index_children().update((self.node.route(self.key)).spec_add(::builtin::spec_literal_nat("1")),
                    new_child)
            }
            #[doc =
            " Returns the tree rooted at self.node, where self.target() is replaced with `replacement`."]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn substitute(self, replacement: Node) -> Node {
                ::builtin::recommends([self.valid()]);
                ::builtin::decreases((self.depth,
                        ::builtin::spec_literal_nat("1")));
                if ::builtin::spec_eq(::builtin::spec_literal_nat("0"),
                            self.depth) {
                        replacement
                    } else {
                       Node::Index {
                           pivots: self.node.get_Index_pivots(),
                           children: self.replaced_children(replacement),
                       }
                   }
            }
            #[doc =
            " Returns true iff `other_key` leads to the same target node as `self.key`."]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn path_equiv(self, other_key: Key) -> bool {
                ::builtin::recommends([self.valid()]);
                ::builtin::decreases((self.depth,
                        ::builtin::spec_literal_nat("1")));
                (::builtin::spec_eq(self.node.route(self.key),
                            self.node.route(other_key))) &&
                    (::builtin::imply((::builtin::spec_literal_nat("0")).spec_lt(self.depth),
                            self.subpath().path_equiv(other_key)))
            }
        }
    }
    pub mod PivotBranchRefinement_v {
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use crate::spec::KeyType_t::*;
        use crate::spec::Messages_t::*;
        use crate::betree::Buffer_v::*;
        use crate::betree::PivotBranch_v::*;
        #[verus::internal(verus_macro)]
        impl Node {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> Buffer {
                ::builtin::recommends([self.wf()]);
                ::builtin::decreases((self));
                ::builtin::decreases_when(::builtin::imply(::builtin::is_variant(self,
                            "Index"),
                        ::builtin::forall(|key|
                                ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            (#[verus::internal(trigger)] self.route(key)).spec_add(::builtin::spec_literal_nat("1"))),
                                        self.get_Index_children().len())))));
                match self {
                    Node::Leaf { keys, msgs } => {
                        Buffer {
                            map: Map::new(::builtin::closure_to_fn_spec(|key|
                                        keys.contains(key)),
                                ::builtin::closure_to_fn_spec(|key|
                                        msgs.spec_index(self.route(key)))),
                        }
                    }
                    Node::Index { pivots, children } => {
                        Buffer {
                            map: Map::new(::builtin::closure_to_fn_spec(|key|
                                        children.spec_index((self.route(key)).spec_add(::builtin::spec_literal_nat("1"))).i().map.contains_key(key)),
                                ::builtin::closure_to_fn_spec(|key|
                                        children.spec_index((self.route(key)).spec_add(::builtin::spec_literal_nat("1"))).i().map.spec_index(key))),
                        }
                    }
                }
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn get_keys_or_pivots(node: Node) -> Seq<Key> {
            ::builtin::recommends([node.wf()]);
            if ::builtin::is_variant(node, "Leaf") {
                    node.get_Leaf_keys()
                } else { node.get_Index_pivots() }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn le_route(node: Node, key: Key, i: int) -> bool {
            ::builtin::recommends([node.wf()]);
            ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                        i), node.route(key)))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn gt_route(node: Node, key: Key, i: int) -> bool {
            ::builtin::recommends([node.wf()]);
            let s = get_keys_or_pivots(node);
            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_lt(::builtin::spec_chained_value(node.route(key)),
                        i), s.len()))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_route_ensures(node: Node, key: Key) {
            ::builtin::requires([node.wf()]);
            ::builtin::ensures([({
                                let s = get_keys_or_pivots(node);
                                (((::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value((::builtin::spec_literal_nat("1")).spec_neg()),
                                                                    #[verus::internal(trigger)] node.route(key)), s.len()))) &&
                                                    (::builtin::forall(|i|
                                                                ::builtin::imply(#[verus::internal(trigger)] le_route(node,
                                                                        key, i), Key::lte(s.spec_index(i), key))))) &&
                                            (::builtin::forall(|i|
                                                        ::builtin::imply(#[verus::internal(trigger)] gt_route(node,
                                                                key, i), Key::lt(key, s.spec_index(i)))))) &&
                                    (::builtin::imply(s.contains(key),
                                            (::builtin::spec_literal_nat("0")).spec_le(node.route(key))
                                                && ::builtin::spec_eq(s.spec_index(node.route(key)), key)))
                            })]);
            let s =
                if ::builtin::is_variant(node, "Leaf") {
                        node.get_Leaf_keys()
                    } else { node.get_Index_pivots() };
            Key::strictly_sorted_implies_sorted(s);
            Key::largest_lte_ensures(s, key, Key::largest_lte(s, key));
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_route_auto() {
            ::builtin::ensures([::builtin::forall(|node: Node, key: Key|
                                ::builtin::imply(node.wf(),
                                    {
                                        let s = get_keys_or_pivots(node);
                                        (((::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value((::builtin::spec_literal_nat("1")).spec_neg()),
                                                                            #[verus::internal(trigger)] node.route(key)), s.len()))) &&
                                                            (::builtin::forall(|i|
                                                                        ::builtin::imply(#[verus::internal(trigger)] le_route(node,
                                                                                key, i), Key::lte(s.spec_index(i), key))))) &&
                                                    (::builtin::forall(|i|
                                                                ::builtin::imply(#[verus::internal(trigger)] gt_route(node,
                                                                        key, i), Key::lt(key, s.spec_index(i)))))) &&
                                            (::builtin::imply(s.contains(key),
                                                    (::builtin::spec_literal_nat("0")).spec_le(node.route(key))
                                                        && ::builtin::spec_eq(s.spec_index(node.route(key)), key)))
                                    }))]);
            {
                ::builtin::assert_forall_by(|node: Node, key: Key|
                        {
                            ::builtin::requires(node.wf());
                            ::builtin::ensures({
                                    let s = get_keys_or_pivots(node);
                                    (((::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value((::builtin::spec_literal_nat("1")).spec_neg()),
                                                                        #[verus::internal(trigger)] node.route(key)), s.len()))) &&
                                                        (::builtin::forall(|i|
                                                                    ::builtin::imply(#[verus::internal(trigger)] le_route(node,
                                                                            key, i), Key::lte(s.spec_index(i), key))))) &&
                                                (::builtin::forall(|i|
                                                            ::builtin::imply(#[verus::internal(trigger)] gt_route(node,
                                                                    key, i), Key::lt(key, s.spec_index(i)))))) &&
                                        (::builtin::imply(s.contains(key),
                                                (::builtin::spec_literal_nat("0")).spec_le(node.route(key))
                                                    && ::builtin::spec_eq(s.spec_index(node.route(key)), key)))
                                });
                            lemma_route_ensures(node, key);
                        });
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_grow_preserves_wf(node: Node) {
            ::builtin::requires([node.wf(),
                        (node.all_keys().len()).spec_gt(::builtin::spec_literal_nat("0"))]);
            ::builtin::ensures([node.grow().wf()]);
            ::builtin::assume_(false);
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_grow_preserves_all_keys(node: Node) {
            ::builtin::requires([node.wf()]);
            ::builtin::ensures([::builtin::spec_eq(node.grow().all_keys(),
                            node.all_keys())]);
            ::builtin::assume_(false);
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_interpretation_delegation(node: Node, key: Key) {
            ::builtin::requires([node.wf(),
                        ::builtin::is_variant(node, "Index"),
                        node.get_Index_children().spec_index((Key::largest_lte(node.get_Index_pivots(),
                                                    key)).spec_add(::builtin::spec_literal_nat("1"))).i().map.contains_key(key)]);
            ::builtin::ensures([node.i().map.contains_pair(key,
                            node.get_Index_children().spec_index((Key::largest_lte(node.get_Index_pivots(),
                                                        key)).spec_add(::builtin::spec_literal_nat("1"))).i().map.spec_index(key))]);
            ::builtin::assume_(false);
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_grow_preserves_i(node: Node) {
            ::builtin::requires([node.wf(),
                        (node.all_keys().len()).spec_gt(::builtin::spec_literal_nat("0"))]);
            ::builtin::ensures([node.grow().wf(),
                        ::builtin::spec_eq(node.grow().i(), node.i())]);
            ::builtin::assume_(false);
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_insert_leaf_is_correct(node: Node, key: Key,
            msg: Message) {
            ::builtin::requires([::builtin::is_variant(node, "Leaf"),
                        node.wf()]);
            ::builtin::ensures([::builtin::spec_eq(node.insert_leaf(key,
                                    msg).i(), (Buffer { map: node.i().map.insert(key, msg) })),
                        ::builtin::spec_eq(node.insert_leaf(key, msg).all_keys(),
                            node.all_keys().insert(key))]);
            ::builtin::assume_(false);
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_split_leaf_preserves_wf(node: Node,
            split_arg: SplitArg) {
            ::builtin::requires([node.wf(),
                        ::builtin::is_variant(node, "Leaf"), split_arg.wf(node)]);
            ::builtin::ensures([({
                                let (left_leaf, right_leaf) = node.split_leaf(split_arg);
                                (left_leaf.wf()) && (right_leaf.wf())
                            })]);
            ::builtin::assume_(false);
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_sub_index_preserves_wf(node: Node, from: int, to: int) {
            ::builtin::requires([node.wf(),
                        ::builtin::is_variant(node, "Index"),
                        ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        from), to), node.get_Index_children().len()))]);
            ::builtin::ensures([node.sub_index(from, to).wf()]);
            ::builtin::assume_(false);
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_split_index_preserves_wf(node: Node,
            split_arg: SplitArg) {
            ::builtin::requires([node.wf(),
                        ::builtin::is_variant(node, "Index"), split_arg.wf(node)]);
            ::builtin::ensures([({
                                let (left_index, right_index) = node.split_index(split_arg);
                                (left_index.wf()) && (right_index.wf())
                            })]);
            ::builtin::assume_(false);
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_split_node_preserves_wf(node: Node,
            split_arg: SplitArg) {
            ::builtin::requires([node.wf(), split_arg.wf(node)]);
            ::builtin::ensures([({
                                let (left_node, right_node) = node.split_node(split_arg);
                                (left_node.wf()) && (right_node.wf())
                            })]);
            ::builtin::assume_(false);
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_split_leaf_interpretation(old_leaf: Node,
            split_arg: SplitArg) {
            ::builtin::requires([old_leaf.wf(),
                        ::builtin::is_variant(old_leaf, "Leaf"),
                        split_arg.wf(old_leaf)]);
            ::builtin::ensures([({
                                let (left_leaf, right_leaf) =
                                    old_leaf.split_leaf(split_arg);
                                ((left_leaf.wf()) && (right_leaf.wf())) &&
                                    (::builtin::spec_eq(old_leaf.i().map,
                                            Key::map_pivoted_union(left_leaf.i().map,
                                                split_arg.get_pivot(), right_leaf.i().map)))
                            })]);
            ::builtin::assume_(false);
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_split_index_interpretation1(old_index: Node,
            split_arg: SplitArg) {
            ::builtin::requires([old_index.wf(),
                        ::builtin::is_variant(old_index, "Index"),
                        split_arg.wf(old_index)]);
            ::builtin::ensures([({
                                let (left_index, right_index) =
                                    old_index.split_index(split_arg);
                                ((left_index.wf()) && (right_index.wf())) &&
                                    (old_index.i().map.submap_of(Key::map_pivoted_union(left_index.i().map,
                                                split_arg.get_pivot(), right_index.i().map)))
                            })]);
            ::builtin::assume_(false);
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_split_index_interpretation2(old_index: Node,
            split_arg: SplitArg) {
            ::builtin::requires([old_index.wf(),
                        ::builtin::is_variant(old_index, "Index"),
                        split_arg.wf(old_index),
                        ({
                                let (left_index, right_index) =
                                    old_index.split_index(split_arg);
                                (left_index.wf()) && (right_index.wf())
                            })]);
            ::builtin::ensures([({
                                let (left_index, right_index) =
                                    old_index.split_index(split_arg);
                                (Key::map_pivoted_union(left_index.i().map,
                                                split_arg.get_pivot(),
                                                right_index.i().map).dom()).spec_le(old_index.i().map.dom())
                            })]);
            ::builtin::assume_(false);
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_split_index_interpretation(old_index: Node,
            split_arg: SplitArg) {
            ::builtin::requires([old_index.wf(),
                        ::builtin::is_variant(old_index, "Index"),
                        split_arg.wf(old_index),
                        ({
                                let (left_index, right_index) =
                                    old_index.split_index(split_arg);
                                (left_index.wf()) && (right_index.wf())
                            })]);
            ::builtin::ensures([({
                                let (left_index, right_index) =
                                    old_index.split_index(split_arg);
                                ::builtin::spec_eq(old_index.i().map,
                                    Key::map_pivoted_union(left_index.i().map,
                                        split_arg.get_pivot(), right_index.i().map))
                            })]);
            ::builtin::assume_(false);
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_split_node_interpretation(old_node: Node,
            split_arg: SplitArg) {
            ::builtin::requires([old_node.wf(), split_arg.wf(old_node),
                        ({
                                let (left_node, right_node) =
                                    old_node.split_node(split_arg);
                                (left_node.wf()) && (right_node.wf())
                            })]);
            ::builtin::ensures([({
                                let (left_node, right_node) =
                                    old_node.split_node(split_arg);
                                ::builtin::spec_eq(old_node.i().map,
                                    Key::map_pivoted_union(left_node.i().map,
                                        split_arg.get_pivot(), right_node.i().map))
                            })]);
            ::builtin::assume_(false);
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_split_leaf_all_keys(old_leaf: Node,
            split_arg: SplitArg) {
            ::builtin::requires([old_leaf.wf(),
                        ::builtin::is_variant(old_leaf, "Leaf"),
                        split_arg.wf(old_leaf),
                        ({
                                let (left_leaf, right_leaf) =
                                    old_leaf.split_leaf(split_arg);
                                (left_leaf.wf()) && (right_leaf.wf())
                            })]);
            ::builtin::ensures([({
                                let (left_leaf, right_leaf) =
                                    old_leaf.split_leaf(split_arg);
                                ((::builtin::spec_eq(old_leaf.all_keys(),
                                                    (left_leaf.all_keys()).spec_add(right_leaf.all_keys()))) &&
                                            (::builtin::forall(|key|
                                                        ::builtin::spec_eq((left_leaf.all_keys().contains(key)),
                                                            ((Key::lt(key, split_arg.get_pivot()) &&
                                                                        old_leaf.all_keys().contains(key))))))) &&
                                    (::builtin::forall(|key|
                                                ::builtin::spec_eq((right_leaf.all_keys().contains(key)),
                                                    ((Key::lte(split_arg.get_pivot(), key) &&
                                                                old_leaf.all_keys().contains(key))))))
                            })]);
            ::builtin::assume_(false);
        }
        #[doc = " (x9du)"]
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_interpretation(node: Node) {
            ::builtin::requires([node.wf()]);
            ::builtin::ensures([node.i().map.dom().subset_of(node.all_keys())]);
            ::builtin::assume_(false);
        }
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct QueryLabel {
            pub key: Key,
            pub msg: Message,
        }
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct InsertLabel {
            pub key: Key,
            pub msg: Message,
            pub path: Path,
        }
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct AppendLabel {
            pub keys: Seq<Key>,
            pub msgs: Seq<Message>,
        }
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct InternalLabel {}
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn query_refines(pre: Node, lbl: QueryLabel) {
            ::builtin::requires([pre.wf(),
                        ::builtin::spec_eq(pre.query(lbl.key), lbl.msg)]);
            ::builtin::ensures([::builtin::spec_eq(pre.i().query(lbl.key),
                            lbl.msg)]);
            ::builtin::decreases((pre));
            let r = pre.route(lbl.key);
            lemma_route_auto();
            if ::builtin::is_variant(pre, "Index") {
                    let pivots = pre.get_Index_pivots();
                    let children = pre.get_Index_children();
                    ::builtin::assert_(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                    (r).spec_add(::builtin::spec_literal_nat("1"))),
                                children.len())));
                    ::builtin::assert_(children.spec_index((r).spec_add(::builtin::spec_literal_nat("1"))).wf());
                    ::builtin::assert_(::builtin::spec_eq(lbl.msg,
                            children.spec_index((r).spec_add(::builtin::spec_literal_nat("1"))).query(lbl.key)));
                    query_refines(children.spec_index((r).spec_add(::builtin::spec_literal_nat("1"))),
                        lbl);
                    ::builtin::assert_(::builtin::spec_eq(children.spec_index((r).spec_add(::builtin::spec_literal_nat("1"))).i().query(lbl.key),
                            lbl.msg));
                    if pre.i().map.contains_key(lbl.key) {
                            ::builtin::assert_(children.spec_index((r).spec_add(::builtin::spec_literal_nat("1"))).i().map.contains_key(lbl.key));
                            lemma_interpretation_delegation(pre, lbl.key);
                            ::builtin::assert_(::builtin::spec_eq(pre.i().map.spec_index(lbl.key),
                                    children.spec_index((r).spec_add(::builtin::spec_literal_nat("1"))).i().map.spec_index(lbl.key)));
                        } else {
                           if (children.spec_index((r).spec_add(::builtin::spec_literal_nat("1"))).i().map.contains_key(lbl.key))
                                   {
                                   lemma_interpretation_delegation(pre, lbl.key);
                                   ::builtin::assert_(pre.i().map.contains_key(lbl.key));
                               }
                           ::builtin::assert_(!children.spec_index((r).spec_add(::builtin::spec_literal_nat("1"))).i().map.contains_key(lbl.key));
                       }
                    ::builtin::assert_(::builtin::spec_eq(pre.i().query(lbl.key),
                            children.spec_index((r).spec_add(::builtin::spec_literal_nat("1"))).i().query(lbl.key)));
                }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_insert_leaf_preserves_wf(node: Node, key: Key,
            msg: Message) {
            ::builtin::requires([node.wf(),
                        ::builtin::is_variant(node, "Leaf")]);
            ::builtin::ensures([node.insert_leaf(key, msg).wf()]);
            let keys = node.get_Leaf_keys();
            let msgs = node.get_Leaf_msgs();
            ::builtin::assert_(::builtin::spec_eq(keys.len(), msgs.len()));
            ::builtin::assert_(Key::is_strictly_sorted(keys));
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_insert_preserves_wf(node: Node, key: Key, msg: Message,
            path: Path) {
            ::builtin::requires([node.wf(), path.valid(),
                        ::builtin::spec_eq(path.node, node),
                        ::builtin::spec_eq(path.key, key),
                        ::builtin::is_variant(path.target(), "Leaf")]);
            ::builtin::ensures([node.insert(key, msg, path).wf()]);
            ::builtin::assume_(false);
            match node {
                Node::Leaf { keys, msgs } => {
                    lemma_insert_leaf_is_correct(node, key, msg);
                    ::builtin::assert_(node.insert(key, msg, path).wf());
                }
                Node::Index { pivots, children } => {
                    ::builtin::assume_(false);
                }
            }
            ::builtin::assert_(node.insert(key, msg, path).wf());
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn insert_refines(pre: Node, lbl: InsertLabel) {
            ::builtin::requires([pre.wf(), lbl.path.valid(),
                        lbl.path.target().wf(),
                        ::builtin::spec_eq(lbl.path.node, pre),
                        ::builtin::spec_eq(lbl.path.key, lbl.key),
                        ::builtin::is_variant(lbl.path.target(), "Leaf")]);
            ::builtin::ensures([pre.insert(lbl.key, lbl.msg, lbl.path).wf(),
                        ::builtin::spec_eq(pre.insert(lbl.key, lbl.msg,
                                    lbl.path).i(), pre.i().insert(lbl.key, lbl.msg))]);
            ::builtin::assume_(false);
            lemma_insert_leaf_is_correct(lbl.path.target(), lbl.key, lbl.msg);
            ::builtin::assert_(pre.insert(lbl.key, lbl.msg, lbl.path).wf());
            ::builtin::assume_(::builtin::spec_eq(pre.insert(lbl.key, lbl.msg,
                            lbl.path).i(), pre.i().insert(lbl.key, lbl.msg)));
        }
    }
    pub mod LinkedBranch_v {
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use crate::spec::KeyType_t::*;
        use crate::spec::Messages_t::*;
        use crate::disk::GenericDisk_v::*;
        #[verus::internal(verus_macro)]
        pub enum SplitArg {
            SplitIndex {
                pivot: Key,
                pivot_index: int,
            },
            SplitLeaf {
                pivot: Key,
            },
        }
        #[verus::internal(verus_macro)]
        #[cfg(verus_keep_ghost)]
        #[automatically_derived]
        impl SplitArg {
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_SplitIndex(&self) -> bool {
                ::builtin::is_variant(self, "SplitIndex")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_SplitIndex_pivot(self) -> Key {
                ::builtin::get_variant_field(self, "SplitIndex", "pivot")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_SplitIndex_pivot_index(self) -> int {
                ::builtin::get_variant_field(self, "SplitIndex",
                    "pivot_index")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_SplitLeaf(&self) -> bool {
                ::builtin::is_variant(self, "SplitLeaf")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_SplitLeaf_pivot(self) -> Key {
                ::builtin::get_variant_field(self, "SplitLeaf", "pivot")
            }
        }
        #[verus::internal(verus_macro)]
        impl SplitArg {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self, split_branch: LinkedBranch) -> bool {
                ::builtin::recommends([split_branch.has_root()]);
                let root = split_branch.root();
                match self {
                    Self::SplitLeaf { pivot } => {
                        ((::builtin::is_variant(root, "Leaf")) &&
                                    (::builtin::spec_eq(root.get_Leaf_keys().len(),
                                            root.get_Leaf_msgs().len()))) &&
                            (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_lt(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            (Key::largest_lt(root.get_Leaf_keys(),
                                                        pivot)).spec_add(::builtin::spec_literal_nat("1"))),
                                        root.get_Leaf_keys().len())))
                    }
                    Self::SplitIndex { pivot, pivot_index } => {
                        ((((::builtin::is_variant(root, "Index")) &&
                                                    (::builtin::spec_eq(root.get_Index_children().len(),
                                                            (root.get_Index_pivots().len()).spec_add(::builtin::spec_literal_nat("1")))))
                                            &&
                                            (::builtin::imply(split_branch.acyclic(),
                                                    split_branch.all_keys_in_range()))) &&
                                    (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                    pivot_index), root.get_Index_pivots().len())))) &&
                            (::builtin::spec_eq(root.get_Index_pivots().spec_index(pivot_index),
                                    pivot))
                    }
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn get_pivot(self) -> Key {
                if ::builtin::is_variant(self, "SplitLeaf") {
                        self.get_SplitLeaf_pivot()
                    } else { self.get_SplitIndex_pivot() }
            }
        }
        #[verus::internal(verus_macro)]
        pub enum Node {
            Index {
                pivots: Seq<Key>,
                children: Seq<Address>,
            },
            Leaf {
                keys: Seq<Key>,
                msgs: Seq<Message>,
            },
        }
        #[verus::internal(verus_macro)]
        #[cfg(verus_keep_ghost)]
        #[automatically_derived]
        impl Node {
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_Index(&self) -> bool {
                ::builtin::is_variant(self, "Index")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_Index_pivots(self) -> Seq<Key> {
                ::builtin::get_variant_field(self, "Index", "pivots")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_Index_children(self) -> Seq<Address> {
                ::builtin::get_variant_field(self, "Index", "children")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_Leaf(&self) -> bool {
                ::builtin::is_variant(self, "Leaf")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_Leaf_keys(self) -> Seq<Key> {
                ::builtin::get_variant_field(self, "Leaf", "keys")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_Leaf_msgs(self) -> Seq<Message> {
                ::builtin::get_variant_field(self, "Leaf", "msgs")
            }
        }
        #[verus::internal(verus_macro)]
        impl Node {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                match self {
                    Self::Leaf { keys, msgs } => {
                        (::builtin::spec_eq(keys.len(), msgs.len())) &&
                            (Key::is_strictly_sorted(keys))
                    }
                    Self::Index { pivots, children } => {
                        (::builtin::spec_eq(pivots.len(),
                                    (children.len()).spec_sub(::builtin::spec_literal_nat("1"))))
                            && (Key::is_strictly_sorted(pivots))
                    }
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid_child_index(self, i: nat) -> bool {
                (::builtin::is_variant(self, "Index")) &&
                    ((i).spec_lt(self.get_Index_children().len()))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn route(self, key: Key) -> int {
                ::builtin::recommends([self.wf()]);
                let s =
                    if ::builtin::is_variant(self, "Leaf") {
                            self.get_Leaf_keys()
                        } else { self.get_Index_pivots() };
                Key::largest_lte(s, key)
            }
        }
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct DiskView {
            pub entries: Map<Address, Node>,
        }
        #[verus::internal(verus_macro)]
        impl DiskView {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                (self.entries_wf()) && (self.no_dangling_address())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn entries_wf(self) -> bool {
                ::builtin::forall(|addr|
                        ::builtin::imply(#[verus::internal(trigger)] self.entries.contains_key(addr),
                            self.entries.spec_index(addr).wf()))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid_address(self, addr: Address) -> bool {
                self.entries.contains_key(addr)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn node_has_valid_child_address(self, node: Node) -> bool {
                ::builtin::imply(::builtin::is_variant(node, "Index"),
                    ::builtin::forall(|idx|
                            ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            idx), node.get_Index_children().len())),
                                self.valid_address(#[verus::internal(trigger)] node.get_Index_children().spec_index(idx)))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn no_dangling_address(self) -> bool {
                ::builtin::forall(|addr|
                        ::builtin::imply(#[verus::internal(trigger)] self.entries.contains_key(addr),
                            self.node_has_valid_child_address(self.entries.spec_index(addr))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn get(self, addr: Address) -> Node {
                ::builtin::recommends([self.valid_address(addr)]);
                self.entries.spec_index(addr)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn get_keys(self, addr: Address) -> Set<Key> {
                ::builtin::recommends([self.valid_address(addr)]);
                let node = self.get(addr);
                if ::builtin::is_variant(node, "Index") {
                        node.get_Index_pivots().to_set()
                    } else { node.get_Leaf_keys().to_set() }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn representation(self) -> Set<Address> { self.entries.dom() }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn agrees_with_disk(self, other: DiskView) -> bool {
                self.entries.agrees(other.entries)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_subset_of(self, other: DiskView) -> bool {
                (self.entries).spec_le(other.entries)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn node_children_respects_rank(self, ranking: Ranking,
                addr: Address) -> bool {
                ::builtin::recommends([self.wf(),
                            self.entries.contains_key(addr),
                            ranking.contains_key(addr)]);
                let node = self.entries.spec_index(addr);
                ::builtin::forall(|child_idx: nat|
                        ::builtin::imply(#[verus::internal(trigger)] node.valid_child_index(child_idx),
                            {
                                (ranking.contains_key(node.get_Index_children().spec_index(::builtin::spec_cast_integer::<_,
                                                        int>(child_idx)))) &&
                                    ((ranking.spec_index(node.get_Index_children().spec_index(::builtin::spec_cast_integer::<_,
                                                                int>(child_idx)))).spec_lt(ranking.spec_index(addr)))
                            }))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid_ranking(self, ranking: Ranking) -> bool {
                ::builtin::recommends([self.wf()]);
                ::builtin::forall(|addr|
                        ::builtin::imply(#[verus::internal(trigger)] ranking.contains_key(addr)
                                && self.entries.contains_key(addr),
                            self.node_children_respects_rank(ranking, addr)))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_fresh(self, addrs: Set<Address>) -> bool {
                addrs.disjoint(self.entries.dom())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec(checked))]
            pub fn merge_disk(self, other: DiskView) -> DiskView {
                DiskView {
                    entries: self.entries.union_prefer_right(other.entries),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec(checked))]
            pub fn remove_disk(self, other: DiskView) -> DiskView {
                DiskView {
                    entries: self.entries.remove_keys(other.entries.dom()),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn modify_disk(self, addr: Address, item: Node) -> DiskView {
                DiskView { entries: self.entries.insert(addr, item) }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn same_except(self, other: DiskView, except: Set<Address>)
                -> bool {
                ::builtin::spec_eq(self.entries.remove_keys(except),
                    other.entries.remove_keys(except))
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn empty_disk() -> DiskView {
            DiskView { entries: ::vstd::map::Map::empty() }
        }
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct LinkedBranch {
            pub root: Address,
            pub disk_view: DiskView,
        }
        #[verus::internal(verus_macro)]
        impl LinkedBranch {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                (self.disk_view.wf()) && (self.has_root())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn has_root(self) -> bool {
                self.disk_view.valid_address(self.root)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn root(self) -> Node {
                ::builtin::recommends([self.has_root()]);
                self.disk_view.get(self.root)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn get_rank(self, ranking: Ranking) -> nat {
                ::builtin::recommends([self.wf()]);
                if ranking.contains_key(self.root) {
                        (ranking.spec_index(self.root)).spec_add(::builtin::spec_literal_nat("1"))
                    } else { ::builtin::spec_literal_integer("0") }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid_ranking(self, ranking: Ranking) -> bool {
                ::builtin::recommends([self.wf()]);
                (self.disk_view.valid_ranking(ranking)) &&
                    (ranking.contains_key(self.root))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn the_ranking(self) -> Ranking {
                ::builtin::recommends([self.acyclic()]);
                let ranking =
                    ::builtin::choose(|ranking| self.valid_ranking(ranking));
                ranking
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn acyclic(self) -> bool {
                (self.wf()) &&
                    (::builtin::exists(|ranking| self.valid_ranking(ranking)))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn all_keys_in_range(self) -> bool {
                ::builtin::recommends([self.acyclic()]);
                self.all_keys_in_range_internal(self.the_ranking())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn all_keys_in_range_internal(self, ranking: Ranking)
                -> bool {
                ::builtin::recommends([self.wf(),
                            self.valid_ranking(ranking)]);
                ::builtin::decreases((self.get_rank(ranking),
                        ::builtin::spec_literal_int("1")));
                ::builtin::imply(::builtin::is_variant(self.root(), "Index"),
                    {
                        ((::builtin::forall(|i|
                                                ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                i), self.root().get_Index_children().len())),
                                                    self.child_all_keys_in_range_internal(ranking, i)))) &&
                                    (::builtin::forall(|i|
                                                ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                i),
                                                            (self.root().get_Index_children().len()).spec_sub(::builtin::spec_literal_nat("1")))),
                                                    self.all_keys_below_bound(i, ranking))))) &&
                            (::builtin::forall(|i|
                                        ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_lt(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                        i), self.root().get_Index_children().len())),
                                            self.all_keys_above_bound(i, ranking))))
                    })
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn child_all_keys_in_range_internal(self, ranking: Ranking,
                i: nat) -> bool {
                ::builtin::recommends([self.wf(), self.valid_ranking(ranking),
                            ::builtin::is_variant(self.root(), "Index"),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        i), self.root().get_Index_children().len()))]);
                ::builtin::decreases((self.get_rank(ranking),
                        ::builtin::spec_literal_int("0")));
                ::builtin::decreases_when({
                        ((::builtin::is_variant(self.root(), "Index")) &&
                                    (self.root().valid_child_index(i))) &&
                            ((self.child_at_idx(i).get_rank(ranking)).spec_lt(self.get_rank(ranking)))
                    });
                self.child_at_idx(i).all_keys_in_range_internal(ranking)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn children_keys(self, ranking: Ranking, i: nat) -> Set<Key> {
                ::builtin::recommends([self.wf(), self.valid_ranking(ranking),
                            ::builtin::is_variant(self.root(), "Index"),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        i), self.root().get_Index_children().len()))]);
                ::builtin::decreases((self.get_rank(ranking),
                        ::builtin::spec_literal_int("0"),
                        (self.root().get_Index_children().len()).spec_sub(i)));
                ::builtin::decreases_when({
                        ((::builtin::is_variant(self.root(), "Index")) &&
                                    (::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                    i), self.root().get_Index_children().len())))) &&
                            (::builtin::imply(self.root().valid_child_index(i),
                                    (self.child_at_idx(i).get_rank(ranking)).spec_lt(self.get_rank(ranking))))
                    });
                if ::builtin::spec_eq(i,
                            self.root().get_Index_children().len()) {
                        ::vstd::set::Set::empty()
                    } else {
                       (self.child_at_idx(i).all_keys(ranking)).spec_add(self.children_keys(ranking,
                               (i).spec_add(::builtin::spec_literal_nat("1"))))
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn all_keys(self, ranking: Ranking) -> Set<Key> {
                ::builtin::recommends([self.wf(),
                            self.valid_ranking(ranking)]);
                ::builtin::decreases((self.get_rank(ranking),
                        ::builtin::spec_literal_int("1")));
                if ::builtin::is_variant(self.root(), "Leaf") {
                        self.root().get_Leaf_keys().to_set()
                    } else {
                       let pivot_keys = self.root().get_Index_pivots().to_set();
                       let index_keys =
                           self.children_keys(ranking,
                               ::builtin::spec_literal_integer("0"));
                       (pivot_keys).spec_add(index_keys)
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn all_keys_below_bound(self, i: int, ranking: Ranking)
                -> bool {
                ::builtin::recommends([self.wf(), self.valid_ranking(ranking),
                            ::builtin::is_variant(self.root(), "Index"),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        i), self.root().get_Index_pivots().len()))]);
                ::builtin::decreases((self.get_rank(ranking)));
                ::builtin::forall(|key|
                        ::builtin::imply(self.child_at_idx(::builtin::spec_cast_integer::<_,
                                                nat>(i)).all_keys(ranking).contains(key),
                            Key::lt(key, self.root().get_Index_pivots().spec_index(i))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn all_keys_above_bound(self, i: int, ranking: Ranking)
                -> bool {
                ::builtin::recommends([self.wf(), self.valid_ranking(ranking),
                            ::builtin::is_variant(self.root(), "Index"),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        (i).spec_sub(::builtin::spec_literal_nat("1"))),
                                    self.root().get_Index_pivots().len()))]);
                ::builtin::decreases((self.get_rank(ranking)));
                ::builtin::forall(|key|
                        ::builtin::imply(self.child_at_idx(::builtin::spec_cast_integer::<_,
                                                nat>(i)).all_keys(ranking).contains(key),
                            #[verus::internal(trigger)] Key::lte(self.root().get_Index_pivots().spec_index((i).spec_sub(::builtin::spec_literal_nat("1"))),
                                key)))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn child_at_idx(self, i: nat) -> LinkedBranch {
                ::builtin::recommends([self.has_root(),
                            self.root().valid_child_index(i)]);
                LinkedBranch {
                    root: self.root().get_Index_children().spec_index(::builtin::spec_cast_integer::<_,
                                int>(i)),
                    disk_view: self.disk_view,
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn representation(self) -> Set<Address> {
                ::builtin::recommends([self.acyclic()]);
                self.reachable_addrs_using_ranking(self.the_ranking())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn reachable_addrs_using_ranking(self, ranking: Ranking)
                -> Set<Address> {
                ::builtin::recommends([self.wf(),
                            self.valid_ranking(ranking)]);
                ::builtin::decreases((self.get_rank(ranking),
                        ::builtin::spec_literal_int("1")));
                if !self.has_root() {
                        ::vstd::set::Set::empty()
                    } else if ::builtin::is_variant(self.root(), "Leaf") {
                       ::vstd::set::Set::empty().insert(self.root)
                   } else {
                       let num_children = self.root().get_Index_children().len();
                       let subtree_addrs =
                           Seq::new(num_children,
                               ::builtin::closure_to_fn_spec(|i: int|
                                       self.child_reachable_addrs_using_ranking(ranking,
                                           ::builtin::spec_cast_integer::<_, nat>(i))));
                       union_seq_of_sets(subtree_addrs).insert(self.root)
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn child_reachable_addrs_using_ranking(self, ranking: Ranking,
                i: nat) -> Set<Address> {
                ::builtin::recommends([self.wf(), self.valid_ranking(ranking),
                            ::builtin::is_variant(self.root(), "Index"),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        i), self.root().get_Index_children().len()))]);
                ::builtin::decreases((self.get_rank(ranking),
                        ::builtin::spec_literal_int("0")));
                ::builtin::decreases_when({
                        (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            i), self.root().get_Index_children().len()))) &&
                            ((self.child_at_idx(i).get_rank(ranking)).spec_lt(self.get_rank(ranking)))
                    });
                self.child_at_idx(i).reachable_addrs_using_ranking(ranking)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn tight_disk_view(self) -> bool {
                ::builtin::imply(self.acyclic(),
                    ::builtin::spec_eq(self.representation(),
                        self.disk_view.representation()))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn query_internal(self, key: Key, ranking: Ranking)
                -> Message {
                ::builtin::recommends([self.wf(),
                            self.valid_ranking(ranking)]);
                ::builtin::decreases((self.get_rank(ranking)));
                ::builtin::decreases_when({
                        ::builtin::imply(::builtin::is_variant(self.root(),
                                "Index"),
                            {
                                let r = self.root().route(key);
                                (self.root().valid_child_index(::builtin::spec_cast_integer::<_,
                                                    nat>(((r).spec_add(::builtin::spec_literal_nat("1")))))) &&
                                    ((self.child_at_idx(::builtin::spec_cast_integer::<_,
                                                                nat>(((r).spec_add(::builtin::spec_literal_nat("1"))))).get_rank(ranking)).spec_lt(self.get_rank(ranking)))
                            })
                    });
                let node = self.root();
                let r = node.route(key);
                if ::builtin::is_variant(node, "Leaf") {
                        if (r).spec_ge(::builtin::spec_literal_nat("0")) &&
                                    ::builtin::spec_eq(node.get_Leaf_keys().spec_index(r), key)
                                {
                                node.get_Leaf_msgs().spec_index(r)
                            } else { Message::Update { delta: nop_delta() } }
                    } else {
                       self.child_at_idx(::builtin::spec_cast_integer::<_,
                                       nat>(((r).spec_add(::builtin::spec_literal_nat("1"))))).query_internal(key,
                           ranking)
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn query(self, key: Key) -> Message {
                if self.acyclic() {
                        self.query_internal(key, self.the_ranking())
                    } else { Message::Update { delta: nop_delta() } }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn grow(self, addr: Address) -> LinkedBranch {
                ::builtin::recommends([self.wf(),
                            self.disk_view.is_fresh(::vstd::set::Set::empty().insert(addr))]);
                let new_root =
                    Node::Index {
                        pivots: ::vstd::seq::Seq::empty(),
                        children: ::vstd::seq::Seq::empty().push(self.root),
                    };
                let new_disk_view =
                    self.disk_view.modify_disk(addr, new_root);
                LinkedBranch { root: addr, disk_view: new_disk_view }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn insert_leaf(self, key: Key, msg: Message) -> LinkedBranch {
                ::builtin::recommends([self.wf(),
                            ::builtin::is_variant(self.root(), "Leaf")]);
                let node = self.root();
                let llte = Key::largest_lte(node.get_Leaf_keys(), key);
                let new_node =
                    if (::builtin::spec_literal_nat("0")).spec_le(llte) &&
                                ::builtin::spec_eq(node.get_Leaf_keys().spec_index(llte),
                                    key) {
                            Node::Leaf {
                                keys: node.get_Leaf_keys(),
                                msgs: node.get_Leaf_msgs().update(llte, msg),
                            }
                        } else {
                           Node::Leaf {
                               keys: node.get_Leaf_keys().insert((llte).spec_add(::builtin::spec_literal_nat("1")),
                                   key),
                               msgs: node.get_Leaf_msgs().insert((llte).spec_add(::builtin::spec_literal_nat("1")),
                                   msg),
                           }
                       };
                LinkedBranch {
                    root: self.root,
                    disk_view: self.disk_view.modify_disk(self.root, new_node),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn insert(self, key: Key, msg: Message, path: Path)
                -> LinkedBranch {
                ::builtin::recommends([self.wf(), path.valid(),
                            ::builtin::spec_eq(path.branch, self),
                            ::builtin::spec_eq(path.key, key),
                            ::builtin::is_variant(path.target().root(), "Leaf")]);
                path.substitute(path.target().insert_leaf(key, msg))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn append_to_new_leaf(self, new_keys: Seq<Key>,
                new_msgs: Seq<Message>) -> LinkedBranch {
                ::builtin::recommends([self.wf(),
                            ::builtin::is_variant(self.root(), "Leaf"),
                            ::builtin::spec_eq(new_keys.len(), new_msgs.len()),
                            Key::is_strictly_sorted(new_keys)]);
                let new_node = Node::Leaf { keys: new_keys, msgs: new_msgs };
                let new_disk_view =
                    self.disk_view.modify_disk(self.root, new_node);
                LinkedBranch { root: self.root, disk_view: new_disk_view }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn append(self, keys: Seq<Key>, msgs: Seq<Message>,
                path: Path) -> LinkedBranch {
                ::builtin::recommends([self.wf(), path.valid(),
                            ::builtin::spec_eq(path.branch, self),
                            ::builtin::spec_eq(path.target().root(),
                                (Node::Leaf {
                                        keys: ::vstd::seq::Seq::empty(),
                                        msgs: ::vstd::seq::Seq::empty(),
                                    })), (keys.len()).spec_gt(::builtin::spec_literal_nat("0")),
                            ::builtin::spec_eq(keys.len(), msgs.len()),
                            Key::is_strictly_sorted(keys),
                            ::builtin::spec_eq(path.key,
                                keys.spec_index(::builtin::spec_literal_integer("0"))),
                            path.path_equiv(keys.last())]);
                path.substitute(path.target().append_to_new_leaf(keys, msgs))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split_leaf(self, split_arg: SplitArg,
                right_root_addr: Address) -> (LinkedBranch, LinkedBranch) {
                ::builtin::recommends([self.has_root(), split_arg.wf(self),
                            self.disk_view.is_fresh(::vstd::set::Set::empty().insert(right_root_addr))]);
                let pivot = split_arg.get_pivot();
                let split_index =
                    (Key::largest_lt(self.root().get_Leaf_keys(),
                                pivot)).spec_add(::builtin::spec_literal_nat("1"));
                let left_root =
                    Node::Leaf {
                        keys: self.root().get_Leaf_keys().take(split_index),
                        msgs: self.root().get_Leaf_msgs().take(split_index),
                    };
                let right_root =
                    Node::Leaf {
                        keys: self.root().get_Leaf_keys().skip(split_index),
                        msgs: self.root().get_Leaf_msgs().skip(split_index),
                    };
                let new_disk_view =
                    self.disk_view.modify_disk(self.root,
                            left_root).modify_disk(right_root_addr, right_root);
                let left_index =
                    LinkedBranch { root: self.root, disk_view: new_disk_view };
                let right_index =
                    LinkedBranch {
                        root: right_root_addr,
                        disk_view: new_disk_view,
                    };
                (left_index, right_index)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn sub_index(self, from: int, to: int) -> Node {
                ::builtin::recommends([self.has_root(),
                            ::builtin::is_variant(self.root(), "Index"),
                            ::builtin::spec_eq(self.root().get_Index_children().len(),
                                (self.root().get_Index_pivots().len()).spec_add(::builtin::spec_literal_nat("1"))),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            from), to), self.root().get_Index_children().len()))]);
                Node::Index {
                    pivots: self.root().get_Index_pivots().subrange(from,
                        (to).spec_sub(::builtin::spec_literal_nat("1"))),
                    children: self.root().get_Index_children().subrange(from,
                        to),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn split_index(self, split_arg: SplitArg,
                right_root_addr: Address) -> (LinkedBranch, LinkedBranch) {
                ::builtin::recommends([self.has_root(), split_arg.wf(self),
                            self.disk_view.is_fresh(::vstd::set::Set::empty().insert(right_root_addr))]);
                let pivot_index = split_arg.get_SplitIndex_pivot_index();
                let left_root =
                    self.sub_index(::builtin::spec_literal_integer("0"),
                        (pivot_index).spec_add(::builtin::spec_literal_nat("1")));
                let right_root =
                    self.sub_index((pivot_index).spec_add(::builtin::spec_literal_nat("1")),
                        ::builtin::spec_cast_integer::<_,
                                int>(self.root().get_Index_children().len()));
                let new_disk_view =
                    self.disk_view.modify_disk(self.root,
                            left_root).modify_disk(right_root_addr, right_root);
                let left_index =
                    LinkedBranch { root: self.root, disk_view: new_disk_view };
                let right_index =
                    LinkedBranch {
                        root: right_root_addr,
                        disk_view: new_disk_view,
                    };
                (left_index, right_index)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split_node(self, split_arg: SplitArg,
                right_root_addr: Address) -> (LinkedBranch, LinkedBranch) {
                ::builtin::recommends([self.has_root(), split_arg.wf(self),
                            self.disk_view.is_fresh(::vstd::set::Set::empty().insert(right_root_addr))]);
                if (::builtin::is_variant(self.root(), "Leaf")) {
                        self.split_leaf(split_arg, right_root_addr)
                    } else { self.split_index(split_arg, right_root_addr) }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn can_split_child_of_index(self, split_arg: SplitArg,
                new_child_addr: Address) -> bool {
                (((self.has_root()) &&
                                    (::builtin::is_variant(self.root(), "Index"))) &&
                            (self.root().wf())) &&
                    ({
                            let child_idx =
                                (self.root().route(split_arg.get_pivot())).spec_add(::builtin::spec_literal_nat("1"));
                            ((self.child_at_idx(::builtin::spec_cast_integer::<_,
                                                            nat>(child_idx)).has_root()) &&
                                        (split_arg.wf(self.child_at_idx(::builtin::spec_cast_integer::<_,
                                                            nat>(child_idx))))) &&
                                (self.child_at_idx(::builtin::spec_cast_integer::<_,
                                                        nat>(child_idx)).disk_view.is_fresh(::vstd::set::Set::empty().insert(new_child_addr)))
                        })
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn split_child_of_index(self, split_arg: SplitArg,
                new_child_addr: Address) -> LinkedBranch {
                ::builtin::recommends([self.can_split_child_of_index(split_arg,
                                new_child_addr)]);
                let pivot = split_arg.get_pivot();
                let child_idx =
                    (self.root().route(pivot)).spec_add(::builtin::spec_literal_nat("1"));
                let (left_branch, right_branch) =
                    self.child_at_idx(::builtin::spec_cast_integer::<_,
                                    nat>(child_idx)).split_node(split_arg, new_child_addr);
                let new_root =
                    Node::Index {
                        pivots: self.root().get_Index_pivots().insert(child_idx,
                            pivot),
                        children: self.root().get_Index_children().insert((child_idx).spec_add(::builtin::spec_literal_nat("1")),
                            new_child_addr),
                    };
                let new_disk_view =
                    self.disk_view.merge_disk(left_branch.disk_view).modify_disk(self.root,
                        new_root);
                LinkedBranch { root: self.root, disk_view: new_disk_view }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split(self, addr: Address, path: Path, split_arg: SplitArg)
                -> LinkedBranch {
                ::builtin::recommends([self.wf(), path.valid(),
                            ::builtin::spec_eq(path.branch, self),
                            path.target().can_split_child_of_index(split_arg, addr),
                            self.disk_view.is_fresh(::vstd::set::Set::empty().insert(addr))]);
                path.substitute(path.target().split_child_of_index(split_arg,
                        addr))
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn empty_linked_branch(root: Address) -> LinkedBranch {
            LinkedBranch {
                root: root,
                disk_view: empty_disk().modify_disk(root,
                    Node::Leaf {
                        keys: ::vstd::seq::Seq::empty(),
                        msgs: ::vstd::seq::Seq::empty(),
                    }),
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn union_seq_of_sets<T>(s: Seq<Set<T>>) -> Set<T> {
            ::builtin::decreases((s.len()));
            if ::builtin::spec_eq(s.len(), ::builtin::spec_literal_nat("0")) {
                    ::vstd::set::Set::empty()
                } else {
                   (s.spec_index(::builtin::spec_literal_integer("0"))).spec_add(union_seq_of_sets(s.skip(::builtin::spec_literal_integer("1"))))
               }
        }
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct Path {
            pub branch: LinkedBranch,
            pub key: Key,
            pub depth: nat,
        }
        #[verus::internal(verus_macro)]
        impl Path {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn subpath(self) -> Path {
                ::builtin::recommends([(::builtin::spec_literal_nat("0")).spec_lt(self.depth),
                            self.branch.wf(),
                            ::builtin::is_variant(self.branch.root(), "Index")]);
                let r =
                    (self.branch.root().route(self.key)).spec_add(::builtin::spec_literal_nat("1"));
                Path {
                    branch: self.branch.child_at_idx(::builtin::spec_cast_integer::<_,
                                nat>(r)),
                    key: self.key,
                    depth: ::builtin::spec_cast_integer::<_,
                            nat>(((self.depth).spec_sub(::builtin::spec_literal_nat("1")))),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid(self) -> bool {
                ::builtin::decreases((self.depth));
                ((self.branch.wf()) &&
                            (::builtin::imply((::builtin::spec_literal_nat("0")).spec_lt(self.depth),
                                    ::builtin::is_variant(self.branch.root(), "Index")))) &&
                    (::builtin::imply((::builtin::spec_literal_nat("0")).spec_lt(self.depth),
                            self.subpath().valid()))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn target(self) -> LinkedBranch {
                ::builtin::recommends([self.valid()]);
                ::builtin::decreases((self.depth));
                if ::builtin::spec_eq(::builtin::spec_literal_nat("0"),
                            self.depth) {
                        self.branch
                    } else { self.subpath().target() }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn substitute(self, replacement: LinkedBranch)
                -> LinkedBranch {
                ::builtin::recommends([self.valid()]);
                LinkedBranch {
                    root: self.branch.root,
                    disk_view: replacement.disk_view,
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn path_equiv(self, other_key: Key) -> bool {
                ::builtin::recommends([self.valid()]);
                ::builtin::decreases((self.depth,
                        ::builtin::spec_literal_int("1")));
                (::builtin::spec_eq(self.branch.root().route(self.key),
                            self.branch.root().route(other_key))) &&
                    (::builtin::imply((::builtin::spec_literal_nat("0")).spec_lt(self.depth),
                            self.subpath().path_equiv(other_key)))
            }
        }
    }
}
mod journal {
    pub mod PagedJournal_v {
        #[allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        use vstd::prelude::*;
        use crate::abstract_system::StampedMap_v::LSN;
        use crate::abstract_system::MsgHistory_v::*;
        #[verus::internal(verus_macro)]
        pub struct JournalRecord {
            pub message_seq: MsgHistory,
            pub prior_rec: Box<Option<JournalRecord>>,
        }
        #[verus::internal(verus_macro)]
        impl JournalRecord {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                ::builtin::decreases((self));
                (self.message_seq.wf()) &&
                    (::builtin::imply(self.prior_rec.is_Some(),
                            {
                                (self.prior_rec.unwrap().wf()) &&
                                    (self.prior_rec.unwrap().message_seq.can_concat(self.message_seq))
                            }))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid(self, boundary_lsn: LSN) -> bool {
                ::builtin::decreases((self));
                ((self.wf()) &&
                            ((boundary_lsn).spec_lt(self.message_seq.seq_end))) &&
                    ({
                            (self.message_seq.can_discard_to(boundary_lsn)) ||
                                ((self.prior_rec.is_Some() &&
                                            self.prior_rec.unwrap().valid(boundary_lsn)))
                        })
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn new_boundary_valid(self, old_lsn: LSN, new_lsn: LSN) {
                ::builtin::requires([self.valid(old_lsn),
                            (old_lsn).spec_le(new_lsn),
                            (new_lsn).spec_lt(self.message_seq.seq_end)]);
                ::builtin::ensures([self.valid(new_lsn)]);
                ::builtin::decreases((self));
                if (new_lsn).spec_lt(self.message_seq.seq_start) {
                        self.prior_rec.get_Some_0().new_boundary_valid(old_lsn,
                            new_lsn);
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn cropped_prior(self, boundary_lsn: LSN)
                -> Option<JournalRecord> {
                if (self.message_seq.seq_start).spec_le(boundary_lsn) {
                        None
                    } else { *self.prior_rec }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_crop_head_records(self, boundary_lsn: LSN, depth: nat)
                -> bool {
                ::builtin::decreases((depth,
                        ::builtin::spec_literal_nat("0")));
                (self.valid(boundary_lsn)) &&
                    (if ::builtin::spec_eq(depth,
                                    ::builtin::spec_literal_nat("0")) {
                                true
                            } else {
                               Self::opt_rec_can_crop_head_records(self.cropped_prior(boundary_lsn),
                                   boundary_lsn,
                                   ::builtin::spec_cast_integer::<_,
                                           nat>(((depth).spec_sub(::builtin::spec_literal_nat("1")))))
                           })
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn opt_rec_can_crop_head_records(ojr: Option<JournalRecord>,
                boundary_lsn: LSN, depth: nat) -> bool {
                ::builtin::decreases((depth,
                        ::builtin::spec_literal_nat("1")));
                match ojr {
                    None =>
                        ::builtin::spec_eq(depth, ::builtin::spec_literal_nat("0")),
                    Some(rec) => rec.can_crop_head_records(boundary_lsn, depth),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn crop_head_records(self, boundary_lsn: LSN, depth: nat)
                -> Option<JournalRecord> {
                ::builtin::recommends([self.can_crop_head_records(boundary_lsn,
                                depth)]);
                ::builtin::decreases((depth,
                        ::builtin::spec_literal_nat("0")));
                if ::builtin::spec_eq(depth, ::builtin::spec_literal_nat("0"))
                        {
                        Some(self)
                    } else {
                       Self::opt_rec_crop_head_records(self.cropped_prior(boundary_lsn),
                           boundary_lsn,
                           ::builtin::spec_cast_integer::<_,
                                   nat>(((depth).spec_sub(::builtin::spec_literal_nat("1")))))
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn opt_rec_crop_head_records(ojr: Option<JournalRecord>,
                boundary_lsn: LSN, depth: nat) -> Option<JournalRecord> {
                ::builtin::recommends([Self::opt_rec_can_crop_head_records(ojr,
                                boundary_lsn, depth)]);
                ::builtin::decreases((depth,
                        ::builtin::spec_literal_nat("1")));
                match ojr {
                    None => None,
                    Some(rec) => rec.crop_head_records(boundary_lsn, depth),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn crop_head_records_lemma(self, boundary_lsn: LSN,
                depth: nat) {
                ::builtin::requires([self.can_crop_head_records(boundary_lsn,
                                depth)]);
                ::builtin::ensures([({
                                    let out = self.crop_head_records(boundary_lsn, depth);
                                    ::builtin::imply(out.is_Some(),
                                        out.unwrap().valid(boundary_lsn))
                                })]);
                ::builtin::decreases((depth,
                        ::builtin::spec_literal_nat("0")));
                if !::builtin::spec_eq(depth,
                                ::builtin::spec_literal_nat("0")) {
                        Self::opt_rec_crop_head_records_lemma(self.cropped_prior(boundary_lsn),
                            boundary_lsn,
                            ::builtin::spec_cast_integer::<_,
                                    nat>(((depth).spec_sub(::builtin::spec_literal_nat("1")))));
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn opt_rec_crop_head_records_lemma(ojr: Option<JournalRecord>,
                boundary_lsn: LSN, depth: nat) {
                ::builtin::requires([Self::opt_rec_can_crop_head_records(ojr,
                                boundary_lsn, depth)]);
                ::builtin::ensures([({
                                    let out =
                                        Self::opt_rec_crop_head_records(ojr, boundary_lsn, depth);
                                    ::builtin::imply(out.is_Some(),
                                        out.unwrap().valid(boundary_lsn))
                                })]);
                ::builtin::decreases((depth,
                        ::builtin::spec_literal_nat("1")));
                match ojr {
                    None => {}
                    Some(rec) => {
                        if ojr.is_Some() {
                                rec.crop_head_records_lemma(boundary_lsn, depth);
                            }
                    }
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn opt_rec_crop_head_records_lemma_forall() {
                ::builtin::ensures([::builtin::forall(|ojr:
                                        Option<JournalRecord>, boundary_lsn: LSN, depth: nat|
                                    ::builtin::imply(Self::opt_rec_can_crop_head_records(ojr,
                                            boundary_lsn, depth),
                                        ::builtin::imply((#[verus::internal(trigger)] Self::opt_rec_crop_head_records(ojr,
                                                        boundary_lsn, depth)).is_Some(),
                                            Self::opt_rec_crop_head_records(ojr, boundary_lsn,
                                                        depth).unwrap().valid(boundary_lsn))))]);
                {
                    ::builtin::assert_forall_by(|ojr: Option<JournalRecord>,
                            boundary_lsn: LSN, depth: nat|
                            {
                                ::builtin::requires(Self::opt_rec_can_crop_head_records(ojr,
                                        boundary_lsn, depth));
                                ::builtin::ensures(::builtin::imply((#[verus::internal(trigger)] Self::opt_rec_crop_head_records(ojr,
                                                    boundary_lsn, depth)).is_Some(),
                                        Self::opt_rec_crop_head_records(ojr, boundary_lsn,
                                                    depth).unwrap().valid(boundary_lsn)));
                                Self::opt_rec_crop_head_records_lemma(ojr, boundary_lsn,
                                    depth);
                            });
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn can_crop_monotonic(self, boundary_lsn: LSN, depth: nat,
                more: nat) {
                ::builtin::requires([(depth).spec_lt(more),
                            self.can_crop_head_records(boundary_lsn, more)]);
                ::builtin::ensures([self.can_crop_head_records(boundary_lsn,
                                depth)]);
                ::builtin::decreases((depth));
                if (::builtin::spec_literal_nat("0")).spec_lt(depth) {
                        self.cropped_prior(boundary_lsn).get_Some_0().can_crop_monotonic(boundary_lsn,
                            ::builtin::spec_cast_integer::<_,
                                    nat>(((depth).spec_sub(::builtin::spec_literal_nat("1")))),
                            ::builtin::spec_cast_integer::<_,
                                    nat>(((more).spec_sub(::builtin::spec_literal_nat("1")))));
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn can_crop_more_yields_some(self, boundary_lsn: LSN,
                depth: nat, more: nat) {
                ::builtin::requires([::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        depth), more)),
                            self.can_crop_head_records(boundary_lsn, more)]);
                ::builtin::ensures([self.crop_head_records(boundary_lsn,
                                    depth).is_Some()]);
                ::builtin::decreases((depth));
                self.can_crop_monotonic(boundary_lsn, depth, more);
                if (::builtin::spec_literal_nat("0")).spec_lt(depth) {
                        ::builtin::assert_(Self::opt_rec_can_crop_head_records(self.cropped_prior(boundary_lsn),
                                boundary_lsn,
                                ::builtin::spec_cast_integer::<_,
                                        nat>(((more).spec_sub(::builtin::spec_literal_nat("1"))))));
                        self.cropped_prior(boundary_lsn).get_Some_0().can_crop_more_yields_some(boundary_lsn,
                            ::builtin::spec_cast_integer::<_,
                                    nat>(((depth).spec_sub(::builtin::spec_literal_nat("1")))),
                            ::builtin::spec_cast_integer::<_,
                                    nat>(((more).spec_sub(::builtin::spec_literal_nat("1")))));
                        ::builtin::assert_(Self::opt_rec_crop_head_records(self.cropped_prior(boundary_lsn),
                                    boundary_lsn,
                                    ::builtin::spec_cast_integer::<_,
                                            nat>(((depth).spec_sub(::builtin::spec_literal_nat("1"))))).is_Some());
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn message_seq_after_crop(self, boundary_lsn: LSN, depth: nat)
                -> MsgHistory {
                ::builtin::recommends([self.valid(boundary_lsn),
                            self.can_crop_head_records(boundary_lsn,
                                (depth).spec_add(::builtin::spec_literal_nat("1")))]);
                let chrms =
                    self.crop_head_records(boundary_lsn,
                                depth).get_Some_0().message_seq;
                let _ = spec_affirm(chrms.wf());
                chrms.maybe_discard_old(boundary_lsn)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn option_new_boundary_valid(ojr: Option<JournalRecord>,
                old_lsn: LSN, new_lsn: LSN) {
                ::builtin::requires([::builtin::imply(ojr.is_Some(),
                                ojr.unwrap().valid(old_lsn)),
                            ::builtin::imply(ojr.is_Some(),
                                (new_lsn).spec_lt(ojr.unwrap().message_seq.seq_end)),
                            (old_lsn).spec_le(new_lsn)]);
                ::builtin::ensures([::builtin::imply(ojr.is_Some(),
                                ojr.unwrap().valid(new_lsn))]);
                if ojr.is_Some() {
                        ojr.unwrap().new_boundary_valid(old_lsn, new_lsn);
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn discard_old_journal_rec(ojr: Option<JournalRecord>,
                lsn: LSN) -> Option<JournalRecord> {
                ::builtin::recommends([::builtin::imply(ojr.is_Some(),
                                ojr.unwrap().valid(lsn))]);
                ::builtin::decreases((ojr));
                match ojr {
                    None => None,
                    Some(rec) => {
                        let prior_rec =
                            if (rec.message_seq.seq_start).spec_le(lsn) {
                                    None
                                } else {
                                   Self::discard_old_journal_rec(*rec.prior_rec, lsn)
                               };
                        Some(JournalRecord {
                                message_seq: rec.message_seq,
                                prior_rec: Box::new(prior_rec),
                            })
                    }
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn discard_old_journal_rec_ensures(ojr: Option<JournalRecord>,
                lsn: LSN) {
                ::builtin::requires([::builtin::imply(ojr.is_Some(),
                                ojr.unwrap().valid(lsn))]);
                ::builtin::ensures([({
                                    let out = Self::discard_old_journal_rec(ojr, lsn);
                                    ::builtin::imply(out.is_Some(), out.unwrap().valid(lsn))
                                })]);
                ::builtin::decreases((ojr));
                match ojr {
                    None => {}
                    Some(rec) => {
                        if (lsn).spec_lt(rec.message_seq.seq_start) {
                                Self::discard_old_journal_rec_ensures(*rec.prior_rec, lsn);
                            }
                    }
                }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct TruncatedJournal {
            pub boundary_lsn: LSN,
            pub freshest_rec: Option<JournalRecord>,
        }
        #[verus::internal(verus_macro)]
        impl TruncatedJournal {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn prior(self) -> TruncatedJournal {
                ::builtin::recommends([self.freshest_rec.is_Some()]);
                TruncatedJournal {
                    boundary_lsn: self.boundary_lsn,
                    freshest_rec: *self.freshest_rec.unwrap().prior_rec,
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                ::builtin::imply(self.freshest_rec.is_Some(),
                    self.freshest_rec.unwrap().valid(self.boundary_lsn))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_empty(self) -> bool {
                ::builtin::recommends([self.wf()]);
                self.freshest_rec.is_None()
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn seq_end(self) -> LSN {
                ::builtin::recommends([self.wf()]);
                if self.freshest_rec.is_Some() {
                        self.freshest_rec.unwrap().message_seq.seq_end
                    } else { self.boundary_lsn }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn seq_start(self) -> LSN {
                ::builtin::recommends([self.wf()]);
                self.boundary_lsn
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_discard_to(self, lsn: LSN) -> bool {
                ::builtin::recommends([self.wf()]);
                ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(self.seq_start()),
                            lsn), self.seq_end()))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn discard_old_defn(self, lsn: LSN) -> TruncatedJournal {
                ::builtin::recommends([self.wf(), self.can_discard_to(lsn)]);
                TruncatedJournal {
                    boundary_lsn: lsn,
                    freshest_rec: if ::builtin::spec_eq(self.seq_end(), lsn) {
                            None
                        } else {
                           JournalRecord::discard_old_journal_rec(self.freshest_rec,
                               lsn)
                       },
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn has_messages_at_depth(self, msgs: MsgHistory, depth: nat)
                -> bool {
                ::builtin::recommends([self.wf(), msgs.wf()]);
                ((self.freshest_rec.is_Some()) &&
                            (self.freshest_rec.unwrap().can_crop_head_records(self.boundary_lsn,
                                    (depth).spec_add(::builtin::spec_literal_nat("1"))))) &&
                    (::builtin::spec_eq(self.freshest_rec.unwrap().message_seq_after_crop(self.boundary_lsn,
                                depth), msgs))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn append_record(self, msgs: MsgHistory) -> TruncatedJournal {
                ::builtin::recommends([self.wf(), msgs.wf()]);
                TruncatedJournal {
                    freshest_rec: Some(JournalRecord {
                            message_seq: msgs,
                            prior_rec: Box::new(self.freshest_rec),
                        }),
                    ..self
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_crop(self, depth: nat) -> bool {
                JournalRecord::opt_rec_can_crop_head_records(self.freshest_rec,
                    self.boundary_lsn, depth)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn crop_head_records(self, depth: nat) -> TruncatedJournal {
                ::builtin::recommends([self.can_crop(depth)]);
                TruncatedJournal {
                    freshest_rec: JournalRecord::opt_rec_crop_head_records(self.freshest_rec,
                        self.boundary_lsn, depth),
                    ..self
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn crop_head_records_ensures(self, depth: nat) {
                ::builtin::requires([self.wf(), self.can_crop(depth)]);
                ::builtin::ensures([self.crop_head_records(depth).wf()]);
                if (::builtin::spec_literal_nat("0")).spec_lt(depth) {
                        self.freshest_rec.unwrap().crop_head_records_lemma(self.boundary_lsn,
                            depth);
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn freeze_for_commit(self, frozen_journal: TruncatedJournal,
                depth: nat) -> bool {
                ::builtin::recommends([self.wf()]);
                (((frozen_journal.wf()) &&
                                    (JournalRecord::opt_rec_can_crop_head_records(self.freshest_rec,
                                            self.boundary_lsn, depth))) &&
                            (self.crop_head_records(depth).can_discard_to(frozen_journal.boundary_lsn)))
                    &&
                    (::builtin::spec_eq(frozen_journal,
                            self.crop_head_records(depth).discard_old_defn(frozen_journal.boundary_lsn)))
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn mkfs() -> TruncatedJournal {
            TruncatedJournal {
                boundary_lsn: ::builtin::spec_literal_integer("0"),
                freshest_rec: None,
            }
        }
        #[allow(unused_parens)]
        pub mod PagedJournal {
            use super::*;
            #[verus::internal(verus_macro)]
            pub struct State {
                pub truncated_journal: TruncatedJournal,
                pub unmarshalled_tail: MsgHistory,
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Step {
                read_for_recovery(nat),
                freeze_for_commit(nat),
                query_end_lsn(),
                put(),
                discard_old(),
                internal_journal_marshal(LSN),
                internal_no_op(),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Step {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_read_for_recovery(&self) -> bool {
                    ::builtin::is_variant(self, "read_for_recovery")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_read_for_recovery_0(self) -> nat {
                    ::builtin::get_variant_field(self, "read_for_recovery", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_freeze_for_commit(&self) -> bool {
                    ::builtin::is_variant(self, "freeze_for_commit")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_freeze_for_commit_0(self) -> nat {
                    ::builtin::get_variant_field(self, "freeze_for_commit", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_query_end_lsn(&self) -> bool {
                    ::builtin::is_variant(self, "query_end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_put(&self) -> bool {
                    ::builtin::is_variant(self, "put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_discard_old(&self) -> bool {
                    ::builtin::is_variant(self, "discard_old")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_internal_journal_marshal(&self) -> bool {
                    ::builtin::is_variant(self, "internal_journal_marshal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_journal_marshal_0(self) -> LSN {
                    ::builtin::get_variant_field(self,
                        "internal_journal_marshal", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_internal_no_op(&self) -> bool {
                    ::builtin::is_variant(self, "internal_no_op")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Config {
                initialize(TruncatedJournal),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Config {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_initialize(&self) -> bool {
                    ::builtin::is_variant(self, "initialize")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_initialize_0(self) -> TruncatedJournal {
                    ::builtin::get_variant_field(self, "initialize", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[verus::internal(verus_macro)]
            pub enum Label {
                ReadForRecovery {
                    messages: MsgHistory,
                },
                FreezeForCommit {
                    frozen_journal: TruncatedJournal,
                },
                QueryEndLsn {
                    end_lsn: LSN,
                },
                Put {
                    messages: MsgHistory,
                },
                DiscardOld {
                    start_lsn: LSN,
                    require_end: LSN,
                },
                Internal {},
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Label {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_ReadForRecovery(&self) -> bool {
                    ::builtin::is_variant(self, "ReadForRecovery")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_ReadForRecovery_messages(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "ReadForRecovery",
                        "messages")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_FreezeForCommit(&self) -> bool {
                    ::builtin::is_variant(self, "FreezeForCommit")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_FreezeForCommit_frozen_journal(self)
                    -> TruncatedJournal {
                    ::builtin::get_variant_field(self, "FreezeForCommit",
                        "frozen_journal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_QueryEndLsn(&self) -> bool {
                    ::builtin::is_variant(self, "QueryEndLsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_QueryEndLsn_end_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "QueryEndLsn", "end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_Put(&self) -> bool {
                    ::builtin::is_variant(self, "Put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_Put_messages(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "Put", "messages")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_DiscardOld(&self) -> bool {
                    ::builtin::is_variant(self, "DiscardOld")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_DiscardOld_start_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "DiscardOld",
                        "start_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_DiscardOld_require_end(self) -> LSN {
                    ::builtin::get_variant_field(self, "DiscardOld",
                        "require_end")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_Internal(&self) -> bool {
                    ::builtin::is_variant(self, "Internal")
                }
            }
            pub mod show {
                use super::*;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn read_for_recovery(pre: super::State,
                    post: super::State, lbl: Label, depth: nat) {
                    ::builtin::requires(super::State::read_for_recovery(pre,
                            post, lbl, depth));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as read_for_recovery;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn freeze_for_commit(pre: super::State,
                    post: super::State, lbl: Label, depth: nat) {
                    ::builtin::requires(super::State::freeze_for_commit(pre,
                            post, lbl, depth));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as freeze_for_commit;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn query_end_lsn(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::query_end_lsn(pre, post,
                            lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as query_end_lsn;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn put(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::put(pre, post, lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as put;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn discard_old(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::discard_old(pre, post,
                            lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as discard_old;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn internal_journal_marshal(pre: super::State,
                    post: super::State, lbl: Label, cut: LSN) {
                    ::builtin::requires(super::State::internal_journal_marshal(pre,
                            post, lbl, cut));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as internal_journal_marshal;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn internal_no_op(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::internal_no_op(pre, post,
                            lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as internal_no_op;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn initialize(post: super::State,
                    truncated_journal: TruncatedJournal) {
                    ::builtin::requires(super::State::initialize(post,
                            truncated_journal));
                    ::builtin::ensures(super::State::init(post));
                }
                use bool as initialize;
            }
            pub mod take_step {
                use super::*;
            }
            #[verus::internal(verus_macro)]
            impl State {
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn read_for_recovery(pre: Self, post: Self, lbl: Label,
                    depth: nat) -> ::core::primitive::bool {
                    {
                        let update_tmp_truncated_journal: TruncatedJournal =
                            pre.truncated_journal;
                        let update_tmp_unmarshalled_tail: MsgHistory =
                            pre.unmarshalled_tail;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_ReadForRecovery())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.get_ReadForRecovery_messages().wf())
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.truncated_journal.has_messages_at_depth(lbl.get_ReadForRecovery_messages(),
                                                                depth)) &&
                                                        (#[verifier::custom_err("cannot prove that the field `unmarshalled_tail` is preserved")] (::builtin::equal(post.unmarshalled_tail,
                                                                        update_tmp_unmarshalled_tail)) &&
                                                                #[verifier::custom_err("cannot prove that the field `truncated_journal` is preserved")] (::builtin::equal(post.truncated_journal,
                                                                        update_tmp_truncated_journal)))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn read_for_recovery_strong(pre: Self, post: Self,
                    lbl: Label, depth: nat) -> ::core::primitive::bool {
                    {
                        let update_tmp_truncated_journal: TruncatedJournal =
                            pre.truncated_journal;
                        let update_tmp_unmarshalled_tail: MsgHistory =
                            pre.unmarshalled_tail;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_ReadForRecovery())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.get_ReadForRecovery_messages().wf())
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.truncated_journal.has_messages_at_depth(lbl.get_ReadForRecovery_messages(),
                                                                depth)) &&
                                                        (#[verifier::custom_err("cannot prove that the field `unmarshalled_tail` is preserved")] (::builtin::equal(post.unmarshalled_tail,
                                                                        update_tmp_unmarshalled_tail)) &&
                                                                #[verifier::custom_err("cannot prove that the field `truncated_journal` is preserved")] (::builtin::equal(post.truncated_journal,
                                                                        update_tmp_truncated_journal)))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn read_for_recovery_enabled(pre: Self, lbl: Label,
                    depth: nat) -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_ReadForRecovery())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.get_ReadForRecovery_messages().wf())
                                                &&
                                                #[verifier::custom_err("cannot prove this condition holds")] (pre.truncated_journal.has_messages_at_depth(lbl.get_ReadForRecovery_messages(),
                                                        depth)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn freeze_for_commit(pre: Self, post: Self, lbl: Label,
                    depth: nat) -> ::core::primitive::bool {
                    {
                        let update_tmp_truncated_journal: TruncatedJournal =
                            pre.truncated_journal;
                        let update_tmp_unmarshalled_tail: MsgHistory =
                            pre.unmarshalled_tail;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_FreezeForCommit())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.truncated_journal.freeze_for_commit(lbl.get_FreezeForCommit_frozen_journal(),
                                                depth)) &&
                                        (#[verifier::custom_err("cannot prove that the field `unmarshalled_tail` is preserved")] (::builtin::equal(post.unmarshalled_tail,
                                                        update_tmp_unmarshalled_tail)) &&
                                                #[verifier::custom_err("cannot prove that the field `truncated_journal` is preserved")] (::builtin::equal(post.truncated_journal,
                                                        update_tmp_truncated_journal)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn freeze_for_commit_strong(pre: Self, post: Self,
                    lbl: Label, depth: nat) -> ::core::primitive::bool {
                    {
                        let update_tmp_truncated_journal: TruncatedJournal =
                            pre.truncated_journal;
                        let update_tmp_unmarshalled_tail: MsgHistory =
                            pre.unmarshalled_tail;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_FreezeForCommit())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.truncated_journal.freeze_for_commit(lbl.get_FreezeForCommit_frozen_journal(),
                                                depth)) &&
                                        (#[verifier::custom_err("cannot prove that the field `unmarshalled_tail` is preserved")] (::builtin::equal(post.unmarshalled_tail,
                                                        update_tmp_unmarshalled_tail)) &&
                                                #[verifier::custom_err("cannot prove that the field `truncated_journal` is preserved")] (::builtin::equal(post.truncated_journal,
                                                        update_tmp_truncated_journal)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn freeze_for_commit_enabled(pre: Self, lbl: Label,
                    depth: nat) -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_FreezeForCommit())
                                &&
                                #[verifier::custom_err("cannot prove this condition holds")] (pre.truncated_journal.freeze_for_commit(lbl.get_FreezeForCommit_frozen_journal(),
                                        depth)))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_end_lsn(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_truncated_journal: TruncatedJournal =
                            pre.truncated_journal;
                        let update_tmp_unmarshalled_tail: MsgHistory =
                            pre.unmarshalled_tail;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_QueryEndLsn())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(lbl.get_QueryEndLsn_end_lsn(),
                                                pre.seq_end())) &&
                                        (#[verifier::custom_err("cannot prove that the field `unmarshalled_tail` is preserved")] (::builtin::equal(post.unmarshalled_tail,
                                                        update_tmp_unmarshalled_tail)) &&
                                                #[verifier::custom_err("cannot prove that the field `truncated_journal` is preserved")] (::builtin::equal(post.truncated_journal,
                                                        update_tmp_truncated_journal)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_end_lsn_strong(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_truncated_journal: TruncatedJournal =
                            pre.truncated_journal;
                        let update_tmp_unmarshalled_tail: MsgHistory =
                            pre.unmarshalled_tail;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_QueryEndLsn())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(lbl.get_QueryEndLsn_end_lsn(),
                                                pre.seq_end())) &&
                                        (#[verifier::custom_err("cannot prove that the field `unmarshalled_tail` is preserved")] (::builtin::equal(post.unmarshalled_tail,
                                                        update_tmp_unmarshalled_tail)) &&
                                                #[verifier::custom_err("cannot prove that the field `truncated_journal` is preserved")] (::builtin::equal(post.truncated_journal,
                                                        update_tmp_truncated_journal)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_end_lsn_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_QueryEndLsn())
                                &&
                                #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(lbl.get_QueryEndLsn_end_lsn(),
                                        pre.seq_end())))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_truncated_journal: TruncatedJournal =
                            pre.truncated_journal;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_Put())
                                &&
                                (({
                                                let msgs = lbl.get_Put_messages();
                                                (#[verifier::custom_err("cannot prove this condition holds")] (msgs.wf())
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(msgs.seq_start,
                                                                        pre.seq_end())) &&
                                                                {
                                                                    let update_tmp_unmarshalled_tail: MsgHistory =
                                                                        pre.unmarshalled_tail.concat(msgs);

                                                                    #[verifier::custom_err("cannot prove that final value of field `unmarshalled_tail` has this updated value")]
                                                                    (::builtin::equal(post.unmarshalled_tail,
                                                                            update_tmp_unmarshalled_tail))
                                                                }))
                                            }) &&
                                        (#[verifier::custom_err("cannot prove that the field `truncated_journal` is preserved")] (::builtin::equal(post.truncated_journal,
                                                    update_tmp_truncated_journal)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put_strong(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_truncated_journal: TruncatedJournal =
                            pre.truncated_journal;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_Put())
                                &&
                                (({
                                                let msgs = lbl.get_Put_messages();
                                                (#[verifier::custom_err("cannot prove this condition holds")] (msgs.wf())
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(msgs.seq_start,
                                                                        pre.seq_end())) &&
                                                                {
                                                                    let update_tmp_unmarshalled_tail: MsgHistory =
                                                                        pre.unmarshalled_tail.concat(msgs);

                                                                    #[verifier::custom_err("cannot prove that final value of field `unmarshalled_tail` has this updated value")]
                                                                    (::builtin::equal(post.unmarshalled_tail,
                                                                            update_tmp_unmarshalled_tail))
                                                                }))
                                            }) &&
                                        (#[verifier::custom_err("cannot prove that the field `truncated_journal` is preserved")] (::builtin::equal(post.truncated_journal,
                                                    update_tmp_truncated_journal)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_Put())
                                &&
                                {
                                    let msgs = lbl.get_Put_messages();
                                    (#[verifier::custom_err("cannot prove this condition holds")] (msgs.wf())
                                            &&
                                            #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(msgs.seq_start,
                                                    pre.seq_end())))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn discard_old(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_DiscardOld())
                                &&
                                {
                                    let lsn = lbl.get_DiscardOld_start_lsn();
                                    (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(pre.seq_start()),
                                                            lsn), pre.seq_end()))) &&
                                            (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(pre.seq_end(),
                                                            lbl.get_DiscardOld_require_end())) &&
                                                    {
                                                        let update_tmp_unmarshalled_tail: MsgHistory =
                                                            if (pre.unmarshalled_tail.seq_start).spec_le(lsn) {
                                                                    pre.unmarshalled_tail.discard_old(lsn)
                                                                } else { pre.unmarshalled_tail };
                                                        let update_tmp_truncated_journal: TruncatedJournal =
                                                            if (pre.unmarshalled_tail.seq_start).spec_le(lsn) {
                                                                    TruncatedJournal { boundary_lsn: lsn, freshest_rec: None }
                                                                } else { pre.truncated_journal.discard_old_defn(lsn) };
                                                        (#[verifier::custom_err("cannot prove that final value of field `truncated_journal` has this updated value")] (::builtin::equal(post.truncated_journal,
                                                                        update_tmp_truncated_journal)) &&
                                                                #[verifier::custom_err("cannot prove that final value of field `unmarshalled_tail` has this updated value")] (::builtin::equal(post.unmarshalled_tail,
                                                                        update_tmp_unmarshalled_tail)))
                                                    }))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn discard_old_strong(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_DiscardOld())
                                &&
                                {
                                    let lsn = lbl.get_DiscardOld_start_lsn();
                                    (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(pre.seq_start()),
                                                            lsn), pre.seq_end()))) &&
                                            (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(pre.seq_end(),
                                                            lbl.get_DiscardOld_require_end())) &&
                                                    {
                                                        let update_tmp_unmarshalled_tail: MsgHistory =
                                                            if (pre.unmarshalled_tail.seq_start).spec_le(lsn) {
                                                                    pre.unmarshalled_tail.discard_old(lsn)
                                                                } else { pre.unmarshalled_tail };
                                                        let update_tmp_truncated_journal: TruncatedJournal =
                                                            if (pre.unmarshalled_tail.seq_start).spec_le(lsn) {
                                                                    TruncatedJournal { boundary_lsn: lsn, freshest_rec: None }
                                                                } else { pre.truncated_journal.discard_old_defn(lsn) };
                                                        (#[verifier::custom_err("cannot prove that final value of field `truncated_journal` has this updated value")] (::builtin::equal(post.truncated_journal,
                                                                        update_tmp_truncated_journal)) &&
                                                                #[verifier::custom_err("cannot prove that final value of field `unmarshalled_tail` has this updated value")] (::builtin::equal(post.unmarshalled_tail,
                                                                        update_tmp_unmarshalled_tail)))
                                                    }))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn discard_old_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_DiscardOld())
                                &&
                                {
                                    let lsn = lbl.get_DiscardOld_start_lsn();
                                    (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(pre.seq_start()),
                                                            lsn), pre.seq_end()))) &&
                                            #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(pre.seq_end(),
                                                    lbl.get_DiscardOld_require_end())))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_journal_marshal(pre: Self, post: Self,
                    lbl: Label, cut: LSN) -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_Internal())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] ((pre.unmarshalled_tail.seq_start).spec_lt(cut))
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.unmarshalled_tail.can_discard_to(cut))
                                                &&
                                                {
                                                    let marshalled_msgs =
                                                        pre.unmarshalled_tail.discard_recent(cut);
                                                    let update_tmp_truncated_journal: TruncatedJournal =
                                                        pre.truncated_journal.append_record(marshalled_msgs);
                                                    let update_tmp_unmarshalled_tail: MsgHistory =
                                                        pre.unmarshalled_tail.discard_old(cut);
                                                    (#[verifier::custom_err("cannot prove that final value of field `unmarshalled_tail` has this updated value")] (::builtin::equal(post.unmarshalled_tail,
                                                                    update_tmp_unmarshalled_tail)) &&
                                                            #[verifier::custom_err("cannot prove that final value of field `truncated_journal` has this updated value")] (::builtin::equal(post.truncated_journal,
                                                                    update_tmp_truncated_journal)))
                                                })))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_journal_marshal_strong(pre: Self, post: Self,
                    lbl: Label, cut: LSN) -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_Internal())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] ((pre.unmarshalled_tail.seq_start).spec_lt(cut))
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.unmarshalled_tail.can_discard_to(cut))
                                                &&
                                                {
                                                    let marshalled_msgs =
                                                        pre.unmarshalled_tail.discard_recent(cut);
                                                    let update_tmp_truncated_journal: TruncatedJournal =
                                                        pre.truncated_journal.append_record(marshalled_msgs);
                                                    let update_tmp_unmarshalled_tail: MsgHistory =
                                                        pre.unmarshalled_tail.discard_old(cut);
                                                    (#[verifier::custom_err("cannot prove that final value of field `unmarshalled_tail` has this updated value")] (::builtin::equal(post.unmarshalled_tail,
                                                                    update_tmp_unmarshalled_tail)) &&
                                                            #[verifier::custom_err("cannot prove that final value of field `truncated_journal` has this updated value")] (::builtin::equal(post.truncated_journal,
                                                                    update_tmp_truncated_journal)))
                                                })))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_journal_marshal_enabled(pre: Self, lbl: Label,
                    cut: LSN) -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_Internal())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] ((pre.unmarshalled_tail.seq_start).spec_lt(cut))
                                        &&
                                        #[verifier::custom_err("cannot prove this condition holds")] (pre.unmarshalled_tail.can_discard_to(cut))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_no_op(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_truncated_journal: TruncatedJournal =
                            pre.truncated_journal;
                        let update_tmp_unmarshalled_tail: MsgHistory =
                            pre.unmarshalled_tail;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_Internal())
                                &&
                                (#[verifier::custom_err("cannot prove that the field `unmarshalled_tail` is preserved")] (::builtin::equal(post.unmarshalled_tail,
                                                update_tmp_unmarshalled_tail)) &&
                                        #[verifier::custom_err("cannot prove that the field `truncated_journal` is preserved")] (::builtin::equal(post.truncated_journal,
                                                update_tmp_truncated_journal))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_no_op_strong(pre: Self, post: Self,
                    lbl: Label) -> ::core::primitive::bool {
                    {
                        let update_tmp_truncated_journal: TruncatedJournal =
                            pre.truncated_journal;
                        let update_tmp_unmarshalled_tail: MsgHistory =
                            pre.unmarshalled_tail;
                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_Internal())
                                &&
                                (#[verifier::custom_err("cannot prove that the field `unmarshalled_tail` is preserved")] (::builtin::equal(post.unmarshalled_tail,
                                                update_tmp_unmarshalled_tail)) &&
                                        #[verifier::custom_err("cannot prove that the field `truncated_journal` is preserved")] (::builtin::equal(post.truncated_journal,
                                                update_tmp_truncated_journal))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_no_op_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {

                        #[verifier::custom_err("cannot prove this condition holds")]
                        (lbl.is_Internal())
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn initialize(post: Self,
                    truncated_journal: TruncatedJournal)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (truncated_journal.wf())
                                &&
                                {
                                    let update_tmp_truncated_journal: TruncatedJournal =
                                        truncated_journal;
                                    let update_tmp_unmarshalled_tail: MsgHistory =
                                        MsgHistory::empty_history_at(truncated_journal.seq_end());
                                    (#[verifier::custom_err("cannot prove that final value of field `unmarshalled_tail` has this updated value")] (::builtin::equal(post.unmarshalled_tail,
                                                    update_tmp_unmarshalled_tail)) &&
                                            #[verifier::custom_err("cannot prove that final value of field `truncated_journal` has this updated value")] (::builtin::equal(post.truncated_journal,
                                                    update_tmp_truncated_journal)))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn initialize_enabled(truncated_journal: TruncatedJournal)
                    -> ::core::primitive::bool {
                    {

                        #[verifier::custom_err("cannot prove this condition holds")]
                        (truncated_journal.wf())
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_by(pre: State, post: State, label: Label,
                    step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::read_for_recovery(depth) =>
                            Self::read_for_recovery(pre, post, label, depth),
                        Step::freeze_for_commit(depth) =>
                            Self::freeze_for_commit(pre, post, label, depth),
                        Step::query_end_lsn() =>
                            Self::query_end_lsn(pre, post, label),
                        Step::put() => Self::put(pre, post, label),
                        Step::discard_old() => Self::discard_old(pre, post, label),
                        Step::internal_journal_marshal(cut) =>
                            Self::internal_journal_marshal(pre, post, label, cut),
                        Step::internal_no_op() =>
                            Self::internal_no_op(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next(pre: State, post: State, label: Label)
                    -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                            Self::next_by(pre, post, label, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_strong_by(pre: State, post: State, label: Label,
                    step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::read_for_recovery(depth) =>
                            Self::read_for_recovery_strong(pre, post, label, depth),
                        Step::freeze_for_commit(depth) =>
                            Self::freeze_for_commit_strong(pre, post, label, depth),
                        Step::query_end_lsn() =>
                            Self::query_end_lsn_strong(pre, post, label),
                        Step::put() => Self::put_strong(pre, post, label),
                        Step::discard_old() =>
                            Self::discard_old_strong(pre, post, label),
                        Step::internal_journal_marshal(cut) =>
                            Self::internal_journal_marshal_strong(pre, post, label,
                                cut),
                        Step::internal_no_op() =>
                            Self::internal_no_op_strong(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_strong(pre: State, post: State, label: Label)
                    -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                            Self::next_strong_by(pre, post, label, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn init_by(post: State, step: Config)
                    -> ::core::primitive::bool {
                    match step {
                        Config::initialize(truncated_journal) =>
                            Self::initialize(post, truncated_journal),
                        Config::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn init(post: State) -> ::core::primitive::bool {
                    ::builtin::exists(|step: Config| Self::init_by(post, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::spec]
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                pub fn invariant(&self) -> ::core::primitive::bool { true }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn wf(self) -> bool {
                    ((self.truncated_journal.wf()) &&
                                (self.unmarshalled_tail.wf())) &&
                        (::builtin::spec_eq(self.truncated_journal.seq_end(),
                                self.unmarshalled_tail.seq_start))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn seq_start(self) -> LSN {
                    ::builtin::recommends([self.wf()]);
                    self.truncated_journal.boundary_lsn
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn seq_end(self) -> LSN {
                    ::builtin::recommends([self.wf()]);
                    self.unmarshalled_tail.seq_end
                }
            }
        }
    }
    pub mod PagedJournalRefinement_v {
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use vstd::calc_macro::*;
        use vstd::prelude::*;
        use vstd::map::*;
        use vstd::seq_lib::*;
        use crate::abstract_system::StampedMap_v::LSN;
        use crate::abstract_system::MsgHistory_v::*;
        use crate::abstract_system::AbstractJournal_v::*;
        use crate::journal::PagedJournal_v::*;
        #[verus::internal(verus_macro)]
        impl JournalRecord {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn i(self, boundary_lsn: LSN) -> MsgHistory {
                ::builtin::recommends([self.wf()]);
                ::builtin::decreases((self));
                if self.message_seq.can_discard_to(boundary_lsn) {
                        self.message_seq.discard_old(boundary_lsn)
                    } else {
                       Self::i_opt(*self.prior_rec,
                               boundary_lsn).concat(self.message_seq)
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn i_opt(ojr: Option<Self>, boundary_lsn: LSN) -> MsgHistory {
                ::builtin::recommends([::builtin::imply(ojr.is_Some(),
                                ojr.unwrap().valid(boundary_lsn))]);
                ::builtin::decreases((ojr));
                match ojr {
                    None => MsgHistory::empty_history_at(boundary_lsn),
                    Some(rec) => rec.i(boundary_lsn),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn i_lemma(self, boundary_lsn: LSN) {
                ::builtin::requires([self.valid(boundary_lsn)]);
                ::builtin::ensures([({
                                    let out = self.i(boundary_lsn);
                                    ((out.wf()) &&
                                                (::builtin::spec_eq(out.seq_start, boundary_lsn))) &&
                                        (::builtin::equal(out.seq_end, self.message_seq.seq_end))
                                })]);
                ::builtin::decreases((self));
                if self.message_seq.can_discard_to(boundary_lsn)
                        {} else {
                       let ojr = *self.prior_rec;
                       match ojr {
                           None => {}
                           Some(rec) => { rec.i_lemma(boundary_lsn) }
                       }
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn i_lemma_forall() {
                ::builtin::ensures([::builtin::forall(|selff: Self,
                                    boundary_lsn: LSN|
                                    ::builtin::imply(selff.valid(boundary_lsn),
                                        ({
                                                let out = selff.i(boundary_lsn);
                                                ((out.wf()) &&
                                                            (::builtin::spec_eq(out.seq_start, boundary_lsn))) &&
                                                    (::builtin::equal(out.seq_end, selff.message_seq.seq_end))
                                            })))]);
                {
                    ::builtin::assert_forall_by(|selff: Self, boundary_lsn: LSN|
                            {
                                ::builtin::requires(selff.valid(boundary_lsn));
                                ::builtin::ensures(({
                                            let out = selff.i(boundary_lsn);
                                            ((out.wf()) &&
                                                        (::builtin::spec_eq(out.seq_start, boundary_lsn))) &&
                                                (::builtin::equal(out.seq_end, selff.message_seq.seq_end))
                                        }));
                                selff.i_lemma(boundary_lsn);
                            });
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn cant_crop(self, bdy: LSN, depth: nat) {
                ::builtin::requires([(::builtin::spec_literal_nat("0")).spec_lt(depth),
                            self.can_crop_head_records(bdy,
                                ::builtin::spec_cast_integer::<_,
                                        nat>(((depth).spec_sub(::builtin::spec_literal_nat("1"))))),
                            self.crop_head_records(bdy,
                                    ::builtin::spec_cast_integer::<_,
                                            nat>(((depth).spec_sub(::builtin::spec_literal_nat("1"))))).is_Some(),
                            self.crop_head_records(bdy,
                                            ::builtin::spec_cast_integer::<_,
                                                    nat>(((depth).spec_sub(::builtin::spec_literal_nat("1"))))).unwrap().message_seq.can_discard_to(bdy)]);
                ::builtin::ensures([!self.can_crop_head_records(bdy,
                                    (depth).spec_add(::builtin::spec_literal_nat("1")))]);
                ::builtin::decreases((depth));
                Self::opt_rec_crop_head_records_lemma_forall();
                if (::builtin::spec_literal_nat("1")).spec_lt(depth) {
                        self.cropped_prior(bdy).unwrap().cant_crop(bdy,
                            ::builtin::spec_cast_integer::<_,
                                    nat>(((depth).spec_sub(::builtin::spec_literal_nat("1")))));
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn crop_head_records_chaining(self, bdy: LSN, depth: nat) {
                ::builtin::requires([(::builtin::spec_literal_nat("0")).spec_lt(depth),
                            self.can_crop_head_records(bdy,
                                ::builtin::spec_cast_integer::<_,
                                        nat>(((depth).spec_sub(::builtin::spec_literal_nat("1"))))),
                            self.crop_head_records(bdy,
                                    ::builtin::spec_cast_integer::<_,
                                            nat>(((depth).spec_sub(::builtin::spec_literal_nat("1"))))).is_Some(),
                            self.can_crop_head_records(bdy, depth)]);
                ::builtin::ensures([::builtin::spec_eq(self.crop_head_records(bdy,
                                            ::builtin::spec_cast_integer::<_,
                                                    nat>(((depth).spec_sub(::builtin::spec_literal_nat("1"))))).unwrap().cropped_prior(bdy),
                                self.crop_head_records(bdy, depth))]);
                ::builtin::decreases((depth));
                Self::opt_rec_crop_head_records_lemma_forall();
                if (::builtin::spec_literal_nat("1")).spec_lt(depth) {
                        self.cropped_prior(bdy).unwrap().crop_head_records_chaining(bdy,
                            ::builtin::spec_cast_integer::<_,
                                    nat>(((depth).spec_sub(::builtin::spec_literal_nat("1")))));
                        ::builtin::assert_(::builtin::spec_eq(self.crop_head_records(bdy,
                                    depth),
                                Self::opt_rec_crop_head_records(self.cropped_prior(bdy),
                                    bdy,
                                    ::builtin::spec_cast_integer::<_,
                                            nat>(((depth).spec_sub(::builtin::spec_literal_nat("1")))))));
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn cropped_subseq_in_interpretation(self, bdy: LSN,
                depth: nat, msgs: MsgHistory) {
                ::builtin::requires([msgs.wf(),
                            self.can_crop_head_records(bdy,
                                (depth).spec_add(::builtin::spec_literal_nat("1"))),
                            self.can_crop_head_records(bdy, depth),
                            self.crop_head_records(bdy, depth).is_Some(),
                            self.crop_head_records(bdy,
                                            depth).unwrap().i(bdy).includes_subseq(msgs)]);
                ::builtin::ensures([::builtin::imply((::builtin::spec_literal_nat("0")).spec_lt(depth),
                                self.can_crop_head_records(bdy,
                                    ::builtin::spec_cast_integer::<_,
                                            nat>(((depth).spec_sub(::builtin::spec_literal_nat("1")))))),
                            self.crop_head_records(bdy,
                                            ::builtin::spec_literal_integer("0")).unwrap().i(bdy).includes_subseq(msgs)]);
                ::builtin::decreases((depth));
                Self::i_lemma_forall();
                if (::builtin::spec_literal_nat("0")).spec_lt(depth) {
                        self.can_crop_monotonic(bdy,
                            ::builtin::spec_cast_integer::<_,
                                    nat>(((depth).spec_sub(::builtin::spec_literal_nat("1")))),
                            depth);
                        self.can_crop_more_yields_some(bdy,
                            ::builtin::spec_cast_integer::<_,
                                    nat>(((depth).spec_sub(::builtin::spec_literal_nat("1")))),
                            depth);
                        let self_pre =
                            self.crop_head_records(bdy,
                                    ::builtin::spec_cast_integer::<_,
                                            nat>(((depth).spec_sub(::builtin::spec_literal_nat("1"))))).unwrap();
                        {
                            ::builtin::assert_by(!self_pre.message_seq.can_discard_to(bdy),
                                {
                                    if self_pre.message_seq.can_discard_to(bdy) {
                                            self.cant_crop(bdy, depth);
                                            ::builtin::assert_(false);
                                        }
                                });
                        }
                        self.crop_head_records_chaining(bdy, depth);
                        self.crop_head_records_lemma(bdy,
                            ::builtin::spec_cast_integer::<_,
                                    nat>(((depth).spec_sub(::builtin::spec_literal_nat("1")))));
                        self.cropped_subseq_in_interpretation(bdy,
                            ::builtin::spec_cast_integer::<_,
                                    nat>(((depth).spec_sub(::builtin::spec_literal_nat("1")))),
                            msgs);
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn can_cut_more(ojr: Option<JournalRecord>, bdy: LSN,
                depth: nat) {
                ::builtin::requires([(::builtin::spec_literal_nat("0")).spec_lt(depth),
                            Self::opt_rec_can_crop_head_records(ojr, bdy, depth)]);
                ::builtin::ensures([Self::opt_rec_can_crop_head_records(ojr,
                                bdy,
                                ::builtin::spec_cast_integer::<_,
                                        nat>(((depth).spec_sub(::builtin::spec_literal_nat("1"))))),
                            Self::opt_rec_can_crop_head_records(Self::opt_rec_crop_head_records(ojr,
                                    bdy,
                                    ::builtin::spec_cast_integer::<_,
                                            nat>(((depth).spec_sub(::builtin::spec_literal_nat("1"))))),
                                bdy, ::builtin::spec_literal_integer("1"))]);
                ::builtin::decreases((depth));
                if (::builtin::spec_literal_nat("1")).spec_lt(depth) {
                        ::builtin::assert_(ojr.unwrap().can_crop_head_records(bdy,
                                depth));
                        Self::can_cut_more(*ojr.unwrap().prior_rec, bdy,
                            ::builtin::spec_cast_integer::<_,
                                    nat>(((depth).spec_sub(::builtin::spec_literal_nat("1")))));
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn crop_equivalence(ojr: Option<JournalRecord>, bdy: LSN,
                depth: nat) {
                ::builtin::requires([(::builtin::spec_literal_nat("0")).spec_lt(depth),
                            ::builtin::imply(ojr.is_Some(), ojr.unwrap().valid(bdy)),
                            Self::opt_rec_can_crop_head_records(ojr, bdy,
                                ::builtin::spec_cast_integer::<_,
                                        nat>(((depth).spec_sub(::builtin::spec_literal_nat("1"))))),
                            Self::opt_rec_can_crop_head_records(ojr, bdy, depth)]);
                ::builtin::ensures([Self::opt_rec_can_crop_head_records(Self::opt_rec_crop_head_records(ojr,
                                    bdy,
                                    ::builtin::spec_cast_integer::<_,
                                            nat>(((depth).spec_sub(::builtin::spec_literal_nat("1"))))),
                                bdy, ::builtin::spec_literal_integer("1")),
                            ::builtin::spec_eq(Self::opt_rec_crop_head_records(ojr, bdy,
                                    depth),
                                Self::opt_rec_crop_head_records(Self::opt_rec_crop_head_records(ojr,
                                        bdy,
                                        ::builtin::spec_cast_integer::<_,
                                                nat>(((depth).spec_sub(::builtin::spec_literal_nat("1"))))),
                                    bdy, ::builtin::spec_literal_integer("1")))]);
                ::builtin::decreases((depth));
                if (::builtin::spec_literal_nat("1")).spec_lt(depth) {
                        Self::can_cut_more(ojr, bdy, depth);
                        ojr.unwrap().can_crop_more_yields_some(bdy,
                            ::builtin::spec_cast_integer::<_,
                                    nat>(((depth).spec_sub(::builtin::spec_literal_nat("1")))),
                            depth);
                        Self::crop_equivalence(*ojr.unwrap().prior_rec, bdy,
                            ::builtin::spec_cast_integer::<_,
                                    nat>(((depth).spec_sub(::builtin::spec_literal_nat("1")))));
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn discard_old_maintains_subseq(ojr: Option<JournalRecord>,
                old_bdy: LSN, new_bdy: LSN) {
                ::builtin::requires([(old_bdy).spec_le(new_bdy),
                            ::builtin::imply(ojr.is_None(),
                                ::builtin::spec_eq(new_bdy, old_bdy)),
                            ::builtin::imply(ojr.is_Some(),
                                (new_bdy).spec_lt(ojr.unwrap().message_seq.seq_end)),
                            ::builtin::imply(ojr.is_Some(),
                                ojr.unwrap().valid(old_bdy))]);
                ::builtin::ensures([::builtin::imply(ojr.is_Some(),
                                ojr.unwrap().valid(new_bdy)),
                            Self::i_opt(ojr,
                                    old_bdy).includes_subseq(Self::i_opt(Self::discard_old_journal_rec(ojr,
                                        new_bdy), new_bdy))]);
                ::builtin::decreases((ojr));
                Self::i_lemma_forall();
                Self::option_new_boundary_valid(ojr, old_bdy, new_bdy);
                if ojr.is_Some() &&
                            (new_bdy).spec_lt(ojr.unwrap().message_seq.seq_start) {
                        Self::discard_old_maintains_subseq(*ojr.unwrap().prior_rec,
                            old_bdy, new_bdy);
                        let prior = *ojr.unwrap().prior_rec;
                        Self::discard_old_journal_rec_ensures(prior, new_bdy);
                        let priornew =
                            Self::i_opt(Self::discard_old_journal_rec(prior, new_bdy),
                                new_bdy);
                        priornew.concat_lemma(ojr.unwrap().message_seq);
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn crop_head_maintains_subseq(ojr: Option<JournalRecord>,
                bdy: LSN, depth: nat) {
                ::builtin::requires([::builtin::imply(ojr.is_Some(),
                                ojr.unwrap().valid(bdy)),
                            Self::opt_rec_can_crop_head_records(ojr, bdy, depth)]);
                ::builtin::ensures([Self::i_opt(ojr,
                                    bdy).includes_subseq(Self::i_opt(Self::opt_rec_crop_head_records(ojr,
                                        bdy, depth), bdy))]);
                ::builtin::decreases((depth));
                if (depth).spec_gt(::builtin::spec_literal_nat("0")) {
                        ojr.unwrap().can_crop_monotonic(bdy,
                            ::builtin::spec_cast_integer::<_,
                                    nat>(((depth).spec_sub(::builtin::spec_literal_nat("1")))),
                            depth);
                        Self::crop_head_maintains_subseq(ojr, bdy,
                            ::builtin::spec_cast_integer::<_,
                                    nat>(((depth).spec_sub(::builtin::spec_literal_nat("1")))));
                        let small =
                            Self::opt_rec_crop_head_records(ojr, bdy,
                                ::builtin::spec_cast_integer::<_,
                                        nat>(((depth).spec_sub(::builtin::spec_literal_nat("1")))));
                        let smaller =
                            Self::opt_rec_crop_head_records(ojr, bdy, depth);
                        Self::crop_equivalence(ojr, bdy, depth);
                        Self::i_lemma_forall();
                        ::builtin::assert_(::builtin::spec_eq(small.unwrap().crop_head_records(bdy,
                                    ::builtin::spec_literal_integer("1")),
                                Self::opt_rec_crop_head_records(small.unwrap().cropped_prior(bdy),
                                    bdy, ::builtin::spec_literal_integer("0"))));
                        ::builtin::assert_(Self::i_opt(small,
                                    bdy).includes_subseq(Self::i_opt(smaller, bdy)));
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn discard_old_defn_interprets(ojr: Option<JournalRecord>,
                old_lsn: LSN, new_lsn: LSN) {
                ::builtin::requires([::builtin::imply(ojr.is_Some(),
                                ojr.unwrap().valid(old_lsn)),
                            ::builtin::imply(ojr.is_Some(),
                                ojr.unwrap().valid(new_lsn)),
                            Self::i_opt(ojr, old_lsn).can_discard_to(new_lsn)]);
                ::builtin::ensures([::builtin::spec_eq(Self::i_opt(Self::discard_old_journal_rec(ojr,
                                        new_lsn), new_lsn),
                                Self::i_opt(ojr, old_lsn).discard_old(new_lsn))]);
                ::builtin::decreases((ojr));
                if ojr.is_Some() {
                        if ojr.is_Some() &&
                                    (new_lsn).spec_lt(ojr.unwrap().message_seq.seq_start) {
                                Self::discard_old_defn_interprets(*ojr.unwrap().prior_rec,
                                    old_lsn, new_lsn);
                                (*ojr.unwrap().prior_rec).unwrap().i_lemma(old_lsn);
                            }
                    }
                #[verifier::spec]
                let m1 =
                    ::vstd::map::check_argument_is_map(Self::i_opt(Self::discard_old_journal_rec(ojr,
                                    new_lsn), new_lsn).msgs);
                #[verifier::spec]
                let m2 =
                    ::vstd::map::check_argument_is_map(Self::i_opt(ojr,
                                    old_lsn).discard_old(new_lsn).msgs);
                ::builtin::assert_by(::builtin::equal(m1, m2),
                    {
                        ::builtin::assert_forall_by(|key|
                                {
                                    ::builtin::ensures([::builtin::imply(#[verifier::trigger] m1.dom().contains(key),
                                                            m2.dom().contains(key)) &&
                                                        ::builtin::imply(m2.dom().contains(key),
                                                            m1.dom().contains(key)) &&
                                                    ::builtin::imply(m1.dom().contains(key) &&
                                                            m2.dom().contains(key),
                                                        ::builtin::equal(m1.index(key), m2.index(key)))]);
                                    { {} }
                                });
                        ::builtin::assert_(::builtin::ext_equal(m1, m2));
                    });
                ;
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn discard_valid(self, old_lsn: LSN, new_lsn: LSN) {
                ::builtin::requires([self.valid(old_lsn),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(old_lsn),
                                        new_lsn), self.message_seq.seq_end))]);
                ::builtin::ensures([self.valid(new_lsn)]);
                ::builtin::decreases((self));
                if !self.message_seq.can_discard_to(new_lsn) {
                        self.prior_rec.unwrap().discard_valid(old_lsn, new_lsn);
                    }
            }
        }
        #[verus::internal(verus_macro)]
        impl TruncatedJournal {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> MsgHistory {
                ::builtin::recommends([self.wf()]);
                JournalRecord::i_opt(self.freshest_rec, self.boundary_lsn)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn crop_head_records_wf_lemma(self, depth: nat) {
                ::builtin::requires([JournalRecord::opt_rec_can_crop_head_records(self.freshest_rec,
                                self.boundary_lsn, depth)]);
                ::builtin::ensures([self.crop_head_records(depth).wf()]);
                JournalRecord::opt_rec_crop_head_records_lemma(self.freshest_rec,
                    self.boundary_lsn, depth);
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn tj_freeze_for_commit(self, frozen: TruncatedJournal,
                depth: nat) {
                ::builtin::requires([self.wf(),
                            self.freeze_for_commit(frozen, depth)]);
                ::builtin::ensures([self.i().includes_subseq(frozen.i())]);
                let ctj = self.crop_head_records(depth);
                if ctj.freshest_rec.is_Some() &&
                            (frozen.boundary_lsn).spec_lt(ctj.freshest_rec.unwrap().message_seq.seq_end)
                        {
                        self.freshest_rec.unwrap().crop_head_records_lemma(self.boundary_lsn,
                            depth);
                        JournalRecord::discard_old_maintains_subseq(ctj.freshest_rec,
                            ctj.boundary_lsn, frozen.boundary_lsn);
                    }
                JournalRecord::i_lemma_forall();
                JournalRecord::crop_head_maintains_subseq(self.freshest_rec,
                    self.boundary_lsn, depth);
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn discard_old_defn_wf(self, lsn: LSN) {
                ::builtin::requires([self.wf(), self.can_discard_to(lsn)]);
                ::builtin::ensures([self.discard_old_defn(lsn).wf()]);
                if !::builtin::spec_eq(lsn, self.seq_end()) {
                        if self.freshest_rec.is_Some() {
                                let rec = self.freshest_rec.unwrap();
                                rec.discard_valid(self.boundary_lsn, lsn);
                                JournalRecord::discard_old_journal_rec_ensures(self.freshest_rec,
                                    lsn);
                            }
                    }
            }
        }
        #[verus::internal(verus_macro)]
        impl PagedJournal::Label {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                match self {
                    PagedJournal::Label::FreezeForCommit { frozen_journal } =>
                        frozen_journal.wf(),
                    _ => true,
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> AbstractJournal::Label {
                ::builtin::recommends([self.wf()]);
                match self {
                    PagedJournal::Label::ReadForRecovery { messages } =>
                        AbstractJournal::Label::ReadForRecoveryLabel { messages },
                    PagedJournal::Label::FreezeForCommit { frozen_journal } =>
                        AbstractJournal::Label::FreezeForCommitLabel {
                            frozen_journal: frozen_journal.i(),
                        },
                    PagedJournal::Label::QueryEndLsn { end_lsn } =>
                        AbstractJournal::Label::QueryEndLsnLabel { end_lsn },
                    PagedJournal::Label::Put { messages } =>
                        AbstractJournal::Label::PutLabel { messages },
                    PagedJournal::Label::DiscardOld { start_lsn, require_end }
                        =>
                        AbstractJournal::Label::DiscardOldLabel {
                            start_lsn,
                            require_end,
                        },
                    PagedJournal::Label::Internal {} =>
                        AbstractJournal::Label::InternalLabel {},
                }
            }
        }
        #[verus::internal(verus_macro)]
        impl PagedJournal::State {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> AbstractJournal::State {
                ::builtin::recommends([self.wf()]);
                AbstractJournal::State {
                    journal: self.truncated_journal.i().concat(self.unmarshalled_tail),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn read_for_recovery_refines(self, post: Self,
                lbl: PagedJournal::Label, depth: nat) {
                ::builtin::requires([self.wf(),
                            PagedJournal::State::read_for_recovery(self, post, lbl,
                                depth)]);
                ::builtin::ensures([post.wf(),
                            AbstractJournal::State::next(self.i(), post.i(), lbl.i())]);
                JournalRecord::i_lemma_forall();
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(AbstractJournal::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(AbstractJournal::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                let ojr = self.truncated_journal.freshest_rec;
                let bdy = self.truncated_journal.boundary_lsn;
                let msgs = lbl.get_ReadForRecovery_messages();
                if ojr.is_Some() {
                        ojr.unwrap().can_crop_monotonic(bdy, depth,
                            (depth).spec_add(::builtin::spec_literal_nat("1")));
                        ojr.unwrap().can_crop_more_yields_some(bdy, depth,
                            (depth).spec_add(::builtin::spec_literal_nat("1")));
                        ojr.unwrap().crop_head_records_lemma(bdy, depth);
                        ojr.unwrap().cropped_subseq_in_interpretation(bdy, depth,
                            msgs);
                        ojr.unwrap().i(bdy).concat_lemma(self.unmarshalled_tail);
                    }
                ::builtin::assert_(AbstractJournal::State::next_by(self.i(),
                        post.i(), lbl.i(),
                        AbstractJournal::Step::read_for_recovery()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn freeze_for_commit_refines(self, post: Self,
                lbl: PagedJournal::Label, depth: nat) {
                ::builtin::requires([self.wf(),
                            PagedJournal::State::freeze_for_commit(self, post, lbl,
                                depth)]);
                ::builtin::ensures([post.wf(),
                            AbstractJournal::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(AbstractJournal::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(AbstractJournal::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                self.truncated_journal.tj_freeze_for_commit(lbl.get_FreezeForCommit_frozen_journal(),
                    depth);
                JournalRecord::i_lemma_forall();
                self.truncated_journal.i().concat_lemma(self.unmarshalled_tail);
                ::builtin::assert_(AbstractJournal::State::next_by(self.i(),
                        post.i(), lbl.i(),
                        AbstractJournal::Step::freeze_for_commit()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn discard_old_refines(self, post: Self,
                lbl: PagedJournal::Label) {
                ::builtin::requires([self.wf(),
                            PagedJournal::State::discard_old(self, post, lbl)]);
                ::builtin::ensures([post.wf(),
                            AbstractJournal::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(AbstractJournal::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(AbstractJournal::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                JournalRecord::i_lemma_forall();
                let lsn = lbl.get_DiscardOld_start_lsn();
                let tj = self.truncated_journal;
                if (lsn).spec_lt(self.unmarshalled_tail.seq_start) {
                        if tj.freshest_rec.is_Some() && (lsn).spec_lt(tj.seq_end())
                                {
                                tj.freshest_rec.unwrap().discard_valid(tj.boundary_lsn,
                                    lsn);
                                tj.discard_old_defn_wf(lsn);
                            }
                        JournalRecord::discard_old_defn_interprets(tj.freshest_rec,
                            tj.boundary_lsn, lsn);
                    }
                #[verifier::spec]
                let m1 =
                    ::vstd::map::check_argument_is_map(post.i().journal.msgs);
                #[verifier::spec]
                let m2 =
                    ::vstd::map::check_argument_is_map(self.i().journal.discard_old(lbl.i().get_DiscardOldLabel_start_lsn()).msgs);
                ::builtin::assert_by(::builtin::equal(m1, m2),
                    {
                        ::builtin::assert_forall_by(|key|
                                {
                                    ::builtin::ensures([::builtin::imply(#[verifier::trigger] m1.dom().contains(key),
                                                            m2.dom().contains(key)) &&
                                                        ::builtin::imply(m2.dom().contains(key),
                                                            m1.dom().contains(key)) &&
                                                    ::builtin::imply(m1.dom().contains(key) &&
                                                            m2.dom().contains(key),
                                                        ::builtin::equal(m1.index(key), m2.index(key)))]);
                                    { {} }
                                });
                        ::builtin::assert_(::builtin::ext_equal(m1, m2));
                    });
                ;
                ::builtin::assert_(AbstractJournal::State::next_by(self.i(),
                        post.i(), lbl.i(), AbstractJournal::Step::discard_old()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn marshall_refines(self, post: Self,
                lbl: PagedJournal::Label, cut: LSN) {
                ::builtin::requires([self.wf(),
                            PagedJournal::State::internal_journal_marshal(self, post,
                                lbl, cut)]);
                ::builtin::ensures([post.wf(),
                            AbstractJournal::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(AbstractJournal::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(AbstractJournal::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                #[verifier::spec]
                let m1 =
                    ::vstd::map::check_argument_is_map(post.i().journal.msgs);
                #[verifier::spec]
                let m2 =
                    ::vstd::map::check_argument_is_map(self.i().journal.msgs);
                ::builtin::assert_by(::builtin::equal(m1, m2),
                    {
                        ::builtin::assert_forall_by(|key|
                                {
                                    ::builtin::ensures([::builtin::imply(#[verifier::trigger] m1.dom().contains(key),
                                                            m2.dom().contains(key)) &&
                                                        ::builtin::imply(m2.dom().contains(key),
                                                            m1.dom().contains(key)) &&
                                                    ::builtin::imply(m1.dom().contains(key) &&
                                                            m2.dom().contains(key),
                                                        ::builtin::equal(m1.index(key), m2.index(key)))]);
                                    { {} }
                                });
                        ::builtin::assert_(::builtin::ext_equal(m1, m2));
                    });
                ;
                JournalRecord::i_lemma_forall();
                ::builtin::assert_(AbstractJournal::State::next_by(self.i(),
                        post.i(), lbl.i(), AbstractJournal::Step::internal()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn next_refines(self, post: Self, lbl: PagedJournal::Label,
                step: PagedJournal::Step) {
                ::builtin::requires([self.wf(),
                            PagedJournal::State::next_by(self, post, lbl, step)]);
                ::builtin::ensures([post.wf(),
                            AbstractJournal::State::next(self.i(), post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PagedJournal::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PagedJournal::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(AbstractJournal::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(AbstractJournal::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(AbstractJournal::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                JournalRecord::i_lemma_forall();
                match step {
                    PagedJournal::Step::read_for_recovery(depth) => {
                        self.read_for_recovery_refines(post, lbl, depth);
                    }
                    PagedJournal::Step::freeze_for_commit(depth) => {
                        self.freeze_for_commit_refines(post, lbl, depth);
                    }
                    PagedJournal::Step::query_end_lsn() => {
                        ::builtin::assert_(AbstractJournal::State::next_by(self.i(),
                                post.i(), lbl.i(),
                                AbstractJournal::Step::observe_fresh_journal()));
                    }
                    PagedJournal::Step::put() => {
                        #[verifier::spec]
                        let m1 =
                            ::vstd::map::check_argument_is_map(post.i().journal.msgs);
                        #[verifier::spec]
                        let m2 =
                            ::vstd::map::check_argument_is_map(self.i().journal.concat(lbl.i().get_PutLabel_messages()).msgs);
                        ::builtin::assert_by(::builtin::equal(m1, m2),
                            {
                                ::builtin::assert_forall_by(|key|
                                        {
                                            ::builtin::ensures([::builtin::imply(#[verifier::trigger] m1.dom().contains(key),
                                                                    m2.dom().contains(key)) &&
                                                                ::builtin::imply(m2.dom().contains(key),
                                                                    m1.dom().contains(key)) &&
                                                            ::builtin::imply(m1.dom().contains(key) &&
                                                                    m2.dom().contains(key),
                                                                ::builtin::equal(m1.index(key), m2.index(key)))]);
                                            { {} }
                                        });
                                ::builtin::assert_(::builtin::ext_equal(m1, m2));
                            });
                        ;
                        ::builtin::assert_(AbstractJournal::State::next_by(self.i(),
                                post.i(), lbl.i(), AbstractJournal::Step::put()));
                    }
                    PagedJournal::Step::discard_old() => {
                        self.discard_old_refines(post, lbl);
                    }
                    PagedJournal::Step::internal_journal_marshal(cut) => {
                        self.marshall_refines(post, lbl, cut);
                    }
                    PagedJournal::Step::internal_no_op() => {
                        ::builtin::assert_(AbstractJournal::State::next_by(self.i(),
                                post.i(), lbl.i(), AbstractJournal::Step::internal()));
                    }
                    _ => { ::builtin::assert_(false); }
                }
            }
        }
    }
    pub mod LinkedJournal_v {
        #![allow(unused_imports)]
        use builtin::*;
        use vstd::prelude::*;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        use vstd::prelude::*;
        use vstd::map::*;
        use vstd::math;
        use crate::abstract_system::StampedMap_v::LSN;
        use crate::abstract_system::MsgHistory_v::*;
        use crate::disk::GenericDisk_v::*;
        use crate::journal::PagedJournal_v;
        use crate::journal::PagedJournal_v::PagedJournal;
        #[verus::internal(verus_macro)]
        pub struct JournalRecord {
            pub message_seq: MsgHistory,
            pub prior_rec: Pointer,
        }
        #[verus::internal(verus_macro)]
        impl JournalRecord {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                (self.message_seq.wf()) && (!self.message_seq.is_empty())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn has_link(self, boundary_lsn: LSN) -> bool {
                ::builtin::imply((boundary_lsn).spec_lt(self.message_seq.seq_start),
                    self.cropped_prior(boundary_lsn).is_Some())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn cropped_prior(self, boundary_lsn: LSN) -> Pointer {
                if (boundary_lsn).spec_lt(self.message_seq.seq_start) {
                        self.prior_rec
                    } else { None }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn contains_lsn(self, boundary_lsn: LSN, lsn: LSN) -> bool {
                ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_cast_integer::<_,
                                        nat>(math::max(::builtin::spec_cast_integer::<_,
                                                int>(self.message_seq.seq_start),
                                        ::builtin::spec_cast_integer::<_, int>(boundary_lsn)))),
                            lsn), self.message_seq.seq_end))
            }
        }
        #[verus::internal(verus_macro)]
        pub struct DiskView {
            pub boundary_lsn: LSN,
            pub entries: Map<Address, JournalRecord>,
        }
        #[verus::internal(verus_macro)]
        impl DiskView {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn entries_wf(self) -> bool {
                ::builtin::forall(|addr|
                        ::builtin::imply(#[verus::internal(trigger)] self.entries.contains_key(addr),
                            self.entries.spec_index(addr).wf()))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_nondangling_pointer(self, ptr: Pointer) -> bool {
                ::builtin::imply(ptr.is_Some(),
                    self.entries.contains_key(ptr.unwrap()))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn nondangling_pointers(self) -> bool {
                ::builtin::forall(|addr|
                        ::builtin::imply(#[verus::internal(trigger)] self.entries.contains_key(addr),
                            self.is_nondangling_pointer(self.entries.spec_index(addr).cropped_prior(self.boundary_lsn))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn this_block_can_concat(self, addr: Address) -> bool {
                ::builtin::recommends([self.entries_wf(),
                            self.nondangling_pointers(),
                            self.entries.contains_key(addr)]);
                let head = self.entries.spec_index(addr);
                let next_ptr = head.cropped_prior(self.boundary_lsn);
                ::builtin::imply(next_ptr.is_Some(),
                    self.entries.spec_index(next_ptr.unwrap()).message_seq.can_concat(head.message_seq))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn blocks_can_concat(self) -> bool {
                ::builtin::recommends([self.entries_wf(),
                            self.nondangling_pointers()]);
                ::builtin::forall(|addr|
                        ::builtin::imply(#[verus::internal(trigger)] self.entries.contains_key(addr),
                            self.this_block_can_concat(addr)))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn blocks_each_have_link(self) -> bool {
                ::builtin::forall(|addr|
                        ::builtin::imply(#[verus::internal(trigger)] self.entries.contains_key(addr),
                            self.entries.spec_index(addr).has_link(self.boundary_lsn)))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn block_in_bounds(self, ptr: Pointer) -> bool {
                (self.is_nondangling_pointer(ptr)) &&
                    ((::builtin::imply(ptr.is_Some(),
                                (self.boundary_lsn).spec_lt(self.entries.spec_index(ptr.unwrap()).message_seq.seq_end))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                (((self.entries_wf()) && (self.nondangling_pointers())) &&
                            (self.blocks_can_concat())) &&
                    (self.blocks_each_have_link())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid_ranking(self, ranking: Ranking) -> bool {
                ::builtin::recommends([self.wf()]);
                (self.entries.dom().subset_of(ranking.dom())) &&
                    ((::builtin::forall(|addr|
                                    ::builtin::imply(#[verus::internal(trigger)] self.entries.contains_key(addr)
                                            &&
                                            self.entries.spec_index(addr).cropped_prior(self.boundary_lsn).is_Some(),
                                        (ranking.spec_index(self.entries.spec_index(addr).cropped_prior(self.boundary_lsn).unwrap())).spec_lt(ranking.spec_index(addr))))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn acyclic(self) -> bool {
                ::builtin::recommends([self.wf()]);
                ::builtin::exists(|ranking| self.valid_ranking(ranking))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn the_ranking(self) -> Ranking {
                ::builtin::recommends([self.wf(), self.acyclic()]);
                ::builtin::choose(|ranking| self.valid_ranking(ranking))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn decodable(self, ptr: Pointer) -> bool {
                (self.wf()) && (self.is_nondangling_pointer(ptr))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn the_rank_of(self, ptr: Pointer) -> nat {
                ::builtin::recommends([self.decodable(ptr)]);
                if ptr.is_Some() && self.acyclic() {
                        (self.the_ranking().spec_index(ptr.unwrap())).spec_add(::builtin::spec_literal_nat("1"))
                    } else { ::builtin::spec_literal_integer("0") }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn seq_start(self) -> LSN { self.boundary_lsn }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn seq_end(self, root: Pointer) -> LSN {
                ::builtin::recommends([self.is_nondangling_pointer(root)]);
                if root.is_None() {
                        self.boundary_lsn
                    } else {
                       self.entries.spec_index(root.unwrap()).message_seq.seq_end
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn discard_old(self, new_boundary: LSN) -> Self {
                ::builtin::recommends([(self.boundary_lsn).spec_le(new_boundary)]);
                Self { boundary_lsn: new_boundary, ..self }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_sub_disk(self, bigger: Self) -> bool {
                (::builtin::spec_eq(bigger.boundary_lsn, self.boundary_lsn))
                    && ((self.entries).spec_le(bigger.entries))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn sub_disk_transitive_auto() {
                ::builtin::ensures([::builtin::forall(|a: Self, b: Self,
                                    c: Self|
                                    ::builtin::imply(#[verus::internal(trigger)] a.is_sub_disk(b)
                                            && #[verus::internal(trigger)] b.is_sub_disk(c),
                                        a.is_sub_disk(c)))]);
                {
                    ::builtin::assert_forall_by(|a: Self, b: Self, c: Self|
                            {
                                ::builtin::requires(#[verus::internal(trigger)] a.is_sub_disk(b)
                                        && #[verus::internal(trigger)] b.is_sub_disk(c));
                                ::builtin::ensures(a.is_sub_disk(c));
                                {
                                    ::builtin::assert_forall_by(|k: Address|
                                            {
                                                ::builtin::requires(#[verus::internal(trigger)] a.entries.dom().contains(k));
                                                ::builtin::ensures(#[verus::internal(trigger)] c.entries.dom().contains(k)
                                                        &&
                                                        ::builtin::spec_eq(a.entries.spec_index(k),
                                                            c.entries.spec_index(k)));
                                                ::builtin::assert_(b.entries.dom().contains(k));
                                                ::builtin::assert_(c.entries.dom().contains(k));
                                            });
                                }
                            });
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_sub_disk_with_newer_lsn(self, bigger: Self) -> bool {
                ((bigger.boundary_lsn).spec_le(self.boundary_lsn)) &&
                    ((self.entries).spec_le(bigger.entries))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn build_tight(self, root: Pointer) -> Self {
                ::builtin::recommends([self.decodable(root)]);
                ::builtin::decreases((self.the_rank_of(root)));
                ::builtin::decreases_when(self.decodable(root));
                if !self.acyclic() {
                        Self {
                            boundary_lsn: ::builtin::spec_literal_integer("0"),
                            entries: ::vstd::map::Map::empty(),
                        }
                    } else if root.is_None() {
                       Self {
                           boundary_lsn: self.boundary_lsn,
                           entries: ::vstd::map::Map::empty(),
                       }
                   } else {
                       let addr = root.unwrap();
                       let tail = self.build_tight(self.next(root));
                       Self {
                           boundary_lsn: self.boundary_lsn,
                           entries: tail.entries.insert(addr,
                               self.entries.spec_index(addr)),
                       }
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn build_tight_ensures(self, root: Pointer) {
                ::builtin::requires([self.decodable(root)]);
                ::builtin::ensures([::builtin::forall(|addr|
                                    ::builtin::imply(#[verus::internal(trigger)] self.build_tight(root).entries.contains_key(addr),
                                        self.entries.contains_key(addr))),
                            ::builtin::imply(self.acyclic(),
                                self.build_tight(root).is_sub_disk(self))]);
                ::builtin::decreases((self.the_rank_of(root),));
                if !self.acyclic()
                        {} else if root.is_None()
                       {} else { self.build_tight_ensures(self.next(root)); }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn build_tight_auto(self) {
                ::builtin::ensures([::builtin::forall(|root: Pointer|
                                    ::builtin::imply(#[verus::internal(trigger)] self.decodable(root),
                                        ({
                                                ((::builtin::forall(|addr|
                                                                    ::builtin::imply(#[verus::internal(trigger)] self.build_tight(root).entries.contains_key(addr),
                                                                        self.entries.contains_key(addr))))) &&
                                                    (::builtin::imply(self.acyclic(),
                                                            self.build_tight(root).is_sub_disk(self)))
                                            })))]);
                {
                    ::builtin::assert_forall_by(|root: Pointer|
                            {
                                ::builtin::requires(#[verus::internal(trigger)] self.decodable(root));
                                ::builtin::ensures(({
                                            ((::builtin::forall(|addr|
                                                                ::builtin::imply(#[verus::internal(trigger)] self.build_tight(root).entries.contains_key(addr),
                                                                    self.entries.contains_key(addr))))) &&
                                                (::builtin::imply(self.acyclic(),
                                                        self.build_tight(root).is_sub_disk(self)))
                                        }));
                                self.build_tight_ensures(root);
                            });
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_crop(self, root: Pointer, depth: nat) -> bool {
                ::builtin::recommends([self.decodable(root),
                            self.block_in_bounds(root)]);
                ::builtin::decreases((depth));
                ::builtin::imply((::builtin::spec_literal_nat("0")).spec_lt(depth),
                    {
                        (root.is_Some()) &&
                            (self.can_crop(self.next(root),
                                    ::builtin::spec_cast_integer::<_,
                                            nat>(((depth).spec_sub(::builtin::spec_literal_nat("1"))))))
                    })
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn pointer_after_crop(self, root: Pointer, depth: nat)
                -> Pointer {
                ::builtin::recommends([self.decodable(root),
                            self.block_in_bounds(root), self.can_crop(root, depth)]);
                ::builtin::decreases((depth));
                if ::builtin::spec_eq(depth, ::builtin::spec_literal_nat("0"))
                        {
                        root
                    } else {
                       self.pointer_after_crop(self.next(root),
                           ::builtin::spec_cast_integer::<_,
                                   nat>(((depth).spec_sub(::builtin::spec_literal_nat("1")))))
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn pointer_after_crop_ensures(self, root: Pointer,
                depth: nat) {
                ::builtin::requires([self.decodable(root),
                            self.block_in_bounds(root), self.can_crop(root, depth)]);
                ::builtin::ensures([self.is_nondangling_pointer(self.pointer_after_crop(root,
                                    depth)),
                            self.block_in_bounds(self.pointer_after_crop(root,
                                    depth))]);
                ::builtin::decreases((depth));
                if (depth).spec_gt(::builtin::spec_literal_nat("0")) {
                        self.pointer_after_crop_ensures(self.next(root),
                            ::builtin::spec_cast_integer::<_,
                                    nat>(((depth).spec_sub(::builtin::spec_literal_nat("1")))))
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn pointer_after_crop_auto(self) {
                ::builtin::ensures([::builtin::forall(|root, depth|
                                    ::builtin::imply({
                                            ((self.decodable(root)) && (self.block_in_bounds(root))) &&
                                                (self.can_crop(root, depth))
                                        },
                                        {
                                            (self.is_nondangling_pointer(#[verus::internal(trigger)] self.pointer_after_crop(root,
                                                            depth))) &&
                                                (self.block_in_bounds(self.pointer_after_crop(root, depth)))
                                        }))]);
                {
                    ::builtin::assert_forall_by(|root, depth|
                            {
                                ::builtin::requires({
                                        ((self.decodable(root)) && (self.block_in_bounds(root))) &&
                                            (self.can_crop(root, depth))
                                    });
                                ::builtin::ensures({
                                        (self.is_nondangling_pointer(#[verus::internal(trigger)] self.pointer_after_crop(root,
                                                        depth))) &&
                                            (self.block_in_bounds(self.pointer_after_crop(root, depth)))
                                    });
                                self.pointer_after_crop_ensures(root, depth);
                            });
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn iptr(self, ptr: Pointer)
                -> Option<PagedJournal_v::JournalRecord> {
                ::builtin::recommends([self.decodable(ptr), self.acyclic()]);
                ::builtin::decreases((self.the_rank_of(ptr)));
                ::builtin::decreases_when(self.decodable(ptr) &&
                        self.acyclic());
                if ptr.is_None() {
                        None
                    } else {
                       let jr = self.entries.spec_index(ptr.unwrap());
                       Some(PagedJournal_v::JournalRecord {
                               message_seq: jr.message_seq,
                               prior_rec: Box::new(self.iptr(jr.cropped_prior(self.boundary_lsn))),
                           })
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn iptr_ignores_extra_blocks(self, ptr: Pointer,
                big: DiskView) {
                ::builtin::requires([self.wf(),
                            self.is_nondangling_pointer(ptr), big.wf(), big.acyclic(),
                            self.is_sub_disk(big)]);
                ::builtin::ensures([self.acyclic(),
                            ::builtin::spec_eq(self.iptr(ptr), big.iptr(ptr))]);
                ::builtin::decreases((big.the_rank_of(ptr)));
                ::builtin::assert_(self.entries.dom().subset_of(big.entries.dom()));
                ::builtin::assert_(self.valid_ranking(big.the_ranking()));
                if ptr.is_Some() {
                        ::builtin::assert_((big.the_rank_of(self.next(ptr))).spec_lt(big.the_rank_of(ptr)));
                        self.iptr_ignores_extra_blocks(self.next(ptr), big);
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn next(self, ptr: Pointer) -> Pointer {
                ::builtin::recommends([self.wf(), ptr.is_Some()]);
                self.entries.spec_index(ptr.unwrap()).cropped_prior(self.boundary_lsn)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn build_tight_ranks(self, ptr: Pointer) {
                ::builtin::requires([self.decodable(ptr), self.acyclic(),
                            ptr.is_Some()]);
                ::builtin::ensures([({
                                    ::builtin::forall(|addr: Address|
                                            ::builtin::imply(#[verus::internal(trigger)] self.build_tight(self.next(ptr)).entries.contains_key(addr),
                                                {
                                                    (self.the_ranking().contains_key(addr)) &&
                                                        ((self.the_ranking().spec_index(addr)).spec_lt(self.the_ranking().spec_index(ptr.unwrap())))
                                                }))
                                })]);
                ::builtin::decreases((self.the_rank_of(ptr)));
                let next = self.next(ptr);
                if next.is_Some() {
                        self.build_tight_ranks(next);
                        {
                            ::builtin::assert_forall_by(|addr: Address|
                                    {
                                        ::builtin::requires(#[verus::internal(trigger)] self.build_tight(self.next(ptr)).entries.contains_key(addr));
                                        ::builtin::ensures({
                                                (self.the_ranking().contains_key(addr)) &&
                                                    ((self.the_ranking().spec_index(addr)).spec_lt(self.the_ranking().spec_index(ptr.unwrap())))
                                            });
                                        if self.build_tight(self.next(next)).entries.contains_key(addr)
                                                {}
                                    });
                        }
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn build_tight_shape(self, root: Pointer) {
                ::builtin::requires([root.is_Some(), self.decodable(root),
                            self.acyclic()]);
                ::builtin::ensures([(::builtin::spec_eq(self.build_tight(self.next(root)),
                                    Self {
                                        entries: self.build_tight(root).entries.remove(root.unwrap()),
                                        ..self
                                    }))]);
                if self.next(root).is_Some() { self.build_tight_ranks(root); }
                #[verifier::spec]
                let m1 =
                    ::vstd::map::check_argument_is_map(self.build_tight(self.entries.spec_index(root.unwrap()).cropped_prior(self.boundary_lsn)).entries);
                #[verifier::spec]
                let m2 =
                    ::vstd::map::check_argument_is_map(self.build_tight(root).entries.remove(root.unwrap()));
                ::builtin::assert_by(::builtin::equal(m1, m2),
                    {
                        ::builtin::assert_forall_by(|key|
                                {
                                    ::builtin::ensures([::builtin::imply(#[verifier::trigger] m1.dom().contains(key),
                                                            m2.dom().contains(key)) &&
                                                        ::builtin::imply(m2.dom().contains(key),
                                                            m1.dom().contains(key)) &&
                                                    ::builtin::imply(m1.dom().contains(key) &&
                                                            m2.dom().contains(key),
                                                        ::builtin::equal(m1.index(key), m2.index(key)))]);
                                    { {} }
                                });
                        ::builtin::assert_(::builtin::ext_equal(m1, m2));
                    });
                ;
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_tight(self, root: Pointer) -> bool {
                ((self.decodable(root)) && (self.acyclic())) &&
                    (::builtin::forall(|other: Self|
                                {
                                    ::builtin::imply(({
                                                (((other.decodable(root)) && (other.acyclic())) &&
                                                            (::builtin::spec_eq(self.iptr(root), other.iptr(root)))) &&
                                                    (#[verus::internal(trigger)] other.is_sub_disk(self))
                                            }), ::builtin::spec_eq(other, self))
                                }))
            }
            #[verifier::spinoff_prover]
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn build_tight_builds_sub_disks(self, root: Pointer) {
                ::builtin::requires([self.decodable(root), self.acyclic()]);
                ::builtin::ensures([self.build_tight(root).is_sub_disk(self)]);
                ::builtin::decreases((self.the_rank_of(root)));
                if root.is_Some() {
                        self.build_tight_builds_sub_disks(self.next(root));
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn tight_empty_disk(self) {
                ::builtin::requires([self.decodable(None)]);
                ::builtin::ensures([self.build_tight(None).is_tight(None)]);
                let tight = self.build_tight(None);
                ::builtin::assert_(tight.wf());
                ::builtin::assert_(tight.valid_ranking(::vstd::map::Map::empty()));
                {
                    ::builtin::assert_forall_by(|other: Self|
                            {
                                ::builtin::requires(({
                                            (((other.decodable(None)) && (other.acyclic())) &&
                                                        (::builtin::spec_eq(tight.iptr(None), other.iptr(None)))) &&
                                                (#[verus::internal(trigger)] other.is_sub_disk(tight))
                                        }));
                                ::builtin::ensures(::builtin::ext_equal(other, tight));
                                ::builtin::assert_(::builtin::ext_equal_deep(tight.entries.dom(),
                                        other.entries.dom()));
                                ::builtin::assert_(::builtin::ext_equal_deep(other.entries,
                                        tight.entries));
                            });
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn tight_sub_disk(self, root: Pointer, tight: Self) {
                ::builtin::requires([self.decodable(root),
                            ::builtin::spec_eq(tight, self.build_tight(root)),
                            self.acyclic(), tight.is_sub_disk(self)]);
                ::builtin::ensures([tight.is_tight(root)]);
                ::builtin::decreases((self.the_rank_of(root)));
                self.build_tight_ensures(root);
                if root.is_Some() {
                        let next = self.next(root);
                        let inner = self.build_tight(next);
                        self.build_tight_shape(root);
                        self.tight_sub_disk(next, inner);
                        ::builtin::assert_(tight.valid_ranking(self.the_ranking()));
                        {
                            ::builtin::assert_by(tight.is_tight(root),
                                {
                                    {
                                        ::builtin::assert_forall_by(|other: Self|
                                                {
                                                    ::builtin::requires({
                                                            (((other.decodable(root)) && (other.acyclic())) &&
                                                                        (::builtin::spec_eq(tight.iptr(root), other.iptr(root)))) &&
                                                                (#[verus::internal(trigger)] other.is_sub_disk(tight))
                                                        });
                                                    ::builtin::ensures(::builtin::spec_eq(other, tight));
                                                    let other_inner =
                                                        DiskView {
                                                            entries: other.entries.remove(root.unwrap()),
                                                            ..other
                                                        };
                                                    ::builtin::assert_(other_inner.entries_wf());
                                                    Self::sub_disk_transitive_auto();
                                                    {
                                                        ::builtin::assert_forall_by(|addr|
                                                                {
                                                                    ::builtin::requires(#[verus::internal(trigger)] other_inner.entries.contains_key(addr));
                                                                    ::builtin::ensures(other_inner.is_nondangling_pointer(other_inner.entries.spec_index(addr).cropped_prior(other_inner.boundary_lsn)));
                                                                    let aprior =
                                                                        self.entries.spec_index(addr).cropped_prior(self.boundary_lsn);
                                                                    ::builtin::assert_(self.entries.contains_key(addr));
                                                                    ::builtin::assert_(self.is_nondangling_pointer(aprior));
                                                                    ::builtin::assert_(other.wf());
                                                                    if ::builtin::spec_eq(aprior, root) {
                                                                            if ::builtin::spec_eq(tight.entries.spec_index(addr).cropped_prior(tight.boundary_lsn),
                                                                                        root) {
                                                                                    ::builtin::assert_(tight.entries.contains_key(addr));
                                                                                    ::builtin::assert_((tight.the_ranking().spec_index(tight.entries.spec_index(addr).cropped_prior(tight.boundary_lsn).unwrap())).spec_gt(tight.the_ranking().spec_index(root.unwrap())));
                                                                                    ::builtin::assert_((tight.the_ranking().spec_index(tight.entries.spec_index(addr).cropped_prior(tight.boundary_lsn).unwrap())).spec_lt(tight.the_ranking().spec_index(root.unwrap())));
                                                                                }
                                                                            ::builtin::assert_(!::builtin::spec_eq(tight.entries.spec_index(addr).cropped_prior(tight.boundary_lsn),
                                                                                        root));
                                                                            ::builtin::assert_(other_inner.is_sub_disk(tight));
                                                                        }
                                                                    ::builtin::assert_(other_inner.is_nondangling_pointer(aprior));
                                                                });
                                                    }
                                                    ::builtin::assert_(other_inner.is_nondangling_pointer(next));
                                                    ::builtin::assert_(other_inner.wf());
                                                    ::builtin::assert_(other_inner.is_sub_disk(inner));
                                                    other_inner.iptr_ignores_extra_blocks(next, inner);
                                                    ::builtin::assert_(inner.is_tight(next));
                                                    ::builtin::assert_(::builtin::forall(|a|
                                                                ::builtin::imply(inner.entries.contains_key(a),
                                                                    #[verus::internal(trigger)] other_inner.entries.contains_key(a)
                                                                        &&
                                                                        ::builtin::spec_eq(other_inner.entries.spec_index(a),
                                                                            inner.entries.spec_index(a)))));
                                                    ::builtin::assert_(::builtin::ext_equal(other_inner,
                                                            inner));
                                                    ::builtin::assert_(::builtin::ext_equal(other.entries,
                                                            tight.entries));
                                                    ::builtin::assert_(::builtin::ext_equal(other, tight));
                                                });
                                    }
                                    ::builtin::assert_(tight.decodable(root));
                                    ::builtin::assert_(tight.acyclic());
                                });
                        }
                    } else { self.tight_empty_disk() }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn tight_interp(big: Self, root: Pointer, tight: Self) {
                ::builtin::requires([big.decodable(root),
                            ::builtin::spec_eq(tight, big.build_tight(root)),
                            big.acyclic()]);
                ::builtin::ensures([tight.is_sub_disk(big),
                            tight.is_tight(root),
                            ::builtin::spec_eq(tight.iptr(root), big.iptr(root)),
                            tight.acyclic()]);
                ::builtin::decreases((big.the_rank_of(root)));
                if root.is_None() {
                        big.tight_empty_disk()
                    } else {
                       big.build_tight_builds_sub_disks(root);
                       big.tight_sub_disk(root, tight);
                       ::builtin::assert_(::builtin::forall(|addr|
                                   ::builtin::imply(tight.entries.contains_key(addr),
                                       big.entries.contains_key(addr))));
                       tight.iptr_ignores_extra_blocks(root, big);
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn lsn_has_entry_at(self, lsn: LSN, addr: Address) -> bool {
                (self.entries.contains_key(addr)) &&
                    (self.entries.spec_index(addr).message_seq.contains(lsn))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn lsn_has_entry(self, lsn: LSN) -> bool {
                ::builtin::exists(|addr| self.lsn_has_entry_at(lsn, addr))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn lsns_have_entries(self, root: Pointer) -> bool {
                ::builtin::forall(|lsn|
                        ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(self.boundary_lsn),
                                        lsn), self.seq_end(root))), self.lsn_has_entry(lsn)))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn decodable_implies_lsns_have_entries(self, root: Pointer) {
                ::builtin::requires([self.decodable(root), self.acyclic()]);
                ::builtin::ensures([self.lsns_have_entries(root)]);
                ::builtin::decreases((self.the_rank_of(root)));
                if root.is_Some() {
                        self.decodable_implies_lsns_have_entries(self.next(root));
                        {
                            ::builtin::assert_forall_by(|lsn|
                                    {
                                        ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(self.seq_start()),
                                                        lsn), self.seq_end(root))));
                                        ::builtin::ensures(self.lsn_has_entry(lsn));
                                        if (self.entries.spec_index(root.unwrap()).message_seq.seq_start).spec_le(lsn)
                                                {
                                                ::builtin::assert_(self.lsn_has_entry_at(lsn,
                                                        root.unwrap()));
                                            }
                                    });
                        }
                    }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct TruncatedJournal {
            pub freshest_rec: Pointer,
            pub disk_view: DiskView,
        }
        #[verus::internal(verus_macro)]
        impl TruncatedJournal {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                ((self.disk_view.wf()) &&
                            (self.disk_view.is_nondangling_pointer(self.freshest_rec)))
                    && (self.disk_view.block_in_bounds(self.freshest_rec))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn seq_start(self) -> LSN { self.disk_view.seq_start() }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn seq_end(self) -> LSN {
                ::builtin::recommends([self.disk_view.is_nondangling_pointer(self.freshest_rec)]);
                self.disk_view.seq_end(self.freshest_rec)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_discard_to(self, lsn: LSN) -> bool {
                ::builtin::recommends([self.wf()]);
                ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(self.seq_start()),
                            lsn), self.seq_end()))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn discard_old(self, lsn: LSN) -> Self {
                ::builtin::recommends([self.wf(), self.can_discard_to(lsn)]);
                TruncatedJournal {
                    freshest_rec: if ::builtin::spec_eq(self.seq_end(), lsn) {
                            None
                        } else { self.freshest_rec },
                    disk_view: self.disk_view.discard_old(lsn),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid_discard_old(self, lsn: LSN, new: Self) -> bool {
                ::builtin::recommends([self.wf(), self.can_discard_to(lsn)]);
                let post_discard = self.discard_old(lsn);
                let post_tight = post_discard.build_tight();
                (((new.wf()) &&
                                    (::builtin::spec_eq(new.freshest_rec,
                                            post_discard.freshest_rec))) &&
                            (new.disk_view.is_sub_disk(post_discard.disk_view))) &&
                    (post_tight.disk_view.is_sub_disk(new.disk_view))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn decodable(self) -> bool {
                (self.wf()) && (self.disk_view.acyclic())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_crop(self, depth: nat) -> bool {
                (self.decodable()) &&
                    (self.disk_view.can_crop(self.freshest_rec, depth))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn crop(self, depth: nat) -> Self {
                ::builtin::recommends([self.can_crop(depth)]);
                let ptr =
                    self.disk_view.pointer_after_crop(self.freshest_rec, depth);
                TruncatedJournal { freshest_rec: ptr, ..self }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn crop_ensures(self, depth: nat) {
                ::builtin::requires([self.can_crop(depth)]);
                ::builtin::ensures([self.crop(depth).wf()]);
                self.disk_view.pointer_after_crop_auto();
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn crop_auto(self) {
                ::builtin::ensures([::builtin::forall(|depth|
                                    ::builtin::imply(self.can_crop(depth),
                                        #[verus::internal(trigger)] self.crop(depth).wf()))]);
                {
                    ::builtin::assert_forall_by(|depth|
                            {
                                ::builtin::requires(self.can_crop(depth));
                                ::builtin::ensures(#[verus::internal(trigger)] self.crop(depth).wf());
                                self.disk_view.pointer_after_crop_auto();
                            });
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn append_record(self, addr: Address, msgs: MsgHistory)
                -> Self {
                Self {
                    disk_view: DiskView {
                        entries: self.disk_view.entries.insert(addr,
                            JournalRecord {
                                message_seq: msgs,
                                prior_rec: self.freshest_rec,
                            }),
                        ..self.disk_view
                    },
                    freshest_rec: Some(addr),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn build_tight(self) -> Self {
                ::builtin::recommends([self.disk_view.decodable(self.freshest_rec)]);
                TruncatedJournal {
                    disk_view: self.disk_view.build_tight(self.freshest_rec),
                    ..self
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn mkfs() -> Self {
                Self {
                    freshest_rec: None,
                    disk_view: DiskView {
                        boundary_lsn: ::builtin::spec_literal_integer("0"),
                        entries: ::vstd::map::Map::empty(),
                    },
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn mkfs_ensures() {
                ::builtin::ensures([Self::mkfs().decodable()]);
                ::builtin::assert_(Self::mkfs().disk_view.valid_ranking(::vstd::map::Map::empty()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn lsns_have_entries(self) -> bool {
                self.disk_view.lsns_have_entries(self.freshest_rec)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn decodable_implies_lsns_have_entries(self) {
                ::builtin::requires([self.decodable()]);
                ::builtin::ensures([self.lsns_have_entries()]);
                self.disk_view.decodable_implies_lsns_have_entries(self.freshest_rec);
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn marshal_ranking(self, addr: Address) -> Ranking {
                ::builtin::recommends([self.decodable()]);
                let pre_rank = self.disk_view.the_ranking();
                pre_rank.insert(addr,
                    if ::builtin::is_variant(self.freshest_rec, "None") {
                            ::builtin::spec_literal_integer("0")
                        } else {
                           (pre_rank.spec_index(self.freshest_rec.unwrap())).spec_add(::builtin::spec_literal_nat("1"))
                       })
            }
        }
        #[verus::internal(verus_macro)]
        impl MsgHistory {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn bounded_discard(self, new_bdy: LSN) -> Self {
                if (self.seq_start).spec_le(new_bdy) {
                        self.discard_old(new_bdy)
                    } else { self }
            }
        }
        #[allow(unused_parens)]
        pub mod LinkedJournal {
            use super::*;
            #[verus::internal(verus_macro)]
            pub struct State {
                pub truncated_journal: TruncatedJournal,
                pub unmarshalled_tail: MsgHistory,
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Step {
                read_for_recovery(nat),
                freeze_for_commit(nat),
                query_end_lsn(),
                put(),
                discard_old(TruncatedJournal),
                internal_journal_marshal(LSN, Address),
                internal_no_op(),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Step {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_read_for_recovery(&self) -> bool {
                    ::builtin::is_variant(self, "read_for_recovery")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_read_for_recovery_0(self) -> nat {
                    ::builtin::get_variant_field(self, "read_for_recovery", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_freeze_for_commit(&self) -> bool {
                    ::builtin::is_variant(self, "freeze_for_commit")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_freeze_for_commit_0(self) -> nat {
                    ::builtin::get_variant_field(self, "freeze_for_commit", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_query_end_lsn(&self) -> bool {
                    ::builtin::is_variant(self, "query_end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_put(&self) -> bool {
                    ::builtin::is_variant(self, "put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_discard_old(&self) -> bool {
                    ::builtin::is_variant(self, "discard_old")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_discard_old_0(self) -> TruncatedJournal {
                    ::builtin::get_variant_field(self, "discard_old", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_internal_journal_marshal(&self) -> bool {
                    ::builtin::is_variant(self, "internal_journal_marshal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_journal_marshal_0(self) -> LSN {
                    ::builtin::get_variant_field(self,
                        "internal_journal_marshal", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_journal_marshal_1(self) -> Address {
                    ::builtin::get_variant_field(self,
                        "internal_journal_marshal", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_internal_no_op(&self) -> bool {
                    ::builtin::is_variant(self, "internal_no_op")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Config {
                initialize(TruncatedJournal),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Config {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_initialize(&self) -> bool {
                    ::builtin::is_variant(self, "initialize")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_initialize_0(self) -> TruncatedJournal {
                    ::builtin::get_variant_field(self, "initialize", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[verus::internal(verus_macro)]
            pub enum Label {
                ReadForRecovery {
                    messages: MsgHistory,
                },
                FreezeForCommit {
                    frozen_journal: TruncatedJournal,
                },
                QueryEndLsn {
                    end_lsn: LSN,
                },
                Put {
                    messages: MsgHistory,
                },
                DiscardOld {
                    start_lsn: LSN,
                    require_end: LSN,
                },
                Internal {},
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Label {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_ReadForRecovery(&self) -> bool {
                    ::builtin::is_variant(self, "ReadForRecovery")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_ReadForRecovery_messages(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "ReadForRecovery",
                        "messages")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_FreezeForCommit(&self) -> bool {
                    ::builtin::is_variant(self, "FreezeForCommit")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_FreezeForCommit_frozen_journal(self)
                    -> TruncatedJournal {
                    ::builtin::get_variant_field(self, "FreezeForCommit",
                        "frozen_journal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_QueryEndLsn(&self) -> bool {
                    ::builtin::is_variant(self, "QueryEndLsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_QueryEndLsn_end_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "QueryEndLsn", "end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_Put(&self) -> bool {
                    ::builtin::is_variant(self, "Put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_Put_messages(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "Put", "messages")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_DiscardOld(&self) -> bool {
                    ::builtin::is_variant(self, "DiscardOld")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_DiscardOld_start_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "DiscardOld",
                        "start_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_DiscardOld_require_end(self) -> LSN {
                    ::builtin::get_variant_field(self, "DiscardOld",
                        "require_end")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_Internal(&self) -> bool {
                    ::builtin::is_variant(self, "Internal")
                }
            }
            pub mod show {
                use super::*;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn read_for_recovery(pre: super::State,
                    post: super::State, lbl: Label, depth: nat) {
                    ::builtin::requires(super::State::read_for_recovery(pre,
                            post, lbl, depth));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as read_for_recovery;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn freeze_for_commit(pre: super::State,
                    post: super::State, lbl: Label, depth: nat) {
                    ::builtin::requires(super::State::freeze_for_commit(pre,
                            post, lbl, depth));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as freeze_for_commit;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn query_end_lsn(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::query_end_lsn(pre, post,
                            lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as query_end_lsn;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn put(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::put(pre, post, lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as put;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn discard_old(pre: super::State, post: super::State,
                    lbl: Label, new_tj: TruncatedJournal) {
                    ::builtin::requires(super::State::discard_old(pre, post,
                            lbl, new_tj));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as discard_old;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn internal_journal_marshal(pre: super::State,
                    post: super::State, lbl: Label, cut: LSN, addr: Address) {
                    ::builtin::requires(super::State::internal_journal_marshal(pre,
                            post, lbl, cut, addr));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as internal_journal_marshal;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn internal_no_op(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::internal_no_op(pre, post,
                            lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as internal_no_op;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn initialize(post: super::State,
                    truncated_journal: TruncatedJournal) {
                    ::builtin::requires(super::State::initialize(post,
                            truncated_journal));
                    ::builtin::ensures(super::State::init(post));
                }
                use bool as initialize;
            }
            pub mod take_step {
                use super::*;
            }
            #[verus::internal(verus_macro)]
            impl State {
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn read_for_recovery(pre: Self, post: Self, lbl: Label,
                    depth: nat) -> ::core::primitive::bool {
                    {
                        let update_tmp_truncated_journal: TruncatedJournal =
                            pre.truncated_journal;
                        let update_tmp_unmarshalled_tail: MsgHistory =
                            pre.unmarshalled_tail;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_ReadForRecovery())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (State::lbl_wf(lbl))
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.truncated_journal.decodable())
                                                        &&
                                                        (({
                                                                        let dv = pre.truncated_journal.disk_view;
                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (dv.can_crop(pre.truncated_journal.freshest_rec,
                                                                                        depth)) &&
                                                                                {
                                                                                    let ptr =
                                                                                        dv.pointer_after_crop(pre.truncated_journal.freshest_rec,
                                                                                            depth);
                                                                                    (#[verifier::custom_err("cannot prove this condition holds")] (ptr.is_Some())
                                                                                            &&
                                                                                            #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(dv.entries.spec_index(ptr.unwrap()).message_seq.maybe_discard_old(dv.boundary_lsn),
                                                                                                    lbl.get_ReadForRecovery_messages())))
                                                                                })
                                                                    }) &&
                                                                ((#[verifier::custom_err("cannot prove that the field `unmarshalled_tail` is preserved")] (::builtin::equal(post.unmarshalled_tail,
                                                                                    update_tmp_unmarshalled_tail)) &&
                                                                            #[verifier::custom_err("cannot prove that the field `truncated_journal` is preserved")] (::builtin::equal(post.truncated_journal,
                                                                                    update_tmp_truncated_journal)))))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn read_for_recovery_strong(pre: Self, post: Self,
                    lbl: Label, depth: nat) -> ::core::primitive::bool {
                    {
                        let update_tmp_truncated_journal: TruncatedJournal =
                            pre.truncated_journal;
                        let update_tmp_unmarshalled_tail: MsgHistory =
                            pre.unmarshalled_tail;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_ReadForRecovery())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (State::lbl_wf(lbl))
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.truncated_journal.decodable())
                                                        &&
                                                        (({
                                                                        let dv = pre.truncated_journal.disk_view;
                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (dv.can_crop(pre.truncated_journal.freshest_rec,
                                                                                        depth)) &&
                                                                                {
                                                                                    let ptr =
                                                                                        dv.pointer_after_crop(pre.truncated_journal.freshest_rec,
                                                                                            depth);
                                                                                    (#[verifier::custom_err("cannot prove this condition holds")] (ptr.is_Some())
                                                                                            &&
                                                                                            #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(dv.entries.spec_index(ptr.unwrap()).message_seq.maybe_discard_old(dv.boundary_lsn),
                                                                                                    lbl.get_ReadForRecovery_messages())))
                                                                                })
                                                                    }) &&
                                                                ((#[verifier::custom_err("cannot prove that the field `unmarshalled_tail` is preserved")] (::builtin::equal(post.unmarshalled_tail,
                                                                                    update_tmp_unmarshalled_tail)) &&
                                                                            #[verifier::custom_err("cannot prove that the field `truncated_journal` is preserved")] (::builtin::equal(post.truncated_journal,
                                                                                    update_tmp_truncated_journal)))))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn read_for_recovery_enabled(pre: Self, lbl: Label,
                    depth: nat) -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_ReadForRecovery())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (State::lbl_wf(lbl))
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.truncated_journal.decodable())
                                                        &&
                                                        {
                                                            let dv = pre.truncated_journal.disk_view;
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (dv.can_crop(pre.truncated_journal.freshest_rec,
                                                                            depth)) &&
                                                                    {
                                                                        let ptr =
                                                                            dv.pointer_after_crop(pre.truncated_journal.freshest_rec,
                                                                                depth);
                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (ptr.is_Some())
                                                                                &&
                                                                                #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(dv.entries.spec_index(ptr.unwrap()).message_seq.maybe_discard_old(dv.boundary_lsn),
                                                                                        lbl.get_ReadForRecovery_messages())))
                                                                    })
                                                        }))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn freeze_for_commit(pre: Self, post: Self, lbl: Label,
                    depth: nat) -> ::core::primitive::bool {
                    {
                        let update_tmp_truncated_journal: TruncatedJournal =
                            pre.truncated_journal;
                        let update_tmp_unmarshalled_tail: MsgHistory =
                            pre.unmarshalled_tail;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (State::lbl_wf(lbl))
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_FreezeForCommit())
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.truncated_journal.decodable())
                                                        &&
                                                        (({
                                                                        let dv = pre.truncated_journal.disk_view;
                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (dv.can_crop(pre.truncated_journal.freshest_rec,
                                                                                        depth)) &&
                                                                                {
                                                                                    let ptr =
                                                                                        dv.pointer_after_crop(pre.truncated_journal.freshest_rec,
                                                                                            depth);
                                                                                    let cropped_tj =
                                                                                        TruncatedJournal {
                                                                                            freshest_rec: ptr,
                                                                                            disk_view: pre.truncated_journal.disk_view,
                                                                                        };
                                                                                    let label_fj = lbl.get_FreezeForCommit_frozen_journal();
                                                                                    let new_bdy = label_fj.seq_start();
                                                                                    (#[verifier::custom_err("cannot prove this condition holds")] ((dv.boundary_lsn).spec_le(new_bdy))
                                                                                            &&
                                                                                            (#[verifier::custom_err("cannot prove this condition holds")] (cropped_tj.can_discard_to(new_bdy))
                                                                                                    &&
                                                                                                    #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(label_fj,
                                                                                                            cropped_tj.discard_old(new_bdy)))))
                                                                                })
                                                                    }) &&
                                                                ((#[verifier::custom_err("cannot prove that the field `unmarshalled_tail` is preserved")] (::builtin::equal(post.unmarshalled_tail,
                                                                                    update_tmp_unmarshalled_tail)) &&
                                                                            #[verifier::custom_err("cannot prove that the field `truncated_journal` is preserved")] (::builtin::equal(post.truncated_journal,
                                                                                    update_tmp_truncated_journal)))))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn freeze_for_commit_strong(pre: Self, post: Self,
                    lbl: Label, depth: nat) -> ::core::primitive::bool {
                    {
                        let update_tmp_truncated_journal: TruncatedJournal =
                            pre.truncated_journal;
                        let update_tmp_unmarshalled_tail: MsgHistory =
                            pre.unmarshalled_tail;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (State::lbl_wf(lbl))
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_FreezeForCommit())
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.truncated_journal.decodable())
                                                        &&
                                                        (({
                                                                        let dv = pre.truncated_journal.disk_view;
                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (dv.can_crop(pre.truncated_journal.freshest_rec,
                                                                                        depth)) &&
                                                                                {
                                                                                    let ptr =
                                                                                        dv.pointer_after_crop(pre.truncated_journal.freshest_rec,
                                                                                            depth);
                                                                                    let cropped_tj =
                                                                                        TruncatedJournal {
                                                                                            freshest_rec: ptr,
                                                                                            disk_view: pre.truncated_journal.disk_view,
                                                                                        };
                                                                                    let label_fj = lbl.get_FreezeForCommit_frozen_journal();
                                                                                    let new_bdy = label_fj.seq_start();
                                                                                    (#[verifier::custom_err("cannot prove this condition holds")] ((dv.boundary_lsn).spec_le(new_bdy))
                                                                                            &&
                                                                                            (#[verifier::custom_err("cannot prove this condition holds")] (cropped_tj.can_discard_to(new_bdy))
                                                                                                    &&
                                                                                                    #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(label_fj,
                                                                                                            cropped_tj.discard_old(new_bdy)))))
                                                                                })
                                                                    }) &&
                                                                ((#[verifier::custom_err("cannot prove that the field `unmarshalled_tail` is preserved")] (::builtin::equal(post.unmarshalled_tail,
                                                                                    update_tmp_unmarshalled_tail)) &&
                                                                            #[verifier::custom_err("cannot prove that the field `truncated_journal` is preserved")] (::builtin::equal(post.truncated_journal,
                                                                                    update_tmp_truncated_journal)))))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn freeze_for_commit_enabled(pre: Self, lbl: Label,
                    depth: nat) -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (State::lbl_wf(lbl))
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_FreezeForCommit())
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.truncated_journal.decodable())
                                                        &&
                                                        {
                                                            let dv = pre.truncated_journal.disk_view;
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (dv.can_crop(pre.truncated_journal.freshest_rec,
                                                                            depth)) &&
                                                                    {
                                                                        let ptr =
                                                                            dv.pointer_after_crop(pre.truncated_journal.freshest_rec,
                                                                                depth);
                                                                        let cropped_tj =
                                                                            TruncatedJournal {
                                                                                freshest_rec: ptr,
                                                                                disk_view: pre.truncated_journal.disk_view,
                                                                            };
                                                                        let label_fj = lbl.get_FreezeForCommit_frozen_journal();
                                                                        let new_bdy = label_fj.seq_start();
                                                                        (#[verifier::custom_err("cannot prove this condition holds")] ((dv.boundary_lsn).spec_le(new_bdy))
                                                                                &&
                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (cropped_tj.can_discard_to(new_bdy))
                                                                                        &&
                                                                                        #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(label_fj,
                                                                                                cropped_tj.discard_old(new_bdy)))))
                                                                    })
                                                        }))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_end_lsn(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_truncated_journal: TruncatedJournal =
                            pre.truncated_journal;
                        let update_tmp_unmarshalled_tail: MsgHistory =
                            pre.unmarshalled_tail;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (State::lbl_wf(lbl))
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_QueryEndLsn())
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(lbl.get_QueryEndLsn_end_lsn(),
                                                                pre.seq_end())) &&
                                                        (#[verifier::custom_err("cannot prove that the field `unmarshalled_tail` is preserved")] (::builtin::equal(post.unmarshalled_tail,
                                                                        update_tmp_unmarshalled_tail)) &&
                                                                #[verifier::custom_err("cannot prove that the field `truncated_journal` is preserved")] (::builtin::equal(post.truncated_journal,
                                                                        update_tmp_truncated_journal)))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_end_lsn_strong(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_truncated_journal: TruncatedJournal =
                            pre.truncated_journal;
                        let update_tmp_unmarshalled_tail: MsgHistory =
                            pre.unmarshalled_tail;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (State::lbl_wf(lbl))
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_QueryEndLsn())
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(lbl.get_QueryEndLsn_end_lsn(),
                                                                pre.seq_end())) &&
                                                        (#[verifier::custom_err("cannot prove that the field `unmarshalled_tail` is preserved")] (::builtin::equal(post.unmarshalled_tail,
                                                                        update_tmp_unmarshalled_tail)) &&
                                                                #[verifier::custom_err("cannot prove that the field `truncated_journal` is preserved")] (::builtin::equal(post.truncated_journal,
                                                                        update_tmp_truncated_journal)))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_end_lsn_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (State::lbl_wf(lbl))
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_QueryEndLsn())
                                                &&
                                                #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(lbl.get_QueryEndLsn_end_lsn(),
                                                        pre.seq_end())))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_truncated_journal: TruncatedJournal =
                            pre.truncated_journal;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (lbl.get_Put_messages().wf())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_Put())
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(lbl.get_Put_messages().seq_start,
                                                                pre.seq_end())) &&
                                                        {
                                                            let update_tmp_unmarshalled_tail: MsgHistory =
                                                                pre.unmarshalled_tail.concat(lbl.get_Put_messages());
                                                            (#[verifier::custom_err("cannot prove that final value of field `unmarshalled_tail` has this updated value")] (::builtin::equal(post.unmarshalled_tail,
                                                                            update_tmp_unmarshalled_tail)) &&
                                                                    #[verifier::custom_err("cannot prove that the field `truncated_journal` is preserved")] (::builtin::equal(post.truncated_journal,
                                                                            update_tmp_truncated_journal)))
                                                        }))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put_strong(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_truncated_journal: TruncatedJournal =
                            pre.truncated_journal;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (lbl.get_Put_messages().wf())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_Put())
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(lbl.get_Put_messages().seq_start,
                                                                pre.seq_end())) &&
                                                        {
                                                            let update_tmp_unmarshalled_tail: MsgHistory =
                                                                pre.unmarshalled_tail.concat(lbl.get_Put_messages());
                                                            (#[verifier::custom_err("cannot prove that final value of field `unmarshalled_tail` has this updated value")] (::builtin::equal(post.unmarshalled_tail,
                                                                            update_tmp_unmarshalled_tail)) &&
                                                                    #[verifier::custom_err("cannot prove that the field `truncated_journal` is preserved")] (::builtin::equal(post.truncated_journal,
                                                                            update_tmp_truncated_journal)))
                                                        }))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (lbl.get_Put_messages().wf())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_Put())
                                                &&
                                                #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(lbl.get_Put_messages().seq_start,
                                                        pre.seq_end())))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn discard_old(pre: Self, post: Self, lbl: Label,
                    new_tj: TruncatedJournal) -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (State::lbl_wf(lbl))
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_DiscardOld())
                                                &&
                                                {
                                                    let start_lsn = lbl.get_DiscardOld_start_lsn();
                                                    let require_end = lbl.get_DiscardOld_require_end();
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(require_end,
                                                                    pre.seq_end())) &&
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (pre.truncated_journal.can_discard_to(start_lsn))
                                                                    &&
                                                                    (#[verifier::custom_err("cannot prove this condition holds")] (pre.truncated_journal.valid_discard_old(start_lsn,
                                                                                    new_tj)) &&
                                                                            {
                                                                                let update_tmp_truncated_journal: TruncatedJournal = new_tj;
                                                                                let update_tmp_unmarshalled_tail: MsgHistory =
                                                                                    pre.unmarshalled_tail.bounded_discard(start_lsn);
                                                                                (#[verifier::custom_err("cannot prove that final value of field `unmarshalled_tail` has this updated value")] (::builtin::equal(post.unmarshalled_tail,
                                                                                                update_tmp_unmarshalled_tail)) &&
                                                                                        #[verifier::custom_err("cannot prove that final value of field `truncated_journal` has this updated value")] (::builtin::equal(post.truncated_journal,
                                                                                                update_tmp_truncated_journal)))
                                                                            })))
                                                })))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn discard_old_strong(pre: Self, post: Self, lbl: Label,
                    new_tj: TruncatedJournal) -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (State::lbl_wf(lbl))
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_DiscardOld())
                                                &&
                                                {
                                                    let start_lsn = lbl.get_DiscardOld_start_lsn();
                                                    let require_end = lbl.get_DiscardOld_require_end();
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(require_end,
                                                                    pre.seq_end())) &&
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (pre.truncated_journal.can_discard_to(start_lsn))
                                                                    &&
                                                                    (#[verifier::custom_err("cannot prove this condition holds")] (pre.truncated_journal.valid_discard_old(start_lsn,
                                                                                    new_tj)) &&
                                                                            {
                                                                                let update_tmp_truncated_journal: TruncatedJournal = new_tj;
                                                                                let update_tmp_unmarshalled_tail: MsgHistory =
                                                                                    pre.unmarshalled_tail.bounded_discard(start_lsn);
                                                                                (#[verifier::custom_err("cannot prove that final value of field `unmarshalled_tail` has this updated value")] (::builtin::equal(post.unmarshalled_tail,
                                                                                                update_tmp_unmarshalled_tail)) &&
                                                                                        #[verifier::custom_err("cannot prove that final value of field `truncated_journal` has this updated value")] (::builtin::equal(post.truncated_journal,
                                                                                                update_tmp_truncated_journal)))
                                                                            })))
                                                })))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn discard_old_enabled(pre: Self, lbl: Label,
                    new_tj: TruncatedJournal) -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (State::lbl_wf(lbl))
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_DiscardOld())
                                                &&
                                                {
                                                    let start_lsn = lbl.get_DiscardOld_start_lsn();
                                                    let require_end = lbl.get_DiscardOld_require_end();
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(require_end,
                                                                    pre.seq_end())) &&
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (pre.truncated_journal.can_discard_to(start_lsn))
                                                                    &&
                                                                    #[verifier::custom_err("cannot prove this condition holds")] (pre.truncated_journal.valid_discard_old(start_lsn,
                                                                            new_tj))))
                                                })))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_journal_marshal(pre: Self, post: Self,
                    lbl: Label, cut: LSN, addr: Address)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.unused_addr(addr))
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_Internal())
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] ((pre.unmarshalled_tail.seq_start).spec_lt(cut))
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.unmarshalled_tail.can_discard_to(cut))
                                                                &&
                                                                {
                                                                    let marshalled_msgs =
                                                                        pre.unmarshalled_tail.discard_recent(cut);
                                                                    let update_tmp_truncated_journal: TruncatedJournal =
                                                                        pre.truncated_journal.append_record(addr, marshalled_msgs);
                                                                    let update_tmp_unmarshalled_tail: MsgHistory =
                                                                        pre.unmarshalled_tail.discard_old(cut);
                                                                    (#[verifier::custom_err("cannot prove that final value of field `unmarshalled_tail` has this updated value")] (::builtin::equal(post.unmarshalled_tail,
                                                                                    update_tmp_unmarshalled_tail)) &&
                                                                            #[verifier::custom_err("cannot prove that final value of field `truncated_journal` has this updated value")] (::builtin::equal(post.truncated_journal,
                                                                                    update_tmp_truncated_journal)))
                                                                })))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_journal_marshal_strong(pre: Self, post: Self,
                    lbl: Label, cut: LSN, addr: Address)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.unused_addr(addr))
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_Internal())
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] ((pre.unmarshalled_tail.seq_start).spec_lt(cut))
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.unmarshalled_tail.can_discard_to(cut))
                                                                &&
                                                                {
                                                                    let marshalled_msgs =
                                                                        pre.unmarshalled_tail.discard_recent(cut);
                                                                    let update_tmp_truncated_journal: TruncatedJournal =
                                                                        pre.truncated_journal.append_record(addr, marshalled_msgs);
                                                                    let update_tmp_unmarshalled_tail: MsgHistory =
                                                                        pre.unmarshalled_tail.discard_old(cut);
                                                                    (#[verifier::custom_err("cannot prove that final value of field `unmarshalled_tail` has this updated value")] (::builtin::equal(post.unmarshalled_tail,
                                                                                    update_tmp_unmarshalled_tail)) &&
                                                                            #[verifier::custom_err("cannot prove that final value of field `truncated_journal` has this updated value")] (::builtin::equal(post.truncated_journal,
                                                                                    update_tmp_truncated_journal)))
                                                                })))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_journal_marshal_enabled(pre: Self, lbl: Label,
                    cut: LSN, addr: Address) -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.unused_addr(addr))
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_Internal())
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] ((pre.unmarshalled_tail.seq_start).spec_lt(cut))
                                                        &&
                                                        #[verifier::custom_err("cannot prove this condition holds")] (pre.unmarshalled_tail.can_discard_to(cut))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_no_op(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_truncated_journal: TruncatedJournal =
                            pre.truncated_journal;
                        let update_tmp_unmarshalled_tail: MsgHistory =
                            pre.unmarshalled_tail;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_Internal())
                                        &&
                                        (#[verifier::custom_err("cannot prove that the field `unmarshalled_tail` is preserved")] (::builtin::equal(post.unmarshalled_tail,
                                                        update_tmp_unmarshalled_tail)) &&
                                                #[verifier::custom_err("cannot prove that the field `truncated_journal` is preserved")] (::builtin::equal(post.truncated_journal,
                                                        update_tmp_truncated_journal)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_no_op_strong(pre: Self, post: Self,
                    lbl: Label) -> ::core::primitive::bool {
                    {
                        let update_tmp_truncated_journal: TruncatedJournal =
                            pre.truncated_journal;
                        let update_tmp_unmarshalled_tail: MsgHistory =
                            pre.unmarshalled_tail;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_Internal())
                                        &&
                                        (#[verifier::custom_err("cannot prove that the field `unmarshalled_tail` is preserved")] (::builtin::equal(post.unmarshalled_tail,
                                                        update_tmp_unmarshalled_tail)) &&
                                                #[verifier::custom_err("cannot prove that the field `truncated_journal` is preserved")] (::builtin::equal(post.truncated_journal,
                                                        update_tmp_truncated_journal)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_no_op_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                #[verifier::custom_err("cannot prove this condition holds")] (lbl.is_Internal()))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn initialize(post: Self,
                    truncated_journal: TruncatedJournal)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (truncated_journal.decodable())
                                &&
                                {
                                    let update_tmp_truncated_journal: TruncatedJournal =
                                        truncated_journal;
                                    let update_tmp_unmarshalled_tail: MsgHistory =
                                        MsgHistory::empty_history_at(truncated_journal.seq_end());
                                    (#[verifier::custom_err("cannot prove that final value of field `unmarshalled_tail` has this updated value")] (::builtin::equal(post.unmarshalled_tail,
                                                    update_tmp_unmarshalled_tail)) &&
                                            #[verifier::custom_err("cannot prove that final value of field `truncated_journal` has this updated value")] (::builtin::equal(post.truncated_journal,
                                                    update_tmp_truncated_journal)))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn initialize_enabled(truncated_journal: TruncatedJournal)
                    -> ::core::primitive::bool {
                    {

                        #[verifier::custom_err("cannot prove this condition holds")]
                        (truncated_journal.decodable())
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_by(pre: State, post: State, label: Label,
                    step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::read_for_recovery(depth) =>
                            Self::read_for_recovery(pre, post, label, depth),
                        Step::freeze_for_commit(depth) =>
                            Self::freeze_for_commit(pre, post, label, depth),
                        Step::query_end_lsn() =>
                            Self::query_end_lsn(pre, post, label),
                        Step::put() => Self::put(pre, post, label),
                        Step::discard_old(new_tj) =>
                            Self::discard_old(pre, post, label, new_tj),
                        Step::internal_journal_marshal(cut, addr) =>
                            Self::internal_journal_marshal(pre, post, label, cut, addr),
                        Step::internal_no_op() =>
                            Self::internal_no_op(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next(pre: State, post: State, label: Label)
                    -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                            Self::next_by(pre, post, label, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_strong_by(pre: State, post: State, label: Label,
                    step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::read_for_recovery(depth) =>
                            Self::read_for_recovery_strong(pre, post, label, depth),
                        Step::freeze_for_commit(depth) =>
                            Self::freeze_for_commit_strong(pre, post, label, depth),
                        Step::query_end_lsn() =>
                            Self::query_end_lsn_strong(pre, post, label),
                        Step::put() => Self::put_strong(pre, post, label),
                        Step::discard_old(new_tj) =>
                            Self::discard_old_strong(pre, post, label, new_tj),
                        Step::internal_journal_marshal(cut, addr) =>
                            Self::internal_journal_marshal_strong(pre, post, label, cut,
                                addr),
                        Step::internal_no_op() =>
                            Self::internal_no_op_strong(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_strong(pre: State, post: State, label: Label)
                    -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                            Self::next_strong_by(pre, post, label, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn init_by(post: State, step: Config)
                    -> ::core::primitive::bool {
                    match step {
                        Config::initialize(truncated_journal) =>
                            Self::initialize(post, truncated_journal),
                        Config::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn init(post: State) -> ::core::primitive::bool {
                    ::builtin::exists(|step: Config| Self::init_by(post, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::spec]
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                pub fn invariant(&self) -> ::core::primitive::bool {
                    self.inv()
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn inv(self) -> bool {
                    (self.wf()) && (self.truncated_journal.decodable())
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::custom_req_err("could not show invariant `inv` on the `post` state")]
                #[verifier::external_body]
                #[verus::internal(verus_macro)]
                #[verifier::proof]
                fn lemma_msg_inv(s: State) {
                    ::builtin::requires(s.inv());
                    ::builtin::ensures(s.inv());
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn read_for_recovery_inductive(pre: Self, post: Self,
                    lbl: Label, depth: nat) {
                    ::builtin::requires(pre.invariant() &&
                            State::read_for_recovery_strong(pre, post, lbl, depth));
                    ::builtin::ensures(post.invariant());
                    {}
                    Self::lemma_msg_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn freeze_for_commit_inductive(pre: Self, post: Self,
                    lbl: Label, depth: nat) {
                    ::builtin::requires(pre.invariant() &&
                            State::freeze_for_commit_strong(pre, post, lbl, depth));
                    ::builtin::ensures(post.invariant());
                    {}
                    Self::lemma_msg_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn query_end_lsn_inductive(pre: Self, post: Self,
                    lbl: Label) {
                    ::builtin::requires(pre.invariant() &&
                            State::query_end_lsn_strong(pre, post, lbl));
                    ::builtin::ensures(post.invariant());
                    {}
                    Self::lemma_msg_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn put_inductive(pre: Self, post: Self, lbl: Label) {
                    ::builtin::requires(pre.invariant() &&
                            State::put_strong(pre, post, lbl));
                    ::builtin::ensures(post.invariant());
                    {}
                    Self::lemma_msg_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn discard_old_inductive(pre: Self, post: Self, lbl: Label,
                    new_tj: TruncatedJournal) {
                    ::builtin::requires(pre.invariant() &&
                            State::discard_old_strong(pre, post, lbl, new_tj));
                    ::builtin::ensures(post.invariant());
                    {
                        let lsn = lbl.get_DiscardOld_start_lsn();
                        let post_discard = pre.truncated_journal.discard_old(lsn);
                        pre.truncated_journal.discard_old_decodable(lsn);
                        new_tj.disk_view.sub_disk_ranking(post_discard.disk_view);
                    }
                    Self::lemma_msg_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn internal_journal_marshal_inductive(pre: Self, post: Self,
                    lbl: Label, cut: LSN, addr: Address) {
                    ::builtin::requires(pre.invariant() &&
                            State::internal_journal_marshal_strong(pre, post, lbl, cut,
                                addr));
                    ::builtin::ensures(post.invariant());
                    {
                        ::builtin::assert_(post.truncated_journal.disk_view.valid_ranking(pre.truncated_journal.marshal_ranking(addr)));
                    }
                    Self::lemma_msg_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn internal_no_op_inductive(pre: Self, post: Self,
                    lbl: Label) {
                    ::builtin::requires(pre.invariant() &&
                            State::internal_no_op_strong(pre, post, lbl));
                    ::builtin::ensures(post.invariant());
                    {}
                    Self::lemma_msg_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn initialize_inductive(post: Self,
                    truncated_journal: TruncatedJournal) {
                    ::builtin::requires(Self::initialize(post,
                            truncated_journal));
                    ::builtin::ensures(post.invariant());
                    {}
                    Self::lemma_msg_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn wf(self) -> bool {
                    (((self.truncated_journal.wf()) &&
                                        (self.unmarshalled_tail.wf())) &&
                                ((self.truncated_journal.seq_start()).spec_le(self.truncated_journal.seq_end())))
                        &&
                        (::builtin::spec_eq(self.truncated_journal.seq_end(),
                                self.unmarshalled_tail.seq_start))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn seq_start(self) -> LSN {
                    self.truncated_journal.seq_start()
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn seq_end(self) -> LSN {
                    ::builtin::recommends([self.wf()]);
                    self.unmarshalled_tail.seq_end
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn unused_addr(self, addr: Address) -> bool {
                    !self.truncated_journal.disk_view.entries.contains_key(addr)
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn lbl_wf(lbl: Label) -> bool {
                    match lbl {
                        Label::ReadForRecovery { messages } => messages.wf(),
                        Label::FreezeForCommit { frozen_journal } =>
                            frozen_journal.decodable(),
                        _ => true,
                    }
                }
            }
        }
    }
    pub mod LinkedJournalRefinement_v {
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        use vstd::prelude::*;
        use vstd::calc_macro::*;
        use crate::abstract_system::StampedMap_v::LSN;
        use crate::abstract_system::MsgHistory_v::*;
        use crate::disk::GenericDisk_v::*;
        use crate::journal::PagedJournal_v;
        use crate::journal::PagedJournal_v::PagedJournal;
        use crate::journal::LinkedJournal_v;
        use crate::journal::LinkedJournal_v::*;
        #[verus::internal(verus_macro)]
        impl DiskView {
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn iptr_output_valid(self, ptr: Pointer) {
                ::builtin::requires([self.decodable(ptr), self.acyclic(),
                            self.block_in_bounds(ptr)]);
                ::builtin::ensures([::builtin::imply(self.iptr(ptr).is_Some(),
                                self.iptr(ptr).unwrap().valid(self.boundary_lsn))]);
                ::builtin::decreases((self.the_rank_of(ptr)));
                if ptr.is_Some() { self.iptr_output_valid(self.next(ptr)); }
            }
            #[verifier::spinoff_prover]
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn discard_interp(self, lsn: LSN, post: Self, ptr: Pointer) {
                ::builtin::requires([self.wf(), self.acyclic(),
                            (self.boundary_lsn).spec_le(lsn),
                            ::builtin::spec_eq(post, self.discard_old(lsn)),
                            self.block_in_bounds(ptr), post.block_in_bounds(ptr)]);
                ::builtin::ensures([post.acyclic(),
                            ::builtin::imply(self.iptr(ptr).is_Some(),
                                self.iptr(ptr).unwrap().valid(lsn)),
                            ::builtin::spec_eq(post.iptr(ptr),
                                PagedJournal_v::JournalRecord::discard_old_journal_rec(self.iptr(ptr),
                                    lsn))]);
                ::builtin::decreases((if ptr.is_Some() {
                                (self.the_ranking().spec_index(ptr.unwrap())).spec_add(::builtin::spec_literal_nat("1"))
                            } else { ::builtin::spec_literal_integer("0") }));
                self.iptr_output_valid(ptr);
                ::builtin::assert_(post.valid_ranking(self.the_ranking()));
                if ptr.is_Some() &&
                            (lsn).spec_lt(self.entries.spec_index(ptr.unwrap()).message_seq.seq_start)
                        {
                        self.discard_interp(lsn, post, post.next(ptr));
                    }
                if post.iptr(ptr).is_None() {
                        ::builtin::assert_(PagedJournal_v::JournalRecord::discard_old_journal_rec(self.iptr(ptr),
                                    lsn).is_None());
                    } else {
                       ::builtin::assert_(PagedJournal_v::JournalRecord::discard_old_journal_rec(self.iptr(ptr),
                                   lsn).is_Some());
                   }
                ::builtin::assert_(::builtin::ext_equal(post.iptr(ptr),
                        PagedJournal_v::JournalRecord::discard_old_journal_rec(self.iptr(ptr),
                            lsn)));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn sub_disk_ranking(self, big: DiskView) {
                ::builtin::requires([big.wf(), big.acyclic(), self.wf(),
                            self.is_sub_disk(big)]);
                ::builtin::ensures([self.acyclic()]);
                let ranking = big.the_ranking();
                ::builtin::assert_(::builtin::forall(|addr|
                            ::builtin::imply(#[verus::internal(trigger)] self.entries.contains_key(addr),
                                big.entries.dom().contains(addr))));
                ::builtin::assert_(self.valid_ranking(big.the_ranking()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn sub_disk_interp(self, big: DiskView, ptr: Pointer) {
                ::builtin::requires([big.wf(), big.acyclic(), self.wf(),
                            self.is_sub_disk(big),
                            ::builtin::spec_eq(self.boundary_lsn, big.boundary_lsn),
                            self.is_nondangling_pointer(ptr)]);
                ::builtin::ensures([self.acyclic(),
                            ::builtin::spec_eq(self.iptr(ptr), big.iptr(ptr))]);
                ::builtin::decreases((if ptr.is_Some() {
                                (self.the_ranking().spec_index(ptr.unwrap())).spec_add(::builtin::spec_literal_nat("1"))
                            } else { ::builtin::spec_literal_integer("0") }));
                ::builtin::assert_(big.valid_ranking(big.the_ranking()));
                self.sub_disk_ranking(big);
                if ptr.is_Some() {
                        ::builtin::assert_(self.entries.contains_key(ptr.unwrap()));
                        self.sub_disk_interp(big, big.next(ptr));
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn pointer_after_crop_commutes_with_interpretation(self,
                ptr: Pointer, bdy: LSN, depth: nat) {
                ::builtin::requires([self.decodable(ptr), self.acyclic(),
                            self.block_in_bounds(ptr),
                            ::builtin::spec_eq(bdy, self.boundary_lsn),
                            self.can_crop(ptr, depth),
                            self.pointer_after_crop(ptr, depth).is_Some()]);
                ::builtin::ensures([PagedJournal_v::JournalRecord::opt_rec_can_crop_head_records(self.iptr(ptr),
                                bdy, depth),
                            PagedJournal_v::JournalRecord::opt_rec_can_crop_head_records(self.iptr(ptr),
                                bdy, (depth).spec_add(::builtin::spec_literal_nat("1"))),
                            ::builtin::spec_eq(self.iptr(self.pointer_after_crop(ptr,
                                        depth)),
                                PagedJournal_v::JournalRecord::opt_rec_crop_head_records(self.iptr(ptr),
                                    bdy, depth))]);
                ::builtin::decreases((depth));
                self.iptr_output_valid(ptr);
                if ::builtin::spec_eq(::builtin::spec_literal_nat("0"), depth)
                        {
                        let pojr = self.iptr(ptr).unwrap().cropped_prior(bdy);
                        if !PagedJournal_v::JournalRecord::opt_rec_can_crop_head_records(pojr,
                                        bdy, ::builtin::spec_literal_integer("0")) {
                                ::builtin::assert_(false);
                            }
                    } else {
                       self.pointer_after_crop_commutes_with_interpretation(self.entries.spec_index(ptr.unwrap()).cropped_prior(bdy),
                           bdy,
                           ::builtin::spec_cast_integer::<_,
                                   nat>(((depth).spec_sub(::builtin::spec_literal_nat("1")))));
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn pointer_after_crop_commutes_with_interpretation_no_some(self,
                ptr: Pointer, depth: nat) {
                ::builtin::requires([self.decodable(ptr), self.acyclic(),
                            self.block_in_bounds(ptr), self.can_crop(ptr, depth)]);
                ::builtin::ensures([PagedJournal_v::JournalRecord::opt_rec_can_crop_head_records(self.iptr(ptr),
                                self.boundary_lsn, depth),
                            ::builtin::spec_eq(self.iptr(self.pointer_after_crop(ptr,
                                        depth)),
                                PagedJournal_v::JournalRecord::opt_rec_crop_head_records(self.iptr(ptr),
                                    self.boundary_lsn, depth))]);
                ::builtin::decreases((depth));
                self.iptr_output_valid(ptr);
                self.pointer_after_crop_ensures(ptr, depth);
                if (::builtin::spec_literal_nat("0")).spec_lt(depth) {
                        self.pointer_after_crop_commutes_with_interpretation_no_some(self.entries.spec_index(ptr.unwrap()).cropped_prior(self.boundary_lsn),
                            ::builtin::spec_cast_integer::<_,
                                    nat>(((depth).spec_sub(::builtin::spec_literal_nat("1")))));
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn discard_old_commutes(self, ptr: Pointer, new_bdy: LSN) {
                ::builtin::requires([self.decodable(ptr), self.acyclic(),
                            self.block_in_bounds(ptr),
                            (self.boundary_lsn).spec_le(new_bdy),
                            ::builtin::imply(ptr.is_Some(),
                                (new_bdy).spec_lt(self.entries.spec_index(ptr.unwrap()).message_seq.seq_end))]);
                ::builtin::ensures([self.discard_old(new_bdy).acyclic(),
                            ::builtin::imply(self.iptr(ptr).is_Some(),
                                self.iptr(ptr).unwrap().valid(new_bdy)),
                            ::builtin::spec_eq(PagedJournal_v::JournalRecord::discard_old_journal_rec(self.iptr(ptr),
                                    new_bdy), self.discard_old(new_bdy).iptr(ptr))]);
                ::builtin::decreases((self.the_rank_of(ptr)));
                self.iptr_output_valid(ptr);
                ::builtin::assert_(self.discard_old(new_bdy).valid_ranking(self.the_ranking()));
                if ptr.is_Some() {
                        let next_ptr =
                            self.entries.spec_index(ptr.unwrap()).cropped_prior(new_bdy);
                        self.iptr(ptr).unwrap().discard_valid(self.boundary_lsn,
                            new_bdy);
                        self.discard_old_commutes(next_ptr, new_bdy);
                    }
            }
            #[verifier::spinoff_prover]
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn iptr_framing(self, dv2: Self, ptr: Pointer) {
                ::builtin::requires([self.wf() && self.acyclic(),
                            dv2.wf() && dv2.acyclic(), self.is_nondangling_pointer(ptr),
                            self.is_sub_disk(dv2),
                            ::builtin::spec_eq(self.boundary_lsn, dv2.boundary_lsn)]);
                ::builtin::ensures([::builtin::spec_eq(self.iptr(ptr),
                                dv2.iptr(ptr))]);
                ::builtin::decreases((self.the_rank_of(ptr)));
                if ptr.is_Some() { self.iptr_framing(dv2, self.next(ptr)); }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn build_tight_is_awesome(self, root: Pointer) {
                ::builtin::requires([self.decodable(root), self.acyclic()]);
                ::builtin::ensures([self.build_tight(root).is_sub_disk(self),
                            self.build_tight(root).wf(),
                            self.build_tight(root).acyclic()]);
                ::builtin::decreases((self.the_rank_of(root),));
                if root.is_Some() {
                        self.build_tight_is_awesome(self.next(root));
                        ::builtin::assert_(self.build_tight(root).is_sub_disk(self));
                        self.build_tight(root).sub_disk_ranking(self);
                    }
                self.build_tight(root).sub_disk_ranking(self);
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn build_tight_maintains_interpretation(self, root: Pointer) {
                ::builtin::requires([self.decodable(root), self.acyclic()]);
                ::builtin::ensures([::builtin::spec_eq(self.iptr(root),
                                self.build_tight(root).iptr(root))]);
                ::builtin::decreases((self.the_rank_of(root),));
                self.build_tight_is_awesome(root);
                if root.is_Some() {
                        self.build_tight_maintains_interpretation(self.next(root));
                        self.build_tight(root).iptr_framing(self, self.next(root));
                        ::builtin::assert_(::builtin::ext_equal_deep(self.iptr(root),
                                self.build_tight(root).iptr(root)));
                    } else {
                       ::builtin::assert_(::builtin::ext_equal_deep(self.iptr(root),
                               self.build_tight(root).iptr(root)));
                   }
            }
        }
        #[verus::internal(verus_macro)]
        impl TruncatedJournal {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn next(self) -> Self {
                ::builtin::recommends([self.wf(),
                            self.freshest_rec.is_Some()]);
                Self {
                    freshest_rec: self.disk_view.next(self.freshest_rec),
                    ..self
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> PagedJournal_v::TruncatedJournal {
                ::builtin::recommends([self.decodable()]);
                PagedJournal_v::TruncatedJournal {
                    boundary_lsn: self.disk_view.boundary_lsn,
                    freshest_rec: self.disk_view.iptr(self.freshest_rec),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn iwf(self) {
                ::builtin::requires([self.decodable()]);
                ::builtin::ensures([self.i().wf()]);
                self.disk_view.iptr_output_valid(self.freshest_rec);
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn mkfs_refines() {
                ::builtin::ensures([Self::mkfs().disk_view.acyclic(),
                            ::builtin::ext_equal(Self::mkfs().i(),
                                PagedJournal_v::mkfs())]);
                ::builtin::assert_(Self::mkfs().disk_view.valid_ranking(::vstd::map::Map::empty()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn discard_old_decodable(self, new_bdy: LSN) {
                ::builtin::requires([self.decodable(),
                            self.can_discard_to(new_bdy)]);
                ::builtin::ensures([self.discard_old(new_bdy).decodable()]);
                ::builtin::assert_(self.disk_view.discard_old(new_bdy).valid_ranking(self.disk_view.the_ranking()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn discard_interp(self, lsn: LSN, post: Self) {
                ::builtin::requires([self.wf(), self.disk_view.acyclic(),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(self.seq_start()),
                                        lsn), self.seq_end())),
                            ::builtin::spec_eq(post, self.discard_old(lsn))]);
                ::builtin::ensures([post.disk_view.acyclic(),
                            ::builtin::spec_eq(self.i().discard_old_defn(lsn),
                                post.i())]);
                ::builtin::assert_(post.disk_view.valid_ranking(self.disk_view.the_ranking()));
                self.disk_view.discard_interp(lsn, post.disk_view,
                    post.freshest_rec);
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn discard_old_commutes(self, new_bdy: LSN) {
                ::builtin::requires([self.decodable(),
                            self.can_discard_to(new_bdy)]);
                ::builtin::ensures([self.discard_old(new_bdy).decodable(),
                            self.i().can_discard_to(new_bdy),
                            ::builtin::spec_eq(self.discard_old(new_bdy).i(),
                                self.i().discard_old_defn(new_bdy))]);
                ::builtin::assert_(self.disk_view.discard_old(new_bdy).valid_ranking(self.disk_view.the_ranking()));
                if (new_bdy).spec_lt(self.seq_end()) {
                        self.disk_view.discard_old_commutes(self.freshest_rec,
                            new_bdy);
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn commute_transitivity<L,
                H>(I: ::builtin::FnSpec<(L,), H>,
                f: ::builtin::FnSpec<(L,), L>, F: ::builtin::FnSpec<(H,), H>,
                g: ::builtin::FnSpec<(L,), L>,
                G: ::builtin::FnSpec<(H,), H>) {
                ::builtin::requires([::builtin::forall(|x|
                                    ::builtin::spec_eq(I(f(x)),
                                        #[verus::internal(trigger)] F(I(x)))),
                            ::builtin::forall(|x|
                                    ::builtin::spec_eq(I(g(x)),
                                        #[verus::internal(trigger)] G(I(x))))]);
                ::builtin::ensures([::builtin::forall(|x|
                                    ::builtin::spec_eq(I(g(f(x))),
                                        G(#[verus::internal(trigger)] F(I(x)))))]);
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn can_crop_monotonic(self, depth: nat, more: nat) {
                ::builtin::requires([(depth).spec_le(more),
                            self.can_crop(more)]);
                ::builtin::ensures([self.can_crop(depth)]);
                ::builtin::decreases((depth));
                if (::builtin::spec_literal_nat("0")).spec_lt(depth) {
                        self.next().can_crop_monotonic(::builtin::spec_cast_integer::<_,
                                    nat>(((depth).spec_sub(::builtin::spec_literal_nat("1")))),
                            ::builtin::spec_cast_integer::<_,
                                    nat>(((more).spec_sub(::builtin::spec_literal_nat("1")))));
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn crop_decreases_seq_end(self, depth: nat) {
                ::builtin::requires([self.can_crop(depth)]);
                ::builtin::ensures([::builtin::imply(::builtin::spec_eq(depth,
                                    ::builtin::spec_literal_nat("0")),
                                ::builtin::spec_eq(self.crop(depth).seq_end(),
                                    self.seq_end())),
                            ::builtin::imply((::builtin::spec_literal_nat("0")).spec_lt(depth),
                                (self.crop(depth).seq_end()).spec_lt(self.seq_end()))]);
                ::builtin::decreases((depth));
                if (::builtin::spec_literal_nat("0")).spec_lt(depth) {
                        self.can_crop_monotonic(::builtin::spec_cast_integer::<_,
                                    nat>(((depth).spec_sub(::builtin::spec_literal_nat("1")))),
                            depth);
                        self.next().crop_decreases_seq_end(::builtin::spec_cast_integer::<_,
                                    nat>(((depth).spec_sub(::builtin::spec_literal_nat("1")))));
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn linked_tj_can_crop_implies_paged_tj_can_crop(self,
                depth: nat) {
                ::builtin::requires([self.decodable(), self.can_crop(depth)]);
                ::builtin::ensures([self.i().can_crop(depth)]);
                ::builtin::decreases((depth));
                self.iwf();
                if (::builtin::spec_literal_nat("0")).spec_lt(depth) {
                        self.crop(::builtin::spec_literal_integer("1")).linked_tj_can_crop_implies_paged_tj_can_crop(::builtin::spec_cast_integer::<_,
                                    nat>(((depth).spec_sub(::builtin::spec_literal_nat("1")))));
                        let irec = self.i().freshest_rec.unwrap();
                        let bdy = self.i().boundary_lsn;
                        ::builtin::assert_(::builtin::spec_eq(self.crop(::builtin::spec_literal_integer("1")).freshest_rec,
                                self.disk_view.pointer_after_crop(self.disk_view.next(self.freshest_rec),
                                    ::builtin::spec_literal_integer("0"))));
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn paged_tj_can_crop_implies_linked_tj_can_crop(self,
                depth: nat) {
                ::builtin::requires([self.decodable(),
                            self.i().can_crop(depth)]);
                ::builtin::ensures([self.can_crop(depth)]);
                ::builtin::decreases((depth));
                if (::builtin::spec_literal_nat("0")).spec_lt(depth) {
                        self.next().paged_tj_can_crop_implies_linked_tj_can_crop(::builtin::spec_cast_integer::<_,
                                    nat>(((depth).spec_sub(::builtin::spec_literal_nat("1")))));
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn crop_head_composed_with_discard_old_commutes(self,
                new_bdy: LSN, depth: nat) {
                ::builtin::requires([self.decodable(), self.can_crop(depth),
                            self.crop(depth).can_discard_to(new_bdy)]);
                ::builtin::ensures([self.i().crop_head_records(depth).can_discard_to(new_bdy),
                            ::builtin::spec_eq(self.i().crop_head_records(depth).discard_old_defn(new_bdy),
                                self.crop(depth).discard_old(new_bdy).i())]);
                let dummy = Self::mkfs();
                let i =
                    ::builtin::closure_to_fn_spec(|tj:
                                LinkedJournal_v::TruncatedJournal|
                            if tj.decodable() { tj.i() } else { dummy.i() });
                let f =
                    ::builtin::closure_to_fn_spec(|tj:
                                LinkedJournal_v::TruncatedJournal|
                            if tj.decodable() && tj.can_crop(depth) {
                                    tj.crop(depth)
                                } else { dummy });
                let g =
                    ::builtin::closure_to_fn_spec(|tj:
                                LinkedJournal_v::TruncatedJournal|
                            if tj.decodable() && tj.can_discard_to(new_bdy) {
                                    tj.discard_old(new_bdy)
                                } else { dummy });
                let F =
                    ::builtin::closure_to_fn_spec(|itj:
                                PagedJournal_v::TruncatedJournal|
                            if PagedJournal_v::JournalRecord::opt_rec_can_crop_head_records(itj.freshest_rec,
                                        itj.boundary_lsn, depth) {
                                    itj.crop_head_records(depth)
                                } else { dummy.i() });
                let G =
                    ::builtin::closure_to_fn_spec(|itj:
                                PagedJournal_v::TruncatedJournal|
                            if itj.wf() && itj.can_discard_to(new_bdy) {
                                    itj.discard_old_defn(new_bdy)
                                } else { dummy.i() });
                Self::mkfs_refines();
                {
                    ::builtin::assert_forall_by(|tjx|
                            {
                                ::builtin::ensures(::builtin::spec_eq(i(f(tjx)),
                                        #[verus::internal(trigger)] F(i(tjx))));
                                if tjx.decodable() && tjx.can_crop(depth) {
                                        tjx.disk_view.pointer_after_crop_commutes_with_interpretation_no_some(tjx.freshest_rec,
                                            depth);
                                        tjx.crop_ensures(depth);
                                    } else {
                                       if tjx.decodable() {
                                               if tjx.i().can_crop(depth) {
                                                       tjx.paged_tj_can_crop_implies_linked_tj_can_crop(depth);
                                                   }
                                           }
                                   }
                            });
                }
                {
                    ::builtin::assert_forall_by(|tjx|
                            {
                                ::builtin::ensures(::builtin::spec_eq(i(g(tjx)),
                                        #[verus::internal(trigger)] G(i(tjx))));
                                if tjx.decodable() && tjx.can_discard_to(new_bdy) {
                                        tjx.discard_old_commutes(new_bdy);
                                        tjx.iwf();
                                    }
                            });
                }
                Self::commute_transitivity(i, f, F, g, G);
                self.crop_ensures(depth);
                self.crop(depth).discard_old_decodable(new_bdy);
                self.disk_view.pointer_after_crop_commutes_with_interpretation_no_some(self.freshest_rec,
                    depth);
                self.i().crop_head_records_ensures(depth);
                ::builtin::assert_(::builtin::spec_eq(G(F(i(self))),
                        self.i().crop_head_records(depth).discard_old_defn(new_bdy)));
                self.linked_tj_can_crop_implies_paged_tj_can_crop(depth);
                self.crop_decreases_seq_end(depth);
            }
        }
        #[verus::internal(verus_macro)]
        impl LinkedJournal::Label {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                match self {
                    Self::FreezeForCommit { frozen_journal } =>
                        frozen_journal.decodable(),
                    _ => true,
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> PagedJournal::Label {
                ::builtin::recommends([self.wf()]);
                match self {
                    Self::ReadForRecovery { messages } =>
                        PagedJournal::Label::ReadForRecovery { messages },
                    Self::FreezeForCommit { frozen_journal } =>
                        PagedJournal::Label::FreezeForCommit {
                            frozen_journal: frozen_journal.i(),
                        },
                    Self::QueryEndLsn { end_lsn } =>
                        PagedJournal::Label::QueryEndLsn { end_lsn },
                    Self::Put { messages } =>
                        PagedJournal::Label::Put { messages },
                    Self::DiscardOld { start_lsn, require_end } =>
                        PagedJournal::Label::DiscardOld { start_lsn, require_end },
                    Self::Internal {} => PagedJournal::Label::Internal {},
                }
            }
        }
        #[verus::internal(verus_macro)]
        impl LinkedJournal::State {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> PagedJournal::State {
                if self.wf() && self.truncated_journal.disk_view.acyclic() {
                        PagedJournal::State {
                            truncated_journal: self.truncated_journal.i(),
                            unmarshalled_tail: self.unmarshalled_tail,
                        }
                    } else { arbitrary() }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn iwf(self) {
                ::builtin::requires([self.wf(),
                            self.truncated_journal.disk_view.acyclic()]);
                ::builtin::ensures([self.i().wf()]);
                self.truncated_journal.iwf();
                ::builtin::assert_(self.i().truncated_journal.wf());
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn freeze_for_commit_refines(self, post: Self,
                lbl: LinkedJournal::Label, step: LinkedJournal::Step) {
                ::builtin::requires([self.inv(),
                            LinkedJournal::State::next_by(self, post, lbl, step),
                            step.is_freeze_for_commit()]);
                ::builtin::ensures([PagedJournal::State::next(self.i(),
                                post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PagedJournal::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PagedJournal::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(LinkedJournal::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                let new_bdy =
                    lbl.i().get_FreezeForCommit_frozen_journal().boundary_lsn;
                let depth = step.get_freeze_for_commit_0();
                let tj = self.truncated_journal;
                let tjd = self.truncated_journal.disk_view;
                tjd.pointer_after_crop_commutes_with_interpretation_no_some(tj.freshest_rec,
                    depth);
                tj.crop_head_composed_with_discard_old_commutes(new_bdy,
                    depth);
                let cropped_ptr =
                    tjd.pointer_after_crop(tj.freshest_rec, depth);
                let cropped_tj =
                    LinkedJournal_v::TruncatedJournal {
                        freshest_rec: cropped_ptr,
                        disk_view: tjd,
                    };
                tjd.pointer_after_crop_ensures(tj.freshest_rec, depth);
                lbl.get_FreezeForCommit_frozen_journal().iwf();
                self.i().truncated_journal.crop_head_records_wf_lemma(depth);
                ::builtin::assert_(PagedJournal::State::next_by(self.i(),
                        post.i(), lbl.i(),
                        PagedJournal::Step::freeze_for_commit(depth)));
            }
            #[doc =
            " NOTE(Jialin): temp creation just to expose submodule inv"]
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn inv_next(self, post: Self, lbl: LinkedJournal::Label,
                step: LinkedJournal::Step) {
                ::builtin::requires([self.inv(),
                            LinkedJournal::State::next_by(self, post, lbl, step)]);
                ::builtin::ensures([post.inv()]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PagedJournal::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PagedJournal::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(LinkedJournal::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                match step {
                    LinkedJournal::Step::discard_old(new_tj) => {
                        let lsn = lbl.get_DiscardOld_start_lsn();
                        let post_discard = self.truncated_journal.discard_old(lsn);
                        self.truncated_journal.discard_old_decodable(lsn);
                        new_tj.disk_view.sub_disk_ranking(post_discard.disk_view);
                    }
                    LinkedJournal::Step::internal_journal_marshal(cut, addr) =>
                        {
                        let rank = self.truncated_journal.disk_view.the_ranking();
                        let post_rank =
                            rank.insert(step.get_internal_journal_marshal_1(),
                                if self.truncated_journal.freshest_rec.is_None() {
                                        ::builtin::spec_literal_integer("0")
                                    } else {
                                       (rank.spec_index(self.truncated_journal.freshest_rec.unwrap())).spec_add(::builtin::spec_literal_nat("1"))
                                   });
                        ::builtin::assert_(post.truncated_journal.disk_view.valid_ranking(post_rank));
                    }
                    _ => {}
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn discard_old_refines(self, post: Self,
                lbl: LinkedJournal::Label, step: LinkedJournal::Step) {
                ::builtin::requires([self.inv(), post.inv(),
                            LinkedJournal::State::next_by(self, post, lbl, step),
                            step.is_discard_old()]);
                ::builtin::ensures([PagedJournal::State::next(self.i(),
                                post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PagedJournal::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PagedJournal::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(LinkedJournal::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                let lsn = lbl.get_DiscardOld_start_lsn();
                if !((self.unmarshalled_tail.seq_start).spec_le(lsn)) {
                        let cropped_tj = self.truncated_journal.discard_old(lsn);
                        self.truncated_journal.disk_view.discard_interp(lsn,
                            cropped_tj.disk_view, self.truncated_journal.freshest_rec);
                        post.truncated_journal.disk_view.sub_disk_interp(cropped_tj.disk_view,
                            cropped_tj.freshest_rec);
                    }
                ::builtin::assert_(PagedJournal::State::next_by(self.i(),
                        post.i(), lbl.i(), PagedJournal::Step::discard_old()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn next_refines(self, post: Self, lbl: LinkedJournal::Label) {
                ::builtin::requires([self.inv(), post.inv(),
                            LinkedJournal::State::next(self, post, lbl)]);
                ::builtin::ensures([PagedJournal::State::next(self.i(),
                                post.i(), lbl.i())]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PagedJournal::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(PagedJournal::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(LinkedJournal::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(LinkedJournal::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                let step =
                    ::builtin::choose(|step|
                            LinkedJournal::State::next_by(self, post, lbl, step));
                match step {
                    LinkedJournal::Step::read_for_recovery(depth) => {
                        let tj = self.truncated_journal;
                        let tjd = self.truncated_journal.disk_view;
                        tjd.pointer_after_crop_commutes_with_interpretation(tj.freshest_rec,
                            tjd.boundary_lsn, depth);
                        tjd.pointer_after_crop_ensures(tj.freshest_rec, depth);
                        ::builtin::assert_(PagedJournal::State::next_by(self.i(),
                                post.i(), lbl.i(),
                                PagedJournal::Step::read_for_recovery(depth)));
                    }
                    LinkedJournal::Step::freeze_for_commit(depth) => {
                        self.freeze_for_commit_refines(post, lbl, step);
                    }
                    LinkedJournal::Step::query_end_lsn() => {
                        ::builtin::assert_(PagedJournal::State::next_by(self.i(),
                                post.i(), lbl.i(), PagedJournal::Step::query_end_lsn()));
                    }
                    LinkedJournal::Step::put() => {
                        ::builtin::assert_(PagedJournal::State::next_by(self.i(),
                                post.i(), lbl.i(), PagedJournal::Step::put()));
                    }
                    LinkedJournal::Step::discard_old(_) => {
                        self.discard_old_refines(post, lbl, step);
                    }
                    LinkedJournal::Step::internal_journal_marshal(cut, addr) =>
                        {
                        self.truncated_journal.disk_view.iptr_framing(post.truncated_journal.disk_view,
                            self.truncated_journal.freshest_rec);
                        ::builtin::assert_(PagedJournal::State::next_by(self.i(),
                                post.i(), lbl.i(),
                                PagedJournal::Step::internal_journal_marshal(cut)));
                    }
                    LinkedJournal::Step::internal_no_op() => {
                        ::builtin::assert_(PagedJournal::State::next_by(self.i(),
                                post.i(), lbl.i(), PagedJournal::Step::internal_no_op()));
                    }
                    _ => { ::builtin::assert_(false); }
                }
            }
        }
    }
    pub mod LikesJournal_v {
        #![allow(unused_imports)]
        use builtin::*;
        use vstd::prelude::*;
        use vstd::{map::*, multiset::*};
        use vstd::math;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        use crate::abstract_system::StampedMap_v::LSN;
        use crate::abstract_system::MsgHistory_v::*;
        use crate::journal::LinkedJournal_v;
        use crate::journal::LinkedJournal_v::TruncatedJournal;
        use crate::journal::LinkedJournal_v::DiskView;
        use crate::disk::GenericDisk_v::*;
        use crate::allocation_layer::Likes_v::*;
        #[verus::internal(verus_macro)]
        impl TruncatedJournal { }
        type LsnAddrIndex = Map<LSN, Address>;
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn lsn_disjoint(lsn_index: Set<LSN>, msgs: MsgHistory) -> bool {
            ::builtin::forall(|lsn|
                    ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(msgs.seq_start),
                                    lsn), msgs.seq_end)), !lsn_index.contains(lsn)))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn lsn_addr_index_discard_up_to(lsn_addr_index: LsnAddrIndex,
            bdy: LSN) -> LsnAddrIndex {
            Map::new(::builtin::closure_to_fn_spec(|k|
                        lsn_addr_index.contains_key(k) && (bdy).spec_le(k)),
                ::builtin::closure_to_fn_spec(|k|
                        lsn_addr_index.spec_index(k)))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lsn_addr_index_discard_up_to_ensures(lsn_addr_index:
                LsnAddrIndex, bdy: LSN) {
            ::builtin::ensures([({
                                let out = lsn_addr_index_discard_up_to(lsn_addr_index, bdy);
                                (((out).spec_le(lsn_addr_index)) &&
                                            (::builtin::forall(|k|
                                                        ::builtin::imply(out.contains_key(k), (bdy).spec_le(k)))))
                                    &&
                                    (::builtin::forall(|k|
                                                ::builtin::imply(lsn_addr_index.contains_key(k) &&
                                                        (bdy).spec_le(k), out.contains_key(k))))
                            })]);
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn singleton_index(start: LSN, end: LSN, value: Address)
            -> LsnAddrIndex {
            Map::new(::builtin::closure_to_fn_spec(|x: LSN|
                        ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(start),
                                    x), end))), ::builtin::closure_to_fn_spec(|x: LSN| value))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn lsn_addr_index_append_record(lsn_addr_index: LsnAddrIndex,
            msgs: MsgHistory, addr: Address) -> LsnAddrIndex {
            ::builtin::recommends([msgs.wf(),
                        (msgs.seq_start).spec_lt(msgs.seq_end)]);
            let update = singleton_index(msgs.seq_start, msgs.seq_end, addr);
            lsn_addr_index.union_prefer_right(update)
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lsn_addr_index_append_record_ensures(lsn_addr_index:
                LsnAddrIndex, msgs: MsgHistory, addr: Address) {
            ::builtin::requires([msgs.wf(),
                        (msgs.seq_start).spec_lt(msgs.seq_end)]);
            ::builtin::ensures([::builtin::imply(lsn_disjoint(lsn_addr_index.dom(),
                                msgs),
                            ::builtin::spec_eq(lsn_addr_index_append_record(lsn_addr_index,
                                        msgs, addr).values(),
                                (lsn_addr_index.values()).spec_add(::vstd::set::Set::empty().insert(addr))))]);
            let out =
                lsn_addr_index_append_record(lsn_addr_index, msgs, addr);
            if lsn_disjoint(lsn_addr_index.dom(), msgs) {
                    let sum =
                        (lsn_addr_index.values()).spec_add(::vstd::set::Set::empty().insert(addr));
                    {
                        ::builtin::assert_forall_by(|a|
                                {
                                    ::builtin::requires(#[verus::internal(trigger)] sum.contains(a));
                                    ::builtin::ensures(out.values().contains(a));
                                    if lsn_addr_index.values().contains(a) {
                                            let lsn =
                                                ::builtin::choose(|lsn|
                                                        #[verus::internal(auto_trigger)] (lsn_addr_index.contains_key(lsn)
                                                                && ::builtin::spec_eq(lsn_addr_index.spec_index(lsn), a)));
                                            ::builtin::assert_(out.contains_key(lsn));
                                        } else {
                                           ::builtin::assert_(out.contains_key(msgs.seq_start));
                                       }
                                });
                    };
                    ::builtin::assert_(::builtin::ext_equal(out.values(),
                            (lsn_addr_index.values()).spec_add(::vstd::set::Set::empty().insert(addr))));
                }
        }
        #[verus::internal(verus_macro)]
        impl DiskView {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn buildable(self, root: Pointer) -> bool {
                ((self.decodable(root)) && (self.acyclic())) &&
                    (::builtin::imply(root.is_Some(),
                            (self.boundary_lsn).spec_lt(self.entries.spec_index(root.unwrap()).message_seq.seq_end)))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn build_lsn_addr_index(self, root: Pointer) -> LsnAddrIndex {
                ::builtin::recommends([self.buildable(root)]);
                ::builtin::decreases((self.the_rank_of(root)));
                ::builtin::decreases_when(self.decodable(root) &&
                        self.acyclic());
                if root.is_None() {
                        ::vstd::map::Map::empty()
                    } else {
                       let curr_msgs =
                           self.entries.spec_index(root.unwrap()).message_seq;
                       let start_lsn =
                           ::builtin::spec_cast_integer::<_,
                                   nat>(math::max(::builtin::spec_cast_integer::<_,
                                           int>(self.boundary_lsn),
                                   ::builtin::spec_cast_integer::<_,
                                           int>(curr_msgs.seq_start)));
                       let update =
                           singleton_index(start_lsn, curr_msgs.seq_end,
                               root.unwrap());
                       self.build_lsn_addr_index(self.next(root)).union_prefer_right(update)
                   }
            }
        }
        #[verus::internal(verus_macro)]
        impl DiskView {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn addr_supports_lsn(self, addr: Address, lsn: LSN) -> bool {
                (self.entries.contains_key(addr)) &&
                    (self.entries.spec_index(addr).contains_lsn(self.boundary_lsn,
                            lsn))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            fn build_lsn_addr_index_ignores_build_tight(self,
                bt_root: Pointer, repr_root: Pointer) {
                ::builtin::requires([self.buildable(repr_root),
                            self.decodable(bt_root),
                            self.build_tight(bt_root).decodable(repr_root)]);
                ::builtin::ensures([self.build_tight(bt_root).wf(),
                            self.build_tight(bt_root).acyclic(),
                            ::builtin::imply(repr_root.is_Some(),
                                (self.boundary_lsn).spec_lt(self.build_tight(bt_root).entries.spec_index(repr_root.unwrap()).message_seq.seq_end)),
                            ::builtin::spec_eq(self.build_lsn_addr_index(repr_root),
                                self.build_tight(bt_root).build_lsn_addr_index(repr_root))]);
                ::builtin::decreases((self.the_rank_of(repr_root)));
                self.build_tight_is_awesome(bt_root);
                if repr_root.is_Some() {
                        self.build_lsn_addr_index_ignores_build_tight(bt_root,
                            self.next(repr_root));
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(spec(checked))]
            fn cropped_msg_seq_contains_lsn(boundary: LSN,
                message_seq: MsgHistory, lsn: LSN) -> bool {
                ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(max(::builtin::spec_cast_integer::<_,
                                            int>(boundary),
                                    ::builtin::spec_cast_integer::<_,
                                            int>(message_seq.seq_start))), lsn), message_seq.seq_end))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn tj_at(self, root: Pointer) -> TruncatedJournal {
                TruncatedJournal { freshest_rec: root, disk_view: self }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn build_lsn_addr_index_domain_valid(self, root: Pointer) {
                ::builtin::requires([self.decodable(root), self.acyclic(),
                            root.is_Some(),
                            (self.boundary_lsn).spec_lt(self.entries.spec_index(root.unwrap()).message_seq.seq_end)]);
                ::builtin::ensures([self.tj_at(root).index_domain_valid(self.build_lsn_addr_index(root)),
                            self.index_keys_map_to_valid_entries(self.build_lsn_addr_index(root))]);
                ::builtin::decreases((self.the_rank_of(root)));
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(TruncatedJournal::index_domain_valid)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(DiskView::index_keys_map_to_valid_entries)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                if self.next(root).is_None() {
                        let curr_msgs =
                            self.entries.spec_index(root.unwrap()).message_seq;
                        let start_lsn =
                            ::builtin::spec_cast_integer::<_,
                                    nat>(math::max(::builtin::spec_cast_integer::<_,
                                            int>(self.boundary_lsn),
                                    ::builtin::spec_cast_integer::<_,
                                            int>(curr_msgs.seq_start)));
                        let update =
                            singleton_index(start_lsn, curr_msgs.seq_end,
                                root.unwrap());
                        let output =
                            self.build_lsn_addr_index(self.next(root)).union_prefer_right(update);
                    } else {
                       self.build_lsn_addr_index_domain_valid(self.next(root));
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            fn build_lsn_addr_index_range_valid(self, root: Pointer) {
                ::builtin::requires([self.buildable(root),
                            self.tj_at(root).index_domain_valid(self.build_lsn_addr_index(root)),
                            self.index_keys_map_to_valid_entries(self.build_lsn_addr_index(root))]);
                ::builtin::ensures([self.tj_at(root).index_range_valid(self.build_lsn_addr_index(root))]);
                ::builtin::decreases((self.the_rank_of(root)));
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(TruncatedJournal::index_domain_valid)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(DiskView::index_keys_map_to_valid_entries)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                if root.is_None() {
                        ::builtin::assert_(self.tj_at(root).index_range_valid(self.build_lsn_addr_index(root)));
                    } else if self.next(root).is_None() {
                       ::builtin::assert_(self.tj_at(root).index_range_valid(self.build_lsn_addr_index(root)));
                   } else {
                       self.build_lsn_addr_index_domain_valid(self.next(root));
                       self.build_lsn_addr_index_range_valid(self.next(root));
                       let tj = self.tj_at(root);
                       let sub_index = self.build_lsn_addr_index(self.next(root));
                       let index = self.build_lsn_addr_index(root);
                       {
                           ::builtin::assert_forall_by(|addr|
                                   {
                                       ::builtin::requires(index.values().contains(addr));
                                       ::builtin::ensures(tj.every_lsn_at_addr_indexed_to_addr(index,
                                               addr));
                                       if !::builtin::spec_eq(addr, root.unwrap()) {
                                               ::builtin::assert_(sub_index.values().contains(addr));
                                           }
                                   });
                       }
                       ::builtin::assert_(self.tj_at(root).index_range_valid(self.build_lsn_addr_index(root)));
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn build_tight_domain_is_build_lsn_addr_index_range(self,
                root: Pointer) {
                ::builtin::requires([self.buildable(root)]);
                ::builtin::ensures([::builtin::imply(root.is_Some(),
                                ::builtin::forall(|lsn|
                                        ::builtin::imply(self.build_lsn_addr_index(root).contains_key(lsn),
                                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(self.boundary_lsn),
                                                        lsn),
                                                    self.entries.spec_index(root.unwrap()).message_seq.seq_end))))),
                            ::builtin::ext_equal(self.build_lsn_addr_index(root).values(),
                                self.build_tight(root).entries.dom())]);
                ::builtin::decreases((self.the_rank_of(root)));
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(TruncatedJournal::index_domain_valid)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(DiskView::index_keys_map_to_valid_entries)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                if root.is_Some() {
                        self.build_tight_domain_is_build_lsn_addr_index_range(self.next(root));
                        let curr_msgs =
                            self.entries.spec_index(root.unwrap()).message_seq;
                        let begin =
                            ::builtin::spec_cast_integer::<_,
                                    nat>(max(::builtin::spec_cast_integer::<_,
                                            int>(self.boundary_lsn),
                                    ::builtin::spec_cast_integer::<_,
                                            int>(curr_msgs.seq_start)));
                        let update =
                            singleton_index(begin, curr_msgs.seq_end, root.unwrap());
                        ::builtin::assert_(update.contains_key(begin));
                        {
                            ::builtin::assert_forall_by(|k|
                                    {
                                        ::builtin::requires(#[verus::internal(auto_trigger)] self.build_lsn_addr_index(root).values().contains(k));
                                        ::builtin::ensures(self.build_tight(root).entries.dom().contains(k));
                                    });
                        }
                        self.build_tight_ensures(root);
                        {
                            ::builtin::assert_forall_by(|addr|
                                    {
                                        ::builtin::requires(#[verus::internal(auto_trigger)] self.build_tight(root).entries.dom().contains(addr));
                                        ::builtin::ensures(self.build_lsn_addr_index(root).values().contains(addr));
                                        let left_index =
                                            self.build_lsn_addr_index(self.entries.spec_index(root.unwrap()).cropped_prior(self.boundary_lsn));
                                        if update.values().contains(addr) {
                                                ::builtin::assert_(self.build_lsn_addr_index(root).contains_key(begin));
                                            } else {
                                               let lsn =
                                                   ::builtin::choose(|lsn|
                                                           #[verus::internal(auto_trigger)] (left_index.contains_key(lsn)
                                                                   && ::builtin::spec_eq(left_index.spec_index(lsn), addr)));
                                               ::builtin::assert_(self.build_lsn_addr_index(root).contains_key(lsn));
                                           }
                                    });
                        }
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            fn sub_disk_with_newer_lsn_repr_index(self, big: DiskView,
                ptr: Pointer) {
                ::builtin::requires([self.decodable(ptr), self.acyclic(),
                            big.decodable(ptr), big.acyclic(),
                            ::builtin::imply(::builtin::is_variant(ptr, "Some"),
                                (self.boundary_lsn).spec_lt(self.entries.spec_index(ptr.unwrap()).message_seq.seq_end)),
                            ::builtin::imply(::builtin::is_variant(ptr, "Some"),
                                (big.boundary_lsn).spec_lt(big.entries.spec_index(ptr.unwrap()).message_seq.seq_end)),
                            self.is_sub_disk_with_newer_lsn(big)]);
                ::builtin::ensures([(self.build_lsn_addr_index(ptr)).spec_le(big.build_lsn_addr_index(ptr))]);
                ::builtin::decreases((self.the_rank_of(ptr)));
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(TruncatedJournal::index_domain_valid)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(DiskView::index_keys_map_to_valid_entries)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                if ::builtin::is_variant(ptr, "Some") {
                        self.sub_disk_with_newer_lsn_repr_index(big,
                            self.next(ptr));
                        if ::builtin::is_variant(self.next(ptr), "Some") {
                                self.build_lsn_addr_index_domain_valid(self.next(ptr));
                            }
                        if ::builtin::is_variant(big.next(ptr), "Some") {
                                big.build_lsn_addr_index_domain_valid(big.next(ptr));
                            }
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn sub_disk_repr_index(self, big: Self, ptr: Pointer) {
                ::builtin::requires([self.wf(), big.wf(), big.acyclic(),
                            self.is_sub_disk(big), self.is_nondangling_pointer(ptr),
                            ::builtin::imply(ptr.is_Some(),
                                (self.boundary_lsn).spec_lt(self.entries.spec_index(ptr.unwrap()).message_seq.seq_end))]);
                ::builtin::ensures([::builtin::spec_eq(self.build_lsn_addr_index(ptr),
                                big.build_lsn_addr_index(ptr))]);
                ::builtin::decreases((if ptr.is_Some() {
                                (big.the_ranking().spec_index(ptr.unwrap())).spec_add(::builtin::spec_literal_nat("1"))
                            } else { ::builtin::spec_literal_integer("0") }));
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(TruncatedJournal::index_domain_valid)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(DiskView::index_keys_map_to_valid_entries)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::assert_(::builtin::forall(|addr|
                            ::builtin::imply(#[verus::internal(trigger)] self.entries.contains_key(addr),
                                big.entries.dom().contains(addr))));
                ::builtin::assert_(self.valid_ranking(big.the_ranking()));
                if ptr.is_Some() {
                        if big.next(ptr).is_Some() {
                                ::builtin::assert_(big.entries.contains_key(ptr.unwrap()));
                                ::builtin::assert_((big.the_ranking().spec_index(big.next(ptr).unwrap())).spec_lt(big.the_ranking().spec_index(ptr.unwrap())));
                            }
                        self.sub_disk_repr_index(big, big.next(ptr));
                    }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn build_lsn_addr_all_decodable(self, root: Pointer) {
                ::builtin::requires([self.buildable(root)]);
                ::builtin::ensures([::builtin::forall(|lsn|
                                    #[verus::internal(auto_trigger)] (::builtin::imply(self.build_lsn_addr_index(root).contains_key(lsn),
                                            self.decodable(Some(self.build_lsn_addr_index(root).spec_index(lsn))))))]);
                ::builtin::decreases((self.the_rank_of(root)));
                let lsn_addr_index = self.build_lsn_addr_index(root);
                if root.is_None()
                        {} else {
                       self.build_lsn_addr_all_decodable(self.next(root));
                       {
                           ::builtin::assert_forall_by(|lsn|
                                   {
                                       ::builtin::requires(#[verus::internal(auto_trigger)] lsn_addr_index.contains_key(lsn));
                                       ::builtin::ensures(self.decodable(Some(lsn_addr_index.spec_index(lsn))));
                                       if self.build_lsn_addr_index(self.next(root)).contains_key(lsn)
                                               {
                                               ::builtin::assert_(self.decodable(Some(lsn_addr_index.spec_index(lsn))));
                                           } else {
                                              ::builtin::assert_(::builtin::spec_eq(lsn_addr_index.spec_index(lsn),
                                                      root.unwrap()));
                                              ::builtin::assert_(self.decodable(Some(lsn_addr_index.spec_index(lsn))));
                                          }
                                   });
                       }
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn build_lsn_addr_honors_rank(self, root: Pointer,
                lsn_addr_index: Map<LSN, Address>) {
                ::builtin::requires([self.buildable(root),
                            ::builtin::spec_eq(lsn_addr_index,
                                self.build_lsn_addr_index(root))]);
                ::builtin::ensures([::builtin::forall(|lsn1, lsn2|
                                    #[verus::internal(auto_trigger)] (::builtin::imply(({
                                                    ((lsn_addr_index.contains_key(lsn1)) &&
                                                                (lsn_addr_index.contains_key(lsn2))) &&
                                                        ((lsn1).spec_le(lsn2))
                                                }),
                                            (self.the_rank_of(Some(lsn_addr_index.spec_index(lsn1)))).spec_le(self.the_rank_of(Some(lsn_addr_index.spec_index(lsn2)))))))]);
                ::builtin::decreases((self.the_rank_of(root)));
                self.build_lsn_addr_all_decodable(root);
                if root.is_None()
                        {} else if self.next(root).is_None()
                       {} else {
                       self.build_lsn_addr_index_domain_valid(root);
                       self.build_lsn_addr_index_domain_valid(self.next(root));
                       let prior_index =
                           self.build_lsn_addr_index(self.next(root));
                       self.build_lsn_addr_honors_rank(self.next(root),
                           prior_index);
                       {
                           ::builtin::assert_forall_by(|lsn1, lsn2|
                                   {
                                       ::builtin::requires(#[verus::internal(auto_trigger)] ({
                                                   ((lsn_addr_index.contains_key(lsn1)) &&
                                                               (lsn_addr_index.contains_key(lsn2))) &&
                                                       ((lsn1).spec_le(lsn2))
                                               }));
                                       ::builtin::ensures(({
                                                   ((self.decodable(Some(lsn_addr_index.spec_index(lsn1)))) &&
                                                               (self.decodable(Some(lsn_addr_index.spec_index(lsn2))))) &&
                                                       ((self.the_rank_of(Some(lsn_addr_index.spec_index(lsn1)))).spec_le(self.the_rank_of(Some(lsn_addr_index.spec_index(lsn2)))))
                                               }));
                                       let corner =
                                           self.entries.spec_index(self.next(root).unwrap()).message_seq.seq_end;
                                       let before =
                                           ::builtin::spec_cast_integer::<_,
                                                   nat>(((corner).spec_sub(::builtin::spec_literal_nat("1"))));
                                       if (lsn1).spec_lt(corner) {
                                               {
                                                   ::builtin::assert_by(prior_index.contains_key(before),
                                                       {
                                                           ::builtin::reveal_hide_({
                                                                   #[verus::internal(reveal_fn)]
                                                                   fn __VERUS_REVEAL_INTERNAL__() {
                                                                       ::builtin::reveal_hide_internal_path_(TruncatedJournal::index_domain_valid)
                                                                   }
                                                                   __VERUS_REVEAL_INTERNAL__
                                                               }, 1);
                                                       });
                                               }
                                           } else {
                                              {
                                                  ::builtin::assert_by(!prior_index.contains_key(lsn1) &&
                                                          !prior_index.contains_key(lsn2),
                                                      {
                                                          ::builtin::reveal_hide_({
                                                                  #[verus::internal(reveal_fn)]
                                                                  fn __VERUS_REVEAL_INTERNAL__() {
                                                                      ::builtin::reveal_hide_internal_path_(TruncatedJournal::index_domain_valid)
                                                                  }
                                                                  __VERUS_REVEAL_INTERNAL__
                                                              }, 1);
                                                      });
                                              }
                                          }
                                   });
                       }
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn index_reflects_disk_view(self,
                lsn_addr_index: LsnAddrIndex) -> bool {
                ::builtin::forall(|lsn|
                        ::builtin::imply(#[verus::internal(trigger)] lsn_addr_index.contains_key(lsn),
                            {
                                (self.entries.contains_key(lsn_addr_index.spec_index(lsn)))
                                    &&
                                    (self.entries.spec_index(lsn_addr_index.spec_index(lsn)).message_seq.contains(lsn))
                            }))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn build_lsn_addr_index_reflects_disk_view(self,
                root: Pointer) {
                ::builtin::requires([self.buildable(root)]);
                ::builtin::ensures([self.index_reflects_disk_view(self.build_lsn_addr_index(root))]);
                ::builtin::decreases((self.the_rank_of(root)));
                if ::builtin::is_variant(root, "Some") {
                        self.build_lsn_addr_index_reflects_disk_view(self.next(root))
                    }
            }
            #[verifier::opaque]
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec(checked))]
            pub fn index_keys_map_to_valid_entries(self,
                lsn_addr_index: LsnAddrIndex) -> bool {
                ::builtin::recommends([self.wf()]);
                ::builtin::forall(|lsn|
                        #[verus::internal(auto_trigger)] (::builtin::imply(lsn_addr_index.contains_key(lsn),
                                self.addr_supports_lsn(lsn_addr_index.spec_index(lsn),
                                    lsn))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn instantiate_index_keys_map_to_valid_entries(self,
                lsn_addr_index: LsnAddrIndex, lsn: LSN) {
                ::builtin::requires([self.wf(),
                            lsn_addr_index.contains_key(lsn),
                            self.index_keys_map_to_valid_entries(lsn_addr_index)]);
                ::builtin::ensures([self.entries.contains_key(lsn_addr_index.spec_index(lsn)),
                            self.entries.spec_index(lsn_addr_index.spec_index(lsn)).contains_lsn(self.boundary_lsn,
                                lsn)]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(DiskView::index_keys_map_to_valid_entries)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn map_to_likes(lsn_addr_map: LsnAddrIndex) -> Likes {
            ::builtin::decreases((lsn_addr_map.dom().len()));
            ::builtin::decreases_when(lsn_addr_map.dom().finite());
            if ::builtin::spec_eq(lsn_addr_map.dom().len(),
                        ::builtin::spec_literal_nat("0")) {
                    no_likes()
                } else {
                   let k = lsn_addr_map.dom().choose();
                   let sub_likes = map_to_likes(lsn_addr_map.remove(k));
                   Multiset::empty().insert(lsn_addr_map.spec_index(k)).add(sub_likes)
               }
        }
        #[verus::internal(verus_macro)]
        impl TruncatedJournal {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn build_lsn_addr_index(self) -> LsnAddrIndex {
                ::builtin::recommends([self.decodable()]);
                self.disk_view.build_lsn_addr_index(self.freshest_rec)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn transitive_likes(self) -> Likes {
                if !self.decodable() {
                        arbitrary()
                    } else {
                       Multiset::from_set(self.build_lsn_addr_index().values())
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn discard_old_cond(self, start_lsn: LSN,
                keep_addrs: Set<Address>, new: Self) -> bool {
                ::builtin::recommends([self.wf()]);
                ((((new.wf()) &&
                                            (::builtin::spec_eq(new.disk_view.boundary_lsn, start_lsn)))
                                    &&
                                    ((new.disk_view.entries).spec_le(self.disk_view.entries)))
                            &&
                            (::builtin::forall(|addr|
                                        ::builtin::imply(#[verus::internal(trigger)] keep_addrs.contains(addr),
                                            new.disk_view.entries.dom().contains(addr))))) &&
                    (::builtin::spec_eq(new.freshest_rec,
                            if ::builtin::spec_eq(self.seq_end(), start_lsn) {
                                    None
                                } else { self.freshest_rec }))
            }
        }
        #[verus::internal(verus_macro)]
        impl MsgHistory {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn tight_discard_old(self, new: Self, new_bdy: LSN) -> bool {
                ::builtin::recommends([self.wf(), new.wf(),
                            self.can_discard_to(new_bdy)]);
                let msgs =
                    if (self.seq_start).spec_le(new_bdy) {
                            self.discard_old(new_bdy)
                        } else { self };
                new.ext_equal(msgs)
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(spec(checked))]
        fn max(a: int, b: int) -> int { if (a).spec_lt(b) { b } else { a } }
        #[verus::internal(verus_macro)]
        impl TruncatedJournal {
            #[verifier::opaque]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn index_domain_valid(self, lsn_addr_index: LsnAddrIndex)
                -> bool {
                ::builtin::recommends([self.wf()]);
                ::builtin::forall(|lsn|
                        ::builtin::spec_eq((lsn_addr_index.contains_key(lsn)),
                            ((::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(self.seq_start()),
                                                lsn), self.seq_end()))))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            pub fn every_lsn_at_addr_indexed_to_addr(self,
                lsn_addr_index: LsnAddrIndex, addr: Address) -> bool {
                let msgs =
                    self.disk_view.entries.spec_index(addr).message_seq;
                let boundary_lsn = self.disk_view.boundary_lsn;
                ::builtin::forall(|lsn|
                        ::builtin::imply(#[verus::internal(trigger)] DiskView::cropped_msg_seq_contains_lsn(boundary_lsn,
                                msgs, lsn),
                            {
                                (lsn_addr_index.contains_key(lsn)) &&
                                    (::builtin::spec_eq(lsn_addr_index.spec_index(lsn), addr))
                            }))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            pub fn index_range_valid(self, lsn_addr_index: LsnAddrIndex)
                -> bool {
                ::builtin::recommends([self.wf(),
                            self.index_domain_valid(lsn_addr_index),
                            self.disk_view.index_keys_map_to_valid_entries(lsn_addr_index)]);
                ::builtin::forall(|addr|
                        ::builtin::imply(lsn_addr_index.values().contains(addr),
                            {
                                self.every_lsn_at_addr_indexed_to_addr(lsn_addr_index, addr)
                            }))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn build_lsn_addr_honors_rank(self,
                lsn_addr_index: Map<LSN, Address>) {
                ::builtin::requires([self.decodable(),
                            ::builtin::spec_eq(lsn_addr_index,
                                self.build_lsn_addr_index())]);
                ::builtin::ensures([::builtin::forall(|lsn1, lsn2|
                                    #[verus::internal(auto_trigger)] (::builtin::imply(({
                                                    ((lsn_addr_index.contains_key(lsn1)) &&
                                                                (lsn_addr_index.contains_key(lsn2))) &&
                                                        ((lsn1).spec_le(lsn2))
                                                }),
                                            (self.disk_view.the_rank_of(Some(lsn_addr_index.spec_index(lsn1)))).spec_le(self.disk_view.the_rank_of(Some(lsn_addr_index.spec_index(lsn2)))))))]);
                self.disk_view.build_lsn_addr_honors_rank(self.freshest_rec,
                    lsn_addr_index)
            }
        }
        #[allow(unused_parens)]
        pub mod LikesJournal {
            use super::*;
            #[verus::internal(verus_macro)]
            pub struct State {
                pub journal: LinkedJournal_v::LinkedJournal::State,
                pub lsn_addr_index: LsnAddrIndex,
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Step {
                read_for_recovery(nat),
                freeze_for_commit(nat),
                query_end_lsn(),
                put(LinkedJournal_v::LinkedJournal::State),
                discard_old(LinkedJournal_v::LinkedJournal::State),
                internal_journal_marshal(LSN, Address,
                    LinkedJournal_v::LinkedJournal::State),
                internal_no_op(),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Step {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_read_for_recovery(&self) -> bool {
                    ::builtin::is_variant(self, "read_for_recovery")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_read_for_recovery_0(self) -> nat {
                    ::builtin::get_variant_field(self, "read_for_recovery", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_freeze_for_commit(&self) -> bool {
                    ::builtin::is_variant(self, "freeze_for_commit")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_freeze_for_commit_0(self) -> nat {
                    ::builtin::get_variant_field(self, "freeze_for_commit", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_query_end_lsn(&self) -> bool {
                    ::builtin::is_variant(self, "query_end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_put(&self) -> bool {
                    ::builtin::is_variant(self, "put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_put_0(self)
                    -> LinkedJournal_v::LinkedJournal::State {
                    ::builtin::get_variant_field(self, "put", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_discard_old(&self) -> bool {
                    ::builtin::is_variant(self, "discard_old")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_discard_old_0(self)
                    -> LinkedJournal_v::LinkedJournal::State {
                    ::builtin::get_variant_field(self, "discard_old", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_internal_journal_marshal(&self) -> bool {
                    ::builtin::is_variant(self, "internal_journal_marshal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_journal_marshal_0(self) -> LSN {
                    ::builtin::get_variant_field(self,
                        "internal_journal_marshal", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_journal_marshal_1(self) -> Address {
                    ::builtin::get_variant_field(self,
                        "internal_journal_marshal", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_journal_marshal_2(self)
                    -> LinkedJournal_v::LinkedJournal::State {
                    ::builtin::get_variant_field(self,
                        "internal_journal_marshal", "2")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_internal_no_op(&self) -> bool {
                    ::builtin::is_variant(self, "internal_no_op")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Config {
                initialize(TruncatedJournal),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Config {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_initialize(&self) -> bool {
                    ::builtin::is_variant(self, "initialize")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_initialize_0(self) -> TruncatedJournal {
                    ::builtin::get_variant_field(self, "initialize", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[verus::internal(verus_macro)]
            pub enum Label {
                ReadForRecovery {
                    messages: MsgHistory,
                },
                FreezeForCommit {
                    frozen_journal: TruncatedJournal,
                },
                QueryEndLsn {
                    end_lsn: LSN,
                },
                Put {
                    messages: MsgHistory,
                },
                DiscardOld {
                    start_lsn: LSN,
                    require_end: LSN,
                },
                Internal {},
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Label {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_ReadForRecovery(&self) -> bool {
                    ::builtin::is_variant(self, "ReadForRecovery")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_ReadForRecovery_messages(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "ReadForRecovery",
                        "messages")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_FreezeForCommit(&self) -> bool {
                    ::builtin::is_variant(self, "FreezeForCommit")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_FreezeForCommit_frozen_journal(self)
                    -> TruncatedJournal {
                    ::builtin::get_variant_field(self, "FreezeForCommit",
                        "frozen_journal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_QueryEndLsn(&self) -> bool {
                    ::builtin::is_variant(self, "QueryEndLsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_QueryEndLsn_end_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "QueryEndLsn", "end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_Put(&self) -> bool {
                    ::builtin::is_variant(self, "Put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_Put_messages(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "Put", "messages")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_DiscardOld(&self) -> bool {
                    ::builtin::is_variant(self, "DiscardOld")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_DiscardOld_start_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "DiscardOld",
                        "start_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_DiscardOld_require_end(self) -> LSN {
                    ::builtin::get_variant_field(self, "DiscardOld",
                        "require_end")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_Internal(&self) -> bool {
                    ::builtin::is_variant(self, "Internal")
                }
            }
            pub mod show {
                use super::*;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn read_for_recovery(pre: super::State,
                    post: super::State, lbl: Label, depth: nat) {
                    ::builtin::requires(super::State::read_for_recovery(pre,
                            post, lbl, depth));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as read_for_recovery;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn freeze_for_commit(pre: super::State,
                    post: super::State, lbl: Label, depth: nat) {
                    ::builtin::requires(super::State::freeze_for_commit(pre,
                            post, lbl, depth));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as freeze_for_commit;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn query_end_lsn(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::query_end_lsn(pre, post,
                            lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as query_end_lsn;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn put(pre: super::State, post: super::State, lbl: Label,
                    new_journal: LinkedJournal_v::LinkedJournal::State) {
                    ::builtin::requires(super::State::put(pre, post, lbl,
                            new_journal));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as put;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn discard_old(pre: super::State, post: super::State,
                    lbl: Label,
                    new_journal: LinkedJournal_v::LinkedJournal::State) {
                    ::builtin::requires(super::State::discard_old(pre, post,
                            lbl, new_journal));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as discard_old;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn internal_journal_marshal(pre: super::State,
                    post: super::State, lbl: Label, cut: LSN, addr: Address,
                    new_journal: LinkedJournal_v::LinkedJournal::State) {
                    ::builtin::requires(super::State::internal_journal_marshal(pre,
                            post, lbl, cut, addr, new_journal));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as internal_journal_marshal;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn internal_no_op(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::internal_no_op(pre, post,
                            lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as internal_no_op;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn initialize(post: super::State,
                    ijournal: TruncatedJournal) {
                    ::builtin::requires(super::State::initialize(post,
                            ijournal));
                    ::builtin::ensures(super::State::init(post));
                }
                use bool as initialize;
            }
            pub mod take_step {
                use super::*;
            }
            #[verus::internal(verus_macro)]
            impl State {
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn read_for_recovery(pre: Self, post: Self, lbl: Label,
                    depth: nat) -> ::core::primitive::bool {
                    {
                        let update_tmp_journal:
                                LinkedJournal_v::LinkedJournal::State = pre.journal;
                        let update_tmp_lsn_addr_index: LsnAddrIndex =
                            pre.lsn_addr_index;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "ReadForRecovery")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal_v::LinkedJournal::State::next_by(pre.journal,
                                                pre.journal, State::lbl_i(lbl),
                                                LinkedJournal_v::LinkedJournal::Step::read_for_recovery(depth)))
                                        &&
                                        (#[verifier::custom_err("cannot prove that the field `lsn_addr_index` is preserved")] (::builtin::equal(post.lsn_addr_index,
                                                        update_tmp_lsn_addr_index)) &&
                                                #[verifier::custom_err("cannot prove that the field `journal` is preserved")] (::builtin::equal(post.journal,
                                                        update_tmp_journal)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn read_for_recovery_strong(pre: Self, post: Self,
                    lbl: Label, depth: nat) -> ::core::primitive::bool {
                    {
                        let update_tmp_journal:
                                LinkedJournal_v::LinkedJournal::State = pre.journal;
                        let update_tmp_lsn_addr_index: LsnAddrIndex =
                            pre.lsn_addr_index;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "ReadForRecovery")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal_v::LinkedJournal::State::next_by(pre.journal,
                                                pre.journal, State::lbl_i(lbl),
                                                LinkedJournal_v::LinkedJournal::Step::read_for_recovery(depth)))
                                        &&
                                        (#[verifier::custom_err("cannot prove that the field `lsn_addr_index` is preserved")] (::builtin::equal(post.lsn_addr_index,
                                                        update_tmp_lsn_addr_index)) &&
                                                #[verifier::custom_err("cannot prove that the field `journal` is preserved")] (::builtin::equal(post.journal,
                                                        update_tmp_journal)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn read_for_recovery_enabled(pre: Self, lbl: Label,
                    depth: nat) -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "ReadForRecovery")) &&
                                #[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal_v::LinkedJournal::State::next_by(pre.journal,
                                        pre.journal, State::lbl_i(lbl),
                                        LinkedJournal_v::LinkedJournal::Step::read_for_recovery(depth))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn freeze_for_commit(pre: Self, post: Self, lbl: Label,
                    depth: nat) -> ::core::primitive::bool {
                    {
                        let update_tmp_journal:
                                LinkedJournal_v::LinkedJournal::State = pre.journal;
                        let update_tmp_lsn_addr_index: LsnAddrIndex =
                            pre.lsn_addr_index;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "FreezeForCommit")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal_v::LinkedJournal::State::next_by(pre.journal,
                                                pre.journal, State::lbl_i(lbl),
                                                LinkedJournal_v::LinkedJournal::Step::freeze_for_commit(depth)))
                                        &&
                                        (#[verifier::custom_err("cannot prove that the field `lsn_addr_index` is preserved")] (::builtin::equal(post.lsn_addr_index,
                                                        update_tmp_lsn_addr_index)) &&
                                                #[verifier::custom_err("cannot prove that the field `journal` is preserved")] (::builtin::equal(post.journal,
                                                        update_tmp_journal)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn freeze_for_commit_strong(pre: Self, post: Self,
                    lbl: Label, depth: nat) -> ::core::primitive::bool {
                    {
                        let update_tmp_journal:
                                LinkedJournal_v::LinkedJournal::State = pre.journal;
                        let update_tmp_lsn_addr_index: LsnAddrIndex =
                            pre.lsn_addr_index;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "FreezeForCommit")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal_v::LinkedJournal::State::next_by(pre.journal,
                                                pre.journal, State::lbl_i(lbl),
                                                LinkedJournal_v::LinkedJournal::Step::freeze_for_commit(depth)))
                                        &&
                                        (#[verifier::custom_err("cannot prove that the field `lsn_addr_index` is preserved")] (::builtin::equal(post.lsn_addr_index,
                                                        update_tmp_lsn_addr_index)) &&
                                                #[verifier::custom_err("cannot prove that the field `journal` is preserved")] (::builtin::equal(post.journal,
                                                        update_tmp_journal)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn freeze_for_commit_enabled(pre: Self, lbl: Label,
                    depth: nat) -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "FreezeForCommit")) &&
                                #[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal_v::LinkedJournal::State::next_by(pre.journal,
                                        pre.journal, State::lbl_i(lbl),
                                        LinkedJournal_v::LinkedJournal::Step::freeze_for_commit(depth))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_end_lsn(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_journal:
                                LinkedJournal_v::LinkedJournal::State = pre.journal;
                        let update_tmp_lsn_addr_index: LsnAddrIndex =
                            pre.lsn_addr_index;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "QueryEndLsn")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal_v::LinkedJournal::State::next(pre.journal,
                                                pre.journal, State::lbl_i(lbl))) &&
                                        (#[verifier::custom_err("cannot prove that the field `lsn_addr_index` is preserved")] (::builtin::equal(post.lsn_addr_index,
                                                        update_tmp_lsn_addr_index)) &&
                                                #[verifier::custom_err("cannot prove that the field `journal` is preserved")] (::builtin::equal(post.journal,
                                                        update_tmp_journal)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_end_lsn_strong(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_journal:
                                LinkedJournal_v::LinkedJournal::State = pre.journal;
                        let update_tmp_lsn_addr_index: LsnAddrIndex =
                            pre.lsn_addr_index;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "QueryEndLsn")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal_v::LinkedJournal::State::next(pre.journal,
                                                pre.journal, State::lbl_i(lbl))) &&
                                        (#[verifier::custom_err("cannot prove that the field `lsn_addr_index` is preserved")] (::builtin::equal(post.lsn_addr_index,
                                                        update_tmp_lsn_addr_index)) &&
                                                #[verifier::custom_err("cannot prove that the field `journal` is preserved")] (::builtin::equal(post.journal,
                                                        update_tmp_journal)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_end_lsn_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "QueryEndLsn")) &&
                                #[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal_v::LinkedJournal::State::next(pre.journal,
                                        pre.journal, State::lbl_i(lbl))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put(pre: Self, post: Self, lbl: Label,
                    new_journal: LinkedJournal_v::LinkedJournal::State)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_lsn_addr_index: LsnAddrIndex =
                            pre.lsn_addr_index;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "Put")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal_v::LinkedJournal::State::next(pre.journal,
                                                new_journal, State::lbl_i(lbl))) &&
                                        {
                                            let update_tmp_journal:
                                                    LinkedJournal_v::LinkedJournal::State = new_journal;
                                            (#[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")] (::builtin::equal(post.journal,
                                                            update_tmp_journal)) &&
                                                    #[verifier::custom_err("cannot prove that the field `lsn_addr_index` is preserved")] (::builtin::equal(post.lsn_addr_index,
                                                            update_tmp_lsn_addr_index)))
                                        }))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put_strong(pre: Self, post: Self, lbl: Label,
                    new_journal: LinkedJournal_v::LinkedJournal::State)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_lsn_addr_index: LsnAddrIndex =
                            pre.lsn_addr_index;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "Put")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal_v::LinkedJournal::State::next(pre.journal,
                                                new_journal, State::lbl_i(lbl))) &&
                                        {
                                            let update_tmp_journal:
                                                    LinkedJournal_v::LinkedJournal::State = new_journal;
                                            (#[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")] (::builtin::equal(post.journal,
                                                            update_tmp_journal)) &&
                                                    #[verifier::custom_err("cannot prove that the field `lsn_addr_index` is preserved")] (::builtin::equal(post.lsn_addr_index,
                                                            update_tmp_lsn_addr_index)))
                                        }))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put_enabled(pre: Self, lbl: Label,
                    new_journal: LinkedJournal_v::LinkedJournal::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "Put")) &&
                                #[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal_v::LinkedJournal::State::next(pre.journal,
                                        new_journal, State::lbl_i(lbl))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn discard_old(pre: Self, post: Self, lbl: Label,
                    new_journal: LinkedJournal_v::LinkedJournal::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "DiscardOld")) &&
                                {
                                    let start_lsn = lbl.get_DiscardOld_start_lsn();
                                    let require_end = lbl.get_DiscardOld_require_end();
                                    (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(require_end,
                                                    pre.journal.seq_end())) &&
                                            (#[verifier::custom_err("cannot prove this condition holds")] (pre.journal.truncated_journal.can_discard_to(start_lsn))
                                                    &&
                                                    {
                                                        let lsn_addr_index_post =
                                                            lsn_addr_index_discard_up_to(pre.lsn_addr_index, start_lsn);
                                                        let keep_addrs = lsn_addr_index_post.values();
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.journal.truncated_journal.discard_old_cond(start_lsn,
                                                                        keep_addrs, new_journal.truncated_journal)) &&
                                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(new_journal.unmarshalled_tail,
                                                                                pre.journal.unmarshalled_tail.bounded_discard(start_lsn)))
                                                                        &&
                                                                        {
                                                                            let update_tmp_journal:
                                                                                    LinkedJournal_v::LinkedJournal::State = new_journal;
                                                                            let update_tmp_lsn_addr_index: LsnAddrIndex =
                                                                                lsn_addr_index_post;
                                                                            (#[verifier::custom_err("cannot prove that final value of field `lsn_addr_index` has this updated value")] (::builtin::equal(post.lsn_addr_index,
                                                                                            update_tmp_lsn_addr_index)) &&
                                                                                    #[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")] (::builtin::equal(post.journal,
                                                                                            update_tmp_journal)))
                                                                        }))
                                                    }))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn discard_old_strong(pre: Self, post: Self, lbl: Label,
                    new_journal: LinkedJournal_v::LinkedJournal::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "DiscardOld")) &&
                                {
                                    let start_lsn = lbl.get_DiscardOld_start_lsn();
                                    let require_end = lbl.get_DiscardOld_require_end();
                                    (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(require_end,
                                                    pre.journal.seq_end())) &&
                                            (#[verifier::custom_err("cannot prove this condition holds")] (pre.journal.truncated_journal.can_discard_to(start_lsn))
                                                    &&
                                                    {
                                                        let lsn_addr_index_post =
                                                            lsn_addr_index_discard_up_to(pre.lsn_addr_index, start_lsn);
                                                        let keep_addrs = lsn_addr_index_post.values();
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.journal.truncated_journal.discard_old_cond(start_lsn,
                                                                        keep_addrs, new_journal.truncated_journal)) &&
                                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(new_journal.unmarshalled_tail,
                                                                                pre.journal.unmarshalled_tail.bounded_discard(start_lsn)))
                                                                        &&
                                                                        {
                                                                            let update_tmp_journal:
                                                                                    LinkedJournal_v::LinkedJournal::State = new_journal;
                                                                            let update_tmp_lsn_addr_index: LsnAddrIndex =
                                                                                lsn_addr_index_post;
                                                                            (#[verifier::custom_err("cannot prove that final value of field `lsn_addr_index` has this updated value")] (::builtin::equal(post.lsn_addr_index,
                                                                                            update_tmp_lsn_addr_index)) &&
                                                                                    #[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")] (::builtin::equal(post.journal,
                                                                                            update_tmp_journal)))
                                                                        }))
                                                    }))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn discard_old_enabled(pre: Self, lbl: Label,
                    new_journal: LinkedJournal_v::LinkedJournal::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "DiscardOld")) &&
                                {
                                    let start_lsn = lbl.get_DiscardOld_start_lsn();
                                    let require_end = lbl.get_DiscardOld_require_end();
                                    (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(require_end,
                                                    pre.journal.seq_end())) &&
                                            (#[verifier::custom_err("cannot prove this condition holds")] (pre.journal.truncated_journal.can_discard_to(start_lsn))
                                                    &&
                                                    {
                                                        let lsn_addr_index_post =
                                                            lsn_addr_index_discard_up_to(pre.lsn_addr_index, start_lsn);
                                                        let keep_addrs = lsn_addr_index_post.values();
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.journal.truncated_journal.discard_old_cond(start_lsn,
                                                                        keep_addrs, new_journal.truncated_journal)) &&
                                                                #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(new_journal.unmarshalled_tail,
                                                                        pre.journal.unmarshalled_tail.bounded_discard(start_lsn))))
                                                    }))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_journal_marshal(pre: Self, post: Self,
                    lbl: Label, cut: LSN, addr: Address,
                    new_journal: LinkedJournal_v::LinkedJournal::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "Internal")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal_v::LinkedJournal::State::next_by(pre.journal,
                                                new_journal, State::lbl_i(lbl),
                                                LinkedJournal_v::LinkedJournal::Step::internal_journal_marshal(cut,
                                                    addr))) &&
                                        {
                                            let update_tmp_journal:
                                                    LinkedJournal_v::LinkedJournal::State = new_journal;
                                            let update_tmp_lsn_addr_index: LsnAddrIndex =
                                                lsn_addr_index_append_record(pre.lsn_addr_index,
                                                    pre.journal.unmarshalled_tail.discard_recent(cut), addr);
                                            (#[verifier::custom_err("cannot prove that final value of field `lsn_addr_index` has this updated value")] (::builtin::equal(post.lsn_addr_index,
                                                            update_tmp_lsn_addr_index)) &&
                                                    #[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")] (::builtin::equal(post.journal,
                                                            update_tmp_journal)))
                                        }))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_journal_marshal_strong(pre: Self, post: Self,
                    lbl: Label, cut: LSN, addr: Address,
                    new_journal: LinkedJournal_v::LinkedJournal::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "Internal")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal_v::LinkedJournal::State::next_by(pre.journal,
                                                new_journal, State::lbl_i(lbl),
                                                LinkedJournal_v::LinkedJournal::Step::internal_journal_marshal(cut,
                                                    addr))) &&
                                        {
                                            let update_tmp_journal:
                                                    LinkedJournal_v::LinkedJournal::State = new_journal;
                                            let update_tmp_lsn_addr_index: LsnAddrIndex =
                                                lsn_addr_index_append_record(pre.lsn_addr_index,
                                                    pre.journal.unmarshalled_tail.discard_recent(cut), addr);
                                            (#[verifier::custom_err("cannot prove that final value of field `lsn_addr_index` has this updated value")] (::builtin::equal(post.lsn_addr_index,
                                                            update_tmp_lsn_addr_index)) &&
                                                    #[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")] (::builtin::equal(post.journal,
                                                            update_tmp_journal)))
                                        }))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_journal_marshal_enabled(pre: Self, lbl: Label,
                    cut: LSN, addr: Address,
                    new_journal: LinkedJournal_v::LinkedJournal::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "Internal")) &&
                                #[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal_v::LinkedJournal::State::next_by(pre.journal,
                                        new_journal, State::lbl_i(lbl),
                                        LinkedJournal_v::LinkedJournal::Step::internal_journal_marshal(cut,
                                            addr))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_no_op(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_journal:
                                LinkedJournal_v::LinkedJournal::State = pre.journal;
                        let update_tmp_lsn_addr_index: LsnAddrIndex =
                            pre.lsn_addr_index;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "Internal")) &&
                                (#[verifier::custom_err("cannot prove that the field `lsn_addr_index` is preserved")] (::builtin::equal(post.lsn_addr_index,
                                                update_tmp_lsn_addr_index)) &&
                                        #[verifier::custom_err("cannot prove that the field `journal` is preserved")] (::builtin::equal(post.journal,
                                                update_tmp_journal))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_no_op_strong(pre: Self, post: Self,
                    lbl: Label) -> ::core::primitive::bool {
                    {
                        let update_tmp_journal:
                                LinkedJournal_v::LinkedJournal::State = pre.journal;
                        let update_tmp_lsn_addr_index: LsnAddrIndex =
                            pre.lsn_addr_index;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "Internal")) &&
                                (#[verifier::custom_err("cannot prove that the field `lsn_addr_index` is preserved")] (::builtin::equal(post.lsn_addr_index,
                                                update_tmp_lsn_addr_index)) &&
                                        #[verifier::custom_err("cannot prove that the field `journal` is preserved")] (::builtin::equal(post.journal,
                                                update_tmp_journal))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_no_op_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {

                        #[verifier::custom_err("cannot prove this condition holds")]
                        (::builtin::is_variant(lbl, "Internal"))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn initialize(post: Self, ijournal: TruncatedJournal)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (ijournal.decodable())
                                &&
                                {
                                    let update_tmp_journal:
                                            LinkedJournal_v::LinkedJournal::State =
                                        LinkedJournal_v::LinkedJournal::State {
                                            truncated_journal: ijournal,
                                            unmarshalled_tail: MsgHistory::empty_history_at(ijournal.seq_end()),
                                        };
                                    let update_tmp_lsn_addr_index: LsnAddrIndex =
                                        ijournal.build_lsn_addr_index();
                                    (#[verifier::custom_err("cannot prove that final value of field `lsn_addr_index` has this updated value")] (::builtin::equal(post.lsn_addr_index,
                                                    update_tmp_lsn_addr_index)) &&
                                            #[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")] (::builtin::equal(post.journal,
                                                    update_tmp_journal)))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn initialize_enabled(ijournal: TruncatedJournal)
                    -> ::core::primitive::bool {
                    {

                        #[verifier::custom_err("cannot prove this condition holds")]
                        (ijournal.decodable())
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_by(pre: State, post: State, label: Label,
                    step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::read_for_recovery(depth) =>
                            Self::read_for_recovery(pre, post, label, depth),
                        Step::freeze_for_commit(depth) =>
                            Self::freeze_for_commit(pre, post, label, depth),
                        Step::query_end_lsn() =>
                            Self::query_end_lsn(pre, post, label),
                        Step::put(new_journal) =>
                            Self::put(pre, post, label, new_journal),
                        Step::discard_old(new_journal) =>
                            Self::discard_old(pre, post, label, new_journal),
                        Step::internal_journal_marshal(cut, addr, new_journal) =>
                            Self::internal_journal_marshal(pre, post, label, cut, addr,
                                new_journal),
                        Step::internal_no_op() =>
                            Self::internal_no_op(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next(pre: State, post: State, label: Label)
                    -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                            Self::next_by(pre, post, label, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_strong_by(pre: State, post: State, label: Label,
                    step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::read_for_recovery(depth) =>
                            Self::read_for_recovery_strong(pre, post, label, depth),
                        Step::freeze_for_commit(depth) =>
                            Self::freeze_for_commit_strong(pre, post, label, depth),
                        Step::query_end_lsn() =>
                            Self::query_end_lsn_strong(pre, post, label),
                        Step::put(new_journal) =>
                            Self::put_strong(pre, post, label, new_journal),
                        Step::discard_old(new_journal) =>
                            Self::discard_old_strong(pre, post, label, new_journal),
                        Step::internal_journal_marshal(cut, addr, new_journal) =>
                            Self::internal_journal_marshal_strong(pre, post, label, cut,
                                addr, new_journal),
                        Step::internal_no_op() =>
                            Self::internal_no_op_strong(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_strong(pre: State, post: State, label: Label)
                    -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                            Self::next_strong_by(pre, post, label, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn init_by(post: State, step: Config)
                    -> ::core::primitive::bool {
                    match step {
                        Config::initialize(ijournal) =>
                            Self::initialize(post, ijournal),
                        Config::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn init(post: State) -> ::core::primitive::bool {
                    ::builtin::exists(|step: Config| Self::init_by(post, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::spec]
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                pub fn invariant(&self) -> ::core::primitive::bool {
                    self.inv()
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn inv(self) -> bool {
                    let tj = self.journal.truncated_journal;
                    (((((self.wf()) && (tj.disk_view.acyclic())) &&
                                                (::builtin::spec_eq(self.lsn_addr_index,
                                                        tj.build_lsn_addr_index()))) &&
                                        (tj.index_domain_valid(self.lsn_addr_index))) &&
                                (tj.disk_view.index_keys_map_to_valid_entries(self.lsn_addr_index)))
                        && (tj.index_range_valid(self.lsn_addr_index))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::custom_req_err("could not show invariant `inv` on the `post` state")]
                #[verifier::external_body]
                #[verus::internal(verus_macro)]
                #[verifier::proof]
                fn lemma_msg_inv(s: State) {
                    ::builtin::requires(s.inv());
                    ::builtin::ensures(s.inv());
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn read_for_recovery_inductive(pre: Self, post: Self,
                    lbl: Label, depth: nat) {
                    ::builtin::requires(pre.invariant() &&
                            State::read_for_recovery_strong(pre, post, lbl, depth));
                    ::builtin::ensures(post.invariant());
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(LinkedJournal_v::LinkedJournal::State::next_by)
                                }
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                    Self::lemma_msg_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn freeze_for_commit_inductive(pre: Self, post: Self,
                    lbl: Label, depth: nat) {
                    ::builtin::requires(pre.invariant() &&
                            State::freeze_for_commit_strong(pre, post, lbl, depth));
                    ::builtin::ensures(post.invariant());
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(LinkedJournal_v::LinkedJournal::State::next_by)
                                }
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                    Self::lemma_msg_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn query_end_lsn_inductive(pre: Self, post: Self,
                    lbl: Label) {
                    ::builtin::requires(pre.invariant() &&
                            State::query_end_lsn_strong(pre, post, lbl));
                    ::builtin::ensures(post.invariant());
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(LinkedJournal_v::LinkedJournal::State::next)
                                }
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(LinkedJournal_v::LinkedJournal::State::next_by)
                                }
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                    Self::lemma_msg_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn put_inductive(pre: Self, post: Self, lbl: Label,
                    new_journal: LinkedJournal_v::LinkedJournal::State) {
                    ::builtin::requires(pre.invariant() &&
                            State::put_strong(pre, post, lbl, new_journal));
                    ::builtin::ensures(post.invariant());
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(LinkedJournal_v::LinkedJournal::State::next)
                                }
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(LinkedJournal_v::LinkedJournal::State::next_by)
                                }
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                    Self::lemma_msg_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn discard_old_inductive(pre: Self, post: Self, lbl: Label,
                    new_journal: LinkedJournal_v::LinkedJournal::State) {
                    ::builtin::requires(pre.invariant() &&
                            State::discard_old_strong(pre, post, lbl, new_journal));
                    ::builtin::ensures(post.invariant());
                    {
                        Self::discard_old_step_preserves_acyclicity(pre, post, lbl);
                        Self::discard_old_step_preserves_index(pre, post, lbl);
                        Self::discard_old_maintains_repr_index(pre, post, lbl);
                    }
                    Self::lemma_msg_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn internal_journal_marshal_inductive(pre: Self, post: Self,
                    lbl: Label, cut: LSN, addr: Address,
                    new_journal: LinkedJournal_v::LinkedJournal::State) {
                    ::builtin::requires(pre.invariant() &&
                            State::internal_journal_marshal_strong(pre, post, lbl, cut,
                                addr, new_journal));
                    ::builtin::ensures(post.invariant());
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(LinkedJournal_v::LinkedJournal::State::next_by)
                                }
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                        ::builtin::assert_(post.wf());
                        let istep: LinkedJournal_v::LinkedJournal::Step =
                            LinkedJournal_v::LinkedJournal::Step::internal_journal_marshal(cut,
                                addr);
                        ::builtin::assert_(LinkedJournal_v::LinkedJournal::State::next_by(pre.journal,
                                post.journal, State::lbl_i(lbl), istep));
                        LinkedJournal_v::LinkedJournal::State::inv_next(pre.journal,
                            post.journal, State::lbl_i(lbl), istep);
                        ::builtin::assert_(post.journal.inv());
                        let tj_pre = pre.journal.truncated_journal;
                        let tj_post = post.journal.truncated_journal;
                        ::builtin::assert_(tj_post.disk_view.acyclic());
                        tj_pre.disk_view.sub_disk_repr_index(tj_post.disk_view,
                            tj_pre.freshest_rec);
                        ::builtin::assert_(::builtin::spec_eq(post.lsn_addr_index,
                                tj_post.build_lsn_addr_index()));
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(TruncatedJournal::index_domain_valid)
                                }
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(DiskView::index_keys_map_to_valid_entries)
                                }
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                        ::builtin::assert_(tj_post.index_domain_valid(post.lsn_addr_index));
                        ::builtin::assert_(tj_post.disk_view.index_keys_map_to_valid_entries(post.lsn_addr_index));
                        let msgs =
                            pre.journal.unmarshalled_tail.discard_recent(cut);
                        lsn_addr_index_append_record_ensures(pre.lsn_addr_index,
                            msgs, addr);
                        ::builtin::assert_(tj_post.index_range_valid(post.lsn_addr_index));
                        ::builtin::assert_(post.inv());
                    }
                    Self::lemma_msg_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn internal_no_op_inductive(pre: Self, post: Self,
                    lbl: Label) {
                    ::builtin::requires(pre.invariant() &&
                            State::internal_no_op_strong(pre, post, lbl));
                    ::builtin::ensures(post.invariant());
                    {}
                    Self::lemma_msg_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn initialize_inductive(post: Self,
                    ijournal: TruncatedJournal) {
                    ::builtin::requires(Self::initialize(post, ijournal));
                    ::builtin::ensures(post.invariant());
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(TruncatedJournal::index_domain_valid)
                                }
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(DiskView::index_keys_map_to_valid_entries)
                                }
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                        if ijournal.freshest_rec.is_Some() {
                                ijournal.disk_view.build_lsn_addr_index_domain_valid(ijournal.freshest_rec);
                            }
                        ijournal.disk_view.build_lsn_addr_index_range_valid(ijournal.freshest_rec);
                    }
                    Self::lemma_msg_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn lbl_i(lbl: Label)
                    -> LinkedJournal_v::LinkedJournal::Label {
                    match lbl {
                        Label::ReadForRecovery { messages } =>
                            LinkedJournal_v::LinkedJournal::Label::ReadForRecovery {
                                messages,
                            },
                        Label::FreezeForCommit { frozen_journal } =>
                            LinkedJournal_v::LinkedJournal::Label::FreezeForCommit {
                                frozen_journal,
                            },
                        Label::QueryEndLsn { end_lsn } =>
                            LinkedJournal_v::LinkedJournal::Label::QueryEndLsn {
                                end_lsn,
                            },
                        Label::Put { messages } =>
                            LinkedJournal_v::LinkedJournal::Label::Put { messages },
                        Label::DiscardOld { start_lsn, require_end } =>
                            LinkedJournal_v::LinkedJournal::Label::DiscardOld {
                                start_lsn,
                                require_end,
                            },
                        Label::Internal {} =>
                            LinkedJournal_v::LinkedJournal::Label::Internal {},
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn wf(self) -> bool { self.journal.wf() }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn transitive_likes(self) -> Likes {
                    self.journal.truncated_journal.transitive_likes()
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn imperative_likes(self) -> Likes {
                    Multiset::from_set(self.lsn_addr_index.values())
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub fn discard_old_step_preserves_acyclicity(pre: Self,
                    post: Self, lbl: Label) {
                    ::builtin::requires([pre.inv(),
                                Self::discard_old(pre, post, lbl, post.journal)]);
                    ::builtin::ensures([post.journal.truncated_journal.disk_view.acyclic()]);
                    let dv = pre.journal.truncated_journal.disk_view;
                    let post_dv = post.journal.truncated_journal.disk_view;
                    let ranking = dv.the_ranking();
                    {
                        ::builtin::assert_forall_by(|addr|
                                {
                                    ::builtin::requires(#[verus::internal(trigger)] post_dv.entries.contains_key(addr)
                                            &&
                                            post_dv.entries.spec_index(addr).cropped_prior(post_dv.boundary_lsn).is_Some());
                                    ::builtin::ensures((ranking.spec_index(post_dv.entries.spec_index(addr).cropped_prior(post_dv.boundary_lsn).unwrap())).spec_lt(ranking.spec_index(addr)));
                                    ::builtin::assert_(dv.entries.contains_key(addr));
                                });
                    }
                    ::builtin::assert_(post_dv.valid_ranking(ranking));
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub fn discard_old_step_preserves_index(pre: Self, post: Self,
                    lbl: Label) {
                    ::builtin::requires([pre.inv(),
                                Self::discard_old(pre, post, lbl, post.journal)]);
                    ::builtin::ensures([post.journal.truncated_journal.index_domain_valid(post.lsn_addr_index),
                                post.journal.truncated_journal.disk_view.index_keys_map_to_valid_entries(post.lsn_addr_index),
                                post.journal.truncated_journal.index_range_valid(post.lsn_addr_index)]);
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(TruncatedJournal::index_domain_valid)
                            }
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(DiskView::index_keys_map_to_valid_entries)
                            }
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                    let tj_pre = pre.journal.truncated_journal;
                    let tj_post = post.journal.truncated_journal;
                    {
                        ::builtin::assert_forall_by(|lsn|
                                {
                                    ::builtin::requires(#[verus::internal(trigger)] post.lsn_addr_index.contains_key(lsn));
                                    ::builtin::ensures(tj_post.disk_view.addr_supports_lsn(post.lsn_addr_index.spec_index(lsn),
                                            lsn));
                                    let addr = post.lsn_addr_index.spec_index(lsn);
                                    ::builtin::assert_(post.lsn_addr_index.values().contains(addr));
                                });
                    }
                    let bdy_pre = tj_pre.disk_view.boundary_lsn;
                    let bdy_post = tj_post.disk_view.boundary_lsn;
                    {
                        ::builtin::assert_forall_by(|addr|
                                {
                                    ::builtin::requires(post.lsn_addr_index.values().contains(addr));
                                    ::builtin::ensures(tj_post.every_lsn_at_addr_indexed_to_addr(post.lsn_addr_index,
                                            addr));
                                    ::builtin::assert_(pre.lsn_addr_index.values().contains(addr));
                                    ::builtin::assert_(tj_pre.every_lsn_at_addr_indexed_to_addr(pre.lsn_addr_index,
                                            addr));
                                    let msgs =
                                        tj_post.disk_view.entries.spec_index(addr).message_seq;
                                    {
                                        ::builtin::assert_forall_by(|lsn|
                                                {
                                                    ::builtin::requires(#[verus::internal(trigger)] DiskView::cropped_msg_seq_contains_lsn(bdy_post,
                                                            msgs, lsn));
                                                    ::builtin::ensures({
                                                            (post.lsn_addr_index.contains_key(lsn)) &&
                                                                (::builtin::spec_eq(post.lsn_addr_index.spec_index(lsn),
                                                                        addr))
                                                        });
                                                    ::builtin::assert_(DiskView::cropped_msg_seq_contains_lsn(bdy_pre,
                                                            msgs, lsn));
                                                });
                                    }
                                });
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub fn discard_old_maintains_repr_index(pre: Self, post: Self,
                    lbl: Label) {
                    ::builtin::requires([pre.inv(),
                                Self::discard_old(pre, post, lbl, post.journal), post.wf(),
                                post.journal.truncated_journal.disk_view.acyclic()]);
                    ::builtin::ensures([::builtin::spec_eq(post.lsn_addr_index,
                                    post.journal.truncated_journal.build_lsn_addr_index())]);
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(TruncatedJournal::index_domain_valid)
                            }
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(DiskView::index_keys_map_to_valid_entries)
                            }
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                    let tj_pre = pre.journal.truncated_journal;
                    let tj_post = post.journal.truncated_journal;
                    let bdy_post = tj_post.disk_view.boundary_lsn;
                    let repr = tj_post.build_lsn_addr_index();
                    if (bdy_post).spec_lt(tj_pre.seq_end()) {
                            tj_post.disk_view.build_lsn_addr_index_domain_valid(tj_post.freshest_rec);
                            tj_post.disk_view.sub_disk_with_newer_lsn_repr_index(tj_pre.disk_view,
                                tj_post.freshest_rec);
                            lsn_addr_index_discard_up_to_ensures(pre.lsn_addr_index,
                                bdy_post);
                            ::builtin::assert_(::builtin::ext_equal(repr.dom(),
                                    post.lsn_addr_index.dom()));
                            ::builtin::assert_(::builtin::ext_equal(repr,
                                    post.lsn_addr_index));
                        } else {
                           ::builtin::assert_(::builtin::ext_equal(post.lsn_addr_index,
                                   repr));
                       }
                }
            }
        }
    }
    pub mod LikesJournalRefinement_v {
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        use vstd::prelude::*;
        use crate::abstract_system::StampedMap_v::LSN;
        use crate::abstract_system::MsgHistory_v::*;
        use crate::disk::GenericDisk_v::*;
        use crate::journal::LinkedJournal_v;
        use crate::journal::LinkedJournal_v::{
            LinkedJournal, DiskView, TruncatedJournal,
        };
        use crate::journal::LikesJournal_v;
        use crate::journal::LikesJournal_v::*;
        #[verus::internal(verus_macro)]
        impl DiskView { }
        #[verus::internal(verus_macro)]
        impl LikesJournal::State {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> LinkedJournal::State {
                ::builtin::recommends([self.journal.truncated_journal.decodable()]);
                self.journal
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn discard_old_refines(self, post: Self,
                lbl: LikesJournal::Label,
                new_journal: LinkedJournal_v::LinkedJournal::State) {
                ::builtin::requires([self.inv(), post.inv(),
                            Self::discard_old(self, post, lbl, new_journal)]);
                ::builtin::ensures([LinkedJournal::State::next_by(self.i(),
                                post.i(), Self::lbl_i(lbl),
                                LinkedJournal::Step::discard_old(new_journal.truncated_journal))]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(LinkedJournal::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                let tj_pre = self.journal.truncated_journal;
                let tj_post = post.journal.truncated_journal;
                let start_lsn = lbl.get_DiscardOld_start_lsn();
                let require_end = lbl.get_DiscardOld_require_end();
                let post_discard = tj_pre.discard_old(start_lsn);
                let post_tight = post_discard.build_tight();
                ::builtin::assert_(tj_post.wf());
                ::builtin::assert_(::builtin::spec_eq(tj_post.freshest_rec,
                        post_discard.freshest_rec));
                ::builtin::assert_(tj_post.disk_view.is_sub_disk(post_discard.disk_view));
                tj_pre.discard_old_decodable(start_lsn);
                ::builtin::assert_(post_discard.disk_view.acyclic());
                post_discard.disk_view.build_tight_ensures(post_discard.freshest_rec);
                post_discard.disk_view.tight_sub_disk(post_discard.freshest_rec,
                    post_tight.disk_view);
                ::builtin::assert_(post_tight.disk_view.acyclic());
                post_tight.disk_view.sub_disk_repr_index(post_discard.disk_view,
                    post_discard.freshest_rec);
                tj_post.disk_view.sub_disk_repr_index(post_discard.disk_view,
                    post_discard.freshest_rec);
                ::builtin::assert_(::builtin::spec_eq(post_tight.disk_view.build_lsn_addr_index(post_discard.freshest_rec),
                        post.lsn_addr_index));
                ::builtin::assert_((post.lsn_addr_index.values()).spec_le(tj_post.disk_view.entries.dom()));
                post_discard.disk_view.build_tight_domain_is_build_lsn_addr_index_range(post_discard.freshest_rec);
                ::builtin::assert_((post_tight.disk_view.entries.dom()).spec_le(tj_post.disk_view.entries.dom()));
                ::builtin::assert_((post_tight.disk_view.entries).spec_le(tj_post.disk_view.entries));
                ::builtin::assert_(::builtin::spec_eq(post_discard.freshest_rec,
                        tj_post.freshest_rec));
                ::builtin::assert_(post_tight.disk_view.is_sub_disk(tj_post.disk_view));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn next_refines(self, post: Self, lbl: LikesJournal::Label) {
                ::builtin::requires([self.inv(), post.inv(),
                            LikesJournal::State::next(self, post, lbl)]);
                ::builtin::ensures([LinkedJournal::State::next(self.i(),
                                post.i(), Self::lbl_i(lbl))]);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(LinkedJournal::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(LinkedJournal::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(LikesJournal::State::next)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(LikesJournal::State::next_by)
                        }
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
                let step =
                    ::builtin::choose(|step|
                            LikesJournal::State::next_by(self, post, lbl, step));
                match step {
                    LikesJournal::Step::read_for_recovery(depth) => {
                        ::builtin::assert_(LinkedJournal::State::next_by(self.i(),
                                post.i(), Self::lbl_i(lbl),
                                LinkedJournal::Step::read_for_recovery(depth)));
                    }
                    LikesJournal::Step::freeze_for_commit(depth) => {
                        ::builtin::assert_(LinkedJournal::State::next_by(self.i(),
                                post.i(), Self::lbl_i(lbl),
                                LinkedJournal::Step::freeze_for_commit(depth)));
                    }
                    LikesJournal::Step::query_end_lsn() => {
                        ::builtin::assert_(LinkedJournal::State::next_by(self.i(),
                                post.i(), Self::lbl_i(lbl),
                                LinkedJournal::Step::query_end_lsn()));
                    }
                    LikesJournal::Step::put(new_journal) => {
                        ::builtin::assert_(LinkedJournal::State::next_by(self.i(),
                                post.i(), Self::lbl_i(lbl), LinkedJournal::Step::put()));
                    }
                    LikesJournal::Step::discard_old(new_journal) => {
                        self.discard_old_refines(post, lbl, new_journal);
                    }
                    LikesJournal::Step::internal_journal_marshal(cut, addr,
                        new_journal) => {
                        ::builtin::assert_(LinkedJournal::State::next_by(self.i(),
                                post.i(), Self::lbl_i(lbl),
                                LinkedJournal::Step::internal_journal_marshal(cut, addr)));
                    }
                    _ => {
                        ::builtin::assert_(LinkedJournal::State::next_by(self.i(),
                                post.i(), Self::lbl_i(lbl),
                                LinkedJournal::Step::internal_no_op()));
                    }
                }
            }
        }
    }
}
mod disk {
    pub mod GenericDisk_v {
        //! This file contains types relating to generic disk addressing and referencing.
        #[allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        #[doc =
        " The `AU` type is the type for a unique allocation unit identifier (thus we use `nat`s)."]
        #[doc = " "]
        #[doc =
        " An Allocation Unit (AU) is the minimum disk unit the \"external\" (i.e.: top-level) allocator"]
        #[doc =
        " allocates to data structures like the Betree and Journal. Allocation Units"]
        #[doc =
        " are made up of contiguous disk sectors. AUs are specified as part of the"]
        #[doc =
        " Splinter implementation. The goal of having large allocation blocks is to"]
        #[doc =
        " amortize allocation costs efficiently for large amounts of data."]
        pub type AU = nat;
        #[doc =
        " A page index within an AU (disk pages, so for SSDs these are on the order of 4KB)."]
        pub type Page = nat;
        #[doc =
        " Returns the number of a disk pages in an Allocation Unit. Left as an uninterpreted function"]
        #[doc = " since it\'s implementation defined."]
        #[verus::internal(verus_macro)]
        #[verus::internal(closed)]
        #[verus::internal(spec(checked))]
        #[verus::internal(external_body)]
        pub fn page_count() -> nat {
            ::core::panicking::panic("not implemented")
        }
        #[doc =
        " An Address specifies a specific disk address (i.e.: an address that identifies a disk sector (or whatever"]
        #[doc = " atomic addressing unit the disk in question uses))."]
        #[doc =
        " It does this by combining an AU index with a page index within the AU."]
        #[verus::internal(verus_macro)]
        pub struct Address {
            #[doc = " The Allocation Unit index this address resides within."]
            pub au: AU,
            #[doc =
            " Page index within AU for this address. In the range [0,page_count)."]
            pub page: Page,
        }
        #[verus::internal(verus_macro)]
        impl Address {
            #[doc = " Returns true iff this Address is well formed."]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool { (self.page).spec_lt(page_count()) }
            #[doc = " Returns the Address for the first page of this AU."]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn first_page(self) -> Address {
                Address { page: ::builtin::spec_literal_integer("0"), ..self }
            }
            #[doc =
            " Returns the previous Address in this AU (may not be well-formed)."]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn previous(self) -> Address {
                Address {
                    page: ::builtin::spec_cast_integer::<_,
                            nat>(((self.page).spec_sub(::builtin::spec_literal_nat("1")))),
                    ..self
                }
            }
            #[doc =
            " Returns the next Address in this AU (may not be well-formed)."]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn next(self) -> Address {
                Address {
                    page: (self.page).spec_add(::builtin::spec_literal_nat("1")),
                    ..self
                }
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn first_page(ptr: Pointer) -> Pointer {
            match ptr { None => None, Some(addr) => Some(addr.first_page()), }
        }
        #[doc =
        " Return the lowest of two addresses. Addresses are first compared by AU,"]
        #[doc = " then by Page index (if AUs match)."]
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn min_addr(a: Address, b: Address) -> Address {
            if (a.au).spec_lt(b.au) {
                    a
                } else if (a.au).spec_gt(b.au) {
                   b
               } else if (a.page).spec_le(b.page) { a } else { b }
        }
        #[doc =
        " Returns the set of AUs that the provided set of Addresses live in."]
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn to_aus(addrs: Set<Address>) -> Set<AU> {
            addrs.map(::builtin::closure_to_fn_spec(|addr: Address| addr.au))
        }
        #[doc =
        " A Pointer is either an Address or None. (i.e.: we wrap Address with the semantics for"]
        #[doc =
        " \"NULL\" pointers). Used when certain data structures might have unallocated pointers."]
        pub type Pointer = Option<Address>;
        pub type Ranking = Map<Address, nat>;
    }
}
mod allocation_layer {
    pub mod MiniAllocator_v {
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use crate::disk::GenericDisk_v::*;
        #[verus::internal(verus_macro)]
        pub struct PageAllocator {
            pub observed: Set<Address>,
            pub reserved: Set<Address>,
            pub au: AU,
        }
        #[verus::internal(verus_macro)]
        impl PageAllocator {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn new(au: AU) -> Self {
                Self { observed: Set::empty(), reserved: Set::empty(), au }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                ((((::builtin::forall(|addr|
                                                    #[verus::internal(auto_trigger)] (::builtin::imply(self.observed.contains(addr),
                                                            addr.wf()))))) &&
                                    ((::builtin::forall(|addr|
                                                    #[verus::internal(auto_trigger)] (::builtin::imply(self.reserved.contains(addr),
                                                            addr.wf())))))) &&
                            ((::builtin::forall(|addr|
                                            #[verus::internal(auto_trigger)] (::builtin::imply(self.observed.contains(addr),
                                                    ::builtin::spec_eq(addr.au, self.au))))))) &&
                    ((::builtin::forall(|addr|
                                    #[verus::internal(auto_trigger)] (::builtin::imply(self.reserved.contains(addr),
                                            ::builtin::spec_eq(addr.au, self.au))))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_free_addr(self, addr: Address) -> bool {
                ((addr.wf()) && (::builtin::spec_eq(addr.au, self.au))) &&
                    (!((self.observed).spec_add(self.reserved)).contains(addr))
            }
            #[doc = " get a stack reference"]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn reserve(self, addrs: Set<Address>) -> Self {
                ::builtin::recommends([self.wf(),
                            ::builtin::forall(|addr|
                                    ::builtin::imply(addrs.contains(addr),
                                        self.is_free_addr(addr)))]);
                Self { reserved: (self.reserved).spec_add(addrs), ..self }
            }
            #[doc = " done with / returns a stack reference "]
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn unreserve(self, addrs: Set<Address>) -> Self {
                ::builtin::recommends([self.wf(),
                            addrs.subset_of(self.reserved)]);
                Self { reserved: self.reserved.difference(addrs), ..self }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn observe(self, addrs: Set<Address>) -> Self {
                ::builtin::recommends([self.wf(),
                            ::builtin::forall(|addr|
                                    ::builtin::imply(#[verus::internal(trigger)] addrs.contains(addr),
                                        addr.wf() && ::builtin::spec_eq(addr.au, self.au)))]);
                Self { observed: (self.observed).spec_add(addrs), ..self }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn unobserve(self, addrs: Set<Address>) -> Self {
                ::builtin::recommends([self.wf(),
                            addrs.subset_of(self.observed)]);
                Self { observed: self.observed.difference(addrs), ..self }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn unobserve_all(self) -> Self {
                ::builtin::recommends([self.wf()]);
                self.unobserve(self.observed)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn free(self, addrs: Set<Address>) -> Self {
                ::builtin::recommends([self.wf(),
                            addrs.subset_of((self.observed).spec_add(self.reserved))]);
                Self {
                    observed: self.observed.difference(addrs),
                    reserved: self.reserved.difference(addrs),
                    au: self.au,
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn has_no_observed_pages(self) -> bool {
                ::builtin::spec_eq(self.observed, Set::<Address>::empty())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn has_no_outstanding_refs(self) -> bool {
                ::builtin::spec_eq(self.reserved, Set::<Address>::empty())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn all_pages_allocated(self) -> bool {
                ::builtin::spec_eq(((self.reserved).spec_add(self.observed)).len(),
                    page_count())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn all_pages_free(self) -> bool {
                (self.has_no_observed_pages()) &&
                    (self.has_no_outstanding_refs())
            }
        }
        #[verus::internal(verus_macro)]
        pub struct MiniAllocator {
            pub allocs: Map<AU, PageAllocator>,
            pub curr: Option<AU>,
        }
        #[verus::internal(verus_macro)]
        impl MiniAllocator {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn empty() -> Self {
                Self { allocs: Map::empty(), curr: None }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                (::builtin::forall(|au|
                                ::builtin::imply(#[verus::internal(trigger)] self.allocs.contains_key(au),
                                    self.allocs.spec_index(au).wf() &&
                                        ::builtin::spec_eq(self.allocs.spec_index(au).au, au)))) &&
                    (::builtin::imply(self.curr.is_Some(),
                            self.allocs.contains_key(self.curr.unwrap())))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn add_aus(self, aus: Set<AU>) -> Self {
                ::builtin::recommends([self.wf()]);
                let new_allocs =
                    Map::new(::builtin::closure_to_fn_spec(|au|
                                ((aus).spec_add(self.allocs.dom())).contains(au)),
                        ::builtin::closure_to_fn_spec(|au|
                                if self.allocs.contains_key(au) {
                                        self.allocs.spec_index(au)
                                    } else { PageAllocator::new(au) }));
                Self { allocs: new_allocs, ..self }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_remove(self, au: AU) -> bool {
                (self.allocs.contains_key(au)) &&
                    (self.allocs.spec_index(au).has_no_outstanding_refs())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn not_observed_aus(self) -> Set<AU> {
                Set::new(::builtin::closure_to_fn_spec(|au|
                            self.allocs.contains_key(au) &&
                                self.allocs.spec_index(au).has_no_observed_pages()))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_allocate(self, addr: Address) -> bool {
                (self.allocs.contains_key(addr.au)) &&
                    (self.allocs.spec_index(addr.au).is_free_addr(addr))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn allocate_and_observe(self, addr: Address) -> Self {
                ::builtin::recommends([self.wf(), self.can_allocate(addr)]);
                let result =
                    self.allocs.spec_index(addr.au).observe(::vstd::set::Set::empty().insert(addr));
                let new_curr =
                    if result.all_pages_allocated() {
                            None
                        } else { Some(addr.au) };
                Self {
                    allocs: self.allocs.insert(addr.au, result),
                    curr: new_curr,
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn allocate_and_observe_wf(self, addr: Address) {
                ::builtin::requires([self.wf(), self.can_allocate(addr),
                            addr.wf()]);
                ::builtin::ensures([self.allocate_and_observe(addr).wf()]);
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn allocate(self, addr: Address) -> Self {
                ::builtin::recommends([self.wf(), self.can_allocate(addr)]);
                let result =
                    self.allocs.spec_index(addr.au).reserve(::vstd::set::Set::empty().insert(addr));
                let new_curr =
                    if result.all_pages_allocated() {
                            None
                        } else { Some(addr.au) };
                Self {
                    allocs: self.allocs.insert(addr.au, result),
                    curr: new_curr,
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn prune(self, aus: Set<AU>) -> Self {
                ::builtin::recommends([self.wf()]);
                let new_allocs =
                    Map::new(::builtin::closure_to_fn_spec(|au|
                                self.allocs.contains_key(au) && !aus.contains(au)),
                        ::builtin::closure_to_fn_spec(|au|
                                self.allocs.spec_index(au)));
                let new_curr =
                    if self.curr.is_Some() && aus.contains(self.curr.unwrap()) {
                            None
                        } else { self.curr };
                Self { allocs: new_allocs, curr: new_curr }
            }
        }
    }
    pub mod Likes_v {
        #![allow(unused_imports)]
        use builtin::*;
        use vstd::prelude::*;
        use vstd::{map::*, multiset::*};
        use crate::disk::GenericDisk_v::*;
        pub type Likes = Multiset<Address>;
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn no_likes() -> Likes { Multiset::empty() }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn map_sum<T>(s: Map<T, Likes>) -> Likes {
            ::builtin::decreases((s.dom().len()));
            ::builtin::decreases_when(s.dom().finite());
            if ::builtin::spec_eq(s.dom().len(),
                        ::builtin::spec_literal_nat("0")) {
                    no_likes()
                } else {
                   let k = s.dom().choose();
                   map_sum(s.remove(k)).add(s.spec_index(k))
               }
        }
    }
    pub mod AllocationJournal_v {
        #![allow(unused_imports)]
        use builtin::*;
        use vstd::prelude::*;
        use vstd::math;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        use vstd::prelude::*;
        use vstd::map::*;
        use crate::abstract_system::StampedMap_v::LSN;
        use crate::abstract_system::MsgHistory_v::*;
        use crate::disk::GenericDisk_v::*;
        use crate::disk::GenericDisk_v::AU;
        use crate::journal::LinkedJournal_v;
        use crate::journal::LinkedJournal_v::{
            DiskView, TruncatedJournal, LinkedJournal,
        };
        use crate::journal::LikesJournal_v;
        use crate::allocation_layer::MiniAllocator_v::*;
        #[verus::internal(verus_macro)]
        pub struct JournalImage {
            pub tj: TruncatedJournal,
            pub first: AU,
        }
        #[verus::internal(verus_macro)]
        impl JournalImage {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool { self.tj.wf() }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn accessible_aus(self) -> Set<AU> {
                to_aus(self.tj.disk_view.entries.dom())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn empty() -> Self {
                Self {
                    tj: TruncatedJournal::mkfs(),
                    first: ::builtin::spec_literal_integer("0"),
                }
            }
        }
        #[allow(unused_parens)]
        pub mod AllocationJournal {
            use super::*;
            #[verus::internal(verus_macro)]
            pub struct State {
                pub journal: LinkedJournal::State,
                pub lsn_au_index: Map<LSN, AU>,
                pub first: AU,
                pub mini_allocator: MiniAllocator,
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Step {
                read_for_recovery(),
                freeze_for_commit(),
                query_end_lsn(),
                put(LinkedJournal_v::LinkedJournal::State),
                discard_old(LinkedJournal::State),
                internal_journal_marshal(LSN, Address, LinkedJournal::State),
                internal_mini_allocator_fill(),
                internal_mini_allocator_prune(),
                internal_no_op(),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Step {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_read_for_recovery(&self) -> bool {
                    ::builtin::is_variant(self, "read_for_recovery")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_freeze_for_commit(&self) -> bool {
                    ::builtin::is_variant(self, "freeze_for_commit")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_query_end_lsn(&self) -> bool {
                    ::builtin::is_variant(self, "query_end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_put(&self) -> bool {
                    ::builtin::is_variant(self, "put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_put_0(self)
                    -> LinkedJournal_v::LinkedJournal::State {
                    ::builtin::get_variant_field(self, "put", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_discard_old(&self) -> bool {
                    ::builtin::is_variant(self, "discard_old")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_discard_old_0(self) -> LinkedJournal::State {
                    ::builtin::get_variant_field(self, "discard_old", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_internal_journal_marshal(&self) -> bool {
                    ::builtin::is_variant(self, "internal_journal_marshal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_journal_marshal_0(self) -> LSN {
                    ::builtin::get_variant_field(self,
                        "internal_journal_marshal", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_journal_marshal_1(self) -> Address {
                    ::builtin::get_variant_field(self,
                        "internal_journal_marshal", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_journal_marshal_2(self)
                    -> LinkedJournal::State {
                    ::builtin::get_variant_field(self,
                        "internal_journal_marshal", "2")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_internal_mini_allocator_fill(&self) -> bool {
                    ::builtin::is_variant(self, "internal_mini_allocator_fill")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_internal_mini_allocator_prune(&self) -> bool {
                    ::builtin::is_variant(self, "internal_mini_allocator_prune")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_internal_no_op(&self) -> bool {
                    ::builtin::is_variant(self, "internal_no_op")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Config {
                initialize(LinkedJournal::State, JournalImage),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Config {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_initialize(&self) -> bool {
                    ::builtin::is_variant(self, "initialize")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_initialize_0(self) -> LinkedJournal::State {
                    ::builtin::get_variant_field(self, "initialize", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_initialize_1(self) -> JournalImage {
                    ::builtin::get_variant_field(self, "initialize", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[verus::internal(verus_macro)]
            pub enum Label {
                ReadForRecovery {
                    messages: MsgHistory,
                },
                FreezeForCommit {
                    frozen_journal: JournalImage,
                },
                QueryEndLsn {
                    end_lsn: LSN,
                },
                Put {
                    messages: MsgHistory,
                },
                DiscardOld {
                    start_lsn: LSN,
                    require_end: LSN,
                    deallocs: Set<AU>,
                },
                InternalAllocations {
                    allocs: Set<AU>,
                    deallocs: Set<AU>,
                },
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Label {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_ReadForRecovery(&self) -> bool {
                    ::builtin::is_variant(self, "ReadForRecovery")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_ReadForRecovery_messages(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "ReadForRecovery",
                        "messages")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_FreezeForCommit(&self) -> bool {
                    ::builtin::is_variant(self, "FreezeForCommit")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_FreezeForCommit_frozen_journal(self)
                    -> JournalImage {
                    ::builtin::get_variant_field(self, "FreezeForCommit",
                        "frozen_journal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_QueryEndLsn(&self) -> bool {
                    ::builtin::is_variant(self, "QueryEndLsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_QueryEndLsn_end_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "QueryEndLsn", "end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_Put(&self) -> bool {
                    ::builtin::is_variant(self, "Put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_Put_messages(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "Put", "messages")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_DiscardOld(&self) -> bool {
                    ::builtin::is_variant(self, "DiscardOld")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_DiscardOld_start_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "DiscardOld",
                        "start_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_DiscardOld_require_end(self) -> LSN {
                    ::builtin::get_variant_field(self, "DiscardOld",
                        "require_end")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_DiscardOld_deallocs(self) -> Set<AU> {
                    ::builtin::get_variant_field(self, "DiscardOld", "deallocs")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_InternalAllocations(&self) -> bool {
                    ::builtin::is_variant(self, "InternalAllocations")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_InternalAllocations_allocs(self) -> Set<AU> {
                    ::builtin::get_variant_field(self, "InternalAllocations",
                        "allocs")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_InternalAllocations_deallocs(self) -> Set<AU> {
                    ::builtin::get_variant_field(self, "InternalAllocations",
                        "deallocs")
                }
            }
            pub mod show {
                use super::*;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn read_for_recovery(pre: super::State,
                    post: super::State, lbl: Label) {
                    ::builtin::requires(super::State::read_for_recovery(pre,
                            post, lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as read_for_recovery;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn freeze_for_commit(pre: super::State,
                    post: super::State, lbl: Label) {
                    ::builtin::requires(super::State::freeze_for_commit(pre,
                            post, lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as freeze_for_commit;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn query_end_lsn(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::query_end_lsn(pre, post,
                            lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as query_end_lsn;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn put(pre: super::State, post: super::State, lbl: Label,
                    new_journal: LinkedJournal_v::LinkedJournal::State) {
                    ::builtin::requires(super::State::put(pre, post, lbl,
                            new_journal));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as put;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn discard_old(pre: super::State, post: super::State,
                    lbl: Label, post_journal: LinkedJournal::State) {
                    ::builtin::requires(super::State::discard_old(pre, post,
                            lbl, post_journal));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as discard_old;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn internal_journal_marshal(pre: super::State,
                    post: super::State, lbl: Label, cut: LSN, addr: Address,
                    post_linked_journal: LinkedJournal::State) {
                    ::builtin::requires(super::State::internal_journal_marshal(pre,
                            post, lbl, cut, addr, post_linked_journal));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as internal_journal_marshal;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn internal_mini_allocator_fill(pre: super::State,
                    post: super::State, lbl: Label) {
                    ::builtin::requires(super::State::internal_mini_allocator_fill(pre,
                            post, lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as internal_mini_allocator_fill;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn internal_mini_allocator_prune(pre: super::State,
                    post: super::State, lbl: Label) {
                    ::builtin::requires(super::State::internal_mini_allocator_prune(pre,
                            post, lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as internal_mini_allocator_prune;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn internal_no_op(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::internal_no_op(pre, post,
                            lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as internal_no_op;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn initialize(post: super::State,
                    journal: LinkedJournal::State, image: JournalImage) {
                    ::builtin::requires(super::State::initialize(post, journal,
                            image));
                    ::builtin::ensures(super::State::init(post));
                }
                use bool as initialize;
            }
            pub mod take_step {
                use super::*;
            }
            #[verus::internal(verus_macro)]
            impl State {
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn read_for_recovery(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_journal: LinkedJournal::State = pre.journal;
                        let update_tmp_lsn_au_index: Map<LSN, AU> =
                            pre.lsn_au_index;
                        let update_tmp_first: AU = pre.first;
                        let update_tmp_mini_allocator: MiniAllocator =
                            pre.mini_allocator;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "ReadForRecovery")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal_v::LinkedJournal::State::next(pre.journal,
                                                pre.journal, State::linked_lbl(lbl))) &&
                                        (#[verifier::custom_err("cannot prove that the field `mini_allocator` is preserved")] (::builtin::equal(post.mini_allocator,
                                                        update_tmp_mini_allocator)) &&
                                                (#[verifier::custom_err("cannot prove that the field `first` is preserved")] (::builtin::equal(post.first,
                                                                update_tmp_first)) &&
                                                        (#[verifier::custom_err("cannot prove that the field `lsn_au_index` is preserved")] (::builtin::equal(post.lsn_au_index,
                                                                        update_tmp_lsn_au_index)) &&
                                                                #[verifier::custom_err("cannot prove that the field `journal` is preserved")] (::builtin::equal(post.journal,
                                                                        update_tmp_journal)))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn read_for_recovery_strong(pre: Self, post: Self,
                    lbl: Label) -> ::core::primitive::bool {
                    {
                        let update_tmp_journal: LinkedJournal::State = pre.journal;
                        let update_tmp_lsn_au_index: Map<LSN, AU> =
                            pre.lsn_au_index;
                        let update_tmp_first: AU = pre.first;
                        let update_tmp_mini_allocator: MiniAllocator =
                            pre.mini_allocator;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "ReadForRecovery")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal_v::LinkedJournal::State::next(pre.journal,
                                                pre.journal, State::linked_lbl(lbl))) &&
                                        (#[verifier::custom_err("cannot prove that the field `mini_allocator` is preserved")] (::builtin::equal(post.mini_allocator,
                                                        update_tmp_mini_allocator)) &&
                                                (#[verifier::custom_err("cannot prove that the field `first` is preserved")] (::builtin::equal(post.first,
                                                                update_tmp_first)) &&
                                                        (#[verifier::custom_err("cannot prove that the field `lsn_au_index` is preserved")] (::builtin::equal(post.lsn_au_index,
                                                                        update_tmp_lsn_au_index)) &&
                                                                #[verifier::custom_err("cannot prove that the field `journal` is preserved")] (::builtin::equal(post.journal,
                                                                        update_tmp_journal)))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn read_for_recovery_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "ReadForRecovery")) &&
                                #[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal_v::LinkedJournal::State::next(pre.journal,
                                        pre.journal, State::linked_lbl(lbl))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn freeze_for_commit(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_journal: LinkedJournal::State = pre.journal;
                        let update_tmp_lsn_au_index: Map<LSN, AU> =
                            pre.lsn_au_index;
                        let update_tmp_first: AU = pre.first;
                        let update_tmp_mini_allocator: MiniAllocator =
                            pre.mini_allocator;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "FreezeForCommit")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal_v::LinkedJournal::State::next(pre.journal,
                                                pre.journal, State::linked_lbl(lbl))) &&
                                        (({
                                                        let frozen_journal =
                                                            lbl.get_FreezeForCommit_frozen_journal();
                                                        let frozen_first =
                                                            State::new_first(frozen_journal.tj, pre.lsn_au_index,
                                                                pre.first, frozen_journal.tj.seq_start());

                                                        #[verifier::custom_err("cannot prove this condition holds")]
                                                        (::builtin::spec_eq(frozen_journal.first, frozen_first))
                                                    }) &&
                                                ((#[verifier::custom_err("cannot prove that the field `mini_allocator` is preserved")] (::builtin::equal(post.mini_allocator,
                                                                    update_tmp_mini_allocator)) &&
                                                            (#[verifier::custom_err("cannot prove that the field `first` is preserved")] (::builtin::equal(post.first,
                                                                            update_tmp_first)) &&
                                                                    (#[verifier::custom_err("cannot prove that the field `lsn_au_index` is preserved")] (::builtin::equal(post.lsn_au_index,
                                                                                    update_tmp_lsn_au_index)) &&
                                                                            #[verifier::custom_err("cannot prove that the field `journal` is preserved")] (::builtin::equal(post.journal,
                                                                                    update_tmp_journal)))))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn freeze_for_commit_strong(pre: Self, post: Self,
                    lbl: Label) -> ::core::primitive::bool {
                    {
                        let update_tmp_journal: LinkedJournal::State = pre.journal;
                        let update_tmp_lsn_au_index: Map<LSN, AU> =
                            pre.lsn_au_index;
                        let update_tmp_first: AU = pre.first;
                        let update_tmp_mini_allocator: MiniAllocator =
                            pre.mini_allocator;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "FreezeForCommit")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal_v::LinkedJournal::State::next(pre.journal,
                                                pre.journal, State::linked_lbl(lbl))) &&
                                        (({
                                                        let frozen_journal =
                                                            lbl.get_FreezeForCommit_frozen_journal();
                                                        let frozen_first =
                                                            State::new_first(frozen_journal.tj, pre.lsn_au_index,
                                                                pre.first, frozen_journal.tj.seq_start());

                                                        #[verifier::custom_err("cannot prove this condition holds")]
                                                        (::builtin::spec_eq(frozen_journal.first, frozen_first))
                                                    }) &&
                                                ((#[verifier::custom_err("cannot prove that the field `mini_allocator` is preserved")] (::builtin::equal(post.mini_allocator,
                                                                    update_tmp_mini_allocator)) &&
                                                            (#[verifier::custom_err("cannot prove that the field `first` is preserved")] (::builtin::equal(post.first,
                                                                            update_tmp_first)) &&
                                                                    (#[verifier::custom_err("cannot prove that the field `lsn_au_index` is preserved")] (::builtin::equal(post.lsn_au_index,
                                                                                    update_tmp_lsn_au_index)) &&
                                                                            #[verifier::custom_err("cannot prove that the field `journal` is preserved")] (::builtin::equal(post.journal,
                                                                                    update_tmp_journal)))))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn freeze_for_commit_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "FreezeForCommit")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal_v::LinkedJournal::State::next(pre.journal,
                                                pre.journal, State::linked_lbl(lbl))) &&
                                        {
                                            let frozen_journal =
                                                lbl.get_FreezeForCommit_frozen_journal();
                                            let frozen_first =
                                                State::new_first(frozen_journal.tj, pre.lsn_au_index,
                                                    pre.first, frozen_journal.tj.seq_start());

                                            #[verifier::custom_err("cannot prove this condition holds")]
                                            (::builtin::spec_eq(frozen_journal.first, frozen_first))
                                        }))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_end_lsn(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_journal: LinkedJournal::State = pre.journal;
                        let update_tmp_lsn_au_index: Map<LSN, AU> =
                            pre.lsn_au_index;
                        let update_tmp_first: AU = pre.first;
                        let update_tmp_mini_allocator: MiniAllocator =
                            pre.mini_allocator;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "QueryEndLsn")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal_v::LinkedJournal::State::next(pre.journal,
                                                pre.journal, State::linked_lbl(lbl))) &&
                                        (#[verifier::custom_err("cannot prove that the field `mini_allocator` is preserved")] (::builtin::equal(post.mini_allocator,
                                                        update_tmp_mini_allocator)) &&
                                                (#[verifier::custom_err("cannot prove that the field `first` is preserved")] (::builtin::equal(post.first,
                                                                update_tmp_first)) &&
                                                        (#[verifier::custom_err("cannot prove that the field `lsn_au_index` is preserved")] (::builtin::equal(post.lsn_au_index,
                                                                        update_tmp_lsn_au_index)) &&
                                                                #[verifier::custom_err("cannot prove that the field `journal` is preserved")] (::builtin::equal(post.journal,
                                                                        update_tmp_journal)))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_end_lsn_strong(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_journal: LinkedJournal::State = pre.journal;
                        let update_tmp_lsn_au_index: Map<LSN, AU> =
                            pre.lsn_au_index;
                        let update_tmp_first: AU = pre.first;
                        let update_tmp_mini_allocator: MiniAllocator =
                            pre.mini_allocator;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "QueryEndLsn")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal_v::LinkedJournal::State::next(pre.journal,
                                                pre.journal, State::linked_lbl(lbl))) &&
                                        (#[verifier::custom_err("cannot prove that the field `mini_allocator` is preserved")] (::builtin::equal(post.mini_allocator,
                                                        update_tmp_mini_allocator)) &&
                                                (#[verifier::custom_err("cannot prove that the field `first` is preserved")] (::builtin::equal(post.first,
                                                                update_tmp_first)) &&
                                                        (#[verifier::custom_err("cannot prove that the field `lsn_au_index` is preserved")] (::builtin::equal(post.lsn_au_index,
                                                                        update_tmp_lsn_au_index)) &&
                                                                #[verifier::custom_err("cannot prove that the field `journal` is preserved")] (::builtin::equal(post.journal,
                                                                        update_tmp_journal)))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_end_lsn_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "QueryEndLsn")) &&
                                #[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal_v::LinkedJournal::State::next(pre.journal,
                                        pre.journal, State::linked_lbl(lbl))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put(pre: Self, post: Self, lbl: Label,
                    new_journal: LinkedJournal_v::LinkedJournal::State)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_journal: LinkedJournal::State = pre.journal;
                        let update_tmp_lsn_au_index: Map<LSN, AU> =
                            pre.lsn_au_index;
                        let update_tmp_first: AU = pre.first;
                        let update_tmp_mini_allocator: MiniAllocator =
                            pre.mini_allocator;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "Put")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal_v::LinkedJournal::State::next(pre.journal,
                                                new_journal, State::linked_lbl(lbl))) &&
                                        (#[verifier::custom_err("cannot prove that the field `mini_allocator` is preserved")] (::builtin::equal(post.mini_allocator,
                                                        update_tmp_mini_allocator)) &&
                                                (#[verifier::custom_err("cannot prove that the field `first` is preserved")] (::builtin::equal(post.first,
                                                                update_tmp_first)) &&
                                                        (#[verifier::custom_err("cannot prove that the field `lsn_au_index` is preserved")] (::builtin::equal(post.lsn_au_index,
                                                                        update_tmp_lsn_au_index)) &&
                                                                #[verifier::custom_err("cannot prove that the field `journal` is preserved")] (::builtin::equal(post.journal,
                                                                        update_tmp_journal)))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put_strong(pre: Self, post: Self, lbl: Label,
                    new_journal: LinkedJournal_v::LinkedJournal::State)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_journal: LinkedJournal::State = pre.journal;
                        let update_tmp_lsn_au_index: Map<LSN, AU> =
                            pre.lsn_au_index;
                        let update_tmp_first: AU = pre.first;
                        let update_tmp_mini_allocator: MiniAllocator =
                            pre.mini_allocator;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "Put")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal_v::LinkedJournal::State::next(pre.journal,
                                                new_journal, State::linked_lbl(lbl))) &&
                                        (#[verifier::custom_err("cannot prove that the field `mini_allocator` is preserved")] (::builtin::equal(post.mini_allocator,
                                                        update_tmp_mini_allocator)) &&
                                                (#[verifier::custom_err("cannot prove that the field `first` is preserved")] (::builtin::equal(post.first,
                                                                update_tmp_first)) &&
                                                        (#[verifier::custom_err("cannot prove that the field `lsn_au_index` is preserved")] (::builtin::equal(post.lsn_au_index,
                                                                        update_tmp_lsn_au_index)) &&
                                                                #[verifier::custom_err("cannot prove that the field `journal` is preserved")] (::builtin::equal(post.journal,
                                                                        update_tmp_journal)))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put_enabled(pre: Self, lbl: Label,
                    new_journal: LinkedJournal_v::LinkedJournal::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "Put")) &&
                                #[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal_v::LinkedJournal::State::next(pre.journal,
                                        new_journal, State::linked_lbl(lbl))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn discard_old(pre: Self, post: Self, lbl: Label,
                    post_journal: LinkedJournal::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (State::lbl_wf(lbl))
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                                        "DiscardOld")) &&
                                                {
                                                    let start_lsn = lbl.get_DiscardOld_start_lsn();
                                                    let require_end = lbl.get_DiscardOld_require_end();
                                                    let deallocs = lbl.get_DiscardOld_deallocs();
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(require_end,
                                                                    pre.journal.seq_end())) &&
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (pre.tj().can_discard_to(start_lsn))
                                                                    &&
                                                                    {
                                                                        let new_first =
                                                                            State::new_first(pre.tj(), pre.lsn_au_index, pre.first,
                                                                                start_lsn);
                                                                        let new_lsn_au_index =
                                                                            State::lsn_au_index_discarding_up_to(pre.lsn_au_index,
                                                                                start_lsn);
                                                                        let discarded_aus =
                                                                            pre.lsn_au_index.values().difference(new_lsn_au_index.values());
                                                                        let keep_addrs =
                                                                            Set::new(::builtin::closure_to_fn_spec(|addr: Address|
                                                                                        addr.wf() && new_lsn_au_index.values().contains(addr.au)));
                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(deallocs,
                                                                                        discarded_aus)) &&
                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.tj().discard_old_cond(start_lsn,
                                                                                                keep_addrs, post_journal.truncated_journal)) &&
                                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(post_journal.unmarshalled_tail,
                                                                                                        pre.journal.unmarshalled_tail.bounded_discard(start_lsn)))
                                                                                                &&
                                                                                                {
                                                                                                    let update_tmp_journal: LinkedJournal::State = post_journal;
                                                                                                    let update_tmp_lsn_au_index: Map<LSN, AU> =
                                                                                                        new_lsn_au_index;
                                                                                                    let update_tmp_first: AU = new_first;
                                                                                                    let update_tmp_mini_allocator: MiniAllocator =
                                                                                                        pre.mini_allocator.prune(discarded_aus.intersect(pre.mini_allocator.allocs.dom()));
                                                                                                    (#[verifier::custom_err("cannot prove that final value of field `mini_allocator` has this updated value")] (::builtin::equal(post.mini_allocator,
                                                                                                                    update_tmp_mini_allocator)) &&
                                                                                                            (#[verifier::custom_err("cannot prove that final value of field `first` has this updated value")] (::builtin::equal(post.first,
                                                                                                                            update_tmp_first)) &&
                                                                                                                    (#[verifier::custom_err("cannot prove that final value of field `lsn_au_index` has this updated value")] (::builtin::equal(post.lsn_au_index,
                                                                                                                                    update_tmp_lsn_au_index)) &&
                                                                                                                            #[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")] (::builtin::equal(post.journal,
                                                                                                                                    update_tmp_journal)))))
                                                                                                })))
                                                                    }))
                                                })))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn discard_old_strong(pre: Self, post: Self, lbl: Label,
                    post_journal: LinkedJournal::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (State::lbl_wf(lbl))
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                                        "DiscardOld")) &&
                                                {
                                                    let start_lsn = lbl.get_DiscardOld_start_lsn();
                                                    let require_end = lbl.get_DiscardOld_require_end();
                                                    let deallocs = lbl.get_DiscardOld_deallocs();
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(require_end,
                                                                    pre.journal.seq_end())) &&
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (pre.tj().can_discard_to(start_lsn))
                                                                    &&
                                                                    {
                                                                        let new_first =
                                                                            State::new_first(pre.tj(), pre.lsn_au_index, pre.first,
                                                                                start_lsn);
                                                                        let new_lsn_au_index =
                                                                            State::lsn_au_index_discarding_up_to(pre.lsn_au_index,
                                                                                start_lsn);
                                                                        let discarded_aus =
                                                                            pre.lsn_au_index.values().difference(new_lsn_au_index.values());
                                                                        let keep_addrs =
                                                                            Set::new(::builtin::closure_to_fn_spec(|addr: Address|
                                                                                        addr.wf() && new_lsn_au_index.values().contains(addr.au)));
                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(deallocs,
                                                                                        discarded_aus)) &&
                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.tj().discard_old_cond(start_lsn,
                                                                                                keep_addrs, post_journal.truncated_journal)) &&
                                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(post_journal.unmarshalled_tail,
                                                                                                        pre.journal.unmarshalled_tail.bounded_discard(start_lsn)))
                                                                                                &&
                                                                                                {
                                                                                                    let update_tmp_journal: LinkedJournal::State = post_journal;
                                                                                                    let update_tmp_lsn_au_index: Map<LSN, AU> =
                                                                                                        new_lsn_au_index;
                                                                                                    let update_tmp_first: AU = new_first;
                                                                                                    let update_tmp_mini_allocator: MiniAllocator =
                                                                                                        pre.mini_allocator.prune(discarded_aus.intersect(pre.mini_allocator.allocs.dom()));
                                                                                                    (#[verifier::custom_err("cannot prove that final value of field `mini_allocator` has this updated value")] (::builtin::equal(post.mini_allocator,
                                                                                                                    update_tmp_mini_allocator)) &&
                                                                                                            (#[verifier::custom_err("cannot prove that final value of field `first` has this updated value")] (::builtin::equal(post.first,
                                                                                                                            update_tmp_first)) &&
                                                                                                                    (#[verifier::custom_err("cannot prove that final value of field `lsn_au_index` has this updated value")] (::builtin::equal(post.lsn_au_index,
                                                                                                                                    update_tmp_lsn_au_index)) &&
                                                                                                                            #[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")] (::builtin::equal(post.journal,
                                                                                                                                    update_tmp_journal)))))
                                                                                                })))
                                                                    }))
                                                })))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn discard_old_enabled(pre: Self, lbl: Label,
                    post_journal: LinkedJournal::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (State::lbl_wf(lbl))
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                                        "DiscardOld")) &&
                                                {
                                                    let start_lsn = lbl.get_DiscardOld_start_lsn();
                                                    let require_end = lbl.get_DiscardOld_require_end();
                                                    let deallocs = lbl.get_DiscardOld_deallocs();
                                                    (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(require_end,
                                                                    pre.journal.seq_end())) &&
                                                            (#[verifier::custom_err("cannot prove this condition holds")] (pre.tj().can_discard_to(start_lsn))
                                                                    &&
                                                                    {
                                                                        let new_first =
                                                                            State::new_first(pre.tj(), pre.lsn_au_index, pre.first,
                                                                                start_lsn);
                                                                        let new_lsn_au_index =
                                                                            State::lsn_au_index_discarding_up_to(pre.lsn_au_index,
                                                                                start_lsn);
                                                                        let discarded_aus =
                                                                            pre.lsn_au_index.values().difference(new_lsn_au_index.values());
                                                                        let keep_addrs =
                                                                            Set::new(::builtin::closure_to_fn_spec(|addr: Address|
                                                                                        addr.wf() && new_lsn_au_index.values().contains(addr.au)));
                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(deallocs,
                                                                                        discarded_aus)) &&
                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.tj().discard_old_cond(start_lsn,
                                                                                                keep_addrs, post_journal.truncated_journal)) &&
                                                                                        #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(post_journal.unmarshalled_tail,
                                                                                                pre.journal.unmarshalled_tail.bounded_discard(start_lsn)))))
                                                                    }))
                                                })))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_journal_marshal(pre: Self, post: Self,
                    lbl: Label, cut: LSN, addr: Address,
                    post_linked_journal: LinkedJournal::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (State::lbl_wf(lbl))
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                                        "InternalAllocations")) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(lbl.get_InternalAllocations_allocs(),
                                                                Set::<AU>::empty())) &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(lbl.get_InternalAllocations_deallocs(),
                                                                        Set::<AU>::empty())) &&
                                                                (#[verifier::custom_err("cannot prove this condition holds")] (State::valid_next_journal_addr(pre.mini_allocator,
                                                                                pre.journal.truncated_journal.freshest_rec, addr)) &&
                                                                        (#[verifier::custom_err("cannot prove this condition holds")] ((pre.journal.unmarshalled_tail.seq_start).spec_lt(cut))
                                                                                &&
                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.journal.unmarshalled_tail.can_discard_to(cut))
                                                                                        &&
                                                                                        {
                                                                                            let marshalled_msgs =
                                                                                                pre.journal.unmarshalled_tail.discard_recent(cut);
                                                                                            (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(post_linked_journal.truncated_journal,
                                                                                                            pre.tj().append_record(addr, marshalled_msgs))) &&
                                                                                                    (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(post_linked_journal.unmarshalled_tail,
                                                                                                                    pre.journal.unmarshalled_tail.discard_old(cut))) &&
                                                                                                            {
                                                                                                                let update_tmp_journal: LinkedJournal::State =
                                                                                                                    post_linked_journal;
                                                                                                                let update_tmp_lsn_au_index: Map<LSN, AU> =
                                                                                                                    State::lsn_au_index_append_record(pre.lsn_au_index,
                                                                                                                        marshalled_msgs, addr.au);
                                                                                                                let update_tmp_first: AU =
                                                                                                                    if pre.journal.truncated_journal.freshest_rec.is_Some() {
                                                                                                                            pre.first
                                                                                                                        } else { addr.au };
                                                                                                                let update_tmp_mini_allocator: MiniAllocator =
                                                                                                                    pre.mini_allocator.allocate_and_observe(addr);
                                                                                                                (#[verifier::custom_err("cannot prove that final value of field `mini_allocator` has this updated value")] (::builtin::equal(post.mini_allocator,
                                                                                                                                update_tmp_mini_allocator)) &&
                                                                                                                        (#[verifier::custom_err("cannot prove that final value of field `first` has this updated value")] (::builtin::equal(post.first,
                                                                                                                                        update_tmp_first)) &&
                                                                                                                                (#[verifier::custom_err("cannot prove that final value of field `lsn_au_index` has this updated value")] (::builtin::equal(post.lsn_au_index,
                                                                                                                                                update_tmp_lsn_au_index)) &&
                                                                                                                                        #[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")] (::builtin::equal(post.journal,
                                                                                                                                                update_tmp_journal)))))
                                                                                                            }))
                                                                                        }))))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_journal_marshal_strong(pre: Self, post: Self,
                    lbl: Label, cut: LSN, addr: Address,
                    post_linked_journal: LinkedJournal::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (State::lbl_wf(lbl))
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                                        "InternalAllocations")) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(lbl.get_InternalAllocations_allocs(),
                                                                Set::<AU>::empty())) &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(lbl.get_InternalAllocations_deallocs(),
                                                                        Set::<AU>::empty())) &&
                                                                (#[verifier::custom_err("cannot prove this condition holds")] (State::valid_next_journal_addr(pre.mini_allocator,
                                                                                pre.journal.truncated_journal.freshest_rec, addr)) &&
                                                                        (#[verifier::custom_err("cannot prove this condition holds")] ((pre.journal.unmarshalled_tail.seq_start).spec_lt(cut))
                                                                                &&
                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.journal.unmarshalled_tail.can_discard_to(cut))
                                                                                        &&
                                                                                        {
                                                                                            let marshalled_msgs =
                                                                                                pre.journal.unmarshalled_tail.discard_recent(cut);
                                                                                            (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(post_linked_journal.truncated_journal,
                                                                                                            pre.tj().append_record(addr, marshalled_msgs))) &&
                                                                                                    (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(post_linked_journal.unmarshalled_tail,
                                                                                                                    pre.journal.unmarshalled_tail.discard_old(cut))) &&
                                                                                                            {
                                                                                                                let update_tmp_journal: LinkedJournal::State =
                                                                                                                    post_linked_journal;
                                                                                                                let update_tmp_lsn_au_index: Map<LSN, AU> =
                                                                                                                    State::lsn_au_index_append_record(pre.lsn_au_index,
                                                                                                                        marshalled_msgs, addr.au);
                                                                                                                let update_tmp_first: AU =
                                                                                                                    if pre.journal.truncated_journal.freshest_rec.is_Some() {
                                                                                                                            pre.first
                                                                                                                        } else { addr.au };
                                                                                                                let update_tmp_mini_allocator: MiniAllocator =
                                                                                                                    pre.mini_allocator.allocate_and_observe(addr);
                                                                                                                (#[verifier::custom_err("cannot prove that final value of field `mini_allocator` has this updated value")] (::builtin::equal(post.mini_allocator,
                                                                                                                                update_tmp_mini_allocator)) &&
                                                                                                                        (#[verifier::custom_err("cannot prove that final value of field `first` has this updated value")] (::builtin::equal(post.first,
                                                                                                                                        update_tmp_first)) &&
                                                                                                                                (#[verifier::custom_err("cannot prove that final value of field `lsn_au_index` has this updated value")] (::builtin::equal(post.lsn_au_index,
                                                                                                                                                update_tmp_lsn_au_index)) &&
                                                                                                                                        #[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")] (::builtin::equal(post.journal,
                                                                                                                                                update_tmp_journal)))))
                                                                                                            }))
                                                                                        }))))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_journal_marshal_enabled(pre: Self, lbl: Label,
                    cut: LSN, addr: Address,
                    post_linked_journal: LinkedJournal::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (State::lbl_wf(lbl))
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                                        "InternalAllocations")) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(lbl.get_InternalAllocations_allocs(),
                                                                Set::<AU>::empty())) &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(lbl.get_InternalAllocations_deallocs(),
                                                                        Set::<AU>::empty())) &&
                                                                (#[verifier::custom_err("cannot prove this condition holds")] (State::valid_next_journal_addr(pre.mini_allocator,
                                                                                pre.journal.truncated_journal.freshest_rec, addr)) &&
                                                                        (#[verifier::custom_err("cannot prove this condition holds")] ((pre.journal.unmarshalled_tail.seq_start).spec_lt(cut))
                                                                                &&
                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.journal.unmarshalled_tail.can_discard_to(cut))
                                                                                        &&
                                                                                        {
                                                                                            let marshalled_msgs =
                                                                                                pre.journal.unmarshalled_tail.discard_recent(cut);
                                                                                            (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(post_linked_journal.truncated_journal,
                                                                                                            pre.tj().append_record(addr, marshalled_msgs))) &&
                                                                                                    #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(post_linked_journal.unmarshalled_tail,
                                                                                                            pre.journal.unmarshalled_tail.discard_old(cut))))
                                                                                        }))))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_mini_allocator_fill(pre: Self, post: Self,
                    lbl: Label) -> ::core::primitive::bool {
                    {
                        let update_tmp_journal: LinkedJournal::State = pre.journal;
                        let update_tmp_lsn_au_index: Map<LSN, AU> =
                            pre.lsn_au_index;
                        let update_tmp_first: AU = pre.first;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (State::lbl_wf(lbl))
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_InternalAllocations())
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(lbl.get_InternalAllocations_deallocs(),
                                                                Set::<AU>::empty())) &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.get_InternalAllocations_allocs().disjoint(pre.mini_allocator.allocs.dom()))
                                                                &&
                                                                {
                                                                    let update_tmp_mini_allocator: MiniAllocator =
                                                                        pre.mini_allocator.add_aus(lbl.get_InternalAllocations_allocs());
                                                                    (#[verifier::custom_err("cannot prove that final value of field `mini_allocator` has this updated value")] (::builtin::equal(post.mini_allocator,
                                                                                    update_tmp_mini_allocator)) &&
                                                                            (#[verifier::custom_err("cannot prove that the field `first` is preserved")] (::builtin::equal(post.first,
                                                                                            update_tmp_first)) &&
                                                                                    (#[verifier::custom_err("cannot prove that the field `lsn_au_index` is preserved")] (::builtin::equal(post.lsn_au_index,
                                                                                                    update_tmp_lsn_au_index)) &&
                                                                                            #[verifier::custom_err("cannot prove that the field `journal` is preserved")] (::builtin::equal(post.journal,
                                                                                                    update_tmp_journal)))))
                                                                })))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_mini_allocator_fill_strong(pre: Self,
                    post: Self, lbl: Label) -> ::core::primitive::bool {
                    {
                        let update_tmp_journal: LinkedJournal::State = pre.journal;
                        let update_tmp_lsn_au_index: Map<LSN, AU> =
                            pre.lsn_au_index;
                        let update_tmp_first: AU = pre.first;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (State::lbl_wf(lbl))
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_InternalAllocations())
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(lbl.get_InternalAllocations_deallocs(),
                                                                Set::<AU>::empty())) &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.get_InternalAllocations_allocs().disjoint(pre.mini_allocator.allocs.dom()))
                                                                &&
                                                                {
                                                                    let update_tmp_mini_allocator: MiniAllocator =
                                                                        pre.mini_allocator.add_aus(lbl.get_InternalAllocations_allocs());
                                                                    (#[verifier::custom_err("cannot prove that final value of field `mini_allocator` has this updated value")] (::builtin::equal(post.mini_allocator,
                                                                                    update_tmp_mini_allocator)) &&
                                                                            (#[verifier::custom_err("cannot prove that the field `first` is preserved")] (::builtin::equal(post.first,
                                                                                            update_tmp_first)) &&
                                                                                    (#[verifier::custom_err("cannot prove that the field `lsn_au_index` is preserved")] (::builtin::equal(post.lsn_au_index,
                                                                                                    update_tmp_lsn_au_index)) &&
                                                                                            #[verifier::custom_err("cannot prove that the field `journal` is preserved")] (::builtin::equal(post.journal,
                                                                                                    update_tmp_journal)))))
                                                                })))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_mini_allocator_fill_enabled(pre: Self,
                    lbl: Label) -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (State::lbl_wf(lbl))
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_InternalAllocations())
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(lbl.get_InternalAllocations_deallocs(),
                                                                Set::<AU>::empty())) &&
                                                        #[verifier::custom_err("cannot prove this condition holds")] (lbl.get_InternalAllocations_allocs().disjoint(pre.mini_allocator.allocs.dom()))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_mini_allocator_prune(pre: Self, post: Self,
                    lbl: Label) -> ::core::primitive::bool {
                    {
                        let update_tmp_journal: LinkedJournal::State = pre.journal;
                        let update_tmp_lsn_au_index: Map<LSN, AU> =
                            pre.lsn_au_index;
                        let update_tmp_first: AU = pre.first;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (State::lbl_wf(lbl))
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_InternalAllocations())
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(lbl.get_InternalAllocations_allocs(),
                                                                Set::<AU>::empty())) &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::forall(|au|
                                                                            ::builtin::imply(lbl.get_InternalAllocations_deallocs().contains(au),
                                                                                pre.mini_allocator.can_remove(au)))) &&
                                                                {
                                                                    let update_tmp_mini_allocator: MiniAllocator =
                                                                        pre.mini_allocator.prune(lbl.get_InternalAllocations_deallocs());
                                                                    (#[verifier::custom_err("cannot prove that final value of field `mini_allocator` has this updated value")] (::builtin::equal(post.mini_allocator,
                                                                                    update_tmp_mini_allocator)) &&
                                                                            (#[verifier::custom_err("cannot prove that the field `first` is preserved")] (::builtin::equal(post.first,
                                                                                            update_tmp_first)) &&
                                                                                    (#[verifier::custom_err("cannot prove that the field `lsn_au_index` is preserved")] (::builtin::equal(post.lsn_au_index,
                                                                                                    update_tmp_lsn_au_index)) &&
                                                                                            #[verifier::custom_err("cannot prove that the field `journal` is preserved")] (::builtin::equal(post.journal,
                                                                                                    update_tmp_journal)))))
                                                                })))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_mini_allocator_prune_strong(pre: Self,
                    post: Self, lbl: Label) -> ::core::primitive::bool {
                    {
                        let update_tmp_journal: LinkedJournal::State = pre.journal;
                        let update_tmp_lsn_au_index: Map<LSN, AU> =
                            pre.lsn_au_index;
                        let update_tmp_first: AU = pre.first;
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (State::lbl_wf(lbl))
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_InternalAllocations())
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(lbl.get_InternalAllocations_allocs(),
                                                                Set::<AU>::empty())) &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::forall(|au|
                                                                            ::builtin::imply(lbl.get_InternalAllocations_deallocs().contains(au),
                                                                                pre.mini_allocator.can_remove(au)))) &&
                                                                {
                                                                    let update_tmp_mini_allocator: MiniAllocator =
                                                                        pre.mini_allocator.prune(lbl.get_InternalAllocations_deallocs());
                                                                    (#[verifier::custom_err("cannot prove that final value of field `mini_allocator` has this updated value")] (::builtin::equal(post.mini_allocator,
                                                                                    update_tmp_mini_allocator)) &&
                                                                            (#[verifier::custom_err("cannot prove that the field `first` is preserved")] (::builtin::equal(post.first,
                                                                                            update_tmp_first)) &&
                                                                                    (#[verifier::custom_err("cannot prove that the field `lsn_au_index` is preserved")] (::builtin::equal(post.lsn_au_index,
                                                                                                    update_tmp_lsn_au_index)) &&
                                                                                            #[verifier::custom_err("cannot prove that the field `journal` is preserved")] (::builtin::equal(post.journal,
                                                                                                    update_tmp_journal)))))
                                                                })))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_mini_allocator_prune_enabled(pre: Self,
                    lbl: Label) -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.wf())
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (State::lbl_wf(lbl))
                                        &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (lbl.is_InternalAllocations())
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(lbl.get_InternalAllocations_allocs(),
                                                                Set::<AU>::empty())) &&
                                                        #[verifier::custom_err("cannot prove this condition holds")] (::builtin::forall(|au|
                                                                    ::builtin::imply(lbl.get_InternalAllocations_deallocs().contains(au),
                                                                        pre.mini_allocator.can_remove(au))))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_no_op(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_journal: LinkedJournal::State = pre.journal;
                        let update_tmp_lsn_au_index: Map<LSN, AU> =
                            pre.lsn_au_index;
                        let update_tmp_first: AU = pre.first;
                        let update_tmp_mini_allocator: MiniAllocator =
                            pre.mini_allocator;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "InternalAllocations")) &&
                                (#[verifier::custom_err("cannot prove that the field `mini_allocator` is preserved")] (::builtin::equal(post.mini_allocator,
                                                update_tmp_mini_allocator)) &&
                                        (#[verifier::custom_err("cannot prove that the field `first` is preserved")] (::builtin::equal(post.first,
                                                        update_tmp_first)) &&
                                                (#[verifier::custom_err("cannot prove that the field `lsn_au_index` is preserved")] (::builtin::equal(post.lsn_au_index,
                                                                update_tmp_lsn_au_index)) &&
                                                        #[verifier::custom_err("cannot prove that the field `journal` is preserved")] (::builtin::equal(post.journal,
                                                                update_tmp_journal))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_no_op_strong(pre: Self, post: Self,
                    lbl: Label) -> ::core::primitive::bool {
                    {
                        let update_tmp_journal: LinkedJournal::State = pre.journal;
                        let update_tmp_lsn_au_index: Map<LSN, AU> =
                            pre.lsn_au_index;
                        let update_tmp_first: AU = pre.first;
                        let update_tmp_mini_allocator: MiniAllocator =
                            pre.mini_allocator;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "InternalAllocations")) &&
                                (#[verifier::custom_err("cannot prove that the field `mini_allocator` is preserved")] (::builtin::equal(post.mini_allocator,
                                                update_tmp_mini_allocator)) &&
                                        (#[verifier::custom_err("cannot prove that the field `first` is preserved")] (::builtin::equal(post.first,
                                                        update_tmp_first)) &&
                                                (#[verifier::custom_err("cannot prove that the field `lsn_au_index` is preserved")] (::builtin::equal(post.lsn_au_index,
                                                                update_tmp_lsn_au_index)) &&
                                                        #[verifier::custom_err("cannot prove that the field `journal` is preserved")] (::builtin::equal(post.journal,
                                                                update_tmp_journal))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_no_op_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {

                        #[verifier::custom_err("cannot prove this condition holds")]
                        (::builtin::is_variant(lbl, "InternalAllocations"))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn initialize(post: Self, journal: LinkedJournal::State,
                    image: JournalImage) -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (State::valid_journal_image(image))
                                &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal::State::initialize(journal,
                                                image.tj)) &&
                                        {
                                            let lsn_au_index =
                                                State::build_lsn_au_index(image.tj, image.first);
                                            let update_tmp_journal: LinkedJournal::State = journal;
                                            let update_tmp_lsn_au_index: Map<LSN, AU> = lsn_au_index;
                                            let update_tmp_first: AU = image.first;
                                            let update_tmp_mini_allocator: MiniAllocator =
                                                MiniAllocator::empty();
                                            (#[verifier::custom_err("cannot prove that final value of field `mini_allocator` has this updated value")] (::builtin::equal(post.mini_allocator,
                                                            update_tmp_mini_allocator)) &&
                                                    (#[verifier::custom_err("cannot prove that final value of field `first` has this updated value")] (::builtin::equal(post.first,
                                                                    update_tmp_first)) &&
                                                            (#[verifier::custom_err("cannot prove that final value of field `lsn_au_index` has this updated value")] (::builtin::equal(post.lsn_au_index,
                                                                            update_tmp_lsn_au_index)) &&
                                                                    #[verifier::custom_err("cannot prove that final value of field `journal` has this updated value")] (::builtin::equal(post.journal,
                                                                            update_tmp_journal)))))
                                        }))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn initialize_enabled(journal: LinkedJournal::State,
                    image: JournalImage) -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (State::valid_journal_image(image))
                                &&
                                #[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal::State::initialize(journal,
                                        image.tj)))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_by(pre: State, post: State, label: Label,
                    step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::read_for_recovery() =>
                            Self::read_for_recovery(pre, post, label),
                        Step::freeze_for_commit() =>
                            Self::freeze_for_commit(pre, post, label),
                        Step::query_end_lsn() =>
                            Self::query_end_lsn(pre, post, label),
                        Step::put(new_journal) =>
                            Self::put(pre, post, label, new_journal),
                        Step::discard_old(post_journal) =>
                            Self::discard_old(pre, post, label, post_journal),
                        Step::internal_journal_marshal(cut, addr,
                            post_linked_journal) =>
                            Self::internal_journal_marshal(pre, post, label, cut, addr,
                                post_linked_journal),
                        Step::internal_mini_allocator_fill() =>
                            Self::internal_mini_allocator_fill(pre, post, label),
                        Step::internal_mini_allocator_prune() =>
                            Self::internal_mini_allocator_prune(pre, post, label),
                        Step::internal_no_op() =>
                            Self::internal_no_op(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next(pre: State, post: State, label: Label)
                    -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                            Self::next_by(pre, post, label, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_strong_by(pre: State, post: State, label: Label,
                    step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::read_for_recovery() =>
                            Self::read_for_recovery_strong(pre, post, label),
                        Step::freeze_for_commit() =>
                            Self::freeze_for_commit_strong(pre, post, label),
                        Step::query_end_lsn() =>
                            Self::query_end_lsn_strong(pre, post, label),
                        Step::put(new_journal) =>
                            Self::put_strong(pre, post, label, new_journal),
                        Step::discard_old(post_journal) =>
                            Self::discard_old_strong(pre, post, label, post_journal),
                        Step::internal_journal_marshal(cut, addr,
                            post_linked_journal) =>
                            Self::internal_journal_marshal_strong(pre, post, label, cut,
                                addr, post_linked_journal),
                        Step::internal_mini_allocator_fill() =>
                            Self::internal_mini_allocator_fill_strong(pre, post, label),
                        Step::internal_mini_allocator_prune() =>
                            Self::internal_mini_allocator_prune_strong(pre, post,
                                label),
                        Step::internal_no_op() =>
                            Self::internal_no_op_strong(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_strong(pre: State, post: State, label: Label)
                    -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                            Self::next_strong_by(pre, post, label, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn init_by(post: State, step: Config)
                    -> ::core::primitive::bool {
                    match step {
                        Config::initialize(journal, image) =>
                            Self::initialize(post, journal, image),
                        Config::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn init(post: State) -> ::core::primitive::bool {
                    ::builtin::exists(|step: Config| Self::init_by(post, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::spec]
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                pub fn invariant(&self) -> ::core::primitive::bool {
                    self.inv()
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn inv(self) -> bool {
                    (((((((self.wf()) &&
                                                                        (LinkedJournal::State::inv(self.journal))) &&
                                                                (::builtin::spec_eq(self.lsn_au_index,
                                                                        Self::build_lsn_au_index(self.tj(), self.first)))) &&
                                                        (Self::journal_pages_not_free(self.tj().disk_view.entries.dom(),
                                                                self.mini_allocator))) &&
                                                (Self::mini_allocator_follows_freshest_rec(self.tj().freshest_rec,
                                                        self.mini_allocator))) &&
                                        (Self::aus_hold_contiguous_lsns(self.lsn_au_index))) &&
                                ((::builtin::imply(self.tj().freshest_rec.is_Some(),
                                            Self::valid_first_au(self.tj().disk_view, self.first))))) &&
                        ((::builtin::imply(self.tj().freshest_rec.is_Some(),
                                    Self::internal_au_pages_fully_linked(self.tj().disk_view))))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::custom_req_err("could not show invariant `inv` on the `post` state")]
                #[verifier::external_body]
                #[verus::internal(verus_macro)]
                #[verifier::proof]
                fn lemma_msg_inv(s: State) {
                    ::builtin::requires(s.inv());
                    ::builtin::ensures(s.inv());
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn freeze_for_commit_inductive(pre: Self, post: Self,
                    lbl: Label) {
                    ::builtin::requires(pre.invariant() &&
                            State::freeze_for_commit_strong(pre, post, lbl));
                    ::builtin::ensures(post.invariant());
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(LinkedJournal::State::next)
                                }
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(LinkedJournal::State::next_by)
                                }
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                    Self::lemma_msg_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn read_for_recovery_inductive(pre: Self, post: Self,
                    lbl: Label) {
                    ::builtin::requires(pre.invariant() &&
                            State::read_for_recovery_strong(pre, post, lbl));
                    ::builtin::ensures(post.invariant());
                    {}
                    Self::lemma_msg_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn query_end_lsn_inductive(pre: Self, post: Self,
                    lbl: Label) {
                    ::builtin::requires(pre.invariant() &&
                            State::query_end_lsn_strong(pre, post, lbl));
                    ::builtin::ensures(post.invariant());
                    {}
                    Self::lemma_msg_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn put_inductive(pre: Self, post: Self, lbl: Label,
                    new_journal: LinkedJournal_v::LinkedJournal::State) {
                    ::builtin::requires(pre.invariant() &&
                            State::put_strong(pre, post, lbl, new_journal));
                    ::builtin::ensures(post.invariant());
                    {}
                    Self::lemma_msg_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn internal_mini_allocator_fill_inductive(pre: Self,
                    post: Self, lbl: Label) {
                    ::builtin::requires(pre.invariant() &&
                            State::internal_mini_allocator_fill_strong(pre, post, lbl));
                    ::builtin::ensures(post.invariant());
                    { ::builtin::assume_(false); }
                    Self::lemma_msg_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn internal_mini_allocator_prune_inductive(pre: Self,
                    post: Self, lbl: Label) {
                    ::builtin::requires(pre.invariant() &&
                            State::internal_mini_allocator_prune_strong(pre, post,
                                lbl));
                    ::builtin::ensures(post.invariant());
                    {}
                    Self::lemma_msg_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn discard_old_inductive(pre: Self, post: Self, lbl: Label,
                    post_journal: LinkedJournal::State) {
                    ::builtin::requires(pre.invariant() &&
                            State::discard_old_strong(pre, post, lbl, post_journal));
                    ::builtin::ensures(post.invariant());
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(LinkedJournal::State::next)
                                }
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(LinkedJournal::State::next_by)
                                }
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(LinkedJournal::State::next_by)
                                }
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                        Self::invoke_submodule_inv(pre, post);
                        ::builtin::assert_(post.wf());
                        ::builtin::assume_(false);
                        ::builtin::assert_(Self::journal_pages_not_free(post.tj().disk_view.entries.dom(),
                                post.mini_allocator));
                        if post.tj().freshest_rec.is_Some() &&
                                    post.tj().freshest_rec.is_None() {}
                        ::builtin::assert_(Self::mini_allocator_follows_freshest_rec(post.tj().freshest_rec,
                                post.mini_allocator));
                        {
                            ::builtin::assert_forall_by(|lsn1, lsn2, lsn3|
                                    {
                                        ::builtin::ensures(Self::contiguous_lsns(post.lsn_au_index,
                                                lsn1, lsn2, lsn3));
                                        if {
                                                    (((::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(lsn1),
                                                                                        lsn2), lsn3))) && (post.lsn_au_index.contains_key(lsn1))) &&
                                                                (post.lsn_au_index.contains_key(lsn3))) &&
                                                        (::builtin::spec_eq(post.lsn_au_index.spec_index(lsn1),
                                                                post.lsn_au_index.spec_index(lsn3)))
                                                } {
                                                ::builtin::assert_(Self::contiguous_lsns(pre.lsn_au_index,
                                                        lsn1, lsn2, lsn3));
                                            }
                                        ::builtin::assert_(Self::contiguous_lsns(post.lsn_au_index,
                                                lsn1, lsn2, lsn3));
                                    });
                        }
                        let pre_dv = pre.tj().disk_view;
                        let post_dv = post.tj().disk_view;
                        if post.tj().freshest_rec.is_Some() {
                                {
                                    ::builtin::assert_by(Self::valid_first_au(post_dv,
                                            post.first),
                                        {
                                            ::builtin::reveal_hide_({
                                                    #[verus::internal(reveal_fn)]
                                                    fn __VERUS_REVEAL_INTERNAL__() {
                                                        ::builtin::reveal_hide_internal_path_(TruncatedJournal::index_domain_valid)
                                                    }
                                                    __VERUS_REVEAL_INTERNAL__
                                                }, 1);
                                        });
                                }
                                {
                                    ::builtin::assert_by(Self::internal_au_pages_fully_linked(post.tj().disk_view),
                                        {
                                            ::builtin::reveal_hide_({
                                                    #[verus::internal(reveal_fn)]
                                                    fn __VERUS_REVEAL_INTERNAL__() {
                                                        ::builtin::reveal_hide_internal_path_(AllocationJournal::State::pages_allocated_in_lsn_order)
                                                    }
                                                    __VERUS_REVEAL_INTERNAL__
                                                }, 1);
                                        });
                                }
                            }
                        ::builtin::assume_(false);
                        Self::build_commutes_over_discard(pre_dv,
                            post.tj().freshest_rec, pre.first, post_dv.boundary_lsn);
                        ::builtin::assert_(post.inv());
                    }
                    Self::lemma_msg_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn internal_journal_marshal_inductive(pre: Self, post: Self,
                    lbl: Label, cut: LSN, addr: Address,
                    post_linked_journal: LinkedJournal::State) {
                    ::builtin::requires(pre.invariant() &&
                            State::internal_journal_marshal_strong(pre, post, lbl, cut,
                                addr, post_linked_journal));
                    ::builtin::ensures(post.invariant());
                    {
                        Self::invoke_submodule_inv(pre, post);
                        ::builtin::assume_(false);
                        let discard_msgs =
                            pre.journal.unmarshalled_tail.discard_recent(cut);
                        {
                            ::builtin::assert_by(LikesJournal_v::lsn_disjoint(pre.lsn_au_index.dom(),
                                    discard_msgs),
                                {
                                    ::builtin::reveal_hide_({
                                            #[verus::internal(reveal_fn)]
                                            fn __VERUS_REVEAL_INTERNAL__() {
                                                ::builtin::reveal_hide_internal_path_(TruncatedJournal::index_domain_valid)
                                            }
                                            __VERUS_REVEAL_INTERNAL__
                                        }, 1);
                                });
                        }
                        let msgs =
                            pre.journal.unmarshalled_tail.discard_recent(cut);
                        let pre_dv = pre.tj().disk_view;
                        let pre_root = pre.tj().freshest_rec;
                        let post_dv = post.tj().disk_view;
                        let post_root = post.tj().freshest_rec;
                        ::builtin::assert_(::builtin::spec_eq(pre.lsn_au_index,
                                Self::build_lsn_au_index(pre.tj(), pre.first)));
                        if ::builtin::is_variant(pre_root, "Some") {
                                Self::build_lsn_au_index_equiv_page_walk(pre_dv, pre_root,
                                    pre.first);
                                ::builtin::assert_(::builtin::spec_eq(pre.lsn_au_index,
                                        Self::build_lsn_au_index_page_walk(pre_dv, pre_root)));
                            } else {
                               ::builtin::assert_(::builtin::ext_equal(Self::build_lsn_au_index(pre.tj(),
                                           pre.first), Map::empty()));
                               ::builtin::assert_(::builtin::ext_equal(Self::build_lsn_au_index_page_walk(pre_dv,
                                           pre_root), Map::empty()));
                               ::builtin::assert_(::builtin::spec_eq(pre.lsn_au_index,
                                       Self::build_lsn_au_index_page_walk(pre_dv, pre_root)));
                           }
                        let curr_msgs =
                            post_dv.entries.spec_index(post_root.unwrap()).message_seq;
                        let update =
                            Self::singleton_index(::builtin::spec_cast_integer::<_,
                                        nat>(math::max(::builtin::spec_cast_integer::<_,
                                                int>(post_dv.boundary_lsn),
                                        ::builtin::spec_cast_integer::<_,
                                                int>(curr_msgs.seq_start))), curr_msgs.seq_end,
                                post_root.unwrap().au);
                        ::builtin::assert_(::builtin::spec_eq(post_dv.next(post_root),
                                pre_root));
                        Self::build_lsn_au_index_page_walk_sub_disk(pre_dv, post_dv,
                            pre_root);
                        ::builtin::assert_(::builtin::spec_eq(Self::build_lsn_au_index_page_walk(post_dv,
                                    pre_root),
                                Self::build_lsn_au_index_page_walk(pre_dv, pre_root)));
                        ::builtin::assert_(::builtin::spec_eq(Self::build_lsn_au_index_page_walk(post_dv,
                                    post_root),
                                Self::build_lsn_au_index_page_walk(post_dv,
                                        pre_root).union_prefer_right(update)));
                        let au_update =
                            Self::singleton_index(msgs.seq_start, msgs.seq_end,
                                addr.au);
                        ::builtin::assert_(::builtin::spec_eq(au_update, update));
                        ::builtin::assert_(::builtin::spec_eq(post.lsn_au_index,
                                Self::build_lsn_au_index_page_walk(post_dv, post_root)));
                        Self::build_commutes_over_append_record(pre_dv, pre_root,
                            msgs, addr);
                        ::builtin::assume_(false);
                        {
                            ::builtin::assert_by(Self::pages_allocated_in_lsn_order(post_dv),
                                {
                                    ::builtin::assume_(false);
                                    let dv = post_dv;
                                    {
                                        ::builtin::assert_forall_by(|alo: Address, ahi: Address|
                                                {
                                                    ::builtin::requires(({
                                                                (((::builtin::spec_eq(alo.au, ahi.au)) &&
                                                                                    ((alo.page).spec_lt(ahi.page))) &&
                                                                            (#[verus::internal(trigger)] dv.entries.contains_key(alo)))
                                                                    &&
                                                                    (#[verus::internal(trigger)] dv.entries.contains_key(ahi))
                                                            }));
                                                    ::builtin::ensures((dv.entries.spec_index(alo).message_seq.seq_end).spec_le(dv.entries.spec_index(ahi).message_seq.seq_start));
                                                    if !::builtin::spec_eq(ahi.au, addr.au) ||
                                                                (ahi.page).spec_lt(addr.page) {
                                                            ::builtin::assert_((dv.entries.spec_index(alo).message_seq.seq_end).spec_le(dv.entries.spec_index(ahi).message_seq.seq_start));
                                                        } else {
                                                           ::builtin::assert_(::builtin::spec_eq(ahi, addr));
                                                           if ::builtin::is_variant(pre.mini_allocator.curr, "None") {
                                                                   ::builtin::assert_(::builtin::spec_eq(ahi.page,
                                                                           ::builtin::spec_literal_nat("0")));
                                                                   ::builtin::assert_((dv.entries.spec_index(alo).message_seq.seq_end).spec_le(dv.entries.spec_index(ahi).message_seq.seq_start));
                                                               } else {
                                                                  ::builtin::assert_(::builtin::spec_eq(addr,
                                                                          pre_root.unwrap().next()));
                                                                  ::builtin::assert_((dv.entries.spec_index(alo).message_seq.seq_end).spec_le(dv.entries.spec_index(ahi).message_seq.seq_start));
                                                              }
                                                       }
                                                });
                                    }
                                });
                        }
                        if ::builtin::is_variant(post_root, "Some") {
                                ::builtin::assert_(Self::internal_au_pages_fully_linked(post_dv));
                                ::builtin::assert_(Self::valid_first_au(post_dv,
                                        post.first));
                            }
                        Self::build_lsn_au_index_equiv_page_walk(post_dv, post_root,
                            post.first);
                        ::builtin::assert_(post.journal.wf());
                        ::builtin::assert_(post.mini_allocator.wf());
                        ::builtin::assert_(post.wf());
                        ::builtin::assert_(Self::aus_hold_contiguous_lsns(post.lsn_au_index));
                        ::builtin::assert_(Self::inv(post));
                    }
                    Self::lemma_msg_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn internal_no_op_inductive(pre: Self, post: Self,
                    lbl: Label) {
                    ::builtin::requires(pre.invariant() &&
                            State::internal_no_op_strong(pre, post, lbl));
                    ::builtin::ensures(post.invariant());
                    {}
                    Self::lemma_msg_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn initialize_inductive(post: Self,
                    journal: LinkedJournal::State, image: JournalImage) {
                    ::builtin::requires(Self::initialize(post, journal, image));
                    ::builtin::ensures(post.invariant());
                    {
                        ::builtin::assume_(LinkedJournal::State::inv(post.journal));
                        ::builtin::assert_(post.wf());
                        let TruncatedJournal { disk_view: dv, freshest_rec: root } =
                            image.tj;
                        Self::lemma_aus_hold_contiguous_lsns(image);
                        ::builtin::assume_(false);
                    }
                    Self::lemma_msg_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(closed)]
                #[verus::internal(spec(checked))]
                pub fn lbl_wf(lbl: Label) -> bool {
                    match lbl {
                        Label::FreezeForCommit { frozen_journal } =>
                            frozen_journal.tj.decodable(),
                        _ => true,
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn linked_lbl(lbl: Label) -> LinkedJournal::Label {
                    match lbl {
                        Label::ReadForRecovery { messages } =>
                            LinkedJournal::Label::ReadForRecovery { messages },
                        Label::FreezeForCommit { frozen_journal } =>
                            LinkedJournal::Label::FreezeForCommit {
                                frozen_journal: frozen_journal.tj,
                            },
                        Label::QueryEndLsn { end_lsn } =>
                            LinkedJournal::Label::QueryEndLsn { end_lsn },
                        Label::Put { messages } =>
                            LinkedJournal::Label::Put { messages },
                        Label::DiscardOld { start_lsn, require_end, deallocs } =>
                            LinkedJournal::Label::DiscardOld { start_lsn, require_end },
                        Label::InternalAllocations { allocs, deallocs } =>
                            LinkedJournal::Label::Internal {},
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn wf(self) -> bool {
                    (self.journal.wf()) && (self.mini_allocator.wf())
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn accessible_aus(self) -> Set<AU> {
                    (self.lsn_au_index.values()).spec_add(self.mini_allocator.allocs.dom())
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn new_first(tj: TruncatedJournal,
                    lsn_au_index: Map<LSN, AU>, old_first: AU, new_bdy: LSN)
                    -> AU {
                    ::builtin::recommends([tj.wf(),
                                lsn_au_index.contains_key(new_bdy)]);
                    let post_freshest_rec =
                        if ::builtin::spec_eq(tj.seq_end(), new_bdy) {
                                None
                            } else { tj.freshest_rec };
                    if ::builtin::is_variant(post_freshest_rec, "None") {
                            old_first
                        } else { lsn_au_index.spec_index(new_bdy) }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn lsn_au_index_discarding_up_to(lsn_au_index:
                        Map<LSN, AU>, bdy: LSN) -> Map<LSN, AU> {
                    Map::new(::builtin::closure_to_fn_spec(|lsn|
                                lsn_au_index.contains_key(lsn) && (bdy).spec_le(lsn)),
                        ::builtin::closure_to_fn_spec(|lsn|
                                lsn_au_index.spec_index(lsn)))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn singleton_index(start_lsn: LSN, end_lsn: LSN,
                    value: AU) -> Map<LSN, AU> {
                    Map::new(::builtin::closure_to_fn_spec(|lsn|
                                ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(start_lsn),
                                            lsn), end_lsn))),
                        ::builtin::closure_to_fn_spec(|lsn| value))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn lsn_au_index_append_record(lsn_au_index: Map<LSN, AU>,
                    msgs: MsgHistory, au: AU) -> Map<LSN, AU> {
                    ::builtin::recommends([msgs.wf(),
                                (msgs.seq_start).spec_lt(msgs.seq_end)]);
                    let update =
                        Self::singleton_index(msgs.seq_start, msgs.seq_end, au);
                    let out = lsn_au_index.union_prefer_right(update);
                    out
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn valid_next_journal_addr(mini_allocator: MiniAllocator,
                    freshest_rec: Pointer, addr: Address) -> bool {
                    ((mini_allocator.can_allocate(addr)) &&
                                ((::builtin::imply(::builtin::is_variant(mini_allocator.curr,
                                                "None"),
                                            {
                                                (mini_allocator.allocs.spec_index(addr.au).all_pages_free())
                                                    &&
                                                    (::builtin::spec_eq(addr.page,
                                                            ::builtin::spec_literal_nat("0")))
                                            })))) &&
                        ((::builtin::imply(::builtin::is_variant(mini_allocator.curr,
                                            "Some") && ::builtin::is_variant(freshest_rec, "Some"),
                                    ::builtin::spec_eq(addr, freshest_rec.unwrap().next()))))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn build_lsn_au_index_page_walk(dv: DiskView,
                    root: Pointer) -> Map<LSN, AU> {
                    ::builtin::recommends([dv.decodable(root), dv.acyclic()]);
                    ::builtin::decreases((dv.the_rank_of(root)));
                    decreases_when({ (dv.decodable(root)) && (dv.acyclic()) });
                    if root.is_None() {
                            Map::empty()
                        } else {
                           let curr_msgs =
                               dv.entries.spec_index(root.unwrap()).message_seq;
                           let update =
                               Self::singleton_index(::builtin::spec_cast_integer::<_,
                                           nat>(math::max(::builtin::spec_cast_integer::<_,
                                                   int>(dv.boundary_lsn),
                                           ::builtin::spec_cast_integer::<_,
                                                   int>(curr_msgs.seq_start))), curr_msgs.seq_end,
                                   root.unwrap().au);
                           Self::build_lsn_au_index_page_walk(dv,
                                   dv.next(root)).union_prefer_right(update)
                       }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub fn build_lsn_au_index_page_walk_domain(dv: DiskView,
                    root: Pointer) {
                    ::builtin::requires([dv.decodable(root), dv.acyclic()]);
                    ::builtin::ensures([::builtin::forall(|lsn|
                                        ::builtin::spec_eq((Self::build_lsn_au_index_page_walk(dv,
                                                        root).contains_key(lsn)),
                                            ((::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(dv.tj_at(root).seq_start()),
                                                                lsn), dv.tj_at(root).seq_end()))))))]);
                    ::builtin::decreases((dv.the_rank_of(root)));
                    if ::builtin::is_variant(root, "Some") {
                            Self::build_lsn_au_index_page_walk_domain(dv,
                                dv.next(root));
                            let prior_result =
                                Self::build_lsn_au_index_page_walk(dv, dv.next(root));
                        }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub fn build_commutes_over_discard_page_walk(dv: DiskView,
                    root: Pointer, new_bdy: LSN) {
                    ::builtin::requires([dv.tj_at(root).decodable(),
                                dv.tj_at(root).can_discard_to(new_bdy)]);
                    ::builtin::ensures([({
                                        let old_au_idx =
                                            Self::build_lsn_au_index_page_walk(dv, root);
                                        let new_tj = dv.tj_at(root).discard_old(new_bdy);
                                        ::builtin::ext_equal(Self::build_lsn_au_index_page_walk(new_tj.disk_view,
                                                new_tj.freshest_rec),
                                            Self::lsn_au_index_discarding_up_to(old_au_idx, new_bdy))
                                    })]);
                    ::builtin::decreases((dv.the_rank_of(root)));
                    Self::build_lsn_au_index_page_walk_domain(dv, root);
                    let discarded_tj = dv.tj_at(root).discard_old(new_bdy);
                    ::builtin::assert_(discarded_tj.disk_view.valid_ranking(dv.the_ranking()));
                    Self::build_lsn_au_index_page_walk_domain(discarded_tj.disk_view,
                        root);
                    if ::builtin::is_variant(root, "Some") &&
                                (new_bdy).spec_lt(dv.entries.spec_index(root.unwrap()).message_seq.seq_start)
                            {
                            Self::build_commutes_over_discard_page_walk(dv,
                                dv.next(root), new_bdy);
                        }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub fn build_lsn_au_index_page_walk_sub_disk(small: DiskView,
                    big: DiskView, root: Pointer) {
                    ::builtin::requires([small.decodable(root), big.acyclic(),
                                big.decodable(root), small.is_sub_disk(big)]);
                    ::builtin::ensures([::builtin::spec_eq(Self::build_lsn_au_index_page_walk(small,
                                        root), Self::build_lsn_au_index_page_walk(big, root))]);
                    ::builtin::decreases((small.the_rank_of(root)));
                    {
                        ::builtin::assert_forall_by(|addr|
                                {
                                    ::builtin::ensures(::builtin::imply(small.entries.contains_key(addr),
                                            big.entries.contains_key(addr)));
                                });
                    }
                    ::builtin::assert_(small.valid_ranking(big.the_ranking()));
                    if ::builtin::is_variant(root, "Some") {
                            Self::build_lsn_au_index_page_walk_sub_disk(small, big,
                                small.next(root));
                        }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub fn build_commutes_over_append_record(dv: DiskView,
                    root: Pointer, msgs: MsgHistory, new_addr: Address) {
                    ::builtin::requires([dv.tj_at(root).decodable(),
                                ::builtin::spec_eq(dv.tj_at(root).seq_end(),
                                    msgs.seq_start), msgs.wf(), !msgs.is_empty(),
                                !dv.entries.contains_key(new_addr)]);
                    ::builtin::ensures([({
                                        let old_au_idx =
                                            Self::build_lsn_au_index_page_walk(dv, root);
                                        let au_update =
                                            Self::singleton_index(msgs.seq_start, msgs.seq_end,
                                                new_addr.au);
                                        let incremental_idx =
                                            old_au_idx.union_prefer_right(au_update);
                                        let appended_tj =
                                            dv.tj_at(root).append_record(new_addr, msgs);
                                        let built_idx =
                                            Self::build_lsn_au_index_page_walk(appended_tj.disk_view,
                                                appended_tj.freshest_rec);
                                        ::builtin::ext_equal(incremental_idx, built_idx)
                                    })]);
                    ::builtin::decreases((dv.the_rank_of(root)));
                    let appended_tj =
                        dv.tj_at(root).append_record(new_addr, msgs);
                    ::builtin::assert_(appended_tj.disk_view.valid_ranking(dv.tj_at(root).marshal_ranking(new_addr)));
                    Self::build_lsn_au_index_page_walk_sub_disk(dv,
                        appended_tj.disk_view, root);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub fn build_lsn_au_index_equiv_page_walk(dv: DiskView,
                    root: Pointer, first: AU) {
                    ::builtin::requires([Self::pointer_is_upstream(dv, root,
                                    first), dv.acyclic(),
                                Self::internal_au_pages_fully_linked(dv),
                                ::builtin::imply(::builtin::is_variant(root, "Some"),
                                    Self::valid_first_au(dv, first))]);
                    ::builtin::ensures([::builtin::ext_equal(Self::build_lsn_au_index_au_walk(dv,
                                        root, first),
                                    Self::build_lsn_au_index_page_walk(dv, root))]);
                    ::builtin::decreases((dv.the_rank_of(root)));
                    match root {
                        None => {}
                        Some(addr) => {
                            if ::builtin::spec_eq(addr.au, first)
                                    {} else {
                                   Self::build_lsn_au_index_equiv_page_walk(dv, dv.next(root),
                                       first);
                                   Self::bottom_properties(dv, root, first);
                                   if (::builtin::spec_literal_nat("0")).spec_lt(root.unwrap().page)
                                           {
                                           {
                                               ::builtin::assert_by(::builtin::is_variant(dv.next(root),
                                                       "Some"),
                                                   {
                                                       if ::builtin::is_variant(dv.next(root), "None") {
                                                               ::builtin::assert_(dv.addr_supports_lsn(root.unwrap(),
                                                                       dv.boundary_lsn));
                                                               ::builtin::assert_(false);
                                                           }
                                                   });
                                           }
                                           Self::bottom_properties(dv, dv.next(root), first);
                                       }
                               }
                        }
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub fn build_commutes_over_discard(dv: DiskView,
                    root: Pointer, old_first: AU, new_bdy: LSN) {
                    ::builtin::requires([dv.tj_at(root).decodable(),
                                dv.tj_at(root).can_discard_to(new_bdy),
                                ::builtin::imply(::builtin::is_variant(root, "Some"),
                                    Self::valid_first_au(dv, old_first)),
                                Self::internal_au_pages_fully_linked(dv)]);
                    ::builtin::ensures([({
                                        let old_lsn_au_index =
                                            Self::build_lsn_au_index(dv.tj_at(root), old_first);
                                        ::builtin::spec_eq(Self::build_lsn_au_index(dv.tj_at(root).discard_old(new_bdy),
                                                Self::new_first(dv.tj_at(root), old_lsn_au_index, old_first,
                                                    new_bdy)),
                                            Self::lsn_au_index_discarding_up_to(old_lsn_au_index,
                                                new_bdy))
                                    })]);
                    let old_lsn_au_index =
                        Self::build_lsn_au_index(dv.tj_at(root), old_first);
                    Self::build_commutes_over_discard_page_walk(dv, root,
                        new_bdy);
                    let discarded_tj = dv.tj_at(root).discard_old(new_bdy);
                    let new_first =
                        Self::new_first(dv.tj_at(root), old_lsn_au_index, old_first,
                            new_bdy);
                    ::builtin::assert_(discarded_tj.disk_view.valid_ranking(dv.the_ranking()));
                    ::builtin::assume_(false);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn upstream(dv: DiskView, addr: Address) -> bool {
                    (dv.entries.contains_key(addr)) &&
                        ((dv.boundary_lsn).spec_lt(dv.entries.spec_index(addr).message_seq.seq_end))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn nonzero_pages_point_backward(dv: DiskView) -> bool {
                    ::builtin::recommends([dv.wf()]);
                    ::builtin::forall(|addr: Address|
                            #[verus::internal(auto_trigger)] (::builtin::imply(({
                                            (!::builtin::spec_eq(addr.page,
                                                            ::builtin::spec_literal_nat("0"))) &&
                                                (dv.entries.contains_key(addr))
                                        }),
                                    ::builtin::spec_eq(dv.entries.spec_index(addr).prior_rec,
                                        Some(addr.previous())))))
                }
                #[verifier::opaque]
                #[verus::internal(verus_macro)]
                #[verus::internal(closed)]
                #[verus::internal(spec(checked))]
                pub fn pages_allocated_in_lsn_order(dv: DiskView) -> bool {
                    ::builtin::recommends([dv.wf()]);
                    ::builtin::forall(|alo: Address, ahi: Address|
                            #[verus::internal(auto_trigger)] (::builtin::imply(({
                                            (((::builtin::spec_eq(alo.au, ahi.au)) &&
                                                                ((alo.page).spec_lt(ahi.page))) &&
                                                        (dv.entries.contains_key(alo))) &&
                                                (dv.entries.contains_key(ahi))
                                        }),
                                    (dv.entries.spec_index(alo).message_seq.seq_end).spec_le(dv.entries.spec_index(ahi).message_seq.seq_start))))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn internal_au_pages_fully_linked(dv: DiskView) -> bool {
                    ::builtin::recommends([dv.wf()]);
                    (Self::nonzero_pages_point_backward(dv)) &&
                        (Self::pages_allocated_in_lsn_order(dv))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub fn nonfirst_properties(dv: DiskView, root: Pointer,
                    first: AU) {
                    ::builtin::requires([Self::pointer_is_upstream(dv, root,
                                    first), root.is_Some(),
                                !::builtin::spec_eq(root.unwrap().au, first)]);
                    ::builtin::ensures([::builtin::forall(|ptr: Pointer|
                                        #[verus::internal(auto_trigger)] (::builtin::imply(::builtin::is_variant(ptr,
                                                            "Some") &&
                                                        ::builtin::spec_eq(ptr.unwrap().au, root.unwrap().au) &&
                                                    (ptr.unwrap().page).spec_le(root.unwrap().page),
                                                Self::pointer_is_upstream(dv, ptr, first)))),
                                ::builtin::forall(|ptr: Pointer|
                                        #[verus::internal(auto_trigger)] (::builtin::imply(::builtin::is_variant(ptr,
                                                            "Some") &&
                                                        ::builtin::spec_eq(ptr.unwrap().au, root.unwrap().au) &&
                                                    ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_lt(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                ptr.unwrap().page), root.unwrap().page)),
                                                ::builtin::is_variant(dv.next(ptr), "Some") &&
                                                    ::builtin::spec_eq(dv.next(ptr).unwrap().au,
                                                        root.unwrap().au))))]);
                    ::builtin::decreases((dv.the_rank_of(root)));
                    if ::builtin::is_variant(dv.next(root), "None") {
                            ::builtin::assert_(dv.addr_supports_lsn(root.unwrap(),
                                    dv.boundary_lsn));
                            ::builtin::assert_(false);
                        }
                    if !::builtin::spec_eq(root.unwrap().page,
                                    ::builtin::spec_literal_nat("0")) {
                            Self::nonfirst_properties(dv, dv.next(root), first);
                        }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub fn transitive_ranking(dv: LinkedJournal_v::DiskView,
                    root: Address, later: Address, first: AU) {
                    ::builtin::requires([Self::pointer_is_upstream(dv,
                                    Some(later), first), dv.decodable(Some(root)), dv.acyclic(),
                                !::builtin::spec_eq(root.au, first),
                                ::builtin::spec_eq(root.au, later.au),
                                (root.page).spec_le(later.page),
                                Self::internal_au_pages_fully_linked(dv)]);
                    ::builtin::ensures([(dv.the_rank_of(Some(root))).spec_le(dv.the_rank_of(Some(later)))]);
                    ::builtin::decreases((later.page));
                    if ::builtin::spec_eq(root, later) {
                            ::builtin::assert_(dv.decodable(Some(later)));
                            return;
                        }
                    let prior = dv.next(Some(later));
                    Self::nonfirst_properties(dv, Some(later), first);
                    Self::transitive_ranking(dv, root, prior.unwrap(), first);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn pointer_is_upstream(dv: DiskView, root: Pointer,
                    first: AU) -> bool {
                    (((((dv.decodable(root)) && (dv.acyclic())) &&
                                                (Self::internal_au_pages_fully_linked(dv))) &&
                                        (Self::valid_first_au(dv, first))) &&
                                (Self::has_unique_lsns(dv))) &&
                        (::builtin::imply(::builtin::is_variant(root, "Some"),
                                Self::upstream(dv, root.unwrap())))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub fn bottom_properties(dv: DiskView, root: Pointer,
                    first: AU) {
                    ::builtin::requires([Self::pointer_is_upstream(dv, root,
                                    first), root.is_Some(),
                                !::builtin::spec_eq(root.unwrap().au, first)]);
                    ::builtin::ensures([::builtin::is_variant(dv.next(first_page(root)),
                                    "Some"), dv.decodable(dv.next(first_page(root))),
                                dv.buildable(dv.next(first_page(root))),
                                Self::pointer_is_upstream(dv, first_page(root), first),
                                (dv.tj_at(dv.next(first_page(root))).seq_end()).spec_le(dv.tj_at(root).seq_end())]);
                    ::builtin::decreases((dv.the_rank_of(root)));
                    if ::builtin::is_variant(dv.next(root), "None") {
                            ::builtin::assert_(dv.addr_supports_lsn(root.unwrap(),
                                    dv.boundary_lsn));
                            ::builtin::assert_(false);
                        }
                    if !::builtin::spec_eq(root.unwrap().page,
                                    ::builtin::spec_literal_nat("0")) {
                            Self::bottom_properties(dv, dv.next(root), first);
                        }
                }
                #[verifier::decreases_by]
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub fn build_lsn_au_index_au_walk_helper(dv: DiskView,
                    root: Pointer, first: AU) {
                    match root {
                        None => {}
                        Some(addr) => {
                            if ::builtin::spec_eq(addr.au, first)
                                    {} else {
                                   let bottom = first_page(root);
                                   Self::bottom_properties(dv, root, first);
                                   Self::transitive_ranking(dv, bottom.unwrap(), root.unwrap(),
                                       first);
                               }
                        }
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn build_lsn_au_index_au_walk(dv: DiskView, root: Pointer,
                    first: AU) -> Map<LSN, AU> {
                    ::builtin::recommends([Self::pointer_is_upstream(dv, root,
                                    first), dv.acyclic(),
                                Self::internal_au_pages_fully_linked(dv)]);
                    ::builtin::decreases((dv.the_rank_of(root)));
                    decreases_when({
                            ((Self::pointer_is_upstream(dv, root, first)) &&
                                        (dv.acyclic())) &&
                                (Self::internal_au_pages_fully_linked(dv))
                        });
                    decreases_by(Self::build_lsn_au_index_au_walk_helper);
                    match root {
                        None => ::vstd::map::Map::empty(),
                        Some(addr) => {
                            if ::builtin::spec_eq(addr.au, first) {
                                    Self::build_lsn_au_index_page_walk(dv, root)
                                } else {
                                   let bottom = first_page(root);
                                   let last_lsn =
                                       dv.entries.spec_index(root.unwrap()).message_seq.seq_end;
                                   let first_lsn =
                                       dv.entries.spec_index(bottom.unwrap()).message_seq.seq_start;
                                   let update =
                                       Self::singleton_index(first_lsn, last_lsn,
                                           bottom.unwrap().au);
                                   let prior_result =
                                       Self::build_lsn_au_index_au_walk(dv, dv.next(bottom),
                                           first);
                                   prior_result.union_prefer_right(update)
                               }
                        }
                    }
                }
                #[verifier::recommends_by]
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub fn build_lsn_au_index_helper(tj: TruncatedJournal,
                    first: AU) {
                    match tj.freshest_rec {
                        None => {}
                        Some(addr) => {
                            if ::builtin::spec_eq(addr.au, first)
                                    {} else {
                                   Self::bottom_properties(tj.disk_view, tj.freshest_rec,
                                       first);
                                   Self::transitive_ranking(tj.disk_view,
                                       tj.freshest_rec.unwrap().first_page(),
                                       tj.freshest_rec.unwrap(), first);
                               }
                        }
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn build_lsn_au_index(tj: TruncatedJournal, first: AU)
                    -> Map<LSN, AU> {
                    ::builtin::recommends([Self::pointer_is_upstream(tj.disk_view,
                                    tj.freshest_rec, first)]);
                    recommends_by(Self::build_lsn_au_index_helper);
                    Self::build_lsn_au_index_au_walk(tj.disk_view,
                        tj.freshest_rec, first)
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn wf_addrs(dv: DiskView) -> bool {
                    ::builtin::forall(|addr|
                            ::builtin::imply(#[verus::internal(trigger)] dv.entries.contains_key(addr),
                                addr.wf()))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn valid_first_au(dv: DiskView, first: AU) -> bool {
                    ::builtin::exists(|addr: Address|
                            #[verus::internal(auto_trigger)] (::builtin::spec_eq(addr.au,
                                        first) && dv.addr_supports_lsn(addr, dv.boundary_lsn)))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn valid_journal_image(image: JournalImage) -> bool {
                    (Self::wf_addrs(image.tj.disk_view)) &&
                        (Self::pointer_is_upstream(image.tj.disk_view,
                                image.tj.freshest_rec, image.first))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn journal_pages_not_free(addrs: Set<Address>,
                    allocator: MiniAllocator) -> bool {
                    ::builtin::forall(|addr|
                            ::builtin::imply(#[verus::internal(trigger)] addrs.contains(addr),
                                addr.wf() && !allocator.can_allocate(addr)))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn mini_allocator_follows_freshest_rec(freshest_rec:
                        Pointer, allocator: MiniAllocator) -> bool {
                    ::builtin::imply(allocator.curr.is_Some(),
                        {
                            (freshest_rec.is_Some()) &&
                                (::builtin::spec_eq(freshest_rec.unwrap().au,
                                        allocator.curr.unwrap()))
                        })
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn tj(self) -> TruncatedJournal {
                    self.journal.truncated_journal
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn contiguous_lsns(lsn_au_index: Map<LSN, AU>, lsn1: LSN,
                    lsn2: LSN, lsn3: LSN) -> bool {
                    ::builtin::imply(({
                                (((::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(lsn1),
                                                                    lsn2), lsn3))) && (lsn_au_index.contains_key(lsn1))) &&
                                            (lsn_au_index.contains_key(lsn3))) &&
                                    (::builtin::spec_eq(lsn_au_index.spec_index(lsn1),
                                            lsn_au_index.spec_index(lsn3)))
                            }),
                        {
                            (lsn_au_index.contains_key(lsn2)) &&
                                (::builtin::spec_eq(lsn_au_index.spec_index(lsn1),
                                        lsn_au_index.spec_index(lsn2)))
                        })
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn aus_hold_contiguous_lsns(lsn_au_index: Map<LSN, AU>)
                    -> bool {
                    ::builtin::forall(|lsn1, lsn2, lsn3|
                            Self::contiguous_lsns(lsn_au_index, lsn1, lsn2, lsn3))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(closed)]
                #[verus::internal(spec(checked))]
                pub fn index_honors_rank(dv: DiskView, root: Pointer,
                    first: AU, au_index: Map<LSN, AU>) -> bool {
                    ::builtin::recommends([dv.decodable(root), dv.acyclic(),
                                Self::internal_au_pages_fully_linked(dv)]);
                    ::builtin::forall(|lsn, addr: Address|
                            #[verus::internal(auto_trigger)] (::builtin::imply(au_index.contains_key(lsn)
                                            && ::builtin::spec_eq(addr.au, au_index.spec_index(lsn)) &&
                                        dv.addr_supports_lsn(addr, lsn),
                                    (dv.the_rank_of(Some(addr))).spec_le(dv.the_rank_of(root)))))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn au_domain_valid(dv: DiskView, root: Pointer,
                    lsn_au_index: Map<LSN, AU>) -> bool {
                    ::builtin::forall(|lsn|
                            ::builtin::spec_eq((lsn_au_index.contains_key(lsn)),
                                ((::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(dv.tj_at(root).seq_start()),
                                                    lsn), dv.tj_at(root).seq_end()))))))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub fn nonfirst_pages(dv: DiskView, addr: Address,
                    first: AU) {
                    ::builtin::requires([Self::pointer_is_upstream(dv,
                                    Some(addr), first), !::builtin::spec_eq(addr.au, first)]);
                    ::builtin::ensures([(dv.boundary_lsn).spec_lt(dv.entries.spec_index(addr).message_seq.seq_start)]);
                    if (dv.entries.spec_index(addr).message_seq.seq_start).spec_le(dv.boundary_lsn)
                            {
                            ::builtin::assert_(dv.addr_supports_lsn(addr,
                                    dv.boundary_lsn));
                            ::builtin::assert_(false);
                        }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub fn build_lsn_addr_index_returns_upstream_pages(dv:
                        DiskView, root: Pointer, first: AU) {
                    ::builtin::requires([Self::has_unique_lsns(dv),
                                Self::internal_au_pages_fully_linked(dv),
                                dv.buildable(root), Self::valid_first_au(dv, first)]);
                    ::builtin::ensures([({
                                        let lsn_addr_index = dv.build_lsn_addr_index(root);
                                        ::builtin::forall(|lsn|
                                                #[verus::internal(auto_trigger)] (::builtin::imply(lsn_addr_index.contains_key(lsn)
                                                            &&
                                                            !::builtin::spec_eq(lsn_addr_index.spec_index(lsn).au,
                                                                    first),
                                                        Self::pointer_is_upstream(dv,
                                                            Some(lsn_addr_index.spec_index(lsn)), first))))
                                    })]);
                    ::builtin::decreases((dv.the_rank_of(root)));
                    let lsn_addr_index = dv.build_lsn_addr_index(root);
                    if ::builtin::is_variant(root, "Some") {
                            Self::build_lsn_addr_index_returns_upstream_pages(dv,
                                dv.next(root), first);
                            let curr_msgs =
                                dv.entries.spec_index(root.unwrap()).message_seq;
                            let start_lsn =
                                ::builtin::spec_cast_integer::<_,
                                        nat>(math::max(::builtin::spec_cast_integer::<_,
                                                int>(dv.boundary_lsn),
                                        ::builtin::spec_cast_integer::<_,
                                                int>(curr_msgs.seq_start)));
                            let update =
                                LikesJournal_v::singleton_index(start_lsn,
                                    curr_msgs.seq_end, root.unwrap());
                            ::builtin::assert_(::builtin::spec_eq(lsn_addr_index,
                                    dv.build_lsn_addr_index(dv.next(root)).union_prefer_right(update)));
                        }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub fn upstream_pages(dv: DiskView, earlier: Address,
                    later: Address, first: AU) {
                    ::builtin::requires([Self::pointer_is_upstream(dv,
                                    Some(later), first), !::builtin::spec_eq(later.au, first),
                                ::builtin::spec_eq(earlier.au, later.au),
                                (earlier.page).spec_le(later.page)]);
                    ::builtin::ensures([Self::pointer_is_upstream(dv,
                                    Some(earlier), first)]);
                    ::builtin::decreases(((later.page).spec_sub(earlier.page)));
                    if (earlier.page).spec_lt(later.page) {
                            let prior = later.previous();
                            Self::nonfirst_pages(dv, later, first);
                            ::builtin::assert_(Self::upstream(dv, prior));
                            ::builtin::assert_(Self::pointer_is_upstream(dv,
                                    Some(prior), first));
                            Self::upstream_pages(dv, earlier, prior, first);
                        }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub fn lemma_next_au_doesnt_intersect(dv: DiskView,
                    root: Pointer, first: AU, prior_result: Map<LSN, AU>) {
                    ::builtin::requires([Self::pointer_is_upstream(dv, root,
                                    first), root.is_Some(),
                                !::builtin::spec_eq(root.unwrap().au, first),
                                ::builtin::spec_eq(prior_result,
                                    Self::build_lsn_au_index_au_walk(dv,
                                        dv.next(first_page(root)), first))]);
                    ::builtin::ensures([::builtin::forall(|lsn|
                                        #[verus::internal(auto_trigger)] (::builtin::imply(prior_result.contains_key(lsn),
                                                !::builtin::spec_eq(prior_result.spec_index(lsn),
                                                        root.unwrap().au))))]);
                    let bottom = first_page(root);
                    let prior_addr_index =
                        dv.tj_at(dv.next(bottom)).build_lsn_addr_index();
                    Self::bottom_properties(dv, root, first);
                    dv.build_lsn_addr_all_decodable(dv.next(bottom));
                    Self::build_lsn_addr_index_returns_upstream_pages(dv,
                        dv.next(bottom), first);
                    ::builtin::assume_(false);
                    {
                        ::builtin::assert_forall_by(|lsn|
                                {
                                    ::builtin::requires(prior_result.contains_key(lsn));
                                    ::builtin::ensures(!::builtin::spec_eq(#[verus::internal(trigger)] prior_result.spec_index(lsn),
                                                root.unwrap().au));
                                    let addr = prior_addr_index.spec_index(lsn);
                                    if ::builtin::spec_eq(addr.au, root.unwrap().au) {
                                            if !::builtin::spec_eq(addr.au, first) {
                                                    let addr0 =
                                                        Address {
                                                            au: addr.au,
                                                            page: ::builtin::spec_literal_integer("0"),
                                                        };
                                                    let addrp = dv.next(bottom).unwrap();
                                                    Self::upstream_pages(dv, addr0, addr, first);
                                                    Self::transitive_ranking(dv, addr0, addr, first);
                                                    let prior_last =
                                                        ::builtin::spec_cast_integer::<_,
                                                                nat>(((dv.entries.spec_index(addrp).message_seq.seq_end).spec_sub(::builtin::spec_literal_nat("1"))));
                                                    {
                                                        ::builtin::assert_by((lsn).spec_le(prior_last),
                                                            {
                                                                ::builtin::reveal_hide_({
                                                                        #[verus::internal(reveal_fn)]
                                                                        fn __VERUS_REVEAL_INTERNAL__() {
                                                                            ::builtin::reveal_hide_internal_path_(TruncatedJournal::index_domain_valid)
                                                                        }
                                                                        __VERUS_REVEAL_INTERNAL__
                                                                    }, 1);
                                                                dv.build_lsn_addr_index_domain_valid(dv.next(bottom));
                                                            });
                                                    }
                                                    dv.tj_at(dv.next(bottom)).build_lsn_addr_honors_rank(prior_addr_index);
                                                    ::builtin::assert_(prior_addr_index.contains_key(prior_last));
                                                    ::builtin::assert_(false);
                                                }
                                            ::builtin::assert_(::builtin::spec_eq(addr.au, first));
                                            ::builtin::assert_(false);
                                        }
                                });
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub fn au_index_page_supports_lsn(dv: DiskView, root: Pointer,
                    lsn: LSN) {
                    ::builtin::requires([dv.decodable(root), dv.acyclic(),
                                Self::build_lsn_au_index_page_walk(dv,
                                        root).contains_key(lsn)]);
                    ::builtin::ensures([::builtin::exists(|addr|
                                        #[verus::internal(auto_trigger)] (dv.addr_supports_lsn(addr,
                                                    lsn) &&
                                                ::builtin::spec_eq(addr.au,
                                                    Self::build_lsn_au_index_page_walk(dv,
                                                            root).spec_index(lsn))))]);
                    ::builtin::decreases((dv.the_rank_of(root)));
                    if ::builtin::is_variant(root, "Some") {
                            let curr_msgs =
                                dv.entries.spec_index(root.unwrap()).message_seq;
                            let update =
                                Self::singleton_index(::builtin::spec_cast_integer::<_,
                                            nat>(math::max(::builtin::spec_cast_integer::<_,
                                                    int>(dv.boundary_lsn),
                                            ::builtin::spec_cast_integer::<_,
                                                    int>(curr_msgs.seq_start))), curr_msgs.seq_end,
                                    root.unwrap().au);
                            if update.contains_key(lsn) {
                                    ::builtin::assert_(dv.addr_supports_lsn(root.unwrap(),
                                            lsn));
                                } else {
                                   Self::au_index_page_supports_lsn(dv, dv.next(root), lsn);
                               }
                        }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub fn first_contains_boundary(dv: DiskView, root: Pointer,
                    first: AU) {
                    ::builtin::requires([dv.decodable(root), dv.acyclic(),
                                Self::valid_first_au(dv, first), Self::has_unique_lsns(dv),
                                ::builtin::is_variant(root, "Some"),
                                Self::upstream(dv, root.unwrap())]);
                    ::builtin::ensures([::builtin::spec_eq(Self::build_lsn_au_index_page_walk(dv,
                                            root).spec_index(dv.boundary_lsn), first)]);
                    let addr =
                        ::builtin::choose(|addr: Address|
                                #[verus::internal(auto_trigger)] (::builtin::spec_eq(addr.au,
                                            first) && dv.addr_supports_lsn(addr, dv.boundary_lsn)));
                    Self::build_lsn_au_index_page_walk_domain(dv, root);
                    Self::au_index_page_supports_lsn(dv, root, dv.boundary_lsn);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub fn lemma_aus_hold_contiguous_lsns_first_page(dv: DiskView,
                    root: Pointer, first: AU) {
                    ::builtin::requires([Self::pointer_is_upstream(dv, root,
                                    first), Self::has_unique_lsns(dv),
                                ::builtin::is_variant(root, "Some"),
                                ::builtin::spec_eq(root.unwrap().au, first)]);
                    ::builtin::ensures([({
                                        let lsn_au_index =
                                            Self::build_lsn_au_index_page_walk(dv, root);
                                        ((::builtin::forall(|lsn|
                                                                #[verus::internal(auto_trigger)] (::builtin::imply(lsn_au_index.contains_key(lsn),
                                                                        ::builtin::spec_eq(lsn_au_index.spec_index(lsn),
                                                                            root.unwrap().au))))) &&
                                                    (Self::au_domain_valid(dv, root, lsn_au_index))) &&
                                            (Self::aus_hold_contiguous_lsns(lsn_au_index))
                                    })]);
                    ::builtin::decreases((dv.the_rank_of(root)));
                    let lsn_au_index =
                        Self::build_lsn_au_index_page_walk(dv, root);
                    if ::builtin::is_variant(root, "None")
                            {} else if ::builtin::is_variant(dv.next(root), "None") {
                           ::builtin::assert_(::builtin::ext_equal(Self::build_lsn_au_index_page_walk(dv,
                                       dv.next(root)), Map::empty()));
                       } else if ::builtin::spec_eq(root.unwrap().page,
                               ::builtin::spec_literal_nat("0")) {
                           ::builtin::assert_(::builtin::exists(|addr: Address|
                                       #[verus::internal(auto_trigger)] (::builtin::spec_eq(addr.au,
                                                   first) && dv.addr_supports_lsn(addr, dv.boundary_lsn))));
                           let first_page =
                               ::builtin::choose(|addr: Address|
                                       #[verus::internal(auto_trigger)] (::builtin::spec_eq(addr.au,
                                                   first) && dv.addr_supports_lsn(addr, dv.boundary_lsn)));
                           ::builtin::assert_(dv.addr_supports_lsn(first_page,
                                   dv.boundary_lsn));
                           Self::first_contains_boundary(dv, root, first);
                           ::builtin::assert_(::builtin::spec_eq(lsn_au_index.spec_index(dv.boundary_lsn),
                                   first));
                           {
                               ::builtin::assert_by((dv.entries.spec_index(root.unwrap()).message_seq.seq_end).spec_le(dv.entries.spec_index(first_page).message_seq.seq_start),
                                   {
                                       ::builtin::reveal_hide_({
                                               #[verus::internal(reveal_fn)]
                                               fn __VERUS_REVEAL_INTERNAL__() {
                                                   ::builtin::reveal_hide_internal_path_(AllocationJournal::State::pages_allocated_in_lsn_order)
                                               }
                                               __VERUS_REVEAL_INTERNAL__
                                           }, 1);
                                   });
                           }
                           ::builtin::assert_(false);
                       } else {
                           Self::lemma_aus_hold_contiguous_lsns_first_page(dv,
                               dv.next(root), first);
                       }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub fn lemma_aus_hold_contiguous_lsns_inner(dv: DiskView,
                    root: Pointer, first: AU) {
                    ::builtin::requires([Self::pointer_is_upstream(dv, root,
                                    first)]);
                    ::builtin::ensures([Self::au_domain_valid(dv, root,
                                    Self::build_lsn_au_index_au_walk(dv, root, first)),
                                Self::aus_hold_contiguous_lsns(Self::build_lsn_au_index_au_walk(dv,
                                        root, first))]);
                    ::builtin::decreases((dv.the_rank_of(root)));
                    let lsn_au_index =
                        Self::build_lsn_au_index_au_walk(dv, root, first);
                    match root {
                        None => {}
                        Some(addr) => {
                            if ::builtin::spec_eq(addr.au, first) {
                                    Self::lemma_aus_hold_contiguous_lsns_first_page(dv, root,
                                        first);
                                } else {
                                   let bottom = first_page(root);
                                   let first_lsn =
                                       dv.entries.spec_index(bottom.unwrap()).message_seq.seq_start;
                                   let prior_result =
                                       Self::build_lsn_au_index_au_walk(dv, dv.next(bottom),
                                           first);
                                   Self::bottom_properties(dv, root, first);
                                   Self::transitive_ranking(dv, bottom.unwrap(), root.unwrap(),
                                       first);
                                   Self::lemma_aus_hold_contiguous_lsns_inner(dv,
                                       dv.next(bottom), first);
                                   {
                                       ::builtin::assert_forall_by(|lsn1, lsn2, lsn3|
                                               {
                                                   ::builtin::ensures(Self::contiguous_lsns(lsn_au_index, lsn1,
                                                           lsn2, lsn3));
                                                   if ({
                                                                   (((::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(lsn1),
                                                                                                       lsn2), lsn3))) && (lsn_au_index.contains_key(lsn1))) &&
                                                                               (lsn_au_index.contains_key(lsn3))) &&
                                                                       (::builtin::spec_eq(lsn_au_index.spec_index(lsn1),
                                                                               lsn_au_index.spec_index(lsn3)))
                                                               }) {
                                                           if (lsn1).spec_lt(first_lsn) {
                                                                   if !prior_result.contains_key(lsn3) {
                                                                           Self::lemma_next_au_doesnt_intersect(dv, root, first,
                                                                               prior_result);
                                                                           ::builtin::assert_(false);
                                                                       }
                                                                   ::builtin::assert_(Self::contiguous_lsns(prior_result, lsn1,
                                                                           lsn2, lsn3));
                                                               }
                                                       }
                                               });
                                   }
                               }
                        }
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub fn lemma_aus_hold_contiguous_lsns(image: JournalImage) {
                    ::builtin::requires([Self::valid_journal_image(image)]);
                    ::builtin::ensures([Self::aus_hold_contiguous_lsns(Self::build_lsn_au_index(image.tj,
                                        image.first))]);
                    Self::lemma_aus_hold_contiguous_lsns_inner(image.tj.disk_view,
                        image.tj.freshest_rec, image.first)
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn has_unique_lsns(dv: DiskView) -> bool {
                    ::builtin::forall(|lsn, addr1, addr2|
                            ::builtin::imply(dv.addr_supports_lsn(addr1, lsn) &&
                                    dv.addr_supports_lsn(addr2, lsn),
                                ::builtin::spec_eq(addr1, addr2)))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub fn invoke_submodule_inv(pre: Self, post: Self) {
                    ::builtin::requires([Self::inv(pre)]);
                    ::builtin::ensures([post.journal.inv()]);
                    ::builtin::assume_(false);
                }
                #[verifier::spinoff_prover]
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub fn discard_old_helper4(pre: Self, post: Self, lbl: Label,
                    post_journal: LinkedJournal::State, xaddr: Address,
                    zaddr: Address) {
                    ::builtin::requires([Self::inv(pre),
                                Self::discard_old(pre, post, lbl, post_journal),
                                post.tj().disk_view.entries.contains_key(zaddr),
                                (post.tj().seq_start()).spec_lt(post.tj().disk_view.entries.spec_index(zaddr).message_seq.seq_start),
                                post.tj().freshest_rec.is_Some(),
                                !::builtin::spec_eq(zaddr.au, pre.first),
                                !::builtin::spec_eq(zaddr.au, post.first),
                                ::builtin::spec_eq(xaddr.au, zaddr.au),
                                ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            xaddr.page), zaddr.page))]);
                    ::builtin::ensures([post.tj().disk_view.entries.contains_key(xaddr)]);
                    ::builtin::decreases(((zaddr.page).spec_sub(xaddr.page)));
                    ::builtin::assume_(false);
                    let pre_dv = pre.tj().disk_view;
                    let post_dv = post.tj().disk_view;
                    Self::invoke_submodule_inv(pre, post);
                    let zpaged = post_dv.iptr(Some(zaddr));
                    ::builtin::assert_(zpaged.is_Some());
                    let zpaged = zpaged.unwrap();
                    let zlsn =
                        post_dv.entries.spec_index(zaddr).message_seq.seq_start;
                    let ylsn =
                        ::builtin::spec_cast_integer::<_,
                                nat>(((zlsn).spec_sub(::builtin::spec_literal_nat("1"))));
                    ::builtin::assert_(!::builtin::spec_eq(post_dv.entries.spec_index(zaddr).message_seq.seq_start,
                                ::builtin::spec_literal_nat("0")));
                    ::builtin::assert_((ylsn).spec_lt(post_dv.entries.spec_index(zaddr).message_seq.seq_start));
                    {
                        ::builtin::assert_by(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(post.tj().seq_start()),
                                        zlsn), post.tj().seq_end())),
                            {
                                ::builtin::reveal_hide_({
                                        #[verus::internal(reveal_fn)]
                                        fn __VERUS_REVEAL_INTERNAL__() {
                                            ::builtin::reveal_hide_internal_path_(TruncatedJournal::index_domain_valid)
                                        }
                                        __VERUS_REVEAL_INTERNAL__
                                    }, 1);
                            });
                    }
                    {
                        ::builtin::assert_by((post_dv.entries.spec_index(zaddr).message_seq.seq_start).spec_lt(post.tj().seq_end()),
                            {});
                    }
                    ::builtin::assert_((ylsn).spec_lt(post.tj().seq_end()));
                    if (ylsn).spec_lt(post.tj().seq_start()) {
                            ::builtin::assert_(::builtin::spec_eq(zlsn,
                                    post.tj().seq_start()));
                            ::builtin::assert_(false);
                        }
                    ::builtin::assert_((post.tj().seq_start()).spec_le(ylsn));
                    {
                        ::builtin::assert_by((post.tj().seq_start()).spec_le(ylsn),
                            {
                                if (ylsn).spec_lt(post.tj().seq_start()) {
                                        ::builtin::assert_(post.lsn_au_index.contains_key(post_dv.boundary_lsn));
                                        ::builtin::assert_(::builtin::spec_eq(post.lsn_au_index.spec_index(post_dv.boundary_lsn),
                                                zaddr.au));
                                        ::builtin::assert_(false);
                                    }
                            });
                    }
                    let yaddr =
                        Address {
                            au: zaddr.au,
                            page: ::builtin::spec_cast_integer::<_,
                                    nat>(((zaddr.page).spec_sub(::builtin::spec_literal_nat("1")))),
                        };
                    let y0lsn =
                        post_dv.entries.spec_index(yaddr).message_seq.seq_start;
                    {
                        ::builtin::assert_by((post.tj().seq_start()).spec_lt(y0lsn),
                            {
                                if (y0lsn).spec_le(post.tj().seq_start()) {
                                        ::builtin::assert_((y0lsn).spec_le(post_dv.boundary_lsn));
                                        ::builtin::assert_((post_dv.boundary_lsn).spec_le(ylsn));
                                        ::builtin::assert_(Self::contiguous_lsns(post.lsn_au_index,
                                                y0lsn, post_dv.boundary_lsn, ylsn));
                                        ::builtin::assert_(::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(y0lsn),
                                                        post_dv.boundary_lsn), ylsn)));
                                        ::builtin::assume_(false);
                                        ::builtin::assert_(post_dv.entries.spec_index(yaddr).message_seq.contains(y0lsn));
                                        ::builtin::assert_(post.lsn_au_index.contains_key(y0lsn));
                                        ::builtin::assert_(post.lsn_au_index.contains_key(ylsn));
                                        ::builtin::assert_(::builtin::spec_eq(post.lsn_au_index.spec_index(y0lsn),
                                                post.lsn_au_index.spec_index(ylsn)));
                                        ::builtin::assert_(post.lsn_au_index.contains_key(post_dv.boundary_lsn));
                                        ::builtin::assert_(::builtin::spec_eq(post.lsn_au_index.spec_index(post_dv.boundary_lsn),
                                                zaddr.au));
                                        ::builtin::assert_(false);
                                    }
                            });
                    }
                    if !::builtin::spec_eq(xaddr, yaddr) {
                            ::builtin::assert_((post.tj().seq_start()).spec_lt(y0lsn));
                            Self::discard_old_helper4(pre, post, lbl, post_journal,
                                xaddr, yaddr);
                        }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub fn discard_old_accessible_aus(pre: Self, post: Self,
                    lbl: Label) {
                    ::builtin::requires([Self::next(pre, post, lbl),
                                lbl.is_DiscardOld()]);
                    ::builtin::ensures([::builtin::spec_eq(post.accessible_aus(),
                                    (pre.accessible_aus()).spec_sub(lbl.get_DiscardOld_deallocs()))]);
                    ::builtin::assume_(false);
                }
            }
        }
    }
    pub mod AllocationJournalRefinement_v {}
    pub mod AllocationCrashAwareJournal_v {
        #![allow(unused_imports)]
        use builtin::*;
        use vstd::prelude::*;
        use vstd::math;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        use vstd::prelude::*;
        use vstd::map::*;
        use vstd::map_lib::*;
        use crate::abstract_system::StampedMap_v::LSN;
        use crate::abstract_system::MsgHistory_v::*;
        use crate::disk::GenericDisk_v::*;
        use crate::disk::GenericDisk_v::AU;
        use crate::allocation_layer::AllocationJournal_v::*;
        use crate::allocation_layer::MiniAllocator_v::*;
        use crate::journal::LinkedJournal_v;
        use crate::journal::LikesJournal_v::*;
        pub type StoreImage = JournalImage;
        #[verus::internal(verus_macro)]
        pub enum Ephemeral {
            Unknown,
            Known {
                v: AllocationJournal::State,
            },
        }
        #[verus::internal(verus_macro)]
        #[cfg(verus_keep_ghost)]
        #[automatically_derived]
        impl Ephemeral {
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_Unknown(&self) -> bool {
                ::builtin::is_variant(self, "Unknown")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_Known(&self) -> bool {
                ::builtin::is_variant(self, "Known")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_Known_v(self) -> AllocationJournal::State {
                ::builtin::get_variant_field(self, "Known", "v")
            }
        }
        #[verus::internal(verus_macro)]
        impl Ephemeral {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                ::builtin::imply(::builtin::is_variant(self, "Known"),
                    self.get_Known_v().wf())
            }
        }
        #[allow(unused_parens)]
        pub mod AllocationCrashAwareJournal {
            use super::*;
            #[verus::internal(verus_macro)]
            pub struct State {
                pub persistent: StoreImage,
                pub ephemeral: Ephemeral,
                pub inflight: Option<StoreImage>,
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Step {
                load_ephemeral_from_persistent(AllocationJournal::State,
                    AllocationJournal::Config),
                read_for_recovery(),
                query_end_lsn(),
                put(AllocationJournal::State),
                internal(AllocationJournal::State),
                query_lsn_persistence(),
                commit_start(StoreImage),
                commit_complete(AllocationJournal::State),
                crash(),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Step {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_load_ephemeral_from_persistent(&self) -> bool {
                    ::builtin::is_variant(self,
                        "load_ephemeral_from_persistent")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_load_ephemeral_from_persistent_0(self)
                    -> AllocationJournal::State {
                    ::builtin::get_variant_field(self,
                        "load_ephemeral_from_persistent", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_load_ephemeral_from_persistent_1(self)
                    -> AllocationJournal::Config {
                    ::builtin::get_variant_field(self,
                        "load_ephemeral_from_persistent", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_read_for_recovery(&self) -> bool {
                    ::builtin::is_variant(self, "read_for_recovery")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_query_end_lsn(&self) -> bool {
                    ::builtin::is_variant(self, "query_end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_put(&self) -> bool {
                    ::builtin::is_variant(self, "put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_put_0(self) -> AllocationJournal::State {
                    ::builtin::get_variant_field(self, "put", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_internal(&self) -> bool {
                    ::builtin::is_variant(self, "internal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_0(self) -> AllocationJournal::State {
                    ::builtin::get_variant_field(self, "internal", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_query_lsn_persistence(&self) -> bool {
                    ::builtin::is_variant(self, "query_lsn_persistence")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_commit_start(&self) -> bool {
                    ::builtin::is_variant(self, "commit_start")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_commit_start_0(self) -> StoreImage {
                    ::builtin::get_variant_field(self, "commit_start", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_commit_complete(&self) -> bool {
                    ::builtin::is_variant(self, "commit_complete")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_commit_complete_0(self)
                    -> AllocationJournal::State {
                    ::builtin::get_variant_field(self, "commit_complete", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_crash(&self) -> bool {
                    ::builtin::is_variant(self, "crash")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Config { initialize(), dummy_to_use_type_params(State), }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Config {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_initialize(&self) -> bool {
                    ::builtin::is_variant(self, "initialize")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[verus::internal(verus_macro)]
            pub enum Label {
                LoadEphemeralFromPersistent,
                ReadForRecovery {
                    records: MsgHistory,
                },
                QueryEndLsn {
                    end_lsn: LSN,
                },
                Put {
                    records: MsgHistory,
                },
                Internal {
                    allocs: Set<AU>,
                    deallocs: Set<AU>,
                },
                QueryLsnPersistence {
                    sync_lsn: LSN,
                },
                CommitStart {
                    new_boundary_lsn: LSN,
                    max_lsn: LSN,
                },
                CommitComplete {
                    require_end: LSN,
                    discarded: Set<AU>,
                },
                Crash,
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Label {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_LoadEphemeralFromPersistent(&self) -> bool {
                    ::builtin::is_variant(self, "LoadEphemeralFromPersistent")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_ReadForRecovery(&self) -> bool {
                    ::builtin::is_variant(self, "ReadForRecovery")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_ReadForRecovery_records(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "ReadForRecovery",
                        "records")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_QueryEndLsn(&self) -> bool {
                    ::builtin::is_variant(self, "QueryEndLsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_QueryEndLsn_end_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "QueryEndLsn", "end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_Put(&self) -> bool {
                    ::builtin::is_variant(self, "Put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_Put_records(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "Put", "records")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_Internal(&self) -> bool {
                    ::builtin::is_variant(self, "Internal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_Internal_allocs(self) -> Set<AU> {
                    ::builtin::get_variant_field(self, "Internal", "allocs")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_Internal_deallocs(self) -> Set<AU> {
                    ::builtin::get_variant_field(self, "Internal", "deallocs")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_QueryLsnPersistence(&self) -> bool {
                    ::builtin::is_variant(self, "QueryLsnPersistence")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_QueryLsnPersistence_sync_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "QueryLsnPersistence",
                        "sync_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_CommitStart(&self) -> bool {
                    ::builtin::is_variant(self, "CommitStart")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_CommitStart_new_boundary_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "CommitStart",
                        "new_boundary_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_CommitStart_max_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "CommitStart", "max_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_CommitComplete(&self) -> bool {
                    ::builtin::is_variant(self, "CommitComplete")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_CommitComplete_require_end(self) -> LSN {
                    ::builtin::get_variant_field(self, "CommitComplete",
                        "require_end")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_CommitComplete_discarded(self) -> Set<AU> {
                    ::builtin::get_variant_field(self, "CommitComplete",
                        "discarded")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_Crash(&self) -> bool {
                    ::builtin::is_variant(self, "Crash")
                }
            }
            pub mod show {
                use super::*;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn load_ephemeral_from_persistent(pre: super::State,
                    post: super::State, lbl: Label,
                    new_journal: AllocationJournal::State,
                    journal_config: AllocationJournal::Config) {
                    ::builtin::requires(super::State::load_ephemeral_from_persistent(pre,
                            post, lbl, new_journal, journal_config));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as load_ephemeral_from_persistent;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn read_for_recovery(pre: super::State,
                    post: super::State, lbl: Label) {
                    ::builtin::requires(super::State::read_for_recovery(pre,
                            post, lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as read_for_recovery;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn query_end_lsn(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::query_end_lsn(pre, post,
                            lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as query_end_lsn;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn put(pre: super::State, post: super::State, lbl: Label,
                    new_journal: AllocationJournal::State) {
                    ::builtin::requires(super::State::put(pre, post, lbl,
                            new_journal));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as put;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn internal(pre: super::State, post: super::State,
                    lbl: Label, new_journal: AllocationJournal::State) {
                    ::builtin::requires(super::State::internal(pre, post, lbl,
                            new_journal));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as internal;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn query_lsn_persistence(pre: super::State,
                    post: super::State, lbl: Label) {
                    ::builtin::requires(super::State::query_lsn_persistence(pre,
                            post, lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as query_lsn_persistence;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn commit_start(pre: super::State, post: super::State,
                    lbl: Label, frozen_journal: StoreImage) {
                    ::builtin::requires(super::State::commit_start(pre, post,
                            lbl, frozen_journal));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as commit_start;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn commit_complete(pre: super::State, post: super::State,
                    lbl: Label, new_journal: AllocationJournal::State) {
                    ::builtin::requires(super::State::commit_complete(pre, post,
                            lbl, new_journal));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as commit_complete;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn crash(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::crash(pre, post, lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as crash;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn initialize(post: super::State) {
                    ::builtin::requires(super::State::initialize(post));
                    ::builtin::ensures(super::State::init(post));
                }
                use bool as initialize;
            }
            pub mod take_step {
                use super::*;
            }
            #[verus::internal(verus_macro)]
            impl State {
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn initialize(post: Self) -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage =
                            JournalImage::empty();
                        let update_tmp_ephemeral: Ephemeral = Ephemeral::Unknown;
                        let update_tmp_inflight: Option<StoreImage> = Option::None;
                        (#[verifier::custom_err("cannot prove that final value of field `inflight` has this updated value")] (::builtin::equal(post.inflight,
                                        update_tmp_inflight)) &&
                                (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                update_tmp_ephemeral)) &&
                                        #[verifier::custom_err("cannot prove that final value of field `persistent` has this updated value")] (::builtin::equal(post.persistent,
                                                update_tmp_persistent))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn initialize_enabled() -> ::core::primitive::bool {
                    { true }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn load_ephemeral_from_persistent(pre: Self, post: Self,
                    lbl: Label, new_journal: AllocationJournal::State,
                    journal_config: AllocationJournal::Config)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        let update_tmp_inflight: Option<StoreImage> = pre.inflight;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "LoadEphemeralFromPersistent")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Unknown")) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::equal(journal_config,
                                                        AllocationJournal::Config::initialize(new_journal.journal,
                                                            pre.persistent))) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (AllocationJournal::State::init_by(new_journal,
                                                                journal_config)) &&
                                                        {
                                                            let update_tmp_ephemeral: Ephemeral =
                                                                Ephemeral::Known { v: new_journal };
                                                            (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                            update_tmp_ephemeral)) &&
                                                                    (#[verifier::custom_err("cannot prove that the field `inflight` is preserved")] (::builtin::equal(post.inflight,
                                                                                    update_tmp_inflight)) &&
                                                                            #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                                    update_tmp_persistent))))
                                                        }))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn load_ephemeral_from_persistent_strong(pre: Self,
                    post: Self, lbl: Label,
                    new_journal: AllocationJournal::State,
                    journal_config: AllocationJournal::Config)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        let update_tmp_inflight: Option<StoreImage> = pre.inflight;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "LoadEphemeralFromPersistent")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Unknown")) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::equal(journal_config,
                                                        AllocationJournal::Config::initialize(new_journal.journal,
                                                            pre.persistent))) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (AllocationJournal::State::init_by(new_journal,
                                                                journal_config)) &&
                                                        {
                                                            let update_tmp_ephemeral: Ephemeral =
                                                                Ephemeral::Known { v: new_journal };
                                                            (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                            update_tmp_ephemeral)) &&
                                                                    (#[verifier::custom_err("cannot prove that the field `inflight` is preserved")] (::builtin::equal(post.inflight,
                                                                                    update_tmp_inflight)) &&
                                                                            #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                                    update_tmp_persistent))))
                                                        }))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn load_ephemeral_from_persistent_enabled(pre: Self,
                    lbl: Label, new_journal: AllocationJournal::State,
                    journal_config: AllocationJournal::Config)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "LoadEphemeralFromPersistent")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Unknown")) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::equal(journal_config,
                                                        AllocationJournal::Config::initialize(new_journal.journal,
                                                            pre.persistent))) &&
                                                #[verifier::custom_err("cannot prove this condition holds")] (AllocationJournal::State::init_by(new_journal,
                                                        journal_config)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn read_for_recovery(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        let update_tmp_inflight: Option<StoreImage> = pre.inflight;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "ReadForRecovery")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Known")) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (AllocationJournal::State::next(pre.ephemeral.get_Known_v(),
                                                        pre.ephemeral.get_Known_v(),
                                                        AllocationJournal::Label::ReadForRecovery {
                                                            messages: lbl.get_ReadForRecovery_records(),
                                                        })) &&
                                                (#[verifier::custom_err("cannot prove that the field `inflight` is preserved")] (::builtin::equal(post.inflight,
                                                                update_tmp_inflight)) &&
                                                        (#[verifier::custom_err("cannot prove that the field `ephemeral` is preserved")] (::builtin::equal(post.ephemeral,
                                                                        update_tmp_ephemeral)) &&
                                                                #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                        update_tmp_persistent)))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn read_for_recovery_strong(pre: Self, post: Self,
                    lbl: Label) -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        let update_tmp_inflight: Option<StoreImage> = pre.inflight;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "ReadForRecovery")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Known")) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (AllocationJournal::State::next(pre.ephemeral.get_Known_v(),
                                                        pre.ephemeral.get_Known_v(),
                                                        AllocationJournal::Label::ReadForRecovery {
                                                            messages: lbl.get_ReadForRecovery_records(),
                                                        })) &&
                                                (#[verifier::custom_err("cannot prove that the field `inflight` is preserved")] (::builtin::equal(post.inflight,
                                                                update_tmp_inflight)) &&
                                                        (#[verifier::custom_err("cannot prove that the field `ephemeral` is preserved")] (::builtin::equal(post.ephemeral,
                                                                        update_tmp_ephemeral)) &&
                                                                #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                        update_tmp_persistent)))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn read_for_recovery_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "ReadForRecovery")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Known")) &&
                                        #[verifier::custom_err("cannot prove this condition holds")] (AllocationJournal::State::next(pre.ephemeral.get_Known_v(),
                                                pre.ephemeral.get_Known_v(),
                                                AllocationJournal::Label::ReadForRecovery {
                                                    messages: lbl.get_ReadForRecovery_records(),
                                                }))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_end_lsn(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        let update_tmp_inflight: Option<StoreImage> = pre.inflight;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "QueryEndLsn")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Known")) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (AllocationJournal::State::next(pre.ephemeral.get_Known_v(),
                                                        pre.ephemeral.get_Known_v(),
                                                        AllocationJournal::Label::QueryEndLsn {
                                                            end_lsn: lbl.get_QueryEndLsn_end_lsn(),
                                                        })) &&
                                                (#[verifier::custom_err("cannot prove that the field `inflight` is preserved")] (::builtin::equal(post.inflight,
                                                                update_tmp_inflight)) &&
                                                        (#[verifier::custom_err("cannot prove that the field `ephemeral` is preserved")] (::builtin::equal(post.ephemeral,
                                                                        update_tmp_ephemeral)) &&
                                                                #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                        update_tmp_persistent)))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_end_lsn_strong(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        let update_tmp_inflight: Option<StoreImage> = pre.inflight;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "QueryEndLsn")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Known")) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (AllocationJournal::State::next(pre.ephemeral.get_Known_v(),
                                                        pre.ephemeral.get_Known_v(),
                                                        AllocationJournal::Label::QueryEndLsn {
                                                            end_lsn: lbl.get_QueryEndLsn_end_lsn(),
                                                        })) &&
                                                (#[verifier::custom_err("cannot prove that the field `inflight` is preserved")] (::builtin::equal(post.inflight,
                                                                update_tmp_inflight)) &&
                                                        (#[verifier::custom_err("cannot prove that the field `ephemeral` is preserved")] (::builtin::equal(post.ephemeral,
                                                                        update_tmp_ephemeral)) &&
                                                                #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                        update_tmp_persistent)))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_end_lsn_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "QueryEndLsn")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Known")) &&
                                        #[verifier::custom_err("cannot prove this condition holds")] (AllocationJournal::State::next(pre.ephemeral.get_Known_v(),
                                                pre.ephemeral.get_Known_v(),
                                                AllocationJournal::Label::QueryEndLsn {
                                                    end_lsn: lbl.get_QueryEndLsn_end_lsn(),
                                                }))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put(pre: Self, post: Self, lbl: Label,
                    new_journal: AllocationJournal::State)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        let update_tmp_inflight: Option<StoreImage> = pre.inflight;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "Put")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Known")) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (AllocationJournal::State::next(pre.ephemeral.get_Known_v(),
                                                        new_journal,
                                                        AllocationJournal::Label::Put {
                                                            messages: lbl.get_Put_records(),
                                                        })) &&
                                                {
                                                    let update_tmp_ephemeral: Ephemeral =
                                                        Ephemeral::Known { v: new_journal };
                                                    (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                    update_tmp_ephemeral)) &&
                                                            (#[verifier::custom_err("cannot prove that the field `inflight` is preserved")] (::builtin::equal(post.inflight,
                                                                            update_tmp_inflight)) &&
                                                                    #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                            update_tmp_persistent))))
                                                })))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put_strong(pre: Self, post: Self, lbl: Label,
                    new_journal: AllocationJournal::State)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        let update_tmp_inflight: Option<StoreImage> = pre.inflight;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "Put")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Known")) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (AllocationJournal::State::next(pre.ephemeral.get_Known_v(),
                                                        new_journal,
                                                        AllocationJournal::Label::Put {
                                                            messages: lbl.get_Put_records(),
                                                        })) &&
                                                {
                                                    let update_tmp_ephemeral: Ephemeral =
                                                        Ephemeral::Known { v: new_journal };
                                                    (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                    update_tmp_ephemeral)) &&
                                                            (#[verifier::custom_err("cannot prove that the field `inflight` is preserved")] (::builtin::equal(post.inflight,
                                                                            update_tmp_inflight)) &&
                                                                    #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                            update_tmp_persistent))))
                                                })))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put_enabled(pre: Self, lbl: Label,
                    new_journal: AllocationJournal::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "Put")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Known")) &&
                                        #[verifier::custom_err("cannot prove this condition holds")] (AllocationJournal::State::next(pre.ephemeral.get_Known_v(),
                                                new_journal,
                                                AllocationJournal::Label::Put {
                                                    messages: lbl.get_Put_records(),
                                                }))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal(pre: Self, post: Self, lbl: Label,
                    new_journal: AllocationJournal::State)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        let update_tmp_inflight: Option<StoreImage> = pre.inflight;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "Internal")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Known")) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.fresh_label(lbl))
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (AllocationJournal::State::next(pre.ephemeral.get_Known_v(),
                                                                new_journal,
                                                                AllocationJournal::Label::InternalAllocations {
                                                                    allocs: lbl.get_Internal_allocs(),
                                                                    deallocs: lbl.get_Internal_deallocs(),
                                                                })) &&
                                                        {
                                                            let update_tmp_ephemeral: Ephemeral =
                                                                Ephemeral::Known { v: new_journal };
                                                            (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                            update_tmp_ephemeral)) &&
                                                                    (#[verifier::custom_err("cannot prove that the field `inflight` is preserved")] (::builtin::equal(post.inflight,
                                                                                    update_tmp_inflight)) &&
                                                                            #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                                    update_tmp_persistent))))
                                                        }))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_strong(pre: Self, post: Self, lbl: Label,
                    new_journal: AllocationJournal::State)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        let update_tmp_inflight: Option<StoreImage> = pre.inflight;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "Internal")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Known")) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.fresh_label(lbl))
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (AllocationJournal::State::next(pre.ephemeral.get_Known_v(),
                                                                new_journal,
                                                                AllocationJournal::Label::InternalAllocations {
                                                                    allocs: lbl.get_Internal_allocs(),
                                                                    deallocs: lbl.get_Internal_deallocs(),
                                                                })) &&
                                                        {
                                                            let update_tmp_ephemeral: Ephemeral =
                                                                Ephemeral::Known { v: new_journal };
                                                            (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                            update_tmp_ephemeral)) &&
                                                                    (#[verifier::custom_err("cannot prove that the field `inflight` is preserved")] (::builtin::equal(post.inflight,
                                                                                    update_tmp_inflight)) &&
                                                                            #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                                    update_tmp_persistent))))
                                                        }))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_enabled(pre: Self, lbl: Label,
                    new_journal: AllocationJournal::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "Internal")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Known")) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.fresh_label(lbl))
                                                &&
                                                #[verifier::custom_err("cannot prove this condition holds")] (AllocationJournal::State::next(pre.ephemeral.get_Known_v(),
                                                        new_journal,
                                                        AllocationJournal::Label::InternalAllocations {
                                                            allocs: lbl.get_Internal_allocs(),
                                                            deallocs: lbl.get_Internal_deallocs(),
                                                        })))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_lsn_persistence(pre: Self, post: Self,
                    lbl: Label) -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        let update_tmp_inflight: Option<StoreImage> = pre.inflight;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "QueryLsnPersistence")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] ((lbl.get_QueryLsnPersistence_sync_lsn()).spec_le(pre.persistent.tj.seq_end()))
                                        &&
                                        (#[verifier::custom_err("cannot prove that the field `inflight` is preserved")] (::builtin::equal(post.inflight,
                                                        update_tmp_inflight)) &&
                                                (#[verifier::custom_err("cannot prove that the field `ephemeral` is preserved")] (::builtin::equal(post.ephemeral,
                                                                update_tmp_ephemeral)) &&
                                                        #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                update_tmp_persistent))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_lsn_persistence_strong(pre: Self, post: Self,
                    lbl: Label) -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        let update_tmp_inflight: Option<StoreImage> = pre.inflight;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "QueryLsnPersistence")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] ((lbl.get_QueryLsnPersistence_sync_lsn()).spec_le(pre.persistent.tj.seq_end()))
                                        &&
                                        (#[verifier::custom_err("cannot prove that the field `inflight` is preserved")] (::builtin::equal(post.inflight,
                                                        update_tmp_inflight)) &&
                                                (#[verifier::custom_err("cannot prove that the field `ephemeral` is preserved")] (::builtin::equal(post.ephemeral,
                                                                update_tmp_ephemeral)) &&
                                                        #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                update_tmp_persistent))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_lsn_persistence_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "QueryLsnPersistence")) &&
                                #[verifier::custom_err("cannot prove this condition holds")] ((lbl.get_QueryLsnPersistence_sync_lsn()).spec_le(pre.persistent.tj.seq_end())))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn commit_start(pre: Self, post: Self, lbl: Label,
                    frozen_journal: StoreImage) -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "CommitStart")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Known")) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.inflight,
                                                        "None")) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(frozen_journal.tj.seq_start(),
                                                                lbl.get_CommitStart_new_boundary_lsn())) &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] ((pre.persistent.tj.seq_end()).spec_le(frozen_journal.tj.seq_end()))
                                                                &&
                                                                (#[verifier::custom_err("cannot prove this condition holds")] ((frozen_journal.tj.seq_start()).spec_le(lbl.get_CommitStart_max_lsn()))
                                                                        &&
                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (AllocationJournal::State::next(pre.ephemeral.get_Known_v(),
                                                                                        pre.ephemeral.get_Known_v(),
                                                                                        AllocationJournal::Label::FreezeForCommit {
                                                                                            frozen_journal: frozen_journal,
                                                                                        })) &&
                                                                                {
                                                                                    let update_tmp_inflight: Option<StoreImage> =
                                                                                        Option::Some(frozen_journal);
                                                                                    (#[verifier::custom_err("cannot prove that final value of field `inflight` has this updated value")] (::builtin::equal(post.inflight,
                                                                                                    update_tmp_inflight)) &&
                                                                                            (#[verifier::custom_err("cannot prove that the field `ephemeral` is preserved")] (::builtin::equal(post.ephemeral,
                                                                                                            update_tmp_ephemeral)) &&
                                                                                                    #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                                                            update_tmp_persistent))))
                                                                                })))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn commit_start_strong(pre: Self, post: Self, lbl: Label,
                    frozen_journal: StoreImage) -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "CommitStart")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Known")) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.inflight,
                                                        "None")) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(frozen_journal.tj.seq_start(),
                                                                lbl.get_CommitStart_new_boundary_lsn())) &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] ((pre.persistent.tj.seq_end()).spec_le(frozen_journal.tj.seq_end()))
                                                                &&
                                                                (#[verifier::custom_err("cannot prove this condition holds")] ((frozen_journal.tj.seq_start()).spec_le(lbl.get_CommitStart_max_lsn()))
                                                                        &&
                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (AllocationJournal::State::next(pre.ephemeral.get_Known_v(),
                                                                                        pre.ephemeral.get_Known_v(),
                                                                                        AllocationJournal::Label::FreezeForCommit {
                                                                                            frozen_journal: frozen_journal,
                                                                                        })) &&
                                                                                {
                                                                                    let update_tmp_inflight: Option<StoreImage> =
                                                                                        Option::Some(frozen_journal);
                                                                                    (#[verifier::custom_err("cannot prove that final value of field `inflight` has this updated value")] (::builtin::equal(post.inflight,
                                                                                                    update_tmp_inflight)) &&
                                                                                            (#[verifier::custom_err("cannot prove that the field `ephemeral` is preserved")] (::builtin::equal(post.ephemeral,
                                                                                                            update_tmp_ephemeral)) &&
                                                                                                    #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                                                            update_tmp_persistent))))
                                                                                })))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn commit_start_enabled(pre: Self, lbl: Label,
                    frozen_journal: StoreImage) -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "CommitStart")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Known")) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.inflight,
                                                        "None")) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(frozen_journal.tj.seq_start(),
                                                                lbl.get_CommitStart_new_boundary_lsn())) &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] ((pre.persistent.tj.seq_end()).spec_le(frozen_journal.tj.seq_end()))
                                                                &&
                                                                (#[verifier::custom_err("cannot prove this condition holds")] ((frozen_journal.tj.seq_start()).spec_le(lbl.get_CommitStart_max_lsn()))
                                                                        &&
                                                                        #[verifier::custom_err("cannot prove this condition holds")] (AllocationJournal::State::next(pre.ephemeral.get_Known_v(),
                                                                                pre.ephemeral.get_Known_v(),
                                                                                AllocationJournal::Label::FreezeForCommit {
                                                                                    frozen_journal: frozen_journal,
                                                                                }))))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn commit_complete(pre: Self, post: Self, lbl: Label,
                    new_journal: AllocationJournal::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "CommitComplete")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Known")) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.inflight,
                                                        "Some")) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (AllocationJournal::State::next(pre.ephemeral.get_Known_v(),
                                                                new_journal,
                                                                AllocationJournal::Label::DiscardOld {
                                                                    start_lsn: pre.inflight.get_Some_0().tj.seq_start(),
                                                                    require_end: lbl.get_CommitComplete_require_end(),
                                                                    deallocs: lbl.get_CommitComplete_discarded(),
                                                                })) &&
                                                        {
                                                            let update_tmp_persistent: StoreImage =
                                                                pre.inflight.get_Some_0();
                                                            let update_tmp_ephemeral: Ephemeral =
                                                                Ephemeral::Known { v: new_journal };
                                                            let update_tmp_inflight: Option<StoreImage> = Option::None;
                                                            (#[verifier::custom_err("cannot prove that final value of field `inflight` has this updated value")] (::builtin::equal(post.inflight,
                                                                            update_tmp_inflight)) &&
                                                                    (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                                    update_tmp_ephemeral)) &&
                                                                            #[verifier::custom_err("cannot prove that final value of field `persistent` has this updated value")] (::builtin::equal(post.persistent,
                                                                                    update_tmp_persistent))))
                                                        }))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn commit_complete_strong(pre: Self, post: Self,
                    lbl: Label, new_journal: AllocationJournal::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "CommitComplete")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Known")) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.inflight,
                                                        "Some")) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (AllocationJournal::State::next(pre.ephemeral.get_Known_v(),
                                                                new_journal,
                                                                AllocationJournal::Label::DiscardOld {
                                                                    start_lsn: pre.inflight.get_Some_0().tj.seq_start(),
                                                                    require_end: lbl.get_CommitComplete_require_end(),
                                                                    deallocs: lbl.get_CommitComplete_discarded(),
                                                                })) &&
                                                        {
                                                            let update_tmp_persistent: StoreImage =
                                                                pre.inflight.get_Some_0();
                                                            let update_tmp_ephemeral: Ephemeral =
                                                                Ephemeral::Known { v: new_journal };
                                                            let update_tmp_inflight: Option<StoreImage> = Option::None;
                                                            (#[verifier::custom_err("cannot prove that final value of field `inflight` has this updated value")] (::builtin::equal(post.inflight,
                                                                            update_tmp_inflight)) &&
                                                                    (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                                    update_tmp_ephemeral)) &&
                                                                            #[verifier::custom_err("cannot prove that final value of field `persistent` has this updated value")] (::builtin::equal(post.persistent,
                                                                                    update_tmp_persistent))))
                                                        }))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn commit_complete_enabled(pre: Self, lbl: Label,
                    new_journal: AllocationJournal::State)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "CommitComplete")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Known")) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.inflight,
                                                        "Some")) &&
                                                #[verifier::custom_err("cannot prove this condition holds")] (AllocationJournal::State::next(pre.ephemeral.get_Known_v(),
                                                        new_journal,
                                                        AllocationJournal::Label::DiscardOld {
                                                            start_lsn: pre.inflight.get_Some_0().tj.seq_start(),
                                                            require_end: lbl.get_CommitComplete_require_end(),
                                                            deallocs: lbl.get_CommitComplete_discarded(),
                                                        })))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn crash(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "Crash")) &&
                                {
                                    let update_tmp_ephemeral: Ephemeral = Ephemeral::Unknown;
                                    let update_tmp_inflight: Option<StoreImage> = Option::None;
                                    (#[verifier::custom_err("cannot prove that final value of field `inflight` has this updated value")] (::builtin::equal(post.inflight,
                                                    update_tmp_inflight)) &&
                                            (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                            update_tmp_ephemeral)) &&
                                                    #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                            update_tmp_persistent))))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn crash_strong(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: StoreImage = pre.persistent;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "Crash")) &&
                                {
                                    let update_tmp_ephemeral: Ephemeral = Ephemeral::Unknown;
                                    let update_tmp_inflight: Option<StoreImage> = Option::None;
                                    (#[verifier::custom_err("cannot prove that final value of field `inflight` has this updated value")] (::builtin::equal(post.inflight,
                                                    update_tmp_inflight)) &&
                                            (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                            update_tmp_ephemeral)) &&
                                                    #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                            update_tmp_persistent))))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn crash_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {

                        #[verifier::custom_err("cannot prove this condition holds")]
                        (::builtin::is_variant(lbl, "Crash"))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_by(pre: State, post: State, label: Label,
                    step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::load_ephemeral_from_persistent(new_journal,
                            journal_config) =>
                            Self::load_ephemeral_from_persistent(pre, post, label,
                                new_journal, journal_config),
                        Step::read_for_recovery() =>
                            Self::read_for_recovery(pre, post, label),
                        Step::query_end_lsn() =>
                            Self::query_end_lsn(pre, post, label),
                        Step::put(new_journal) =>
                            Self::put(pre, post, label, new_journal),
                        Step::internal(new_journal) =>
                            Self::internal(pre, post, label, new_journal),
                        Step::query_lsn_persistence() =>
                            Self::query_lsn_persistence(pre, post, label),
                        Step::commit_start(frozen_journal) =>
                            Self::commit_start(pre, post, label, frozen_journal),
                        Step::commit_complete(new_journal) =>
                            Self::commit_complete(pre, post, label, new_journal),
                        Step::crash() => Self::crash(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next(pre: State, post: State, label: Label)
                    -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                            Self::next_by(pre, post, label, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_strong_by(pre: State, post: State, label: Label,
                    step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::load_ephemeral_from_persistent(new_journal,
                            journal_config) =>
                            Self::load_ephemeral_from_persistent_strong(pre, post,
                                label, new_journal, journal_config),
                        Step::read_for_recovery() =>
                            Self::read_for_recovery_strong(pre, post, label),
                        Step::query_end_lsn() =>
                            Self::query_end_lsn_strong(pre, post, label),
                        Step::put(new_journal) =>
                            Self::put_strong(pre, post, label, new_journal),
                        Step::internal(new_journal) =>
                            Self::internal_strong(pre, post, label, new_journal),
                        Step::query_lsn_persistence() =>
                            Self::query_lsn_persistence_strong(pre, post, label),
                        Step::commit_start(frozen_journal) =>
                            Self::commit_start_strong(pre, post, label, frozen_journal),
                        Step::commit_complete(new_journal) =>
                            Self::commit_complete_strong(pre, post, label, new_journal),
                        Step::crash() => Self::crash_strong(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_strong(pre: State, post: State, label: Label)
                    -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                            Self::next_strong_by(pre, post, label, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn init_by(post: State, step: Config)
                    -> ::core::primitive::bool {
                    match step {
                        Config::initialize() => Self::initialize(post),
                        Config::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn init(post: State) -> ::core::primitive::bool {
                    ::builtin::exists(|step: Config| Self::init_by(post, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::spec]
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                pub fn invariant(&self) -> ::core::primitive::bool {
                    self.inv()
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn inv(self) -> bool {
                    (((((::builtin::imply(::builtin::is_variant(self.ephemeral,
                                                                    "Unknown"), ::builtin::is_variant(self.inflight, "None")))
                                                        &&
                                                        (::builtin::imply(::builtin::is_variant(self.ephemeral,
                                                                    "Known"), self.ephemeral.get_Known_v().inv()))) &&
                                                (::builtin::imply(::builtin::is_variant(self.inflight,
                                                            "Some"), self.inflight.get_Some_0().tj.decodable()))) &&
                                        (self.persistent.tj.decodable())) &&
                                (self.state_relations())) && (self.journal_pages_not_free())
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::custom_req_err("could not show invariant `inv` on the `post` state")]
                #[verifier::external_body]
                #[verus::internal(verus_macro)]
                #[verifier::proof]
                fn lemma_msg_inv(s: State) {
                    ::builtin::requires(s.inv());
                    ::builtin::ensures(s.inv());
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn initialize_inductive(post: Self) {
                    ::builtin::requires(Self::initialize(post));
                    ::builtin::ensures(post.invariant());
                    {
                        LinkedJournal_v::TruncatedJournal::mkfs_ensures();
                        ::builtin::assert_(post.persistent.tj.decodable());
                    }
                    Self::lemma_msg_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn load_ephemeral_from_persistent_inductive(pre: Self,
                    post: Self, lbl: Label,
                    new_journal: AllocationJournal::State,
                    journal_config: AllocationJournal::Config) {
                    ::builtin::requires(pre.invariant() &&
                            State::load_ephemeral_from_persistent_strong(pre, post, lbl,
                                new_journal, journal_config));
                    ::builtin::ensures(post.invariant());
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(AllocationJournal::State::init_by)
                                }
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                        ::builtin::assert_(::builtin::imply(::builtin::is_variant(pre.ephemeral,
                                    "Known"), pre.ephemeral.get_Known_v().inv()));
                        ::builtin::assume_(::builtin::imply(::builtin::is_variant(post.ephemeral,
                                    "Known"), post.ephemeral.get_Known_v().inv()));
                        ::builtin::assert_(::builtin::spec_eq(new_journal.mini_allocator,
                                MiniAllocator::empty()));
                        ::builtin::assert_(post.journal_pages_not_free());
                        ::builtin::assert_(post.state_relations());
                    }
                    Self::lemma_msg_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn read_for_recovery_inductive(pre: Self, post: Self,
                    lbl: Label) {
                    ::builtin::requires(pre.invariant() &&
                            State::read_for_recovery_strong(pre, post, lbl));
                    ::builtin::ensures(post.invariant());
                    {
                        ::builtin::assume_(::builtin::imply(::builtin::is_variant(post.ephemeral,
                                    "Known"), post.ephemeral.get_Known_v().inv()));
                    }
                    Self::lemma_msg_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn query_end_lsn_inductive(pre: Self, post: Self,
                    lbl: Label) {
                    ::builtin::requires(pre.invariant() &&
                            State::query_end_lsn_strong(pre, post, lbl));
                    ::builtin::ensures(post.invariant());
                    {
                        ::builtin::assume_(::builtin::imply(::builtin::is_variant(post.ephemeral,
                                    "Known"), post.ephemeral.get_Known_v().inv()));
                    }
                    Self::lemma_msg_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn put_inductive(pre: Self, post: Self, lbl: Label,
                    new_journal: AllocationJournal::State) {
                    ::builtin::requires(pre.invariant() &&
                            State::put_strong(pre, post, lbl, new_journal));
                    ::builtin::ensures(post.invariant());
                    {
                        ::builtin::assume_(::builtin::imply(::builtin::is_variant(post.ephemeral,
                                    "Known"), post.ephemeral.get_Known_v().inv()));
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(AllocationJournal::State::next)
                                }
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(AllocationJournal::State::next_by)
                                }
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                        ::builtin::assert_(post.journal_pages_not_free());
                        ::builtin::assert_(post.state_relations());
                    }
                    Self::lemma_msg_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn internal_inductive(pre: Self, post: Self, lbl: Label,
                    new_journal: AllocationJournal::State) {
                    ::builtin::requires(pre.invariant() &&
                            State::internal_strong(pre, post, lbl, new_journal));
                    ::builtin::ensures(post.invariant());
                    {
                        ::builtin::assume_(::builtin::imply(::builtin::is_variant(post.ephemeral,
                                    "Known"), post.ephemeral.get_Known_v().inv()));
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(AllocationJournal::State::next)
                                }
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(AllocationJournal::State::next_by)
                                }
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                        ::builtin::assert_(post.journal_pages_not_free());
                        let aj_lbl =
                            AllocationJournal::Label::InternalAllocations {
                                allocs: lbl.get_Internal_allocs(),
                                deallocs: lbl.get_Internal_deallocs(),
                            };
                        match ::builtin::choose(|step|
                                    AllocationJournal::State::next_by(pre.ephemeral.get_Known_v(),
                                        post.ephemeral.get_Known_v(), aj_lbl, step)) {
                            AllocationJournal::Step::internal_journal_marshal(cut, addr,
                                post_linked_journal) => {
                                if ::builtin::is_variant(post.inflight, "Some") {
                                        let ephemeral_disk =
                                            post.ephemeral.get_Known_v().tj().disk_view;
                                        let inflight_disk = post.inflight.unwrap().tj.disk_view;
                                        ::builtin::assert_(inflight_disk.is_sub_disk_with_newer_lsn(ephemeral_disk));
                                    }
                            }
                            AllocationJournal::Step::internal_mini_allocator_fill() =>
                                {}
                            AllocationJournal::Step::internal_mini_allocator_prune() =>
                                {}
                            AllocationJournal::Step::internal_no_op() => {}
                            _ => { ::builtin::assert_(false); }
                        }
                        ::builtin::assert_(post.state_relations());
                    }
                    Self::lemma_msg_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn query_lsn_persistence_inductive(pre: Self, post: Self,
                    lbl: Label) {
                    ::builtin::requires(pre.invariant() &&
                            State::query_lsn_persistence_strong(pre, post, lbl));
                    ::builtin::ensures(post.invariant());
                    {
                        ::builtin::assume_(::builtin::imply(::builtin::is_variant(post.ephemeral,
                                    "Known"), post.ephemeral.get_Known_v().inv()));
                    }
                    Self::lemma_msg_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn commit_start_inductive(pre: Self, post: Self, lbl: Label,
                    frozen_journal: StoreImage) {
                    ::builtin::requires(pre.invariant() &&
                            State::commit_start_strong(pre, post, lbl, frozen_journal));
                    ::builtin::ensures(post.invariant());
                    {
                        ::builtin::assume_(::builtin::imply(::builtin::is_variant(post.ephemeral,
                                    "Known"), post.ephemeral.get_Known_v().inv()));
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(AllocationJournal::State::next)
                                }
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(AllocationJournal::State::next_by)
                                }
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(LikesJournal::State::next)
                                }
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(LikesJournal::State::next_by)
                                }
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(LinkedJournal_v::LinkedJournal::State::next)
                                }
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(LinkedJournal_v::LinkedJournal::State::next_by)
                                }
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                        ::builtin::assert_(::builtin::imply(::builtin::is_variant(post.inflight,
                                    "Some"), post.inflight.get_Some_0().tj.decodable()));
                        let aj = pre.ephemeral.get_Known_v();
                        let ephemeral_disk = aj.tj().disk_view;
                        let ephemeral_discarded_disk =
                            ephemeral_disk.discard_old(frozen_journal.tj.disk_view.boundary_lsn);
                        ephemeral_disk.build_tight_auto();
                        ephemeral_disk.pointer_after_crop_auto();
                        ephemeral_discarded_disk.build_tight_builds_sub_disks(frozen_journal.tj.freshest_rec);
                        ::builtin::assert_(post.state_relations());
                        ::builtin::assert_((frozen_journal.tj.disk_view.entries.dom()).spec_le(ephemeral_disk.entries.dom()));
                        ::builtin::assert_(post.journal_pages_not_free());
                    }
                    Self::lemma_msg_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn commit_complete_inductive(pre: Self, post: Self,
                    lbl: Label, new_journal: AllocationJournal::State) {
                    ::builtin::requires(pre.invariant() &&
                            State::commit_complete_strong(pre, post, lbl, new_journal));
                    ::builtin::ensures(post.invariant());
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(AllocationJournal::State::next)
                                }
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(AllocationJournal::State::next_by)
                                }
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                        ::builtin::assume_(::builtin::imply(::builtin::is_variant(post.ephemeral,
                                    "Known"), post.ephemeral.get_Known_v().inv()));
                        ::builtin::assert_(post.journal_pages_not_free());
                        let pre_ephemeral_disk =
                            pre.ephemeral.get_Known_v().tj().disk_view;
                        let pre_inflight_disk = pre.inflight.unwrap().tj.disk_view;
                        ::builtin::assert_(pre_inflight_disk.is_sub_disk_with_newer_lsn(pre_ephemeral_disk));
                        let post_ephemeral_disk =
                            post.ephemeral.get_Known_v().tj().disk_view;
                        ::builtin::assert_(post_ephemeral_disk.is_sub_disk_with_newer_lsn(pre_ephemeral_disk));
                        {
                            ::builtin::assert_forall_by(|addr|
                                    {
                                        ::builtin::ensures(::builtin::imply(pre_inflight_disk.entries.dom().contains(addr)
                                                    && post_ephemeral_disk.entries.dom().contains(addr),
                                                pre_ephemeral_disk.entries.dom().contains(addr)));
                                    });
                        }
                        ::builtin::assert_(Map::agrees(pre_inflight_disk.entries,
                                post_ephemeral_disk.entries));
                        ::builtin::assert_(post.state_relations());
                    }
                    Self::lemma_msg_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn crash_inductive(pre: Self, post: Self, lbl: Label) {
                    ::builtin::requires(pre.invariant() &&
                            State::crash_strong(pre, post, lbl));
                    ::builtin::ensures(post.invariant());
                    {
                        ::builtin::assume_(::builtin::imply(::builtin::is_variant(post.ephemeral,
                                    "Known"), post.ephemeral.get_Known_v().inv()));
                    }
                    Self::lemma_msg_inv(post);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn fresh_label(self, lbl: Label) -> bool {
                    ::builtin::recommends([::builtin::imply(::builtin::is_variant(lbl,
                                        "Internal"),
                                    ::builtin::is_variant(self.ephemeral, "Known"))]);
                    ::builtin::imply(::builtin::is_variant(lbl, "Internal"),
                        {
                            ((lbl.get_Internal_allocs().disjoint(self.persistent.accessible_aus()))
                                        &&
                                        (lbl.get_Internal_allocs().disjoint(self.ephemeral.get_Known_v().accessible_aus())))
                                &&
                                (::builtin::imply(::builtin::is_variant(self.inflight,
                                            "Some"),
                                        lbl.get_Internal_allocs().disjoint(self.inflight.unwrap().accessible_aus())))
                        })
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn state_relations(self) -> bool {
                    (::builtin::imply(::builtin::is_variant(self.ephemeral,
                                    "Known"),
                                {
                                    let ephemeral_disk =
                                        self.ephemeral.get_Known_v().tj().disk_view;
                                    let persistent_disk = self.persistent.tj.disk_view;
                                    Map::agrees(ephemeral_disk.entries, persistent_disk.entries)
                                })) &&
                        (::builtin::imply(::builtin::is_variant(self.ephemeral,
                                        "Known") && ::builtin::is_variant(self.inflight, "Some"),
                                {
                                    let ephemeral_disk =
                                        self.ephemeral.get_Known_v().tj().disk_view;
                                    let inflight_disk = self.inflight.get_Some_0().tj.disk_view;
                                    inflight_disk.is_sub_disk_with_newer_lsn(ephemeral_disk)
                                }))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn journal_pages_not_free(self) -> bool {
                    ::builtin::recommends([::builtin::imply(::builtin::is_variant(self.ephemeral,
                                        "Known"), self.ephemeral.get_Known_v().inv())]);
                    (::builtin::imply(::builtin::is_variant(self.ephemeral,
                                    "Known"),
                                {
                                    let v = self.ephemeral.get_Known_v();
                                    let persistent_disk = self.persistent.tj.disk_view;
                                    AllocationJournal::State::journal_pages_not_free(persistent_disk.entries.dom(),
                                        v.mini_allocator)
                                })) &&
                        (::builtin::imply(::builtin::is_variant(self.ephemeral,
                                        "Known") && ::builtin::is_variant(self.inflight, "Some"),
                                {
                                    let v = self.ephemeral.get_Known_v();
                                    let inflight_disk = self.inflight.get_Some_0().tj.disk_view;
                                    AllocationJournal::State::journal_pages_not_free(inflight_disk.entries.dom(),
                                        v.mini_allocator)
                                }))
                }
            }
        }
    }
    pub mod UnifiedCrashAwareJournal_v {
        #![allow(unused_imports)]
        use builtin::*;
        use vstd::prelude::*;
        use vstd::math;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        use vstd::prelude::*;
        use vstd::map::*;
        use vstd::map_lib::*;
        use crate::abstract_system::StampedMap_v::LSN;
        use crate::abstract_system::MsgHistory_v::*;
        use crate::disk::GenericDisk_v::*;
        use crate::disk::GenericDisk_v::AU;
        use crate::journal::LinkedJournal_v;
        use crate::journal::LinkedJournal_v::LinkedJournal;
        use crate::journal::LinkedJournal_v::JournalRecord;
        use crate::allocation_layer::AllocationJournal_v::*;
        use crate::allocation_layer::MiniAllocator_v::*;
        pub type JournalDiskView = LinkedJournal_v::DiskView;
        #[verus::internal(verus_macro)]
        pub struct ImageState {
            pub freshest_rec: Pointer,
            pub boundary_lsn: LSN,
            pub first: AU,
        }
        #[verus::internal(verus_macro)]
        impl ImageState {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn empty() -> Self {
                ImageState {
                    freshest_rec: None,
                    boundary_lsn: ::builtin::spec_literal_integer("0"),
                    first: ::builtin::spec_literal_integer("0"),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn dom(self, dv: DiskView) -> Set<Address> {
                if self.to_tj(dv).decodable() {
                        self.to_tj(dv).build_lsn_addr_index().values()
                    } else { Set::empty() }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self, dv: DiskView) -> bool {
                ::builtin::imply(::builtin::is_variant(self.freshest_rec,
                        "Some"), self.dom(dv).contains(self.freshest_rec.unwrap()))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid_image(self, dv: DiskView) -> bool {
                (dv.to_JournalDiskView(self.boundary_lsn).wf()) &&
                    (AllocationJournal::State::pointer_is_upstream(dv.to_JournalDiskView(self.boundary_lsn),
                            self.freshest_rec, self.first))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn to_tj(self, dv: DiskView)
                -> LinkedJournal_v::TruncatedJournal {
                LinkedJournal_v::TruncatedJournal {
                    freshest_rec: self.freshest_rec,
                    disk_view: dv.to_JournalDiskView(self.boundary_lsn),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn seq_start(self) -> LSN { self.boundary_lsn }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn seq_end(self, dv: DiskView) -> LSN {
                ::builtin::recommends([dv.is_nondangling_pointer(self.freshest_rec)]);
                if ::builtin::is_variant(self.freshest_rec, "None") {
                        self.boundary_lsn
                    } else {
                       dv.entries.spec_index(self.freshest_rec.unwrap()).message_seq.seq_end
                   }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct EphemeralState {
            pub image: ImageState,
            pub unmarshalled_tail: MsgHistory,
            pub lsn_au_index: Map<LSN, AU>,
            pub mini_allocator: MiniAllocator,
        }
        #[verus::internal(verus_macro)]
        impl EphemeralState {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn init_by(self, image: ImageState, dv: DiskView) -> bool {
                ::builtin::recommends([image.valid_image(dv)]);
                let tj = self.image.to_tj(dv);
                (((::builtin::spec_eq(self.image, image)) &&
                                    (::builtin::spec_eq(self.unmarshalled_tail,
                                            MsgHistory::empty_history_at(tj.build_tight().seq_end()))))
                            &&
                            (::builtin::spec_eq(self.lsn_au_index,
                                    AllocationJournal::State::build_lsn_au_index(tj,
                                        self.image.first)))) &&
                    (::builtin::spec_eq(self.mini_allocator,
                            MiniAllocator::empty()))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self, dv: DiskView) -> bool {
                (self.image.to_tj(dv).wf()) && (self.unmarshalled_tail.wf())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn decodable(self, dv: DiskView) -> bool {
                ::builtin::recommends([self.wf(dv)]);
                self.image.to_tj(dv).decodable()
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn to_lj(self, dv: DiskView) -> LinkedJournal::State {
                LinkedJournal::State {
                    truncated_journal: self.image.to_tj(dv),
                    unmarshalled_tail: self.unmarshalled_tail,
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn same_except_lj(self, new_state: Self) -> bool {
                ::builtin::spec_eq(new_state,
                    EphemeralState {
                        image: ImageState {
                            first: self.image.first,
                            ..new_state.image
                        },
                        unmarshalled_tail: new_state.unmarshalled_tail,
                        ..self
                    })
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_marshalled_state(self, dv: DiskView, allocs: Set<AU>,
                deallocs: Set<AU>, cut: LSN, addr: Address, new_state: Self,
                new_dv: DiskView) -> bool {
                ((((((((self.mini_allocator.wf()) && (self.to_lj(dv).wf())) &&
                                                                    (::builtin::spec_eq(allocs, Set::<AU>::empty()))) &&
                                                            (::builtin::spec_eq(deallocs, Set::<AU>::empty()))) &&
                                                    (AllocationJournal::State::valid_next_journal_addr(self.mini_allocator,
                                                            self.image.freshest_rec, addr))) &&
                                            (LinkedJournal::State::internal_journal_marshal(self.to_lj(dv),
                                                    new_state.to_lj(new_dv), LinkedJournal::Label::Internal {},
                                                    cut, addr))) &&
                                    (::builtin::spec_eq(new_state.image.first,
                                            if ::builtin::is_variant(self.image.freshest_rec, "Some") {
                                                    self.image.first
                                                } else { addr.au }))) &&
                            (::builtin::spec_eq(new_state.lsn_au_index,
                                    AllocationJournal::State::lsn_au_index_append_record(self.lsn_au_index,
                                        self.unmarshalled_tail.discard_recent(cut), addr.au)))) &&
                    (::builtin::spec_eq(new_state.mini_allocator,
                            self.mini_allocator.allocate_and_observe(addr)))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_allocator_fill(self, dv: DiskView, allocs: Set<AU>,
                deallocs: Set<AU>, new_state: Self, new_dv: DiskView)
                -> bool {
                (((((self.mini_allocator.wf()) && (self.to_lj(dv).wf())) &&
                                            (allocs.disjoint(self.mini_allocator.allocs.dom()))) &&
                                    (::builtin::spec_eq(deallocs, Set::<AU>::empty()))) &&
                            (::builtin::spec_eq(new_state,
                                    EphemeralState {
                                        mini_allocator: self.mini_allocator.add_aus(allocs),
                                        ..self
                                    }))) && (::builtin::spec_eq(new_dv, dv))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_allocator_prune(self, dv: DiskView, allocs: Set<AU>,
                deallocs: Set<AU>, new_state: Self, new_dv: DiskView)
                -> bool {
                (((((self.mini_allocator.wf()) && (self.to_lj(dv).wf())) &&
                                            (::builtin::spec_eq(allocs, Set::<AU>::empty()))) &&
                                    (::builtin::forall(|au|
                                                #[verus::internal(auto_trigger)] (::builtin::imply(deallocs.contains(au),
                                                        self.mini_allocator.can_remove(au)))))) &&
                            (::builtin::spec_eq(new_state,
                                    EphemeralState {
                                        mini_allocator: self.mini_allocator.prune(deallocs),
                                        ..self
                                    }))) && (::builtin::spec_eq(new_dv, dv))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_no_op(self, dv: DiskView, allocs: Set<AU>,
                deallocs: Set<AU>, new_state: Self, new_dv: DiskView)
                -> bool {
                (((::builtin::spec_eq(allocs, Set::<AU>::empty())) &&
                                    (::builtin::spec_eq(deallocs, Set::<AU>::empty()))) &&
                            (::builtin::spec_eq(new_state, self))) &&
                    (::builtin::spec_eq(new_dv, dv))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_internal_op(self, dv: DiskView, allocs: Set<AU>,
                deallocs: Set<AU>, new_state: Self, new_dv: DiskView)
                -> bool {
                (((::builtin::exists(|cut, addr|
                                                ::builtin::spec_eq(self.is_marshalled_state(dv, allocs,
                                                        deallocs, cut, addr, new_state, new_dv), true))) ||
                                    (::builtin::spec_eq(self.is_allocator_fill(dv, allocs,
                                                deallocs, new_state, new_dv), true))) ||
                            (::builtin::spec_eq(self.is_allocator_prune(dv, allocs,
                                        deallocs, new_state, new_dv), true))) ||
                    (::builtin::spec_eq(self.is_no_op(dv, allocs, deallocs,
                                new_state, new_dv), true))
            }
        }
        #[verus::internal(verus_macro)]
        pub enum Ephemeral {
            Unknown,
            Known {
                v: EphemeralState,
            },
        }
        #[verus::internal(verus_macro)]
        #[cfg(verus_keep_ghost)]
        #[automatically_derived]
        impl Ephemeral {
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_Unknown(&self) -> bool {
                ::builtin::is_variant(self, "Unknown")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn is_Known(&self) -> bool {
                ::builtin::is_variant(self, "Known")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(verus_macro)]
            pub fn get_Known_v(self) -> EphemeralState {
                ::builtin::get_variant_field(self, "Known", "v")
            }
        }
        #[verus::internal(verus_macro)]
        pub struct DiskView {
            pub entries: Map<Address, JournalRecord>,
        }
        #[verus::internal(verus_macro)]
        impl DiskView {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn to_JournalDiskView(self, boundary_lsn: LSN)
                -> JournalDiskView {
                JournalDiskView {
                    boundary_lsn: boundary_lsn,
                    entries: self.entries,
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn entries_wf(self) -> bool {
                ::builtin::forall(|addr|
                        ::builtin::imply(#[verus::internal(trigger)] self.entries.contains_key(addr),
                            self.entries.spec_index(addr).wf()))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_nondangling_pointer(self, ptr: Pointer) -> bool {
                ::builtin::imply(ptr.is_Some(),
                    self.entries.contains_key(ptr.unwrap()))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn nondangling_pointers(self, boundary_lsn: LSN,
                dom: Set<Address>) -> bool {
                ::builtin::recommends([dom.subset_of(self.entries.dom())]);
                ::builtin::forall(|addr|
                        ::builtin::imply(#[verus::internal(trigger)] dom.contains(addr),
                            self.is_nondangling_pointer(self.entries.spec_index(addr).cropped_prior(boundary_lsn))))
            }
        }
        #[allow(unused_parens)]
        pub mod UnifiedCrashAwareJournal {
            use super::*;
            #[verus::internal(verus_macro)]
            pub struct State {
                pub ephemeral: Ephemeral,
                pub persistent: ImageState,
                pub inflight: Option<ImageState>,
                pub dv: DiskView,
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Step {
                load_ephemeral_from_persistent(EphemeralState),
                read_for_recovery(),
                query_end_lsn(),
                put(EphemeralState),
                internal(EphemeralState, DiskView),
                query_lsn_persistence(),
                commit_start(ImageState, DiskView),
                commit_complete(EphemeralState, DiskView),
                crash(),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Step {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_load_ephemeral_from_persistent(&self) -> bool {
                    ::builtin::is_variant(self,
                        "load_ephemeral_from_persistent")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_load_ephemeral_from_persistent_0(self)
                    -> EphemeralState {
                    ::builtin::get_variant_field(self,
                        "load_ephemeral_from_persistent", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_read_for_recovery(&self) -> bool {
                    ::builtin::is_variant(self, "read_for_recovery")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_query_end_lsn(&self) -> bool {
                    ::builtin::is_variant(self, "query_end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_put(&self) -> bool {
                    ::builtin::is_variant(self, "put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_put_0(self) -> EphemeralState {
                    ::builtin::get_variant_field(self, "put", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_internal(&self) -> bool {
                    ::builtin::is_variant(self, "internal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_0(self) -> EphemeralState {
                    ::builtin::get_variant_field(self, "internal", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_internal_1(self) -> DiskView {
                    ::builtin::get_variant_field(self, "internal", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_query_lsn_persistence(&self) -> bool {
                    ::builtin::is_variant(self, "query_lsn_persistence")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_commit_start(&self) -> bool {
                    ::builtin::is_variant(self, "commit_start")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_commit_start_0(self) -> ImageState {
                    ::builtin::get_variant_field(self, "commit_start", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_commit_start_1(self) -> DiskView {
                    ::builtin::get_variant_field(self, "commit_start", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_commit_complete(&self) -> bool {
                    ::builtin::is_variant(self, "commit_complete")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_commit_complete_0(self) -> EphemeralState {
                    ::builtin::get_variant_field(self, "commit_complete", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_commit_complete_1(self) -> DiskView {
                    ::builtin::get_variant_field(self, "commit_complete", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_crash(&self) -> bool {
                    ::builtin::is_variant(self, "crash")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Config { initialize(), dummy_to_use_type_params(State), }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Config {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_initialize(&self) -> bool {
                    ::builtin::is_variant(self, "initialize")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[verus::internal(verus_macro)]
            pub enum Label {
                LoadEphemeralFromPersistent,
                ReadForRecovery {
                    records: MsgHistory,
                },
                QueryEndLsn {
                    end_lsn: LSN,
                },
                Put {
                    records: MsgHistory,
                },
                Internal {
                    allocs: Set<AU>,
                    deallocs: Set<AU>,
                },
                QueryLsnPersistence {
                    sync_lsn: LSN,
                },
                CommitStart {
                    new_boundary_lsn: LSN,
                    max_lsn: LSN,
                },
                CommitComplete {
                    require_end: LSN,
                    discarded: Set<AU>,
                },
                Crash,
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Label {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_LoadEphemeralFromPersistent(&self) -> bool {
                    ::builtin::is_variant(self, "LoadEphemeralFromPersistent")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_ReadForRecovery(&self) -> bool {
                    ::builtin::is_variant(self, "ReadForRecovery")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_ReadForRecovery_records(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "ReadForRecovery",
                        "records")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_QueryEndLsn(&self) -> bool {
                    ::builtin::is_variant(self, "QueryEndLsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_QueryEndLsn_end_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "QueryEndLsn", "end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_Put(&self) -> bool {
                    ::builtin::is_variant(self, "Put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_Put_records(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "Put", "records")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_Internal(&self) -> bool {
                    ::builtin::is_variant(self, "Internal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_Internal_allocs(self) -> Set<AU> {
                    ::builtin::get_variant_field(self, "Internal", "allocs")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_Internal_deallocs(self) -> Set<AU> {
                    ::builtin::get_variant_field(self, "Internal", "deallocs")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_QueryLsnPersistence(&self) -> bool {
                    ::builtin::is_variant(self, "QueryLsnPersistence")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_QueryLsnPersistence_sync_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "QueryLsnPersistence",
                        "sync_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_CommitStart(&self) -> bool {
                    ::builtin::is_variant(self, "CommitStart")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_CommitStart_new_boundary_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "CommitStart",
                        "new_boundary_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_CommitStart_max_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "CommitStart", "max_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_CommitComplete(&self) -> bool {
                    ::builtin::is_variant(self, "CommitComplete")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_CommitComplete_require_end(self) -> LSN {
                    ::builtin::get_variant_field(self, "CommitComplete",
                        "require_end")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn get_CommitComplete_discarded(self) -> Set<AU> {
                    ::builtin::get_variant_field(self, "CommitComplete",
                        "discarded")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                pub fn is_Crash(&self) -> bool {
                    ::builtin::is_variant(self, "Crash")
                }
            }
            pub mod show {
                use super::*;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn load_ephemeral_from_persistent(pre: super::State,
                    post: super::State, lbl: Label,
                    new_ephemeral: EphemeralState) {
                    ::builtin::requires(super::State::load_ephemeral_from_persistent(pre,
                            post, lbl, new_ephemeral));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as load_ephemeral_from_persistent;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn read_for_recovery(pre: super::State,
                    post: super::State, lbl: Label) {
                    ::builtin::requires(super::State::read_for_recovery(pre,
                            post, lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as read_for_recovery;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn query_end_lsn(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::query_end_lsn(pre, post,
                            lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as query_end_lsn;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn put(pre: super::State, post: super::State, lbl: Label,
                    new_ephemeral: EphemeralState) {
                    ::builtin::requires(super::State::put(pre, post, lbl,
                            new_ephemeral));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as put;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn internal(pre: super::State, post: super::State,
                    lbl: Label, new_ephemeral: EphemeralState,
                    new_dv: DiskView) {
                    ::builtin::requires(super::State::internal(pre, post, lbl,
                            new_ephemeral, new_dv));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as internal;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn query_lsn_persistence(pre: super::State,
                    post: super::State, lbl: Label) {
                    ::builtin::requires(super::State::query_lsn_persistence(pre,
                            post, lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as query_lsn_persistence;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn commit_start(pre: super::State, post: super::State,
                    lbl: Label, frozen_journal: ImageState,
                    frozen_dv: DiskView) {
                    ::builtin::requires(super::State::commit_start(pre, post,
                            lbl, frozen_journal, frozen_dv));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as commit_start;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn commit_complete(pre: super::State, post: super::State,
                    lbl: Label, new_ephemeral: EphemeralState,
                    new_dv: DiskView) {
                    ::builtin::requires(super::State::commit_complete(pre, post,
                            lbl, new_ephemeral, new_dv));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as commit_complete;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn crash(pre: super::State, post: super::State,
                    lbl: Label) {
                    ::builtin::requires(super::State::crash(pre, post, lbl));
                    ::builtin::ensures(super::State::next(pre, post, lbl));
                }
                use bool as crash;
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::external_body]
                #[verifier::proof]
                pub fn initialize(post: super::State) {
                    ::builtin::requires(super::State::initialize(post));
                    ::builtin::ensures(super::State::init(post));
                }
                use bool as initialize;
            }
            pub mod take_step {
                use super::*;
            }
            #[verus::internal(verus_macro)]
            impl State {
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn initialize(post: Self) -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: ImageState = ImageState::empty();
                        let update_tmp_ephemeral: Ephemeral = Ephemeral::Unknown;
                        let update_tmp_inflight: Option<ImageState> = Option::None;
                        let update_tmp_dv: DiskView =
                            DiskView { entries: Map::empty() };
                        (#[verifier::custom_err("cannot prove that final value of field `dv` has this updated value")] (::builtin::equal(post.dv,
                                        update_tmp_dv)) &&
                                (#[verifier::custom_err("cannot prove that final value of field `inflight` has this updated value")] (::builtin::equal(post.inflight,
                                                update_tmp_inflight)) &&
                                        (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                        update_tmp_ephemeral)) &&
                                                #[verifier::custom_err("cannot prove that final value of field `persistent` has this updated value")] (::builtin::equal(post.persistent,
                                                        update_tmp_persistent)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn initialize_enabled() -> ::core::primitive::bool {
                    { true }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn load_ephemeral_from_persistent(pre: Self, post: Self,
                    lbl: Label, new_ephemeral: EphemeralState)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: ImageState = pre.persistent;
                        let update_tmp_inflight: Option<ImageState> = pre.inflight;
                        let update_tmp_dv: DiskView = pre.dv;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "LoadEphemeralFromPersistent")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Unknown")) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.persistent.valid_image(pre.dv))
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (new_ephemeral.init_by(pre.persistent,
                                                                pre.dv)) &&
                                                        {
                                                            let update_tmp_ephemeral: Ephemeral =
                                                                Ephemeral::Known { v: new_ephemeral };
                                                            (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                            update_tmp_ephemeral)) &&
                                                                    (#[verifier::custom_err("cannot prove that the field `dv` is preserved")] (::builtin::equal(post.dv,
                                                                                    update_tmp_dv)) &&
                                                                            (#[verifier::custom_err("cannot prove that the field `inflight` is preserved")] (::builtin::equal(post.inflight,
                                                                                            update_tmp_inflight)) &&
                                                                                    #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                                            update_tmp_persistent)))))
                                                        }))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn load_ephemeral_from_persistent_strong(pre: Self,
                    post: Self, lbl: Label, new_ephemeral: EphemeralState)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: ImageState = pre.persistent;
                        let update_tmp_inflight: Option<ImageState> = pre.inflight;
                        let update_tmp_dv: DiskView = pre.dv;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "LoadEphemeralFromPersistent")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Unknown")) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.persistent.valid_image(pre.dv))
                                                &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (new_ephemeral.init_by(pre.persistent,
                                                                pre.dv)) &&
                                                        {
                                                            let update_tmp_ephemeral: Ephemeral =
                                                                Ephemeral::Known { v: new_ephemeral };
                                                            (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                            update_tmp_ephemeral)) &&
                                                                    (#[verifier::custom_err("cannot prove that the field `dv` is preserved")] (::builtin::equal(post.dv,
                                                                                    update_tmp_dv)) &&
                                                                            (#[verifier::custom_err("cannot prove that the field `inflight` is preserved")] (::builtin::equal(post.inflight,
                                                                                            update_tmp_inflight)) &&
                                                                                    #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                                            update_tmp_persistent)))))
                                                        }))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn load_ephemeral_from_persistent_enabled(pre: Self,
                    lbl: Label, new_ephemeral: EphemeralState)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "LoadEphemeralFromPersistent")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Unknown")) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.persistent.valid_image(pre.dv))
                                                &&
                                                #[verifier::custom_err("cannot prove this condition holds")] (new_ephemeral.init_by(pre.persistent,
                                                        pre.dv)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn read_for_recovery(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        let update_tmp_persistent: ImageState = pre.persistent;
                        let update_tmp_inflight: Option<ImageState> = pre.inflight;
                        let update_tmp_dv: DiskView = pre.dv;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "ReadForRecovery")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Known")) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal::State::next(pre.ephemeral.get_Known_v().to_lj(pre.dv),
                                                        pre.ephemeral.get_Known_v().to_lj(pre.dv),
                                                        LinkedJournal::Label::ReadForRecovery {
                                                            messages: lbl.get_ReadForRecovery_records(),
                                                        })) &&
                                                (#[verifier::custom_err("cannot prove that the field `dv` is preserved")] (::builtin::equal(post.dv,
                                                                update_tmp_dv)) &&
                                                        (#[verifier::custom_err("cannot prove that the field `inflight` is preserved")] (::builtin::equal(post.inflight,
                                                                        update_tmp_inflight)) &&
                                                                (#[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                                update_tmp_persistent)) &&
                                                                        #[verifier::custom_err("cannot prove that the field `ephemeral` is preserved")] (::builtin::equal(post.ephemeral,
                                                                                update_tmp_ephemeral))))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn read_for_recovery_strong(pre: Self, post: Self,
                    lbl: Label) -> ::core::primitive::bool {
                    {
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        let update_tmp_persistent: ImageState = pre.persistent;
                        let update_tmp_inflight: Option<ImageState> = pre.inflight;
                        let update_tmp_dv: DiskView = pre.dv;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "ReadForRecovery")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Known")) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal::State::next(pre.ephemeral.get_Known_v().to_lj(pre.dv),
                                                        pre.ephemeral.get_Known_v().to_lj(pre.dv),
                                                        LinkedJournal::Label::ReadForRecovery {
                                                            messages: lbl.get_ReadForRecovery_records(),
                                                        })) &&
                                                (#[verifier::custom_err("cannot prove that the field `dv` is preserved")] (::builtin::equal(post.dv,
                                                                update_tmp_dv)) &&
                                                        (#[verifier::custom_err("cannot prove that the field `inflight` is preserved")] (::builtin::equal(post.inflight,
                                                                        update_tmp_inflight)) &&
                                                                (#[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                                update_tmp_persistent)) &&
                                                                        #[verifier::custom_err("cannot prove that the field `ephemeral` is preserved")] (::builtin::equal(post.ephemeral,
                                                                                update_tmp_ephemeral))))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn read_for_recovery_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "ReadForRecovery")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Known")) &&
                                        #[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal::State::next(pre.ephemeral.get_Known_v().to_lj(pre.dv),
                                                pre.ephemeral.get_Known_v().to_lj(pre.dv),
                                                LinkedJournal::Label::ReadForRecovery {
                                                    messages: lbl.get_ReadForRecovery_records(),
                                                }))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_end_lsn(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        let update_tmp_persistent: ImageState = pre.persistent;
                        let update_tmp_inflight: Option<ImageState> = pre.inflight;
                        let update_tmp_dv: DiskView = pre.dv;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "QueryEndLsn")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Known")) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal::State::next(pre.ephemeral.get_Known_v().to_lj(pre.dv),
                                                        pre.ephemeral.get_Known_v().to_lj(pre.dv),
                                                        LinkedJournal::Label::QueryEndLsn {
                                                            end_lsn: lbl.get_QueryEndLsn_end_lsn(),
                                                        })) &&
                                                (#[verifier::custom_err("cannot prove that the field `dv` is preserved")] (::builtin::equal(post.dv,
                                                                update_tmp_dv)) &&
                                                        (#[verifier::custom_err("cannot prove that the field `inflight` is preserved")] (::builtin::equal(post.inflight,
                                                                        update_tmp_inflight)) &&
                                                                (#[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                                update_tmp_persistent)) &&
                                                                        #[verifier::custom_err("cannot prove that the field `ephemeral` is preserved")] (::builtin::equal(post.ephemeral,
                                                                                update_tmp_ephemeral))))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_end_lsn_strong(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        let update_tmp_persistent: ImageState = pre.persistent;
                        let update_tmp_inflight: Option<ImageState> = pre.inflight;
                        let update_tmp_dv: DiskView = pre.dv;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "QueryEndLsn")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Known")) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal::State::next(pre.ephemeral.get_Known_v().to_lj(pre.dv),
                                                        pre.ephemeral.get_Known_v().to_lj(pre.dv),
                                                        LinkedJournal::Label::QueryEndLsn {
                                                            end_lsn: lbl.get_QueryEndLsn_end_lsn(),
                                                        })) &&
                                                (#[verifier::custom_err("cannot prove that the field `dv` is preserved")] (::builtin::equal(post.dv,
                                                                update_tmp_dv)) &&
                                                        (#[verifier::custom_err("cannot prove that the field `inflight` is preserved")] (::builtin::equal(post.inflight,
                                                                        update_tmp_inflight)) &&
                                                                (#[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                                update_tmp_persistent)) &&
                                                                        #[verifier::custom_err("cannot prove that the field `ephemeral` is preserved")] (::builtin::equal(post.ephemeral,
                                                                                update_tmp_ephemeral))))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_end_lsn_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "QueryEndLsn")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Known")) &&
                                        #[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal::State::next(pre.ephemeral.get_Known_v().to_lj(pre.dv),
                                                pre.ephemeral.get_Known_v().to_lj(pre.dv),
                                                LinkedJournal::Label::QueryEndLsn {
                                                    end_lsn: lbl.get_QueryEndLsn_end_lsn(),
                                                }))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put(pre: Self, post: Self, lbl: Label,
                    new_ephemeral: EphemeralState) -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: ImageState = pre.persistent;
                        let update_tmp_inflight: Option<ImageState> = pre.inflight;
                        let update_tmp_dv: DiskView = pre.dv;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "Put")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Known")) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal::State::next(pre.ephemeral.get_Known_v().to_lj(pre.dv),
                                                        new_ephemeral.to_lj(pre.dv),
                                                        LinkedJournal::Label::Put {
                                                            messages: lbl.get_Put_records(),
                                                        })) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.get_Known_v().same_except_lj(new_ephemeral))
                                                        &&
                                                        {
                                                            let update_tmp_ephemeral: Ephemeral =
                                                                Ephemeral::Known { v: new_ephemeral };
                                                            (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                            update_tmp_ephemeral)) &&
                                                                    (#[verifier::custom_err("cannot prove that the field `dv` is preserved")] (::builtin::equal(post.dv,
                                                                                    update_tmp_dv)) &&
                                                                            (#[verifier::custom_err("cannot prove that the field `inflight` is preserved")] (::builtin::equal(post.inflight,
                                                                                            update_tmp_inflight)) &&
                                                                                    #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                                            update_tmp_persistent)))))
                                                        }))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put_strong(pre: Self, post: Self, lbl: Label,
                    new_ephemeral: EphemeralState) -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: ImageState = pre.persistent;
                        let update_tmp_inflight: Option<ImageState> = pre.inflight;
                        let update_tmp_dv: DiskView = pre.dv;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "Put")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Known")) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal::State::next(pre.ephemeral.get_Known_v().to_lj(pre.dv),
                                                        new_ephemeral.to_lj(pre.dv),
                                                        LinkedJournal::Label::Put {
                                                            messages: lbl.get_Put_records(),
                                                        })) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.get_Known_v().same_except_lj(new_ephemeral))
                                                        &&
                                                        {
                                                            let update_tmp_ephemeral: Ephemeral =
                                                                Ephemeral::Known { v: new_ephemeral };
                                                            (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                            update_tmp_ephemeral)) &&
                                                                    (#[verifier::custom_err("cannot prove that the field `dv` is preserved")] (::builtin::equal(post.dv,
                                                                                    update_tmp_dv)) &&
                                                                            (#[verifier::custom_err("cannot prove that the field `inflight` is preserved")] (::builtin::equal(post.inflight,
                                                                                            update_tmp_inflight)) &&
                                                                                    #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                                            update_tmp_persistent)))))
                                                        }))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn put_enabled(pre: Self, lbl: Label,
                    new_ephemeral: EphemeralState) -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "Put")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Known")) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal::State::next(pre.ephemeral.get_Known_v().to_lj(pre.dv),
                                                        new_ephemeral.to_lj(pre.dv),
                                                        LinkedJournal::Label::Put {
                                                            messages: lbl.get_Put_records(),
                                                        })) &&
                                                #[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.get_Known_v().same_except_lj(new_ephemeral)))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal(pre: Self, post: Self, lbl: Label,
                    new_ephemeral: EphemeralState, new_dv: DiskView)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: ImageState = pre.persistent;
                        let update_tmp_inflight: Option<ImageState> = pre.inflight;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "Internal")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Known")) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.get_Known_v().is_internal_op(pre.dv,
                                                        lbl.get_Internal_allocs(), lbl.get_Internal_deallocs(),
                                                        new_ephemeral, new_dv)) &&
                                                {
                                                    let update_tmp_ephemeral: Ephemeral =
                                                        Ephemeral::Known { v: new_ephemeral };
                                                    let update_tmp_dv: DiskView = new_dv;
                                                    (#[verifier::custom_err("cannot prove that final value of field `dv` has this updated value")] (::builtin::equal(post.dv,
                                                                    update_tmp_dv)) &&
                                                            (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                            update_tmp_ephemeral)) &&
                                                                    (#[verifier::custom_err("cannot prove that the field `inflight` is preserved")] (::builtin::equal(post.inflight,
                                                                                    update_tmp_inflight)) &&
                                                                            #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                                    update_tmp_persistent)))))
                                                })))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_strong(pre: Self, post: Self, lbl: Label,
                    new_ephemeral: EphemeralState, new_dv: DiskView)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: ImageState = pre.persistent;
                        let update_tmp_inflight: Option<ImageState> = pre.inflight;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "Internal")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Known")) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.get_Known_v().is_internal_op(pre.dv,
                                                        lbl.get_Internal_allocs(), lbl.get_Internal_deallocs(),
                                                        new_ephemeral, new_dv)) &&
                                                {
                                                    let update_tmp_ephemeral: Ephemeral =
                                                        Ephemeral::Known { v: new_ephemeral };
                                                    let update_tmp_dv: DiskView = new_dv;
                                                    (#[verifier::custom_err("cannot prove that final value of field `dv` has this updated value")] (::builtin::equal(post.dv,
                                                                    update_tmp_dv)) &&
                                                            (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                            update_tmp_ephemeral)) &&
                                                                    (#[verifier::custom_err("cannot prove that the field `inflight` is preserved")] (::builtin::equal(post.inflight,
                                                                                    update_tmp_inflight)) &&
                                                                            #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                                    update_tmp_persistent)))))
                                                })))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn internal_enabled(pre: Self, lbl: Label,
                    new_ephemeral: EphemeralState, new_dv: DiskView)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "Internal")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Known")) &&
                                        #[verifier::custom_err("cannot prove this condition holds")] (pre.ephemeral.get_Known_v().is_internal_op(pre.dv,
                                                lbl.get_Internal_allocs(), lbl.get_Internal_deallocs(),
                                                new_ephemeral, new_dv))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_lsn_persistence(pre: Self, post: Self,
                    lbl: Label) -> ::core::primitive::bool {
                    {
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        let update_tmp_persistent: ImageState = pre.persistent;
                        let update_tmp_inflight: Option<ImageState> = pre.inflight;
                        let update_tmp_dv: DiskView = pre.dv;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "QueryLsnPersistence")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] ((lbl.get_QueryLsnPersistence_sync_lsn()).spec_le(pre.persistent.seq_end(pre.dv)))
                                        &&
                                        (#[verifier::custom_err("cannot prove that the field `dv` is preserved")] (::builtin::equal(post.dv,
                                                        update_tmp_dv)) &&
                                                (#[verifier::custom_err("cannot prove that the field `inflight` is preserved")] (::builtin::equal(post.inflight,
                                                                update_tmp_inflight)) &&
                                                        (#[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                        update_tmp_persistent)) &&
                                                                #[verifier::custom_err("cannot prove that the field `ephemeral` is preserved")] (::builtin::equal(post.ephemeral,
                                                                        update_tmp_ephemeral)))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_lsn_persistence_strong(pre: Self, post: Self,
                    lbl: Label) -> ::core::primitive::bool {
                    {
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        let update_tmp_persistent: ImageState = pre.persistent;
                        let update_tmp_inflight: Option<ImageState> = pre.inflight;
                        let update_tmp_dv: DiskView = pre.dv;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "QueryLsnPersistence")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] ((lbl.get_QueryLsnPersistence_sync_lsn()).spec_le(pre.persistent.seq_end(pre.dv)))
                                        &&
                                        (#[verifier::custom_err("cannot prove that the field `dv` is preserved")] (::builtin::equal(post.dv,
                                                        update_tmp_dv)) &&
                                                (#[verifier::custom_err("cannot prove that the field `inflight` is preserved")] (::builtin::equal(post.inflight,
                                                                update_tmp_inflight)) &&
                                                        (#[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                        update_tmp_persistent)) &&
                                                                #[verifier::custom_err("cannot prove that the field `ephemeral` is preserved")] (::builtin::equal(post.ephemeral,
                                                                        update_tmp_ephemeral)))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn query_lsn_persistence_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "QueryLsnPersistence")) &&
                                #[verifier::custom_err("cannot prove this condition holds")] ((lbl.get_QueryLsnPersistence_sync_lsn()).spec_le(pre.persistent.seq_end(pre.dv))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn commit_start(pre: Self, post: Self, lbl: Label,
                    frozen_journal: ImageState, frozen_dv: DiskView)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        let update_tmp_persistent: ImageState = pre.persistent;
                        let update_tmp_dv: DiskView = pre.dv;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "CommitStart")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Known")) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.inflight,
                                                        "None")) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] ((pre.persistent.seq_end(pre.dv)).spec_le(frozen_journal.seq_end(pre.dv)))
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] ((frozen_journal.seq_start()).spec_le(lbl.get_CommitStart_max_lsn()))
                                                                &&
                                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(frozen_journal.seq_start(),
                                                                                lbl.get_CommitStart_new_boundary_lsn())) &&
                                                                        (({
                                                                                        let v = pre.ephemeral.get_Known_v();
                                                                                        let frozen_tj = frozen_journal.to_tj(frozen_dv);
                                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal::State::next(pre.ephemeral.get_Known_v().to_lj(pre.dv),
                                                                                                        pre.ephemeral.get_Known_v().to_lj(pre.dv),
                                                                                                        LinkedJournal::Label::FreezeForCommit {
                                                                                                            frozen_journal: frozen_tj,
                                                                                                        })) &&
                                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(frozen_journal.first,
                                                                                                                AllocationJournal::State::new_first(frozen_tj,
                                                                                                                    v.lsn_au_index, v.image.first, frozen_tj.seq_start()))) &&
                                                                                                        {
                                                                                                            let update_tmp_inflight: Option<ImageState> =
                                                                                                                Option::Some(frozen_journal);

                                                                                                            #[verifier::custom_err("cannot prove that final value of field `inflight` has this updated value")]
                                                                                                            (::builtin::equal(post.inflight, update_tmp_inflight))
                                                                                                        }))
                                                                                    }) &&
                                                                                ((#[verifier::custom_err("cannot prove that the field `dv` is preserved")] (::builtin::equal(post.dv,
                                                                                                    update_tmp_dv)) &&
                                                                                            (#[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                                                            update_tmp_persistent)) &&
                                                                                                    #[verifier::custom_err("cannot prove that the field `ephemeral` is preserved")] (::builtin::equal(post.ephemeral,
                                                                                                            update_tmp_ephemeral))))))))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn commit_start_strong(pre: Self, post: Self, lbl: Label,
                    frozen_journal: ImageState, frozen_dv: DiskView)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_ephemeral: Ephemeral = pre.ephemeral;
                        let update_tmp_persistent: ImageState = pre.persistent;
                        let update_tmp_dv: DiskView = pre.dv;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "CommitStart")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Known")) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.inflight,
                                                        "None")) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] ((pre.persistent.seq_end(pre.dv)).spec_le(frozen_journal.seq_end(pre.dv)))
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] ((frozen_journal.seq_start()).spec_le(lbl.get_CommitStart_max_lsn()))
                                                                &&
                                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(frozen_journal.seq_start(),
                                                                                lbl.get_CommitStart_new_boundary_lsn())) &&
                                                                        (({
                                                                                        let v = pre.ephemeral.get_Known_v();
                                                                                        let frozen_tj = frozen_journal.to_tj(frozen_dv);
                                                                                        (#[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal::State::next(pre.ephemeral.get_Known_v().to_lj(pre.dv),
                                                                                                        pre.ephemeral.get_Known_v().to_lj(pre.dv),
                                                                                                        LinkedJournal::Label::FreezeForCommit {
                                                                                                            frozen_journal: frozen_tj,
                                                                                                        })) &&
                                                                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(frozen_journal.first,
                                                                                                                AllocationJournal::State::new_first(frozen_tj,
                                                                                                                    v.lsn_au_index, v.image.first, frozen_tj.seq_start()))) &&
                                                                                                        {
                                                                                                            let update_tmp_inflight: Option<ImageState> =
                                                                                                                Option::Some(frozen_journal);

                                                                                                            #[verifier::custom_err("cannot prove that final value of field `inflight` has this updated value")]
                                                                                                            (::builtin::equal(post.inflight, update_tmp_inflight))
                                                                                                        }))
                                                                                    }) &&
                                                                                ((#[verifier::custom_err("cannot prove that the field `dv` is preserved")] (::builtin::equal(post.dv,
                                                                                                    update_tmp_dv)) &&
                                                                                            (#[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                                                            update_tmp_persistent)) &&
                                                                                                    #[verifier::custom_err("cannot prove that the field `ephemeral` is preserved")] (::builtin::equal(post.ephemeral,
                                                                                                            update_tmp_ephemeral))))))))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn commit_start_enabled(pre: Self, lbl: Label,
                    frozen_journal: ImageState, frozen_dv: DiskView)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "CommitStart")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Known")) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.inflight,
                                                        "None")) &&
                                                (#[verifier::custom_err("cannot prove this condition holds")] ((pre.persistent.seq_end(pre.dv)).spec_le(frozen_journal.seq_end(pre.dv)))
                                                        &&
                                                        (#[verifier::custom_err("cannot prove this condition holds")] ((frozen_journal.seq_start()).spec_le(lbl.get_CommitStart_max_lsn()))
                                                                &&
                                                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(frozen_journal.seq_start(),
                                                                                lbl.get_CommitStart_new_boundary_lsn())) &&
                                                                        {
                                                                            let v = pre.ephemeral.get_Known_v();
                                                                            let frozen_tj = frozen_journal.to_tj(frozen_dv);
                                                                            (#[verifier::custom_err("cannot prove this condition holds")] (LinkedJournal::State::next(pre.ephemeral.get_Known_v().to_lj(pre.dv),
                                                                                            pre.ephemeral.get_Known_v().to_lj(pre.dv),
                                                                                            LinkedJournal::Label::FreezeForCommit {
                                                                                                frozen_journal: frozen_tj,
                                                                                            })) &&
                                                                                    #[verifier::custom_err("cannot prove this condition holds")] (::builtin::spec_eq(frozen_journal.first,
                                                                                            AllocationJournal::State::new_first(frozen_tj,
                                                                                                v.lsn_au_index, v.image.first, frozen_tj.seq_start()))))
                                                                        }))))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn commit_complete(pre: Self, post: Self, lbl: Label,
                    new_ephemeral: EphemeralState, new_dv: DiskView)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "CommitComplete")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Known")) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.inflight,
                                                        "Some")) &&
                                                {
                                                    let update_tmp_persistent: ImageState =
                                                        pre.inflight.get_Some_0();
                                                    let update_tmp_ephemeral: Ephemeral =
                                                        Ephemeral::Known { v: new_ephemeral };
                                                    let update_tmp_inflight: Option<ImageState> = Option::None;
                                                    let update_tmp_dv: DiskView = new_dv;
                                                    (#[verifier::custom_err("cannot prove that final value of field `dv` has this updated value")] (::builtin::equal(post.dv,
                                                                    update_tmp_dv)) &&
                                                            (#[verifier::custom_err("cannot prove that final value of field `inflight` has this updated value")] (::builtin::equal(post.inflight,
                                                                            update_tmp_inflight)) &&
                                                                    (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                                    update_tmp_ephemeral)) &&
                                                                            #[verifier::custom_err("cannot prove that final value of field `persistent` has this updated value")] (::builtin::equal(post.persistent,
                                                                                    update_tmp_persistent)))))
                                                })))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn commit_complete_strong(pre: Self, post: Self,
                    lbl: Label, new_ephemeral: EphemeralState, new_dv: DiskView)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "CommitComplete")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Known")) &&
                                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.inflight,
                                                        "Some")) &&
                                                {
                                                    let update_tmp_persistent: ImageState =
                                                        pre.inflight.get_Some_0();
                                                    let update_tmp_ephemeral: Ephemeral =
                                                        Ephemeral::Known { v: new_ephemeral };
                                                    let update_tmp_inflight: Option<ImageState> = Option::None;
                                                    let update_tmp_dv: DiskView = new_dv;
                                                    (#[verifier::custom_err("cannot prove that final value of field `dv` has this updated value")] (::builtin::equal(post.dv,
                                                                    update_tmp_dv)) &&
                                                            (#[verifier::custom_err("cannot prove that final value of field `inflight` has this updated value")] (::builtin::equal(post.inflight,
                                                                            update_tmp_inflight)) &&
                                                                    (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                                                    update_tmp_ephemeral)) &&
                                                                            #[verifier::custom_err("cannot prove that final value of field `persistent` has this updated value")] (::builtin::equal(post.persistent,
                                                                                    update_tmp_persistent)))))
                                                })))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn commit_complete_enabled(pre: Self, lbl: Label,
                    new_ephemeral: EphemeralState, new_dv: DiskView)
                    -> ::core::primitive::bool {
                    {
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "CommitComplete")) &&
                                (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.ephemeral,
                                                "Known")) &&
                                        #[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(pre.inflight,
                                                "Some"))))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn crash(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: ImageState = pre.persistent;
                        let update_tmp_dv: DiskView = pre.dv;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "Crash")) &&
                                {
                                    let update_tmp_ephemeral: Ephemeral = Ephemeral::Unknown;
                                    let update_tmp_inflight: Option<ImageState> = Option::None;
                                    (#[verifier::custom_err("cannot prove that final value of field `inflight` has this updated value")] (::builtin::equal(post.inflight,
                                                    update_tmp_inflight)) &&
                                            (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                            update_tmp_ephemeral)) &&
                                                    (#[verifier::custom_err("cannot prove that the field `dv` is preserved")] (::builtin::equal(post.dv,
                                                                    update_tmp_dv)) &&
                                                            #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                    update_tmp_persistent)))))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn crash_strong(pre: Self, post: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {
                        let update_tmp_persistent: ImageState = pre.persistent;
                        let update_tmp_dv: DiskView = pre.dv;
                        (#[verifier::custom_err("cannot prove this condition holds")] (::builtin::is_variant(lbl,
                                        "Crash")) &&
                                {
                                    let update_tmp_ephemeral: Ephemeral = Ephemeral::Unknown;
                                    let update_tmp_inflight: Option<ImageState> = Option::None;
                                    (#[verifier::custom_err("cannot prove that final value of field `inflight` has this updated value")] (::builtin::equal(post.inflight,
                                                    update_tmp_inflight)) &&
                                            (#[verifier::custom_err("cannot prove that final value of field `ephemeral` has this updated value")] (::builtin::equal(post.ephemeral,
                                                            update_tmp_ephemeral)) &&
                                                    (#[verifier::custom_err("cannot prove that the field `dv` is preserved")] (::builtin::equal(post.dv,
                                                                    update_tmp_dv)) &&
                                                            #[verifier::custom_err("cannot prove that the field `persistent` is preserved")] (::builtin::equal(post.persistent,
                                                                    update_tmp_persistent)))))
                                })
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                #[verus::internal(open)]
                pub fn crash_enabled(pre: Self, lbl: Label)
                    -> ::core::primitive::bool {
                    {

                        #[verifier::custom_err("cannot prove this condition holds")]
                        (::builtin::is_variant(lbl, "Crash"))
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_by(pre: State, post: State, label: Label,
                    step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::load_ephemeral_from_persistent(new_ephemeral) =>
                            Self::load_ephemeral_from_persistent(pre, post, label,
                                new_ephemeral),
                        Step::read_for_recovery() =>
                            Self::read_for_recovery(pre, post, label),
                        Step::query_end_lsn() =>
                            Self::query_end_lsn(pre, post, label),
                        Step::put(new_ephemeral) =>
                            Self::put(pre, post, label, new_ephemeral),
                        Step::internal(new_ephemeral, new_dv) =>
                            Self::internal(pre, post, label, new_ephemeral, new_dv),
                        Step::query_lsn_persistence() =>
                            Self::query_lsn_persistence(pre, post, label),
                        Step::commit_start(frozen_journal, frozen_dv) =>
                            Self::commit_start(pre, post, label, frozen_journal,
                                frozen_dv),
                        Step::commit_complete(new_ephemeral, new_dv) =>
                            Self::commit_complete(pre, post, label, new_ephemeral,
                                new_dv),
                        Step::crash() => Self::crash(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next(pre: State, post: State, label: Label)
                    -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                            Self::next_by(pre, post, label, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_strong_by(pre: State, post: State, label: Label,
                    step: Step) -> ::core::primitive::bool {
                    match step {
                        Step::load_ephemeral_from_persistent(new_ephemeral) =>
                            Self::load_ephemeral_from_persistent_strong(pre, post,
                                label, new_ephemeral),
                        Step::read_for_recovery() =>
                            Self::read_for_recovery_strong(pre, post, label),
                        Step::query_end_lsn() =>
                            Self::query_end_lsn_strong(pre, post, label),
                        Step::put(new_ephemeral) =>
                            Self::put_strong(pre, post, label, new_ephemeral),
                        Step::internal(new_ephemeral, new_dv) =>
                            Self::internal_strong(pre, post, label, new_ephemeral,
                                new_dv),
                        Step::query_lsn_persistence() =>
                            Self::query_lsn_persistence_strong(pre, post, label),
                        Step::commit_start(frozen_journal, frozen_dv) =>
                            Self::commit_start_strong(pre, post, label, frozen_journal,
                                frozen_dv),
                        Step::commit_complete(new_ephemeral, new_dv) =>
                            Self::commit_complete_strong(pre, post, label,
                                new_ephemeral, new_dv),
                        Step::crash() => Self::crash_strong(pre, post, label),
                        Step::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn next_strong(pre: State, post: State, label: Label)
                    -> ::core::primitive::bool {
                    ::builtin::exists(|step: Step|
                            Self::next_strong_by(pre, post, label, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn init_by(post: State, step: Config)
                    -> ::core::primitive::bool {
                    match step {
                        Config::initialize() => Self::initialize(post),
                        Config::dummy_to_use_type_params(_) => false,
                    }
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::opaque]
                #[verus::internal(open)]
                #[verus::internal(verus_macro)]
                #[verifier::spec]
                pub fn init(post: State) -> ::core::primitive::bool {
                    ::builtin::exists(|step: Config| Self::init_by(post, step))
                }
                #[cfg(verus_keep_ghost_body)]
                #[verifier::spec]
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                pub fn invariant(&self) -> ::core::primitive::bool { true }
            }
        }
    }
}
mod marshalling {
    pub mod Slice_v {
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        #[verus::internal(verus_macro)]
        pub struct Slice {
            pub start: u64,
            pub end: u64,
        }
        #[verus::internal(verus_macro)]
        impl Slice {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn valid<T>(&self, data: Seq<T>) -> bool {
                ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                (::builtin::spec_cast_integer::<_, int>(self.start))),
                            (::builtin::spec_cast_integer::<_, int>(self.end))),
                        data.len()))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn i<T>(&self, data: Seq<T>) -> Seq<T> {
                ::builtin::recommends([self.valid(data)]);
                data.subrange(::builtin::spec_cast_integer::<_,
                            int>(self.start),
                    ::builtin::spec_cast_integer::<_, int>(self.end))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn all<T>(data: Seq<T>) -> Slice {
                Slice {
                    start: ::builtin::spec_literal_integer("0"),
                    end: ::builtin::spec_cast_integer::<_, u64>(data.len()),
                }
            }
        }
    }
    pub mod MarshalledAccessors_v {
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use vstd::bytes::*;
        use vstd::slice::*;
        use crate::marshalling::Slice_v::*;
        #[verus::internal(verus_macro)]
        trait Config {
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn valid(&self)
            -> bool;
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__valid(&self) -> bool {
                ::builtin::no_method_body()
            }
        }
        #[verus::internal(verus_macro)]
        trait Marshalling<C: Config, U> {
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn parsable(cfg: &C, data: Seq<u8>)
            -> bool;
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn parse(cfg: &C, data: Seq<u8>)
            -> U;
            #[verus::internal(verus_macro)]
            fn try_parse(cfg: &C, data: &Vec<u8>)
            -> Option<U>;
            #[verus::internal(verus_macro)]
            fn exec_parsable(cfg: &C, data: &Vec<u8>)
            -> bool;
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn marshallable(cfg: &C, value: &U)
            -> bool;
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn size(cfg: &C, value: &U)
            -> u64;
            #[verus::internal(verus_macro)]
            fn exec_size(cfg: &C, value: &U)
            -> u64;
            #[verus::internal(verus_macro)]
            fn marshall(cfg: &C, value: &U, data: &mut Vec<u8>, start: u64)
            -> u64;
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__parsable(cfg: &C, data: Seq<u8>) -> bool {
                ::builtin::recommends([cfg.valid()]);
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__parse(cfg: &C, data: Seq<u8>) -> U {
                ::builtin::recommends([cfg.valid(),
                            Self::parsable(cfg, data)]);
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            fn VERUS_SPEC__try_parse(cfg: &C, data: &Vec<u8>) -> Option<U> {
                ::builtin::requires([cfg.valid()]);
                ::builtin::ensures(|ov: Option<U>|
                        [::builtin::spec_eq((Self::parsable(cfg, (data.view()))),
                                    (::builtin::is_variant(ov, "Some"))),
                                ::builtin::imply(Self::parsable(cfg, (data.view())),
                                    ::builtin::spec_eq(ov.unwrap(),
                                        Self::parse(cfg, (data.view()))))]);
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            fn VERUS_SPEC__exec_parsable(cfg: &C, data: &Vec<u8>) -> bool {
                ::builtin::requires([cfg.valid()]);
                ::builtin::ensures(|p: bool|
                        [::builtin::spec_eq(p,
                                    Self::parsable(cfg, (data.view())))]);
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__marshallable(cfg: &C, value: &U) -> bool {
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__size(cfg: &C, value: &U) -> u64 {
                ::builtin::recommends([cfg.valid(),
                            Self::marshallable(cfg, value)]);
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            fn VERUS_SPEC__exec_size(cfg: &C, value: &U) -> u64 {
                ::builtin::requires([cfg.valid(),
                            Self::marshallable(cfg, value)]);
                ::builtin::ensures(|sz: u64|
                        [::builtin::spec_eq(sz, Self::size(cfg, value))]);
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            fn VERUS_SPEC__marshall(cfg: &C, value: &U, data: &mut Vec<u8>,
                start: u64) -> u64 {
                ::builtin::requires([cfg.valid(),
                            Self::marshallable(cfg, value),
                            ((::builtin::spec_cast_integer::<_,
                                                    int>(start)).spec_add(::builtin::spec_cast_integer::<_,
                                                int>(Self::size(cfg, value)))).spec_le(old(data).len())]);
                ::builtin::ensures(|end: u64|
                        [::builtin::spec_eq(end,
                                    (start).spec_add(Self::size(cfg, value))),
                                ::builtin::spec_eq(data.len(), old(data).len()),
                                ::builtin::forall(|i|
                                        ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                        i), start)),
                                            ::builtin::spec_eq(data.spec_index(i),
                                                old(data).spec_index(i)))),
                                ::builtin::forall(|i|
                                        ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(end),
                                                        i), data.len())),
                                            ::builtin::spec_eq(data.spec_index(i),
                                                old(data).spec_index(i)))),
                                Self::parsable(cfg,
                                    (data.view()).subrange(::builtin::spec_cast_integer::<_,
                                                int>(start), ::builtin::spec_cast_integer::<_, int>(end))),
                                ::builtin::spec_eq(Self::parse(cfg,
                                        (data.view()).subrange(::builtin::spec_cast_integer::<_,
                                                    int>(start), ::builtin::spec_cast_integer::<_, int>(end))),
                                    value)]);
                ::builtin::no_method_body()
            }
        }
        #[verus::internal(verus_macro)]
        struct DefaultConfig {}
        #[verus::internal(verus_macro)]
        impl Config for DefaultConfig {
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn valid(&self) -> bool { true }
        }
        #[verus::internal(verus_macro)]
        struct IntegerMarshalling {}
        #[verus::internal(verus_macro)]
        impl Marshalling<DefaultConfig, u64> for IntegerMarshalling {
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn parsable(cfg: &DefaultConfig, data: Seq<u8>) -> bool {
                (::builtin::spec_literal_nat("8")).spec_le(data.len())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn parse(cfg: &DefaultConfig, data: Seq<u8>) -> u64 {
                spec_u64_from_le_bytes(data.subrange(::builtin::spec_literal_integer("0"),
                        ::builtin::spec_literal_integer("8")))
            }
            #[verus::internal(verus_macro)]
            fn try_parse(cfg: &DefaultConfig, data: &Vec<u8>) -> Option<u64> {
                if 8 <= data.len() {
                        Some(u64_from_le_bytes(slice_subrange(data.as_slice(), 0,
                                    8)))
                    } else { None }
            }
            #[verus::internal(verus_macro)]
            fn exec_parsable(cfg: &DefaultConfig, data: &Vec<u8>) -> bool {
                8 <= data.len()
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn marshallable(cfg: &DefaultConfig, value: &u64) -> bool { true }
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn size(cfg: &DefaultConfig, value: &u64) -> u64 {
                ::builtin::spec_literal_integer("8")
            }
            #[verus::internal(verus_macro)]
            fn exec_size(cfg: &DefaultConfig, value: &u64) -> u64 { 8 }
            #[verus::internal(verus_macro)]
            fn marshall(cfg: &DefaultConfig, value: &u64, data: &mut Vec<u8>,
                start: u64) -> u64 {
                let s = u64_to_le_bytes(*value);

                #[verifier::proof_block]
                { lemma_auto_spec_u64_to_from_le_bytes(); }

                #[verifier::proof_block]
                {
                    ::builtin::assert_(::builtin::ext_equal((s.view()).subrange(::builtin::spec_literal_integer("0"),
                                ::builtin::spec_literal_integer("8")), (s.view())))
                };
                let end = start + 8;
                let mut k: usize = 0;
                while k < 8 {
                    ::builtin::invariant([::builtin::spec_eq(end,
                                    (start).spec_add(Self::size(cfg, value))),
                                (end).spec_le(data.len()),
                                ::builtin::spec_eq(data.len(), old(data).len()),
                                ::builtin::spec_eq(s.len(),
                                    ::builtin::spec_literal_nat("8")),
                                ::builtin::forall(|i|
                                        ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                        i), start)),
                                            ::builtin::spec_eq(data.spec_index(i),
                                                old(data).spec_index(i)))),
                                ::builtin::forall(|i|
                                        ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                        i), k)),
                                            ::builtin::spec_eq(data.spec_index((::builtin::spec_cast_integer::<_,
                                                                    int>(start)).spec_add(i)), s.spec_index(i)))),
                                ::builtin::forall(|i|
                                        ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(end),
                                                        i), data.len())),
                                            ::builtin::spec_eq(data.spec_index(i),
                                                old(data).spec_index(i))))]);
                    data.set(start as usize + k, s[k]);
                    k += 1;
                }

                #[verifier::proof_block]
                {
                    ::builtin::assert_(::builtin::ext_equal((data.view()).subrange(::builtin::spec_cast_integer::<_,
                                        int>(start), ::builtin::spec_cast_integer::<_, int>(end)),
                            (s.view())))
                };
                end
            }
        }
        #[verus::internal(verus_macro)]
        trait SeqMarshalling<C: Config, U,
            Elt: Marshalling<C, U>>: Marshalling<DefaultConfig, Vec<U>> {
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn spec_elt_cfg(cfg: &DefaultConfig)
            -> C;
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            fn spec_elt_cfg_ensures(cfg: &DefaultConfig)
            -> C;
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn lengthable(cfg: &DefaultConfig, data: Seq<u8>)
            -> bool;
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn length(cfg: &DefaultConfig, data: Seq<u8>)
            -> int;
            #[verus::internal(verus_macro)]
            fn try_length(cfg: &DefaultConfig, data: &Vec<u8>)
            -> Option<u64>;
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn gettable(cfg: &DefaultConfig, data: Seq<u8>, idx: int)
            -> bool;
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn get(cfg: &DefaultConfig, slice: Slice, data: Seq<u8>, idx: int)
            -> Slice;
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            fn get_ensures(cfg: &DefaultConfig, slice: Slice, data: Seq<u8>,
            idx: int);
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn get_data(cfg: &DefaultConfig, slice: Slice, data: Seq<u8>,
            idx: int)
            -> Seq<u8>;
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn elt_parsable(cfg: &DefaultConfig, data: Seq<u8>, idx: int)
            -> bool;
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn get_elt(cfg: &DefaultConfig, slice: Slice, data: Seq<u8>,
            idx: int)
            -> Elt;
            #[verus::internal(verus_macro)]
            fn try_get(cfg: &DefaultConfig, slice: Slice, data: Seq<u8>,
            idx: int)
            -> Option<Slice>;
            #[verus::internal(verus_macro)]
            fn try_get_elt(cfg: &DefaultConfig, slice: Slice, data: Seq<u8>,
            idx: int)
            -> Option<Elt>;
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn settable(cfg: &DefaultConfig, data: Seq<u8>, idx: int,
            value: U);
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__spec_elt_cfg(cfg: &DefaultConfig) -> C {
                ::builtin::recommends([cfg.valid()]);
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            fn VERUS_SPEC__spec_elt_cfg_ensures(cfg: &DefaultConfig) -> C {
                ::builtin::requires([cfg.valid()]);
                ::builtin::ensures(|elt_cfg: C| [elt_cfg.valid()]);
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__lengthable(cfg: &DefaultConfig, data: Seq<u8>)
                -> bool {
                ::builtin::recommends([cfg.valid()]);
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__length(cfg: &DefaultConfig, data: Seq<u8>) -> int {
                ::builtin::recommends([cfg.valid(),
                            Self::lengthable(cfg, data)]);
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            fn VERUS_SPEC__try_length(cfg: &DefaultConfig, data: &Vec<u8>)
                -> Option<u64> {
                ::builtin::requires([cfg.valid()]);
                ::builtin::ensures(|out: Option<u64>|
                        [::builtin::spec_eq((::builtin::is_variant(out, "Some")),
                                    (Self::lengthable(cfg, (data.view())))),
                                ::builtin::imply(::builtin::is_variant(out, "Some"),
                                    ::builtin::spec_eq(::builtin::spec_cast_integer::<_,
                                                int>(out.unwrap()), Self::length(cfg, (data.view()))))]);
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__gettable(cfg: &DefaultConfig, data: Seq<u8>,
                idx: int) -> bool {
                ::builtin::recommends([cfg.valid()]);
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__get(cfg: &DefaultConfig, slice: Slice,
                data: Seq<u8>, idx: int) -> Slice {
                ::builtin::recommends([cfg.valid(), slice.valid(data),
                            Self::gettable(cfg, slice.i(data), idx)]);
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            fn VERUS_SPEC__get_ensures(cfg: &DefaultConfig, slice: Slice,
                data: Seq<u8>, idx: int) {
                ::builtin::requires([cfg.valid(), slice.valid(data),
                            Self::gettable(cfg, slice.i(data), idx)]);
                ::builtin::ensures([Self::get(cfg, slice, data,
                                    idx).valid(data)]);
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__get_data(cfg: &DefaultConfig, slice: Slice,
                data: Seq<u8>, idx: int) -> Seq<u8> {
                ::builtin::recommends([cfg.valid(),
                            Self::gettable(cfg, slice.i(data), idx)]);
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__elt_parsable(cfg: &DefaultConfig, data: Seq<u8>,
                idx: int) -> bool {
                ::builtin::recommends([cfg.valid(),
                            Self::gettable(cfg, data, idx)]);
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__get_elt(cfg: &DefaultConfig, slice: Slice,
                data: Seq<u8>, idx: int) -> Elt {
                ::builtin::recommends([cfg.valid(),
                            Self::gettable(cfg, slice.i(data), idx),
                            Self::elt_parsable(cfg, slice.i(data), idx)]);
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            fn VERUS_SPEC__try_get(cfg: &DefaultConfig, slice: Slice,
                data: Seq<u8>, idx: int) -> Option<Slice> {
                ::builtin::requires([cfg.valid(), slice.valid(data)]);
                ::builtin::ensures(|oeslice: Option<Slice>|
                        [::builtin::spec_eq((::builtin::is_variant(oeslice,
                                            "Some")),
                                    (Self::gettable(cfg, slice.i(data),
                                            ::builtin::spec_cast_integer::<_, int>(idx)))),
                                ::builtin::imply(::builtin::is_variant(oeslice, "Some"),
                                    ::builtin::spec_eq(oeslice.unwrap(),
                                        Self::get(cfg, slice, data,
                                            ::builtin::spec_cast_integer::<_, int>(idx))))]);
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            fn VERUS_SPEC__try_get_elt(cfg: &DefaultConfig, slice: Slice,
                data: Seq<u8>, idx: int) -> Option<Elt> {
                ::builtin::requires([cfg.valid()]);
                ::builtin::ensures(|oelt: Option<Elt>|
                        [::builtin::spec_eq((::builtin::is_variant(oelt, "Some")),
                                    ({
                                            (Self::gettable(cfg, slice.i(data),
                                                        ::builtin::spec_cast_integer::<_, int>(idx))) &&
                                                (Self::elt_parsable(cfg, data,
                                                        ::builtin::spec_cast_integer::<_, int>(idx)))
                                        })),
                                ::builtin::imply(::builtin::is_variant(oelt, "Some"),
                                    ::builtin::spec_eq(oelt.unwrap(),
                                        Self::get_elt(cfg, slice, data,
                                            ::builtin::spec_cast_integer::<_, int>(idx))))]);
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__settable(cfg: &DefaultConfig, data: Seq<u8>,
                idx: int, value: U) {
                ::builtin::recommends([cfg.valid(),
                            Elt::marshallable(&Self::spec_elt_cfg(cfg), &value)]);
                ::builtin::no_method_body()
            }
        }
    }
}
fn main() {}
verification results:: 0 verified, 0 errors
#![feature(prelude_import)]

#![allow(internal_features)]
#![feature(stmt_expr_attributes)]
#![feature(box_patterns)]
#![feature(negative_impls)]
#![feature(rustc_attrs)]
#![feature(unboxed_closures)]
#![feature(register_tool)]
#![feature(tuple_trait)]
#![feature(custom_inner_attributes)]
#![feature(try_trait_v2)]
#![register_tool(verus)]
#![register_tool(verifier)]
#[prelude_import]
use std::prelude::rust_2018::*;
#[macro_use]
extern crate std;
mod spec {
    pub mod Option_t {
        #[allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        #[verus::internal(verus_macro)]
        pub enum Option<T> { None, Some(T), }
        #[verus::internal(verus_macro)]
        #[cfg(verus_keep_ghost)]
        #[automatically_derived]
        impl<T> Option<T> {
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_None(&self) -> bool {
                ::builtin::is_variant(self, "None")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_Some(&self) -> bool {
                ::builtin::is_variant(self, "Some")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_Some_0(self) -> T {
                ::builtin::get_variant_field(self, "Some", "0")
            }
        }
    }
    pub mod FloatingSeq_t {
        use builtin_macros::*;
        use builtin::*;
        use vstd::{*, seq::*};
        use crate::spec::MapSpec_t::Version;
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct FloatingSeq<T> {
            pub start: nat,
            pub entries: Seq<T>,
        }
        #[verus::internal(verus_macro)]
        impl<T> FloatingSeq<T> {
            #[doc =
            " Returns a new FloatingSeq with active indices in the range [start, length). The entries"]
            #[doc =
            " in the active indices are populated using a caller-provided lambda, which should map"]
            #[doc =
            " active indices to the element that should populate that index."]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn new(start: nat, length: nat,
                f: ::builtin::FnSpec<(int,), T>) -> FloatingSeq<T> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn len(self) -> int {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn first_active_index(self) -> int {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_active(self, i: int) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn get(self, i: int) -> T {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn spec_index(self, i: int) -> T {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[doc =
            " Return a FloatingSeq containing the elements of this seq in the range"]
            #[doc =
            " [start, end_idx). (Note however for all FloatingSeq\'s we interpret all the"]
            #[doc =
            " empty indices [0, start) as \"occupied\"; they just represent forgotten"]
            #[doc = " values)."]
            #[doc =
            " i.e.: chop off all elements at index end_idx and beyond. (end_idx is"]
            #[doc =
            " in the \"absolute space\", FloatingSeq handles translation)."]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn get_prefix(self, end_idx: int) -> FloatingSeq<T> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[doc =
            " Return a FloatingSeq containing the elements of this FloatingSeq in the range"]
            #[doc = " [newStart, self.len())."]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn get_suffix(self, newStart: int) -> FloatingSeq<T> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn append(self, elts: Seq<T>) -> FloatingSeq<T> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn last(self) -> T {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn drop_last(self) -> FloatingSeq<T> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn extensionality(self, b: FloatingSeq<T>) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        impl FloatingSeq<Version> {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn ext_equal(self, other: FloatingSeq<Version>) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn ext_equal_is_equality() {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
    }
    pub mod MapSpec_t {
        use builtin_macros::*;
        use builtin::*;
        use vstd::{*, map::*, set::*};
        use crate::spec::KeyType_t::*;
        use crate::spec::Messages_t::*;
        use crate::spec::FloatingSeq_t::*;
        use crate::spec::TotalKMMap_t::*;
        use state_machines_macros::state_machine;
        #[doc =
        " An Input represents a possible action that can be taken on an abstract"]
        #[doc =
        " MapSpec (i.e.: abstract key-value store), and contains the relevant"]
        #[doc = " arguments for performing that operation."]
        #[verus::internal(verus_macro)]
        pub enum Input {
            QueryInput {
                key: Key,
            },
            PutInput {
                key: Key,
                value: Value,
            },
            NoopInput,
        }
        #[verus::internal(verus_macro)]
        #[cfg(verus_keep_ghost)]
        #[automatically_derived]
        impl Input {
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_QueryInput(&self) -> bool {
                ::builtin::is_variant(self, "QueryInput")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_QueryInput_key(self) -> Key {
                ::builtin::get_variant_field(self, "QueryInput", "key")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_PutInput(&self) -> bool {
                ::builtin::is_variant(self, "PutInput")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_PutInput_key(self) -> Key {
                ::builtin::get_variant_field(self, "PutInput", "key")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_PutInput_value(self) -> Value {
                ::builtin::get_variant_field(self, "PutInput", "value")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_NoopInput(&self) -> bool {
                ::builtin::is_variant(self, "NoopInput")
            }
        }
        #[doc =
        " An Output represents the result from taking an Input action (and contains"]
        #[doc =
        " any relevant return arguments from performing the corresponding action)."]
        #[verus::internal(verus_macro)]
        pub enum Output {
            QueryOutput {
                value: Value,
            },
            PutOutput,
            NoopOutput,
        }
        #[verus::internal(verus_macro)]
        #[cfg(verus_keep_ghost)]
        #[automatically_derived]
        impl Output {
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_QueryOutput(&self) -> bool {
                ::builtin::is_variant(self, "QueryOutput")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_QueryOutput_value(self) -> Value {
                ::builtin::get_variant_field(self, "QueryOutput", "value")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_PutOutput(&self) -> bool {
                ::builtin::is_variant(self, "PutOutput")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_NoopOutput(&self) -> bool {
                ::builtin::is_variant(self, "NoopOutput")
            }
        }
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn my_init() -> MapSpec::State {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn getInput(label: MapSpec::Label) -> Input {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn getOutput(label: MapSpec::Label) -> Output {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[allow(unused_parens)]
        pub mod MapSpec {
            use super::*;
            #[verus::internal(verus_macro)]
            pub struct State {
                pub kmmap: TotalKMMap,
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Step {
                query(),
                put(),
                noop(),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Step {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_query(&self) -> bool {
                    ::builtin::is_variant(self, "query")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_put(&self) -> bool {
                    ::builtin::is_variant(self, "put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_noop(&self) -> bool {
                    ::builtin::is_variant(self, "noop")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Config { my_init_2(), dummy_to_use_type_params(State), }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Config {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_my_init_2(&self) -> bool {
                    ::builtin::is_variant(self, "my_init_2")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[verus::internal(verus_macro)]
            pub enum Label {
                Query {
                    input: Input,
                    output: Output,
                },
                Put {
                    input: Input,
                    output: Output,
                },
                Noop {
                    input: Input,
                    output: Output,
                },
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Label {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_Query(&self) -> bool {
                    ::builtin::is_variant(self, "Query")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_Query_input(self) -> Input {
                    ::builtin::get_variant_field(self, "Query", "input")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_Query_output(self) -> Output {
                    ::builtin::get_variant_field(self, "Query", "output")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_Put(&self) -> bool {
                    ::builtin::is_variant(self, "Put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_Put_input(self) -> Input {
                    ::builtin::get_variant_field(self, "Put", "input")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_Put_output(self) -> Output {
                    ::builtin::get_variant_field(self, "Put", "output")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_Noop(&self) -> bool {
                    ::builtin::is_variant(self, "Noop")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_Noop_input(self) -> Input {
                    ::builtin::get_variant_field(self, "Noop", "input")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_Noop_output(self) -> Output {
                    ::builtin::get_variant_field(self, "Noop", "output")
                }
            }
            pub mod show {
                use super::*;
                use bool as query;
                use bool as put;
                use bool as noop;
                use bool as my_init_2;
            }
            pub mod take_step {
                use super::*;
            }
            #[verus::internal(verus_macro)]
            impl State { }
        }
        type ID = int;
        #[verus::internal(verus_macro)]
        pub struct Request {
            pub input: Input,
            pub id: ID,
        }
        #[verus::internal(verus_macro)]
        pub struct Reply {
            pub output: Output,
            pub id: ID,
        }
        #[doc =
        " PersistentState represents the actual state of the AsyncMap (wraps"]
        #[doc =
        " the true key-value store). Whenever an operation is executed the"]
        #[doc = " PersistentState is updated."]
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct PersistentState {
            pub appv: MapSpec::State,
        }
        #[verus::internal(verus_macro)]
        impl PersistentState {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn ext_equal(self, other: PersistentState) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn ext_equal_is_equality() {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[doc =
        " EphemeralState captures the relevant async information we need to"]
        #[doc =
        " track whether operations violate linearizability (and thus enforce"]
        #[doc =
        " in our transitions that all operations are linearizable from the "]
        #[doc = " perspective of the client)."]
        #[doc = ""]
        #[doc =
        " We view our EphemeralState as a set of outstanding client requests"]
        #[doc =
        " that haven\'t been executed and a set of executed replies that have"]
        #[doc = " yet to be delivered to the client."]
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct EphemeralState {
            #[doc = " The set of received but not yet executed requests."]
            pub requests: Set<Request>,
            #[doc = " The set of executed but not yet delivered replies."]
            pub replies: Set<Reply>,
        }
        #[allow(unused_parens)]
        pub mod AsyncMap {
            use super::*;
            #[verus::internal(verus_macro)]
            pub struct State {
                pub persistent: PersistentState,
                pub ephemeral: EphemeralState,
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Step {
                request(),
                execute(MapSpec::Label, PersistentState),
                reply(),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Step {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_request(&self) -> bool {
                    ::builtin::is_variant(self, "request")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_execute(&self) -> bool {
                    ::builtin::is_variant(self, "execute")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_execute_0(self) -> MapSpec::Label {
                    ::builtin::get_variant_field(self, "execute", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_execute_1(self) -> PersistentState {
                    ::builtin::get_variant_field(self, "execute", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_reply(&self) -> bool {
                    ::builtin::is_variant(self, "reply")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Config { dummy_to_use_type_params(State), }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Config {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[verus::internal(verus_macro)]
            pub enum Label {

                #[doc =
                " Request transition is labeled with the requested operation."]
                RequestOp {
                    req: Request,
                },

                #[doc =
                " Execute transition is labeled with the requested operation that"]
                #[doc = " was executed and the produced reply."]
                ExecuteOp {
                    req: Request,
                    reply: Reply,
                },

                #[doc =
                " Reply transition is labeled with what reply is delivered."]
                ReplyOp {
                    reply: Reply,
                },
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Label {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_RequestOp(&self) -> bool {
                    ::builtin::is_variant(self, "RequestOp")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_RequestOp_req(self) -> Request {
                    ::builtin::get_variant_field(self, "RequestOp", "req")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_ExecuteOp(&self) -> bool {
                    ::builtin::is_variant(self, "ExecuteOp")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_ExecuteOp_req(self) -> Request {
                    ::builtin::get_variant_field(self, "ExecuteOp", "req")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_ExecuteOp_reply(self) -> Reply {
                    ::builtin::get_variant_field(self, "ExecuteOp", "reply")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_ReplyOp(&self) -> bool {
                    ::builtin::is_variant(self, "ReplyOp")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_ReplyOp_reply(self) -> Reply {
                    ::builtin::get_variant_field(self, "ReplyOp", "reply")
                }
            }
            pub mod show {
                use super::*;
                use bool as request;
                use bool as execute;
                use bool as reply;
            }
            pub mod take_step {
                use super::*;
            }
            #[verus::internal(verus_macro)]
            impl State {
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn init_persistent_state() -> PersistentState {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn init_ephemeral_state() -> EphemeralState {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
            }
        }
        type SyncReqId = nat;
        #[doc =
        " A Version is a snapshot of a map (its key-value pairs). Specifically it wraps"]
        #[doc = " a `MapSpec::State`."]
        #[verifier::ext_equal]
        pub type Version = PersistentState;
        #[allow(unused_parens)]
        pub mod CrashTolerantAsyncMap {
            use super::*;
            #[verus::internal(verus_macro)]
            pub struct State {
                pub versions: FloatingSeq<Version>,
                pub async_ephemeral: EphemeralState,
                pub sync_requests: Map<SyncReqId, nat>,
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Step {
                operate(FloatingSeq<Version>, EphemeralState),
                crash(),
                sync(int),
                req_sync(),
                reply_sync(),
                noop(),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Step {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_operate(&self) -> bool {
                    ::builtin::is_variant(self, "operate")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_operate_0(self) -> FloatingSeq<Version> {
                    ::builtin::get_variant_field(self, "operate", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_operate_1(self) -> EphemeralState {
                    ::builtin::get_variant_field(self, "operate", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_crash(&self) -> bool {
                    ::builtin::is_variant(self, "crash")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_sync(&self) -> bool {
                    ::builtin::is_variant(self, "sync")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_sync_0(self) -> int {
                    ::builtin::get_variant_field(self, "sync", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_req_sync(&self) -> bool {
                    ::builtin::is_variant(self, "req_sync")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_reply_sync(&self) -> bool {
                    ::builtin::is_variant(self, "reply_sync")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_noop(&self) -> bool {
                    ::builtin::is_variant(self, "noop")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Config { initialize(), dummy_to_use_type_params(State), }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Config {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_initialize(&self) -> bool {
                    ::builtin::is_variant(self, "initialize")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[verus::internal(verus_macro)]
            pub enum Label {
                OperateOp {
                    base_op: AsyncMap::Label,
                },
                CrashOp,
                SyncOp,
                ReqSyncOp {
                    sync_req_id: SyncReqId,
                },
                ReplySyncOp {
                    sync_req_id: SyncReqId,
                },
                Noop,
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Label {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_OperateOp(&self) -> bool {
                    ::builtin::is_variant(self, "OperateOp")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_OperateOp_base_op(self) -> AsyncMap::Label {
                    ::builtin::get_variant_field(self, "OperateOp", "base_op")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_CrashOp(&self) -> bool {
                    ::builtin::is_variant(self, "CrashOp")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_SyncOp(&self) -> bool {
                    ::builtin::is_variant(self, "SyncOp")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_ReqSyncOp(&self) -> bool {
                    ::builtin::is_variant(self, "ReqSyncOp")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_ReqSyncOp_sync_req_id(self) -> SyncReqId {
                    ::builtin::get_variant_field(self, "ReqSyncOp",
                        "sync_req_id")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_ReplySyncOp(&self) -> bool {
                    ::builtin::is_variant(self, "ReplySyncOp")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_ReplySyncOp_sync_req_id(self) -> SyncReqId {
                    ::builtin::get_variant_field(self, "ReplySyncOp",
                        "sync_req_id")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_Noop(&self) -> bool {
                    ::builtin::is_variant(self, "Noop")
                }
            }
            pub mod show {
                use super::*;
                use bool as operate;
                use bool as crash;
                use bool as sync;
                use bool as req_sync;
                use bool as reply_sync;
                use bool as noop;
                use bool as initialize;
            }
            pub mod take_step {
                use super::*;
            }
            #[verus::internal(verus_macro)]
            impl State {
                #[doc =
                " Return the latest index in `self.versions` which is stable (i.e.: persistent across"]
                #[doc = " crashes)."]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn stable_index(self) -> int {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[doc =
                " Returns true iff versions_prime is one of the following:"]
                #[doc = " - Equal to versions."]
                #[doc =
                " - Equal to versions with a single version appended."]
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn optionally_append_version(versions:
                        FloatingSeq<Version>, versions_prime: FloatingSeq<Version>)
                    -> bool {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
            }
        }
        fn main() {}
    }
    pub mod TotalKMMap_t {
        use builtin_macros::*;
        use vstd::prelude::*;
        use vstd::set_lib::*;
        use crate::spec::KeyType_t::*;
        use crate::spec::Messages_t::*;
        #[doc =
        " A TotalKMMap wraps a regular verus map. Maps Keys to Messages."]
        #[doc = " We use this to represent our abstract map state."]
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct TotalKMMap(pub Map<Key, Message>);
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn total_domain() -> Set<Key> {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(verus_macro)]
        impl TotalKMMap {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn empty() -> TotalKMMap {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn spec_index(self, idx: Key) -> Message {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn insert(self, key: Key, value: Message) -> Self {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn dom(self) -> Set<Key> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn ext_equal(self, other: TotalKMMap) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn ext_equal_is_equality(self, other: TotalKMMap) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn insert_lemma(self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
    }
    pub mod Messages_t {
        #[allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        #[verus::internal(verus_macro)]
        pub struct Value(pub int);
        #[verus::internal(verus_macro)]
        pub struct Delta(pub int);
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn default_value() -> Value {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn nop_delta() -> Delta {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[doc =
        " Messages represent operations that can be performed to update/define the"]
        #[doc = " state of values in a map."]
        #[doc =
        " Messages can themselves be used as the values of a map as long as only \"Define\""]
        #[doc = " messages are stored (see TotalKMMap)."]
        #[verus::internal(verus_macro)]
        pub enum Message {

            #[doc =
            " A Define message represents setting a variable to the given value."]
            Define {
                value: Value,
            },

            #[doc =
            " An Update message represents updating a variable by the given delta."]
            Update {
                delta: Delta,
            },
        }
        #[verus::internal(verus_macro)]
        #[cfg(verus_keep_ghost)]
        #[automatically_derived]
        impl Message {
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_Define(&self) -> bool {
                ::builtin::is_variant(self, "Define")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_Define_value(self) -> Value {
                ::builtin::get_variant_field(self, "Define", "value")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_Update(&self) -> bool {
                ::builtin::is_variant(self, "Update")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_Update_delta(self) -> Delta {
                ::builtin::get_variant_field(self, "Update", "delta")
            }
        }
        #[verus::internal(verus_macro)]
        impl Message {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn combine_deltas(new: Delta, old: Delta) -> Delta {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn apply_delta(delta: Delta, value: Value) -> Value {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn merge(self, new: Message) -> Message {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn empty() -> Message {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
    }
    pub mod KeyType_t {
        #![allow(unused_imports)]
        use builtin_macros::*;
        use builtin::*;
        use vstd::prelude::*;
        use vstd::set_lib::*;
        #[doc =
        " A Key is a key in a B+-tree. Tuple style type makes it typecheck as its"]
        #[doc = " own type in Rust."]
        #[doc = " Keys in the real implementation are meant to be strings."]
        #[verus::internal(verus_macro)]
        pub struct Key(pub nat);
        #[doc =
        " An Element is a Be-tree pivot value. It is an enum type because we need a special"]
        #[doc =
        " value `Max` for representing a value larger than the largest key. `Max` is only used"]
        #[doc =
        " in the special case where the last bucket of a node has an unbounded upper bound."]
        #[doc = " "]
        #[doc =
        " We don\'t need a `Min` value, as the empty bytestring will represent the lowest possible"]
        #[doc =
        " value (and bucket lower bounds are inclusive). So we can use the empty bytestring as"]
        #[doc = " our lowest pivot if we want to represent all lower keys."]
        #[doc = " "]
        #[doc =
        " Elements are essentially just Keys with a special `Max` value, and thus the two types"]
        #[doc = " can be converted between each other."]
        #[verus::internal(verus_macro)]
        pub enum Element {

            #[doc =
            " Max is the max key in the domain. Only the last pivot of a Be-tree can"]
            #[doc =
            " be Max (in which case the last bucket has an unbounded upper bound)."]
            Max,
            Elem {
                e: nat,
            },
        }
        #[verus::internal(verus_macro)]
        #[cfg(verus_keep_ghost)]
        #[automatically_derived]
        impl Element {
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_Max(&self) -> bool {
                ::builtin::is_variant(self, "Max")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_Elem(&self) -> bool {
                ::builtin::is_variant(self, "Elem")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_Elem_e(self) -> nat {
                ::builtin::get_variant_field(self, "Elem", "e")
            }
        }
        #[doc = " Pre: elem is Element::Elem (and not `Max`)."]
        #[doc = " Returns the key corresponding to an Element::Elem."]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn to_key(elem: Element) -> Key {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn to_element(key: Key) -> Element {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(verus_macro)]
        impl Key {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn lte(a: Key, b: Key) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn lt(a: Key, b: Key) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_strictly_sorted(run: Seq<Key>) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[doc =
            " Returns the index of the largest element in `run` that\'s <= to the provided"]
            #[doc = " needle."]
            #[doc = " "]
            #[doc = " # Arguments"]
            #[doc = " "]
            #[doc = " * `run`: the sequence to search within."]
            #[doc = " * `needle`: the needle to search for."]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn largest_lte(run: Seq<Key>, needle: Key) -> int {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn largest_lt(run: Seq<Key>, needle: Key) -> int {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn map_pivoted_union<V>(left: Map<Key, V>, pivot: Key,
                right: Map<Key, V>) -> Map<Key, V> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_sorted(run: Seq<Key>) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn strictly_sorted_implies_sorted(run: Seq<Key>) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn lte_transitive_forall() {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn largest_lte_ensures(run: Seq<Key>, needle: Key, out: int) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        impl Element {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn lte(a: Element, b: Element) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn lt(a: Element, b: Element) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn lt_transitive(a: Element, b: Element, c: Element) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn lt_transitive_forall() {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn lte_transitive(a: Element, b: Element, c: Element) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn lte_transitive_forall() {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn min_elem() -> Element {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_sorted(run: Seq<Element>) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_strictly_sorted(run: Seq<Element>) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn strictly_sorted_implies_sorted(run: Seq<Element>) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn largest_lte(run: Seq<Element>, needle: Element) -> int {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn largest_lte_lemma(run: Seq<Element>, needle: Element,
                out: int) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
    }
}
mod abstract_system {
    pub mod StampedMap_v {
        use builtin_macros::*;
        use builtin::*;
        use crate::spec::TotalKMMap_t::*;
        use crate::abstract_system::MsgHistory_v::MsgHistory;
        pub type LSN = nat;
        #[doc = " A Stamped type is one which has the concept of a seq_end."]
        #[doc = " I guess the original naming was meant to refer to how"]
        #[doc = " you \"stamp\" the end with an LSN? IDK."]
        #[verus::internal(verus_macro)]
        pub struct Stamped<T> {
            pub value: T,
            pub seq_end: LSN,
        }
        #[doc = " A TotalKMMap with a seq_end field."]
        pub type StampedMap = Stamped<TotalKMMap>;
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn empty() -> StampedMap {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(verus_macro)]
        impl StampedMap {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn ext_equal(self, other: StampedMap) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[doc =
            " Returns a StampedMap formed by applying the operations in the given journal"]
            #[doc = " (aka Message History) to this StampedMap."]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn plus_history(self, history: MsgHistory) -> StampedMap {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn ext_equal_is_equality() {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        fn main() {}
    }
    pub mod MsgHistory_v {
        use builtin_macros::*;
        use builtin::*;
        use vstd::{*, map::*, set::*};
        use crate::spec::KeyType_t::*;
        use crate::spec::Messages_t::*;
        use crate::abstract_system::StampedMap_v::*;
        #[doc =
        " A KeyedMessage stores a \"key\" to perform the operation in the stored"]
        #[doc = " \"message\" on."]
        #[verus::internal(verus_macro)]
        pub struct KeyedMessage {
            pub key: Key,
            pub message: Message,
        }
        #[doc =
        " A contiguous log of kv-store command messages (keyed by LSN)."]
        #[doc = " Stores requests from seq_start <= LSN < seq_end."]
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct MsgHistory {
            #[doc =
            " The messages stored in this history. Stored as key-value pairs,"]
            #[doc =
            " where key is the LSN of the operation, and KeyedMessage stores"]
            #[doc = " the operation to perform."]
            pub msgs: Map<LSN, KeyedMessage>,
            #[doc = " The first LSN in this MsgHistory."]
            pub seq_start: LSN,
            #[doc = " The first LSN *past the end* of this MsgHistory."]
            pub seq_end: LSN,
        }
        #[verus::internal(verus_macro)]
        impl MsgHistory {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn ext_equal(self, other: MsgHistory) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn ext_equal_is_equality() {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn contains(self, lsn: LSN) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn contains_key(self, key: Key) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn contains_exactly(self, lsns: Set<LSN>) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_empty(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn len(self) -> nat {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_follow(self, lsn: LSN) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_concat(self, other: MsgHistory) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn concat(self, other: MsgHistory) -> MsgHistory {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn concat_lemma(self, other: MsgHistory) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn concat_forall_lemma() {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_discard_to(self, lsn: LSN) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[doc = " Returns this[start, lsn). (Slice off right side)."]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn discard_recent(self, lsn: LSN) -> MsgHistory {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn _dr(self, lsn: LSN) -> MsgHistory {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[doc =
            " Returns a StampedMap formed by applying the operations in self (MsgHistory)"]
            #[doc = " to the StampedMap \"orig\"."]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn apply_to_stamped_map(self, orig: StampedMap)
                -> StampedMap {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn apply_to_stamped_map_wf_lemma(self, orig: StampedMap) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn apply_to_stamped_map_length_lemma(self, orig: StampedMap) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn discard_old(self, lsn: LSN) -> MsgHistory {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn _do(self, lsn: LSN) -> MsgHistory {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn maybe_discard_old(self, lsn: LSN) -> MsgHistory {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn discard_order_is_commutative(self, start: LSN, end: LSN) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn added_slices_union(self, middle: LSN) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn includes_subseq(self, subseq: MsgHistory) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn empty_history_at(lsn: LSN) -> MsgHistory {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn singleton_at(lsn: LSN, msg: KeyedMessage) -> MsgHistory {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn map_plus_history(stamped_map: StampedMap,
                history: MsgHistory) -> StampedMap {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn map_plus_history_lemma(stamped_map: StampedMap,
                history: MsgHistory) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn map_plus_history_forall_lemma() {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn map_plus_history_seq_end_lemma(stamped_map: StampedMap,
                history: MsgHistory) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
    }
    pub mod AbstractJournal_v {
        #[allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        use crate::abstract_system::StampedMap_v::*;
        use crate::abstract_system::MsgHistory_v::*;
        #[allow(unused_parens)]
        pub mod AbstractJournal {
            use super::*;
            #[verus::internal(verus_macro)]
            pub struct State {
                pub journal: MsgHistory,
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Step {
                read_for_recovery(),
                freeze_for_commit(),
                observe_fresh_journal(),
                put(),
                discard_old(),
                internal(),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Step {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_read_for_recovery(&self) -> bool {
                    ::builtin::is_variant(self, "read_for_recovery")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_freeze_for_commit(&self) -> bool {
                    ::builtin::is_variant(self, "freeze_for_commit")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_observe_fresh_journal(&self) -> bool {
                    ::builtin::is_variant(self, "observe_fresh_journal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_put(&self) -> bool {
                    ::builtin::is_variant(self, "put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_discard_old(&self) -> bool {
                    ::builtin::is_variant(self, "discard_old")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_internal(&self) -> bool {
                    ::builtin::is_variant(self, "internal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Config {
                initialize(MsgHistory),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Config {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_initialize(&self) -> bool {
                    ::builtin::is_variant(self, "initialize")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_initialize_0(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "initialize", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[verus::internal(verus_macro)]
            pub enum Label {
                ReadForRecoveryLabel {
                    messages: MsgHistory,
                },
                FreezeForCommitLabel {
                    frozen_journal: MsgHistory,
                },
                QueryEndLsnLabel {
                    end_lsn: LSN,
                },
                PutLabel {
                    messages: MsgHistory,
                },
                DiscardOldLabel {
                    start_lsn: LSN,
                    require_end: LSN,
                },
                InternalLabel,
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Label {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_ReadForRecoveryLabel(&self) -> bool {
                    ::builtin::is_variant(self, "ReadForRecoveryLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_ReadForRecoveryLabel_messages(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "ReadForRecoveryLabel",
                        "messages")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_FreezeForCommitLabel(&self) -> bool {
                    ::builtin::is_variant(self, "FreezeForCommitLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_FreezeForCommitLabel_frozen_journal(self)
                    -> MsgHistory {
                    ::builtin::get_variant_field(self, "FreezeForCommitLabel",
                        "frozen_journal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_QueryEndLsnLabel(&self) -> bool {
                    ::builtin::is_variant(self, "QueryEndLsnLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_QueryEndLsnLabel_end_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "QueryEndLsnLabel",
                        "end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_PutLabel(&self) -> bool {
                    ::builtin::is_variant(self, "PutLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_PutLabel_messages(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "PutLabel", "messages")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_DiscardOldLabel(&self) -> bool {
                    ::builtin::is_variant(self, "DiscardOldLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_DiscardOldLabel_start_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "DiscardOldLabel",
                        "start_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_DiscardOldLabel_require_end(self) -> LSN {
                    ::builtin::get_variant_field(self, "DiscardOldLabel",
                        "require_end")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_InternalLabel(&self) -> bool {
                    ::builtin::is_variant(self, "InternalLabel")
                }
            }
            pub mod show {
                use super::*;
                use bool as read_for_recovery;
                use bool as freeze_for_commit;
                use bool as observe_fresh_journal;
                use bool as put;
                use bool as discard_old;
                use bool as internal;
                use bool as initialize;
            }
            pub mod take_step {
                use super::*;
            }
            #[verus::internal(verus_macro)]
            impl State {
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn wf(self) -> bool {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn can_end_at(self, lsn: LSN) -> bool {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
            }
        }
    }
    pub mod AbstractMap_v {
        #[allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        use crate::spec::KeyType_t::*;
        use crate::spec::Messages_t::*;
        use crate::abstract_system::StampedMap_v::*;
        use crate::abstract_system::MsgHistory_v::*;
        #[allow(unused_parens)]
        pub mod AbstractMap {
            use super::*;
            #[verus::internal(verus_macro)]
            pub struct State {
                pub stamped_map: StampedMap,
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Step {
                query(),
                put(),
                freeze_as(),
                internal(),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Step {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_query(&self) -> bool {
                    ::builtin::is_variant(self, "query")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_put(&self) -> bool {
                    ::builtin::is_variant(self, "put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_freeze_as(&self) -> bool {
                    ::builtin::is_variant(self, "freeze_as")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_internal(&self) -> bool {
                    ::builtin::is_variant(self, "internal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Config {
                initialize(StampedMap),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Config {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_initialize(&self) -> bool {
                    ::builtin::is_variant(self, "initialize")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_initialize_0(self) -> StampedMap {
                    ::builtin::get_variant_field(self, "initialize", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[verus::internal(verus_macro)]
            pub enum Label {

                #[doc =
                " When querying, we label the transition with the map LSN (one past the end)"]
                #[doc =
                " at time of querying, plus the queried key and received value."]
                QueryLabel {
                    end_lsn: LSN,
                    key: Key,
                    value: Value,
                },

                #[doc =
                " We label put transitions with a MsgHistory representing the set of messages"]
                #[doc = " to apply."]
                PutLabel {
                    puts: MsgHistory,
                },

                #[doc =
                " FreezeAs transitions are labeled with the StampedMap state at the time the"]
                #[doc =
                " transition is taken. (Label allows state machine client to validate/assert"]
                #[doc =
                " that the version of map they\'re freezing is correct)."]
                FreezeAsLabel {
                    stamped_map: StampedMap,
                },

                #[doc = " Internal transitions are unlabeled."]
                InternalLabel,
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Label {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_QueryLabel(&self) -> bool {
                    ::builtin::is_variant(self, "QueryLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_QueryLabel_end_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "QueryLabel", "end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_QueryLabel_key(self) -> Key {
                    ::builtin::get_variant_field(self, "QueryLabel", "key")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_QueryLabel_value(self) -> Value {
                    ::builtin::get_variant_field(self, "QueryLabel", "value")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_PutLabel(&self) -> bool {
                    ::builtin::is_variant(self, "PutLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_PutLabel_puts(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "PutLabel", "puts")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_FreezeAsLabel(&self) -> bool {
                    ::builtin::is_variant(self, "FreezeAsLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_FreezeAsLabel_stamped_map(self) -> StampedMap {
                    ::builtin::get_variant_field(self, "FreezeAsLabel",
                        "stamped_map")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_InternalLabel(&self) -> bool {
                    ::builtin::is_variant(self, "InternalLabel")
                }
            }
            pub mod show {
                use super::*;
                use bool as query;
                use bool as put;
                use bool as freeze_as;
                use bool as internal;
                use bool as initialize;
            }
            pub mod take_step {
                use super::*;
            }
            #[verus::internal(verus_macro)]
            impl State { }
        }
    }
    pub mod AbstractCrashAwareJournal_v {
        #[allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        #[allow(unused_imports)]
        use vstd::map::*;
        use crate::spec::Option_t::*;
        use crate::abstract_system::StampedMap_v::*;
        use crate::abstract_system::MsgHistory_v::*;
        use crate::abstract_system::AbstractJournal_v::*;
        pub type StoreImage = MsgHistory;
        #[verus::internal(verus_macro)]
        pub enum Ephemeral {
            Unknown,
            Known {
                v: AbstractJournal::State,
            },
        }
        #[verus::internal(verus_macro)]
        #[cfg(verus_keep_ghost)]
        #[automatically_derived]
        impl Ephemeral {
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_Unknown(&self) -> bool {
                ::builtin::is_variant(self, "Unknown")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_Known(&self) -> bool {
                ::builtin::is_variant(self, "Known")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_Known_v(self) -> AbstractJournal::State {
                ::builtin::get_variant_field(self, "Known", "v")
            }
        }
        #[verus::internal(verus_macro)]
        impl Ephemeral {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[allow(unused_parens)]
        pub mod CrashTolerantJournal {
            use super::*;
            #[verus::internal(verus_macro)]
            pub struct State {
                pub persistent: StoreImage,
                pub ephemeral: Ephemeral,
                pub in_flight: Option<StoreImage>,
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Step {
                load_ephemeral_from_persistent(AbstractJournal::State,
                    AbstractJournal::Config),
                read_for_recovery(),
                query_end_lsn(),
                put(AbstractJournal::State),
                internal(AbstractJournal::State),
                query_lsn_persistence(),
                commit_start(StoreImage, AbstractJournal::State),
                commit_complete(AbstractJournal::State),
                crash(),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Step {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_load_ephemeral_from_persistent(&self) -> bool {
                    ::builtin::is_variant(self,
                        "load_ephemeral_from_persistent")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_load_ephemeral_from_persistent_0(self)
                    -> AbstractJournal::State {
                    ::builtin::get_variant_field(self,
                        "load_ephemeral_from_persistent", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_load_ephemeral_from_persistent_1(self)
                    -> AbstractJournal::Config {
                    ::builtin::get_variant_field(self,
                        "load_ephemeral_from_persistent", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_read_for_recovery(&self) -> bool {
                    ::builtin::is_variant(self, "read_for_recovery")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_query_end_lsn(&self) -> bool {
                    ::builtin::is_variant(self, "query_end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_put(&self) -> bool {
                    ::builtin::is_variant(self, "put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_put_0(self) -> AbstractJournal::State {
                    ::builtin::get_variant_field(self, "put", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_internal(&self) -> bool {
                    ::builtin::is_variant(self, "internal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_0(self) -> AbstractJournal::State {
                    ::builtin::get_variant_field(self, "internal", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_query_lsn_persistence(&self) -> bool {
                    ::builtin::is_variant(self, "query_lsn_persistence")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_commit_start(&self) -> bool {
                    ::builtin::is_variant(self, "commit_start")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_commit_start_0(self) -> StoreImage {
                    ::builtin::get_variant_field(self, "commit_start", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_commit_start_1(self) -> AbstractJournal::State {
                    ::builtin::get_variant_field(self, "commit_start", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_commit_complete(&self) -> bool {
                    ::builtin::is_variant(self, "commit_complete")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_commit_complete_0(self) -> AbstractJournal::State {
                    ::builtin::get_variant_field(self, "commit_complete", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_crash(&self) -> bool {
                    ::builtin::is_variant(self, "crash")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Config { initialize(), dummy_to_use_type_params(State), }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Config {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_initialize(&self) -> bool {
                    ::builtin::is_variant(self, "initialize")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[verus::internal(verus_macro)]
            pub enum Label {
                LoadEphemeralFromPersistentLabel,
                ReadForRecoveryLabel {
                    records: MsgHistory,
                },
                QueryEndLsnLabel {
                    end_lsn: LSN,
                },
                PutLabel {
                    records: MsgHistory,
                },
                InternalLabel,
                QueryLsnPersistenceLabel {
                    sync_lsn: LSN,
                },
                CommitStartLabel {
                    new_boundary_lsn: LSN,
                    max_lsn: LSN,
                },
                CommitCompleteLabel {
                    require_end: LSN,
                },
                CrashLabel,
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Label {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_LoadEphemeralFromPersistentLabel(&self) -> bool {
                    ::builtin::is_variant(self,
                        "LoadEphemeralFromPersistentLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_ReadForRecoveryLabel(&self) -> bool {
                    ::builtin::is_variant(self, "ReadForRecoveryLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_ReadForRecoveryLabel_records(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "ReadForRecoveryLabel",
                        "records")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_QueryEndLsnLabel(&self) -> bool {
                    ::builtin::is_variant(self, "QueryEndLsnLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_QueryEndLsnLabel_end_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "QueryEndLsnLabel",
                        "end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_PutLabel(&self) -> bool {
                    ::builtin::is_variant(self, "PutLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_PutLabel_records(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "PutLabel", "records")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_InternalLabel(&self) -> bool {
                    ::builtin::is_variant(self, "InternalLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_QueryLsnPersistenceLabel(&self) -> bool {
                    ::builtin::is_variant(self, "QueryLsnPersistenceLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_QueryLsnPersistenceLabel_sync_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self,
                        "QueryLsnPersistenceLabel", "sync_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_CommitStartLabel(&self) -> bool {
                    ::builtin::is_variant(self, "CommitStartLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_CommitStartLabel_new_boundary_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "CommitStartLabel",
                        "new_boundary_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_CommitStartLabel_max_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "CommitStartLabel",
                        "max_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_CommitCompleteLabel(&self) -> bool {
                    ::builtin::is_variant(self, "CommitCompleteLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_CommitCompleteLabel_require_end(self) -> LSN {
                    ::builtin::get_variant_field(self, "CommitCompleteLabel",
                        "require_end")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_CrashLabel(&self) -> bool {
                    ::builtin::is_variant(self, "CrashLabel")
                }
            }
            pub mod show {
                use super::*;
                use bool as load_ephemeral_from_persistent;
                use bool as read_for_recovery;
                use bool as query_end_lsn;
                use bool as put;
                use bool as internal;
                use bool as query_lsn_persistence;
                use bool as commit_start;
                use bool as commit_complete;
                use bool as crash;
                use bool as initialize;
            }
            pub mod take_step {
                use super::*;
            }
            #[verus::internal(verus_macro)]
            impl State { }
        }
    }
    pub mod AbstractCrashAwareMap_v {
        /// An AbstractMap (see `AbstractMap_v.rs`) but wrapped with the concept of crashes and recovery.
        /// We use this as the abstract crash tolerant map which is coordinated with the
        /// CrashAwareJournal in the coordination layer in our refinement proof.
        #[allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        #[allow(unused_imports)]
        use vstd::map::*;
        use crate::spec::Option_t::*;
        use crate::spec::KeyType_t::*;
        use crate::spec::Messages_t::*;
        use crate::abstract_system::StampedMap_v::*;
        use crate::abstract_system::MsgHistory_v::*;
        use crate::abstract_system::AbstractMap_v::*;
        type StoreImage = StampedMap;
        #[doc =
        " Ephemeral state of crash aware map is the ephemeral (not crash-tolerant)"]
        #[doc = " view of the map."]
        #[verus::internal(verus_macro)]
        pub enum Ephemeral {
            Unknown,
            Known {
                v: AbstractMap::State,
            },
        }
        #[verus::internal(verus_macro)]
        #[cfg(verus_keep_ghost)]
        #[automatically_derived]
        impl Ephemeral {
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_Unknown(&self) -> bool {
                ::builtin::is_variant(self, "Unknown")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_Known(&self) -> bool {
                ::builtin::is_variant(self, "Known")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_Known_v(self) -> AbstractMap::State {
                ::builtin::get_variant_field(self, "Known", "v")
            }
        }
        #[allow(unused_parens)]
        pub mod CrashTolerantMap {
            use super::*;
            #[verus::internal(verus_macro)]
            pub struct State {
                pub persistent: StoreImage,
                pub ephemeral: Ephemeral,
                pub in_flight: Option<StoreImage>,
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Step {
                load_ephemeral_from_persistent(),
                put_records(AbstractMap::State),
                query(AbstractMap::State),
                freeze_map_internal(StampedMap, AbstractMap::State),
                ephemeral_internal(AbstractMap::State),
                commit_start(),
                commit_complete(),
                crash(),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Step {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_load_ephemeral_from_persistent(&self) -> bool {
                    ::builtin::is_variant(self,
                        "load_ephemeral_from_persistent")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_put_records(&self) -> bool {
                    ::builtin::is_variant(self, "put_records")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_put_records_0(self) -> AbstractMap::State {
                    ::builtin::get_variant_field(self, "put_records", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_query(&self) -> bool {
                    ::builtin::is_variant(self, "query")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_query_0(self) -> AbstractMap::State {
                    ::builtin::get_variant_field(self, "query", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_freeze_map_internal(&self) -> bool {
                    ::builtin::is_variant(self, "freeze_map_internal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_freeze_map_internal_0(self) -> StampedMap {
                    ::builtin::get_variant_field(self, "freeze_map_internal",
                        "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_freeze_map_internal_1(self) -> AbstractMap::State {
                    ::builtin::get_variant_field(self, "freeze_map_internal",
                        "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_ephemeral_internal(&self) -> bool {
                    ::builtin::is_variant(self, "ephemeral_internal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_ephemeral_internal_0(self) -> AbstractMap::State {
                    ::builtin::get_variant_field(self, "ephemeral_internal",
                        "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_commit_start(&self) -> bool {
                    ::builtin::is_variant(self, "commit_start")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_commit_complete(&self) -> bool {
                    ::builtin::is_variant(self, "commit_complete")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_crash(&self) -> bool {
                    ::builtin::is_variant(self, "crash")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Config { initialize(), dummy_to_use_type_params(State), }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Config {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_initialize(&self) -> bool {
                    ::builtin::is_variant(self, "initialize")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[verus::internal(verus_macro)]
            pub enum Label {
                LoadEphemeralFromPersistentLabel {
                    end_lsn: LSN,
                },
                PutRecordsLabel {
                    records: MsgHistory,
                },
                QueryLabel {
                    end_lsn: LSN,
                    key: Key,
                    value: Value,
                },
                InternalLabel,
                CommitStartLabel {
                    new_boundary_lsn: LSN,
                },
                CommitCompleteLabel,
                CrashLabel,
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Label {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_LoadEphemeralFromPersistentLabel(&self) -> bool {
                    ::builtin::is_variant(self,
                        "LoadEphemeralFromPersistentLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_LoadEphemeralFromPersistentLabel_end_lsn(self)
                    -> LSN {
                    ::builtin::get_variant_field(self,
                        "LoadEphemeralFromPersistentLabel", "end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_PutRecordsLabel(&self) -> bool {
                    ::builtin::is_variant(self, "PutRecordsLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_PutRecordsLabel_records(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "PutRecordsLabel",
                        "records")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_QueryLabel(&self) -> bool {
                    ::builtin::is_variant(self, "QueryLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_QueryLabel_end_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "QueryLabel", "end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_QueryLabel_key(self) -> Key {
                    ::builtin::get_variant_field(self, "QueryLabel", "key")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_QueryLabel_value(self) -> Value {
                    ::builtin::get_variant_field(self, "QueryLabel", "value")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_InternalLabel(&self) -> bool {
                    ::builtin::is_variant(self, "InternalLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_CommitStartLabel(&self) -> bool {
                    ::builtin::is_variant(self, "CommitStartLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_CommitStartLabel_new_boundary_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "CommitStartLabel",
                        "new_boundary_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_CommitCompleteLabel(&self) -> bool {
                    ::builtin::is_variant(self, "CommitCompleteLabel")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_CrashLabel(&self) -> bool {
                    ::builtin::is_variant(self, "CrashLabel")
                }
            }
            pub mod show {
                use super::*;
                use bool as load_ephemeral_from_persistent;
                use bool as put_records;
                use bool as query;
                use bool as freeze_map_internal;
                use bool as ephemeral_internal;
                use bool as commit_start;
                use bool as commit_complete;
                use bool as crash;
                use bool as initialize;
            }
            pub mod take_step {
                use super::*;
            }
            #[verus::internal(verus_macro)]
            impl State { }
        }
    }
    pub mod AbstractCrashTolerantSystem_v {
        /// AbstractCrashTolerantSystem. Formerly named AbstractCoordinationSystem.
        /// Coordinates a map and a journal to present a unified map once abstracted.
        ///
        /// This is the final refinement layer before the top level trusted spec.
        use builtin::*;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        use vstd::prelude::*;
        use crate::spec::Messages_t::*;
        use crate::spec::MapSpec_t;
        use crate::spec::MapSpec_t::*;
        use crate::abstract_system::AbstractCrashAwareJournal_v::*;
        use crate::abstract_system::AbstractCrashAwareMap_v::*;
        use crate::abstract_system::StampedMap_v::*;
        use crate::abstract_system::MsgHistory_v::{MsgHistory, KeyedMessage};
        #[doc =
        " SyncReqId\'s are used to assign sync requests unique IDs. Actual value is meaningless beyond"]
        #[doc = " identifying a specific sync request."]
        type SyncReqId = nat;
        #[doc =
        " SyncReqs represents a set of outstanding sync requests. Sync requests are stored as key-value"]
        #[doc =
        " pairs: (key, map_lsn), where \"key\" is the sync request ID, and \"map_lsn\" was the last executed"]
        #[doc = " LSN on the map at the time the sync request was made."]
        type SyncReqs = Map<SyncReqId, LSN>;
        #[doc =
        " The ephemeral state of the Coordination Layer (when known)."]
        #[verus::internal(verus_macro)]
        pub struct Known {
            #[doc =
            " Tracks the set of outstanding client requests and undelivered replies. See MapSpec_t::EphemeralState."]
            pub progress: MapSpec_t::EphemeralState,
            #[doc = " The set of outstanding sync requests."]
            pub sync_reqs: SyncReqs,
            #[doc = " The LSN one past the end of "]
            pub map_lsn: LSN,
        }
        #[doc =
        " Ephemeral state for coordination layer can be known or unknown. The ephemeral"]
        #[doc =
        " state is known if the Option type is Some, and unknown if the Option type is"]
        #[doc = " None."]
        type Ephemeral = Option<Known>;
        #[allow(unused_parens)]
        pub mod CoordinationSystem {
            use super::*;
            #[verus::internal(verus_macro)]
            pub struct State {
                pub journal: CrashTolerantJournal::State,
                pub mapadt: CrashTolerantMap::State,
                pub ephemeral: Ephemeral,
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Step {
                load_ephemeral_from_persistent(CrashTolerantJournal::State,
                    CrashTolerantMap::State, LSN),
                recover(CrashTolerantJournal::State, CrashTolerantMap::State,
                    MsgHistory),
                accept_request(),
                query(CrashTolerantJournal::State, CrashTolerantMap::State),
                put(CrashTolerantJournal::State, CrashTolerantMap::State),
                deliver_reply(),
                journal_internal(CrashTolerantJournal::State),
                map_internal(CrashTolerantMap::State),
                req_sync(CrashTolerantJournal::State),
                reply_sync(CrashTolerantJournal::State),
                commit_start(LSN, CrashTolerantMap::State,
                    CrashTolerantJournal::State),
                commit_complete(CrashTolerantMap::State,
                    CrashTolerantJournal::State),
                crash(CrashTolerantJournal::State, CrashTolerantMap::State),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Step {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_load_ephemeral_from_persistent(&self) -> bool {
                    ::builtin::is_variant(self,
                        "load_ephemeral_from_persistent")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_load_ephemeral_from_persistent_0(self)
                    -> CrashTolerantJournal::State {
                    ::builtin::get_variant_field(self,
                        "load_ephemeral_from_persistent", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_load_ephemeral_from_persistent_1(self)
                    -> CrashTolerantMap::State {
                    ::builtin::get_variant_field(self,
                        "load_ephemeral_from_persistent", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_load_ephemeral_from_persistent_2(self) -> LSN {
                    ::builtin::get_variant_field(self,
                        "load_ephemeral_from_persistent", "2")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_recover(&self) -> bool {
                    ::builtin::is_variant(self, "recover")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_recover_0(self) -> CrashTolerantJournal::State {
                    ::builtin::get_variant_field(self, "recover", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_recover_1(self) -> CrashTolerantMap::State {
                    ::builtin::get_variant_field(self, "recover", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_recover_2(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "recover", "2")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_accept_request(&self) -> bool {
                    ::builtin::is_variant(self, "accept_request")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_query(&self) -> bool {
                    ::builtin::is_variant(self, "query")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_query_0(self) -> CrashTolerantJournal::State {
                    ::builtin::get_variant_field(self, "query", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_query_1(self) -> CrashTolerantMap::State {
                    ::builtin::get_variant_field(self, "query", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_put(&self) -> bool {
                    ::builtin::is_variant(self, "put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_put_0(self) -> CrashTolerantJournal::State {
                    ::builtin::get_variant_field(self, "put", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_put_1(self) -> CrashTolerantMap::State {
                    ::builtin::get_variant_field(self, "put", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_deliver_reply(&self) -> bool {
                    ::builtin::is_variant(self, "deliver_reply")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_journal_internal(&self) -> bool {
                    ::builtin::is_variant(self, "journal_internal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_journal_internal_0(self)
                    -> CrashTolerantJournal::State {
                    ::builtin::get_variant_field(self, "journal_internal", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_map_internal(&self) -> bool {
                    ::builtin::is_variant(self, "map_internal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_map_internal_0(self) -> CrashTolerantMap::State {
                    ::builtin::get_variant_field(self, "map_internal", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_req_sync(&self) -> bool {
                    ::builtin::is_variant(self, "req_sync")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_req_sync_0(self) -> CrashTolerantJournal::State {
                    ::builtin::get_variant_field(self, "req_sync", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_reply_sync(&self) -> bool {
                    ::builtin::is_variant(self, "reply_sync")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_reply_sync_0(self) -> CrashTolerantJournal::State {
                    ::builtin::get_variant_field(self, "reply_sync", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_commit_start(&self) -> bool {
                    ::builtin::is_variant(self, "commit_start")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_commit_start_0(self) -> LSN {
                    ::builtin::get_variant_field(self, "commit_start", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_commit_start_1(self) -> CrashTolerantMap::State {
                    ::builtin::get_variant_field(self, "commit_start", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_commit_start_2(self)
                    -> CrashTolerantJournal::State {
                    ::builtin::get_variant_field(self, "commit_start", "2")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_commit_complete(&self) -> bool {
                    ::builtin::is_variant(self, "commit_complete")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_commit_complete_0(self)
                    -> CrashTolerantMap::State {
                    ::builtin::get_variant_field(self, "commit_complete", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_commit_complete_1(self)
                    -> CrashTolerantJournal::State {
                    ::builtin::get_variant_field(self, "commit_complete", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_crash(&self) -> bool {
                    ::builtin::is_variant(self, "crash")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_crash_0(self) -> CrashTolerantJournal::State {
                    ::builtin::get_variant_field(self, "crash", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_crash_1(self) -> CrashTolerantMap::State {
                    ::builtin::get_variant_field(self, "crash", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Config {
                initialize(CoordinationSystem::State),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Config {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_initialize(&self) -> bool {
                    ::builtin::is_variant(self, "initialize")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_initialize_0(self) -> CoordinationSystem::State {
                    ::builtin::get_variant_field(self, "initialize", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[verus::internal(verus_macro)]
            pub enum Label {
                Label {
                    ctam_label: CrashTolerantAsyncMap::Label,
                },
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Label {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_Label(&self) -> bool {
                    ::builtin::is_variant(self, "Label")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_Label_ctam_label(self)
                    -> CrashTolerantAsyncMap::Label {
                    ::builtin::get_variant_field(self, "Label", "ctam_label")
                }
            }
            pub mod show {
                use super::*;
                use bool as load_ephemeral_from_persistent;
                use bool as recover;
                use bool as accept_request;
                use bool as query;
                use bool as put;
                use bool as deliver_reply;
                use bool as journal_internal;
                use bool as map_internal;
                use bool as req_sync;
                use bool as reply_sync;
                use bool as commit_start;
                use bool as commit_complete;
                use bool as crash;
                use bool as initialize;
            }
            pub mod take_step {
                use super::*;
            }
            #[verus::internal(verus_macro)]
            impl State { }
        }
    }
    pub mod AbstractCrashTolerantSystemRefinement_v {
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        use vstd::map::*;
        use vstd::prelude::*;
        use vstd::seq_lib::*;
        use vstd::set_lib::*;
        use crate::spec::FloatingSeq_t::*;
        use crate::spec::MapSpec_t;
        use crate::spec::MapSpec_t::*;
        use crate::spec::Messages_t::*;
        use crate::spec::Option_t;
        use crate::spec::TotalKMMap_t;
        use crate::abstract_system::AbstractCrashAwareJournal_v;
        use crate::abstract_system::AbstractCrashAwareJournal_v::*;
        use crate::abstract_system::AbstractCrashAwareMap_v;
        use crate::abstract_system::AbstractCrashAwareMap_v::*;
        use crate::abstract_system::AbstractCrashTolerantSystem_v::*;
        use crate::abstract_system::AbstractJournal_v::AbstractJournal;
        use crate::abstract_system::AbstractMap_v::*;
        use crate::abstract_system::MsgHistory_v::{KeyedMessage, MsgHistory};
        use crate::abstract_system::StampedMap_v::*;
        #[verus::internal(verus_macro)]
        impl CrashTolerantJournal::State {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> MsgHistory {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        impl CrashTolerantMap::State {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> StampedMap {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        type Journal = MsgHistory;
        #[verus::internal(verus_macro)]
        impl CoordinationSystem::State {
            #[doc =
            " Return the \"seq_end\" of the ephemeral (most up-to-date, not necessarily persisted)"]
            #[doc = " state."]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn ephemeral_seq_end(self) -> LSN {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[doc =
            " Return the CrashTolerantAsyncMap state that this CoordinationSystem state"]
            #[doc = " corresponds to. (Interpretation function)."]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> CrashTolerantAsyncMap::State {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[doc =
        " Convert a StampedMap to a Version. (Both are representations of a map\'s concrete"]
        #[doc =
        " state (key-value pairs), Version just doesn\'t have seq_end)."]
        #[verus::internal(verus_macro)]
        impl StampedMap {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn to_version(self) -> Version {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[doc =
        " Return a FloatingSeq `s` of Versions (map state snapshots), with active"]
        #[doc =
        " indices in the range [stable_lsn, msg_history.seq_end], where"]
        #[doc =
        " `s[stable_lsn + i]` is the state of the map after the first `i` active"]
        #[doc = " operations in `msg_history` have been applied to `base`."]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn floating_versions(base: StampedMap, msg_history: MsgHistory,
            stable_lsn: LSN) -> FloatingSeq<Version> {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(verus_macro)]
        impl CoordinationSystem::State { }
        #[verus::internal(closed)]
        #[verus::internal(spec(checked))]
        pub fn journal_overlaps_agree(j0: Journal, j1: Journal) -> bool {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn journal_extends_journal(jlong: Journal, jshort: Journal,
            start_lsn: LSN) -> bool {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(verus_macro)]
        impl CoordinationSystem::State {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn inv_persistent_journal_geometry(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn inv_ephemeral_geometry(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn inv_ephemeral_value_agreement(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn map_is_frozen(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn commit_started(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn inv_frozen_map_geometry(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn inv_frozen_map_value_agreement(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn inv_commit_started_geometry(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn inv_commit_started_value_agreement(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn inv(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(proof)]
        pub fn lemma_init_refines(v: CoordinationSystem::State) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(proof)]
        pub fn commit_step_preserves_history(v: CoordinationSystem::State,
            vp: CoordinationSystem::State, label: CoordinationSystem::Label,
            step: CoordinationSystem::Step, lsn: LSN) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(proof)]
        pub fn journal_associativity(x: StampedMap, y: MsgHistory,
            z: MsgHistory) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(proof)]
        pub fn inv_inductive_put_step(v: CoordinationSystem::State,
            vp: CoordinationSystem::State, label: CoordinationSystem::Label,
            step: CoordinationSystem::Step) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(proof)]
        pub fn inv_inductive_commit_start_step(v: CoordinationSystem::State,
            vp: CoordinationSystem::State, label: CoordinationSystem::Label,
            step: CoordinationSystem::Step) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(proof)]
        pub fn inv_inductive_commit_complete_step(v:
                CoordinationSystem::State, vp: CoordinationSystem::State,
            label: CoordinationSystem::Label,
            step: CoordinationSystem::Step) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(proof)]
        pub fn inv_inductive(v: CoordinationSystem::State,
            vp: CoordinationSystem::State, label: CoordinationSystem::Label) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(proof)]
        pub fn put_step_refines(v: CoordinationSystem::State,
            vp: CoordinationSystem::State, label: CoordinationSystem::Label,
            step: CoordinationSystem::Step) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[doc =
        " Proof that a \"commit_complete\" transition maps to a \"sync\" transition"]
        #[doc = " in abstract CrashTolerantAsyncMap."]
        #[verus::internal(proof)]
        pub fn commit_complete_step_refines(v: CoordinationSystem::State,
            vp: CoordinationSystem::State, label: CoordinationSystem::Label,
            step: CoordinationSystem::Step) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[doc =
        " Proof that a \"Crash\" transition maps to a \"Crash\" transition"]
        #[doc = " in abstract CrashTolerantAsyncMap."]
        #[verus::internal(proof)]
        pub fn crash_step_refines(v: CoordinationSystem::State,
            vp: CoordinationSystem::State, label: CoordinationSystem::Label,
            step: CoordinationSystem::Step) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[doc =
        " Proof that all transitions which map to no-ops in the refined state machine can be"]
        #[doc = " refined to, well, no-ops."]
        #[verus::internal(proof)]
        pub fn noop_steps_refine(v: CoordinationSystem::State,
            vp: CoordinationSystem::State, label: CoordinationSystem::Label,
            step: CoordinationSystem::Step) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(proof)]
        pub fn query_step_refines(v: CoordinationSystem::State,
            vp: CoordinationSystem::State, label: CoordinationSystem::Label,
            step: CoordinationSystem::Step) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(proof)]
        pub fn accept_request_step_and_deliver_reply_step_refine(v:
                CoordinationSystem::State, vp: CoordinationSystem::State,
            label: CoordinationSystem::Label,
            step: CoordinationSystem::Step) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(proof)]
        pub fn req_sync_step_and_reply_sync_step_refine(v:
                CoordinationSystem::State, vp: CoordinationSystem::State,
            label: CoordinationSystem::Label,
            step: CoordinationSystem::Step) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(proof)]
        pub fn next_refines(v: CoordinationSystem::State,
            vp: CoordinationSystem::State, label: CoordinationSystem::Label) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
    }
}
mod betree {
    pub mod Buffer_v {
        use builtin_macros::*;
        use vstd::{map::*, set::*};
        use crate::spec::KeyType_t::*;
        use crate::spec::Messages_t::*;
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn all_keys() -> Set<Key> {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn total_keys(keys: Set<Key>) -> bool {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct Buffer {
            pub map: Map<Key, Message>,
        }
        #[verus::internal(verus_macro)]
        impl Buffer {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn query(self, key: Key) -> Message {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn apply_filter(self, accept: Set<Key>) -> Buffer {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn merge(self, new_buffer: Buffer) -> Buffer {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn empty() -> Buffer {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn insert(self, key: Key, msg: Message) -> Buffer {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
    }
    pub mod BufferSeq_v {
        use builtin::*;
        use builtin_macros::*;
        use vstd::{*, seq::*, set::*};
        use crate::spec::KeyType_t::*;
        use crate::spec::Messages_t::*;
        use crate::betree::Buffer_v::*;
        use crate::betree::OffsetMap_v::*;
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct BufferSeq {
            pub buffers: Seq<Buffer>,
        }
        #[verus::internal(verus_macro)]
        impl BufferSeq {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn empty() -> BufferSeq {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn len(self) -> nat {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn spec_index(self, i: int) -> Buffer {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn slice(self, start: int, end: int) -> BufferSeq {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn drop_first(self) -> BufferSeq {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn query_from(self, key: Key, start: int) -> Message {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn query(self, key: Key) -> Message {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn apply_filter(self, accept: Set<Key>) -> BufferSeq {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn extend(self, new_buffers: BufferSeq) -> BufferSeq {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn update_subrange(self, start: int, end: int,
                new_buffer: Buffer) -> BufferSeq {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i_from(self, idx: int) -> Buffer {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> Buffer {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn key_in_buffer(self, from_idx: int, k: Key, buffer_idx: int)
                -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn i_filtered_from(self, offset_map: OffsetMap, idx: int)
                -> Buffer {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i_filtered(self, offset_map: OffsetMap) -> Buffer {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn key_in_buffer_filtered(self, offset_map: OffsetMap,
                from_idx: int, k: Key, buffer_idx: int) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn query_agrees_with_i(self, k: Key, start: int) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn i_from_domain(self, idx: int) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn i_filtered_from_domain(self, offset_map: OffsetMap,
                idx: int) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn query_from_same_as_i_filtered(self, k: Key,
                buffer_idx: int, offset_map: OffsetMap) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn common_buffer_seqs(a: BufferSeq, b: BufferSeq,
                a_start: int, b_delta: int, key: Key) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn extend_buffer_seq_lemma(top: BufferSeq, bottom: BufferSeq,
                key: Key, start: int) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn not_present_query_lemma(self, k: Key, start: int) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
    }
    pub mod OffsetMap_v {
        use builtin::*;
        use builtin_macros::*;
        use vstd::{map::*, set::*};
        use crate::spec::KeyType_t::*;
        use crate::betree::Buffer_v::*;
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct OffsetMap {
            pub offsets: Map<Key, nat>,
        }
        #[verus::internal(verus_macro)]
        impl OffsetMap {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_total(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn get(self, k: Key) -> nat {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn active_keys(self, offset: nat) -> Set<Key> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn decrement(self, i: nat) -> OffsetMap {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
    }
    pub mod Memtable_v {
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use vstd::map::*;
        use crate::betree::Buffer_v::*;
        use crate::spec::Messages_t::*;
        use crate::spec::KeyType_t::*;
        use crate::abstract_system::StampedMap_v::*;
        use crate::abstract_system::MsgHistory_v::*;
        #[verus::internal(verus_macro)]
        pub struct Memtable {
            pub buffer: Buffer,
            pub seq_end: LSN,
        }
        #[verus::internal(verus_macro)]
        impl Memtable {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn query(self, key: Key) -> Message {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn apply_put(self, km: KeyedMessage) -> Memtable {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn apply_puts(self, puts: MsgHistory) -> Memtable {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn apply_puts_end(self, puts: MsgHistory) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn apply_puts_additive(self, puts1: MsgHistory,
                puts2: MsgHistory) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn empty_memtable(lsn: LSN) -> Memtable {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn drain(self) -> Memtable {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_empty(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
    }
    pub mod PagedBetree_v {
        use builtin::*;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        use vstd::prelude::*;
        use crate::spec::KeyType_t::*;
        use crate::spec::Messages_t::*;
        use crate::betree::Buffer_v::*;
        use crate::betree::Memtable_v::*;
        use crate::abstract_system::StampedMap_v::*;
        use crate::abstract_system::MsgHistory_v::*;
        pub type StampedBetree = Stamped<BetreeNode>;
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn empty_image() -> StampedBetree {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct ChildMap {
            pub map: Map<Key, BetreeNode>,
        }
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn constant_child_map(target: BetreeNode) -> ChildMap {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(verus_macro)]
        impl ChildMap {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn empty_child_map() -> ChildMap {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub enum BetreeNode {
            Nil,
            Node {
                buffer: Buffer,
                children: ChildMap,
            },
        }
        #[verus::internal(verus_macro)]
        #[cfg(verus_keep_ghost)]
        #[automatically_derived]
        impl BetreeNode {
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_Nil(&self) -> bool {
                ::builtin::is_variant(self, "Nil")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_Node(&self) -> bool {
                ::builtin::is_variant(self, "Node")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_Node_buffer(self) -> Buffer {
                ::builtin::get_variant_field(self, "Node", "buffer")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_Node_children(self) -> ChildMap {
                ::builtin::get_variant_field(self, "Node", "children")
            }
        }
        #[verus::internal(verus_macro)]
        impl BetreeNode {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn child(self, key: Key) -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn empty_root() -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn promote(self) -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn merge_buffer(self, new_buffer: Buffer) -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn push_memtable(self, memtable: Memtable) -> StampedBetree {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn filter_buffer_and_children(self, filter: Set<Key>)
                -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split(self, left_keys: Set<Key>, right_keys: Set<Key>)
                -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn flush(self, down_keys: Set<Key>) -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct QueryReceiptLine {
            pub node: BetreeNode,
            pub result: Message,
        }
        #[verus::internal(verus_macro)]
        impl QueryReceiptLine {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct QueryReceipt {
            pub key: Key,
            pub root: BetreeNode,
            pub lines: Seq<QueryReceiptLine>,
        }
        #[verus::internal(verus_macro)]
        impl QueryReceipt {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn structure(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn all_lines_wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn child_at(self, i: int) -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn child_linked_at(self, i: int) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn result_at(self, i: int) -> Message {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn result_linked_at(self, i: int) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn result(self) -> Message {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid_for(self, root: BetreeNode, key: Key) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct Path {
            pub node: BetreeNode,
            pub key: Key,
            pub routing: Seq<Set<Key>>,
        }
        #[verus::internal(verus_macro)]
        impl Path {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn subpath(self) -> Path {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn common_children(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn target(self) -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn replaced_children(self, replacement: BetreeNode)
                -> ChildMap {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn substitute(self, replacement: BetreeNode) -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[allow(unused_parens)]
        pub mod PagedBetree {
            use super::*;
            #[verus::internal(verus_macro)]
            pub struct State {
                pub memtable: Memtable,
                pub root: BetreeNode,
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Step {
                query(QueryReceipt),
                put(),
                freeze_as(),
                internal_flush_memtable(),
                internal_grow(),
                internal_split(Path, Set<Key>, Set<Key>),
                internal_flush(Path, Set<Key>),
                internal_noop(),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Step {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_query(&self) -> bool {
                    ::builtin::is_variant(self, "query")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_query_0(self) -> QueryReceipt {
                    ::builtin::get_variant_field(self, "query", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_put(&self) -> bool {
                    ::builtin::is_variant(self, "put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_freeze_as(&self) -> bool {
                    ::builtin::is_variant(self, "freeze_as")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_internal_flush_memtable(&self) -> bool {
                    ::builtin::is_variant(self, "internal_flush_memtable")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_internal_grow(&self) -> bool {
                    ::builtin::is_variant(self, "internal_grow")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_internal_split(&self) -> bool {
                    ::builtin::is_variant(self, "internal_split")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_split_0(self) -> Path {
                    ::builtin::get_variant_field(self, "internal_split", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_split_1(self) -> Set<Key> {
                    ::builtin::get_variant_field(self, "internal_split", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_split_2(self) -> Set<Key> {
                    ::builtin::get_variant_field(self, "internal_split", "2")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_internal_flush(&self) -> bool {
                    ::builtin::is_variant(self, "internal_flush")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_flush_0(self) -> Path {
                    ::builtin::get_variant_field(self, "internal_flush", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_flush_1(self) -> Set<Key> {
                    ::builtin::get_variant_field(self, "internal_flush", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_internal_noop(&self) -> bool {
                    ::builtin::is_variant(self, "internal_noop")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Config {
                initialize(StampedBetree),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Config {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_initialize(&self) -> bool {
                    ::builtin::is_variant(self, "initialize")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_initialize_0(self) -> StampedBetree {
                    ::builtin::get_variant_field(self, "initialize", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[verus::internal(verus_macro)]
            pub enum Label {
                Query {
                    end_lsn: LSN,
                    key: Key,
                    value: Value,
                },
                Put {
                    puts: MsgHistory,
                },
                FreezeAs {
                    stamped_betree: StampedBetree,
                },
                Internal {},
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Label {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_Query(&self) -> bool {
                    ::builtin::is_variant(self, "Query")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_Query_end_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "Query", "end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_Query_key(self) -> Key {
                    ::builtin::get_variant_field(self, "Query", "key")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_Query_value(self) -> Value {
                    ::builtin::get_variant_field(self, "Query", "value")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_Put(&self) -> bool {
                    ::builtin::is_variant(self, "Put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_Put_puts(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "Put", "puts")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_FreezeAs(&self) -> bool {
                    ::builtin::is_variant(self, "FreezeAs")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_FreezeAs_stamped_betree(self) -> StampedBetree {
                    ::builtin::get_variant_field(self, "FreezeAs",
                        "stamped_betree")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_Internal(&self) -> bool {
                    ::builtin::is_variant(self, "Internal")
                }
            }
            pub mod show {
                use super::*;
                use bool as query;
                use bool as put;
                use bool as freeze_as;
                use bool as internal_flush_memtable;
                use bool as internal_grow;
                use bool as internal_split;
                use bool as internal_flush;
                use bool as internal_noop;
                use bool as initialize;
            }
            pub mod take_step {
                use super::*;
            }
            #[verus::internal(verus_macro)]
            impl State {
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn wf(self) -> bool {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
            }
        }
    }
    pub mod PagedBetreeRefinement_v {
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use vstd::map::*;
        use crate::spec::KeyType_t::*;
        use crate::spec::Messages_t::*;
        use crate::spec::TotalKMMap_t::*;
        use crate::abstract_system::StampedMap_v::*;
        use crate::abstract_system::MsgHistory_v::*;
        use crate::abstract_system::AbstractMap_v::*;
        use crate::betree::PagedBetree_v::*;
        use crate::betree::Buffer_v::*;
        use crate::betree::Memtable_v::*;
        #[verus::internal(verus_macro)]
        impl BetreeNode {
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn build_query_receipt(self, key: Key) -> QueryReceipt {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn build_query_receipt_valid(self, key: Key) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn i_at(self, key: Key) -> Message {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> TotalKMMap {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn memtable_distributes_over_betree(self,
                memtable: Memtable) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn push_empty_memtable_refines(self, memtable: Memtable) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn merge_buffer_lemma(self, new_buffer: Buffer, key: Key) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn filter_buffer_and_children_wf(self, filter: Set<Key>) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn split_wf(self, left_keys: Set<Key>, right_keys: Set<Key>) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn apply_filter_equivalence(self, filter: Set<Key>,
                key: Key) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn flush_wf(self, down_keys: Set<Key>) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn map_apply(memtable: Memtable, base: TotalKMMap) -> TotalKMMap {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn i_stamped_betree(stamped: StampedBetree) -> StampedMap {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(verus_macro)]
        impl QueryReceipt {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn drop_first(self) -> QueryReceipt {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn drop_first_valid(self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn equal_receipts(self, other: QueryReceipt) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        impl Path {
            #[verus::internal(proof)]
            pub fn target_wf(self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn substitute_preserves_wf(self, replacement: BetreeNode) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn substitute_receipt_equivalence(self,
                replacement: BetreeNode, key: Key) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn substitute_equivalence(self, replacement: BetreeNode) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        impl PagedBetree::Label {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> AbstractMap::Label {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(proof)]
        pub fn composite_single_put(puts1: MsgHistory, puts2: MsgHistory,
            stamped_map: StampedMap) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(verus_macro)]
        impl PagedBetree::State {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn inv(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> AbstractMap::State {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn init_refines(self, stamped_betree: StampedBetree) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn query_refines(self, post: Self, lbl: PagedBetree::Label,
                receipt: QueryReceipt) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn apply_single_put_is_map_plus_history(self, post: Self,
                puts: MsgHistory) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn apply_put_is_map_plus_history(self, post: Self,
                puts: MsgHistory) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn put_refines(self, post: Self, lbl: PagedBetree::Label) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn freeze_as_refines(self, post: Self,
                lbl: PagedBetree::Label) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn internal_flush_memtable_noop(self, post: Self,
                lbl: PagedBetree::Label) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn equivalent_roots(self, post: Self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn internal_grow_noop(self, post: Self,
                lbl: PagedBetree::Label) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn internal_split_noop(self, post: Self,
                lbl: PagedBetree::Label, path: Path, left_keys: Set<Key>,
                right_keys: Set<Key>) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn internal_flush_noop(self, post: Self,
                lbl: PagedBetree::Label, path: Path, down_keys: Set<Key>) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn internal_noop_noop(self, post: Self,
                lbl: PagedBetree::Label) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn next_refines(self, post: Self, lbl: PagedBetree::Label) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
    }
    pub mod Domain_v {
        use builtin_macros::*;
        use vstd::set::*;
        use crate::spec::KeyType_t::*;
        #[verus::internal(verus_macro)]
        pub enum Domain {
            EmptyDomain,
            Domain {
                start: Element,
                end: Element,
            },
        }
        #[verus::internal(verus_macro)]
        #[cfg(verus_keep_ghost)]
        #[automatically_derived]
        impl Domain {
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_EmptyDomain(&self) -> bool {
                ::builtin::is_variant(self, "EmptyDomain")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_Domain(&self) -> bool {
                ::builtin::is_variant(self, "Domain")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_Domain_start(self) -> Element {
                ::builtin::get_variant_field(self, "Domain", "start")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_Domain_end(self) -> Element {
                ::builtin::get_variant_field(self, "Domain", "end")
            }
        }
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn total_domain() -> Domain {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(verus_macro)]
        impl Domain {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn contains(self, key: Key) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn key_set(self) -> Set<Key> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
    }
    pub mod PivotTable_v {
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use vstd::{*, map::*, seq::*, set::*};
        use crate::spec::KeyType_t::*;
        use crate::betree::Domain_v::*;
        #[verus::internal(verus_macro)]
        pub struct PivotTable {
            pub pivots: Seq<Element>,
        }
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn domain_to_pivots(domain: Domain) -> PivotTable {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(verus_macro)]
        impl PivotTable {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn num_ranges(self) -> int {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn len(self) -> nat {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn spec_index(self, i: int) -> Element {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn update(self, i: int, element: Element) -> PivotTable {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn subrange(self, start: int, end: int) -> PivotTable {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_insert(self, i: int, element: Element) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn insert(self, i: int, element: Element) -> PivotTable {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn insert_wf(self, idx: int, element: Element) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn bounded_key(self, key: Key) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn route(self, key: Key) -> int {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn route_lemma(self, key: Key) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn route_lemma_auto() {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn route_is_lemma(self, key: Key, r: int) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn route_is_lemma_auto() {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn pivot_range_keyset(self, i: int) -> Set<Key> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
    }
    pub mod PivotBetree_v {
        use builtin::*;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        use vstd::prelude::*;
        use crate::spec::KeyType_t::*;
        use crate::spec::Messages_t::*;
        use crate::betree::Buffer_v::*;
        use crate::betree::Memtable_v::*;
        use crate::betree::Domain_v::*;
        use crate::betree::PivotTable_v::*;
        use crate::betree::SplitRequest_v::*;
        use crate::abstract_system::StampedMap_v::*;
        use crate::abstract_system::MsgHistory_v::*;
        pub type StampedBetree = Stamped<BetreeNode>;
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn empty_image() -> StampedBetree {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub enum BetreeNode {
            Nil,
            Node {
                buffer: Buffer,
                pivots: PivotTable,
                children: Seq<BetreeNode>,
            },
        }
        #[verus::internal(verus_macro)]
        #[cfg(verus_keep_ghost)]
        #[automatically_derived]
        impl BetreeNode {
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_Nil(&self) -> bool {
                ::builtin::is_variant(self, "Nil")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_Node(&self) -> bool {
                ::builtin::is_variant(self, "Node")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_Node_buffer(self) -> Buffer {
                ::builtin::get_variant_field(self, "Node", "buffer")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_Node_pivots(self) -> PivotTable {
                ::builtin::get_variant_field(self, "Node", "pivots")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_Node_children(self) -> Seq<BetreeNode> {
                ::builtin::get_variant_field(self, "Node", "children")
            }
        }
        #[verus::internal(verus_macro)]
        impl BetreeNode {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn local_structure(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid_child_index(self, child_idx: nat) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn my_domain(self) -> Domain {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn child_domain(self, child_idx: nat) -> Domain {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn linked_children(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf_children(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn merge_buffer(self, new_buffer: Buffer) -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn push_memtable(self, memtable: Memtable) -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_leaf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_index(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_split_leaf(self, split_key: Key) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split_leaf(self, split_key: Key)
                -> (BetreeNode, BetreeNode) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_split_index(self, pivot_idx: nat) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split_index(self, pivot_idx: nat)
                -> (BetreeNode, BetreeNode) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_split_parent(self, request: SplitRequest) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split_parent(self, request: SplitRequest) -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn empty_root(domain: Domain) -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn grow(self) -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn promote(self, domain: Domain) -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_flush(self, child_idx: nat) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn flush(self, child_idx: nat) -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn key_in_domain(self, key: Key) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn child(self, key: Key) -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct QueryReceiptLine {
            pub node: BetreeNode,
            pub result: Message,
        }
        #[verus::internal(verus_macro)]
        impl QueryReceiptLine {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct QueryReceipt {
            pub key: Key,
            pub root: BetreeNode,
            pub lines: Seq<QueryReceiptLine>,
        }
        #[verus::internal(verus_macro)]
        impl QueryReceipt {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn structure(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn all_lines_wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn child_at(self, i: int) -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn child_linked_at(self, i: int) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn result_at(self, i: int) -> Message {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn result_linked_at(self, i: int) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn result(self) -> Message {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid_for(self, root: BetreeNode, key: Key) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct Path {
            pub node: BetreeNode,
            pub key: Key,
            pub depth: nat,
        }
        #[verus::internal(verus_macro)]
        impl Path {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn subpath(self) -> Path {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn target(self) -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn can_substitute(self, replacement: BetreeNode) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn replaced_children(self, replacement: BetreeNode)
                -> Seq<BetreeNode> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn substitute(self, replacement: BetreeNode) -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[allow(unused_parens)]
        pub mod PivotBetree {
            use super::*;
            #[verus::internal(verus_macro)]
            pub struct State {
                pub memtable: Memtable,
                pub root: BetreeNode,
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Step {
                query(QueryReceipt),
                put(),
                freeze_as(),
                internal_flush_memtable(),
                internal_grow(),
                internal_split(Path, SplitRequest),
                internal_flush(Path, nat),
                internal_noop(),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Step {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_query(&self) -> bool {
                    ::builtin::is_variant(self, "query")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_query_0(self) -> QueryReceipt {
                    ::builtin::get_variant_field(self, "query", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_put(&self) -> bool {
                    ::builtin::is_variant(self, "put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_freeze_as(&self) -> bool {
                    ::builtin::is_variant(self, "freeze_as")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_internal_flush_memtable(&self) -> bool {
                    ::builtin::is_variant(self, "internal_flush_memtable")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_internal_grow(&self) -> bool {
                    ::builtin::is_variant(self, "internal_grow")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_internal_split(&self) -> bool {
                    ::builtin::is_variant(self, "internal_split")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_split_0(self) -> Path {
                    ::builtin::get_variant_field(self, "internal_split", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_split_1(self) -> SplitRequest {
                    ::builtin::get_variant_field(self, "internal_split", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_internal_flush(&self) -> bool {
                    ::builtin::is_variant(self, "internal_flush")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_flush_0(self) -> Path {
                    ::builtin::get_variant_field(self, "internal_flush", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_flush_1(self) -> nat {
                    ::builtin::get_variant_field(self, "internal_flush", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_internal_noop(&self) -> bool {
                    ::builtin::is_variant(self, "internal_noop")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Config {
                initialize(StampedBetree),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Config {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_initialize(&self) -> bool {
                    ::builtin::is_variant(self, "initialize")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_initialize_0(self) -> StampedBetree {
                    ::builtin::get_variant_field(self, "initialize", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[verus::internal(verus_macro)]
            pub enum Label {
                Query {
                    end_lsn: LSN,
                    key: Key,
                    value: Value,
                },
                Put {
                    puts: MsgHistory,
                },
                FreezeAs {
                    stamped_betree: StampedBetree,
                },
                Internal {},
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Label {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_Query(&self) -> bool {
                    ::builtin::is_variant(self, "Query")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_Query_end_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "Query", "end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_Query_key(self) -> Key {
                    ::builtin::get_variant_field(self, "Query", "key")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_Query_value(self) -> Value {
                    ::builtin::get_variant_field(self, "Query", "value")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_Put(&self) -> bool {
                    ::builtin::is_variant(self, "Put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_Put_puts(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "Put", "puts")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_FreezeAs(&self) -> bool {
                    ::builtin::is_variant(self, "FreezeAs")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_FreezeAs_stamped_betree(self) -> StampedBetree {
                    ::builtin::get_variant_field(self, "FreezeAs",
                        "stamped_betree")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_Internal(&self) -> bool {
                    ::builtin::is_variant(self, "Internal")
                }
            }
            pub mod show {
                use super::*;
                use bool as query;
                use bool as put;
                use bool as freeze_as;
                use bool as internal_flush_memtable;
                use bool as internal_grow;
                use bool as internal_split;
                use bool as internal_flush;
                use bool as internal_noop;
                use bool as initialize;
            }
            pub mod take_step {
                use super::*;
            }
            #[verus::internal(verus_macro)]
            impl State {
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn wf(self) -> bool {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
            }
        }
    }
    pub mod PivotBetreeRefinement_v {
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use crate::spec::KeyType_t::*;
        use crate::abstract_system::StampedMap_v::*;
        use crate::betree::Domain_v::*;
        use crate::betree::PivotTable_v::*;
        use crate::betree::Buffer_v::*;
        use crate::betree::PagedBetree_v;
        use crate::betree::PagedBetree_v::PagedBetree;
        use crate::betree::PivotBetree_v::*;
        use crate::betree::SplitRequest_v::*;
        #[verus::internal(verus_macro)]
        impl BetreeNode {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i_children_seq(self, start: int)
                -> Seq<PagedBetree_v::BetreeNode> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i_children(self) -> PagedBetree_v::ChildMap {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> PagedBetree_v::BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i_child(self, k: Key) -> PagedBetree_v::BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn i_children_seq_lemma(self, start: int) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn i_children_seq_same(self, other: BetreeNode, start: int) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn i_children_lemma(self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn i_wf(self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn children_have_matching_domains(self,
                other_children: Seq<BetreeNode>) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn empty_root_refines() {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split_element(self, request: SplitRequest) -> Element {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn split_leaf_wf(self, split_key: Key) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn split_index_wf(self, pivot_idx: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn split_parent_wf(self, request: SplitRequest) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split_keys(self, request: SplitRequest)
                -> (Set<Key>, Set<Key>) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn split_keys_agrees_with_domains(self,
                request: SplitRequest) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn split_commutes_with_i_left(self, request: SplitRequest,
                key: Key) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn split_commutes_with_i_right(self, request: SplitRequest,
                key: Key) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn split_commutes_with_i_nonsplit(self, request: SplitRequest,
                key: Key) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn split_commutes_with_i(self, request: SplitRequest) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn promote_and_merge_wf(self, domain: Domain,
                buffer: Buffer) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn flush_wf(self, child_idx: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn promote_and_merge_commutes_with_i(self, domain: Domain,
                new_buffer: Buffer) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn flush_commutes_with_i(self, child_idx: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn i_stamped_betree(stamped: StampedBetree)
            -> PagedBetree_v::StampedBetree {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(verus_macro)]
        impl QueryReceiptLine {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> PagedBetree_v::QueryReceiptLine {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        impl QueryReceipt {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> PagedBetree_v::QueryReceipt {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn i_valid(self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        impl Path {
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn routing(self) -> Seq<Set<Key>> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn routing_lemma(self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn i(self) -> PagedBetree_v::Path {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn subpath_commutes_with_i(self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn i_valid(self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn target_wf(self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn target_commutes_with_i(self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn substitute_preserves_wf(self, replacement: BetreeNode) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verifier::spinoff_prover]
            #[verus::internal(proof)]
            pub fn replaced_children_matching_domains(self,
                replacement: BetreeNode) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn substitute_commutes_with_i(self, replacement: BetreeNode) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        impl PivotBetree::Label {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> PagedBetree::Label {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        impl PivotBetree::State {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn inv(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> PagedBetree::State {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn init_refines(self, stamped_betree: StampedBetree) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn query_refines(self, post: Self, lbl: PivotBetree::Label,
                receipt: QueryReceipt) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn put_refines(self, post: Self, lbl: PivotBetree::Label) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn freeze_as_refines(self, post: Self,
                lbl: PivotBetree::Label) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn internal_flush_memtable_refines(self, post: Self,
                lbl: PivotBetree::Label) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn internal_grow_refines(self, post: Self,
                lbl: PivotBetree::Label) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn internal_split_refines(self, post: Self,
                lbl: PivotBetree::Label, path: Path, request: SplitRequest) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn internal_flush_refines(self, post: Self,
                lbl: PivotBetree::Label, path: Path, child_idx: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn internal_noop_noop(self, post: Self,
                lbl: PivotBetree::Label) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn next_refines(self, post: Self, lbl: PivotBetree::Label) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
    }
    pub mod SplitRequest_v {
        #[allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use crate::spec::KeyType_t::*;
        #[verus::internal(verus_macro)]
        pub enum SplitRequest {
            SplitLeaf {
                child_idx: nat,
                split_key: Key,
            },
            SplitIndex {
                child_idx: nat,
                child_pivot_idx: nat,
            },
        }
        #[verus::internal(verus_macro)]
        #[cfg(verus_keep_ghost)]
        #[automatically_derived]
        impl SplitRequest {
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_SplitLeaf(&self) -> bool {
                ::builtin::is_variant(self, "SplitLeaf")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_SplitLeaf_child_idx(self) -> nat {
                ::builtin::get_variant_field(self, "SplitLeaf", "child_idx")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_SplitLeaf_split_key(self) -> Key {
                ::builtin::get_variant_field(self, "SplitLeaf", "split_key")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_SplitIndex(&self) -> bool {
                ::builtin::is_variant(self, "SplitIndex")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_SplitIndex_child_idx(self) -> nat {
                ::builtin::get_variant_field(self, "SplitIndex", "child_idx")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_SplitIndex_child_pivot_idx(self) -> nat {
                ::builtin::get_variant_field(self, "SplitIndex",
                    "child_pivot_idx")
            }
        }
        #[verus::internal(verus_macro)]
        impl SplitRequest {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn get_child_idx(self) -> nat {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
    }
    pub mod BufferOffsets_v {
        use builtin::*;
        use builtin_macros::*;
        use vstd::seq::*;
        #[verus::internal(verus_macro)]
        pub struct BufferOffsets {
            pub offsets: Seq<nat>,
        }
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn empty_bufer_offsets() -> BufferOffsets {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(verus_macro)]
        impl BufferOffsets {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn len(self) -> nat {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn slice(self, start: int, end: int) -> BufferOffsets {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn dup(self, idx: int) -> BufferOffsets {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn update(self, idx: int, value: nat) -> BufferOffsets {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn all_lte(self, target: nat) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn all_gte(self, target: nat) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn shift_left(self, target: nat) -> BufferOffsets {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn shift_left_preserves_lte(self, target: nat, limit: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn adjust_compact(self, start: int, end: int)
                -> BufferOffsets {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
    }
    pub mod FilteredBetree_v {
        use builtin::*;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        use vstd::prelude::*;
        use crate::spec::KeyType_t::*;
        use crate::spec::Messages_t::*;
        use crate::betree::Buffer_v::*;
        use crate::betree::BufferSeq_v::*;
        use crate::betree::BufferOffsets_v::*;
        use crate::betree::OffsetMap_v::*;
        use crate::betree::Memtable_v::*;
        use crate::betree::Domain_v::*;
        use crate::betree::PivotTable_v::*;
        use crate::betree::SplitRequest_v::*;
        use crate::abstract_system::StampedMap_v::*;
        use crate::abstract_system::MsgHistory_v::*;
        pub type StampedBetree = Stamped<BetreeNode>;
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn empty_image() -> StampedBetree {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub enum BetreeNode {
            Nil,
            Node {
                buffers: BufferSeq,
                pivots: PivotTable,
                children: Seq<BetreeNode>,
                flushed: BufferOffsets,
            },
        }
        #[verus::internal(verus_macro)]
        #[cfg(verus_keep_ghost)]
        #[automatically_derived]
        impl BetreeNode {
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_Nil(&self) -> bool {
                ::builtin::is_variant(self, "Nil")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_Node(&self) -> bool {
                ::builtin::is_variant(self, "Node")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_Node_buffers(self) -> BufferSeq {
                ::builtin::get_variant_field(self, "Node", "buffers")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_Node_pivots(self) -> PivotTable {
                ::builtin::get_variant_field(self, "Node", "pivots")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_Node_children(self) -> Seq<BetreeNode> {
                ::builtin::get_variant_field(self, "Node", "children")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_Node_flushed(self) -> BufferOffsets {
                ::builtin::get_variant_field(self, "Node", "flushed")
            }
        }
        #[verus::internal(verus_macro)]
        impl BetreeNode {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn local_structure(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid_child_index(self, child_idx: nat) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn my_domain(self) -> Domain {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn child_domain(self, child_idx: nat) -> Domain {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn linked_children(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf_children(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn push_memtable(self, memtable: Memtable) -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn extend_buffer_seq(self, buffers: BufferSeq) -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verifier::recommends_by]
            #[verus::internal(proof)]
            pub fn flushed_ofs_inline_lemma(self, key: Key) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn flushed_ofs(self, key: Key) -> nat {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_leaf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_index(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_split_leaf(self, split_key: Key) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split_leaf(self, split_key: Key)
                -> (BetreeNode, BetreeNode) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_split_index(self, pivot_idx: nat) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split_index(self, pivot_idx: nat)
                -> (BetreeNode, BetreeNode) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_split_parent(self, request: SplitRequest) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split_parent(self, request: SplitRequest) -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn empty_root(domain: Domain) -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn grow(self) -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn promote(self, domain: Domain) -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_flush(self, child_idx: nat, buffer_gc: nat) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn flush(self, child_idx: nat, buffer_gc: nat) -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn compact_key_range(self, start: nat, end: nat, k: Key)
                -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn can_compact(self, start: nat, end: nat,
                compacted_buffer: Buffer) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn compact(self, start: nat, end: nat,
                compacted_buffer: Buffer) -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn key_in_domain(self, key: Key) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn child(self, key: Key) -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn make_offset_map(self) -> OffsetMap {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct QueryReceiptLine {
            pub node: BetreeNode,
            pub result: Message,
        }
        #[verus::internal(verus_macro)]
        impl QueryReceiptLine {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct QueryReceipt {
            pub key: Key,
            pub root: BetreeNode,
            pub lines: Seq<QueryReceiptLine>,
        }
        #[verus::internal(verus_macro)]
        impl QueryReceipt {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn structure(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn all_lines_wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn child_at(self, i: int) -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn child_linked_at(self, i: int) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn result_at(self, i: int) -> Message {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn result_linked_at(self, i: int) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn result(self) -> Message {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid_for(self, root: BetreeNode, key: Key) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct Path {
            pub node: BetreeNode,
            pub key: Key,
            pub depth: nat,
        }
        #[verus::internal(verus_macro)]
        impl Path {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn subpath(self) -> Path {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn target(self) -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn can_substitute(self, replacement: BetreeNode) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn replaced_children(self, replacement: BetreeNode)
                -> Seq<BetreeNode> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn substitute(self, replacement: BetreeNode) -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[allow(unused_parens)]
        pub mod FilteredBetree {
            use super::*;
            #[verus::internal(verus_macro)]
            pub struct State {
                pub memtable: Memtable,
                pub root: BetreeNode,
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Step {
                query(QueryReceipt),
                put(),
                freeze_as(),
                internal_flush_memtable(),
                internal_grow(),
                internal_split(Path, SplitRequest),
                internal_flush(Path, nat, nat),
                internal_compact(Path, nat, nat, Buffer),
                internal_noop(),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Step {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_query(&self) -> bool {
                    ::builtin::is_variant(self, "query")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_query_0(self) -> QueryReceipt {
                    ::builtin::get_variant_field(self, "query", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_put(&self) -> bool {
                    ::builtin::is_variant(self, "put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_freeze_as(&self) -> bool {
                    ::builtin::is_variant(self, "freeze_as")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_internal_flush_memtable(&self) -> bool {
                    ::builtin::is_variant(self, "internal_flush_memtable")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_internal_grow(&self) -> bool {
                    ::builtin::is_variant(self, "internal_grow")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_internal_split(&self) -> bool {
                    ::builtin::is_variant(self, "internal_split")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_split_0(self) -> Path {
                    ::builtin::get_variant_field(self, "internal_split", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_split_1(self) -> SplitRequest {
                    ::builtin::get_variant_field(self, "internal_split", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_internal_flush(&self) -> bool {
                    ::builtin::is_variant(self, "internal_flush")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_flush_0(self) -> Path {
                    ::builtin::get_variant_field(self, "internal_flush", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_flush_1(self) -> nat {
                    ::builtin::get_variant_field(self, "internal_flush", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_flush_2(self) -> nat {
                    ::builtin::get_variant_field(self, "internal_flush", "2")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_internal_compact(&self) -> bool {
                    ::builtin::is_variant(self, "internal_compact")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_compact_0(self) -> Path {
                    ::builtin::get_variant_field(self, "internal_compact", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_compact_1(self) -> nat {
                    ::builtin::get_variant_field(self, "internal_compact", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_compact_2(self) -> nat {
                    ::builtin::get_variant_field(self, "internal_compact", "2")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_compact_3(self) -> Buffer {
                    ::builtin::get_variant_field(self, "internal_compact", "3")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_internal_noop(&self) -> bool {
                    ::builtin::is_variant(self, "internal_noop")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Config {
                initialize(StampedBetree),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Config {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_initialize(&self) -> bool {
                    ::builtin::is_variant(self, "initialize")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_initialize_0(self) -> StampedBetree {
                    ::builtin::get_variant_field(self, "initialize", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[verus::internal(verus_macro)]
            pub enum Label {
                Query {
                    end_lsn: LSN,
                    key: Key,
                    value: Value,
                },
                Put {
                    puts: MsgHistory,
                },
                FreezeAs {
                    stamped_betree: StampedBetree,
                },
                Internal {},
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Label {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_Query(&self) -> bool {
                    ::builtin::is_variant(self, "Query")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_Query_end_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "Query", "end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_Query_key(self) -> Key {
                    ::builtin::get_variant_field(self, "Query", "key")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_Query_value(self) -> Value {
                    ::builtin::get_variant_field(self, "Query", "value")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_Put(&self) -> bool {
                    ::builtin::is_variant(self, "Put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_Put_puts(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "Put", "puts")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_FreezeAs(&self) -> bool {
                    ::builtin::is_variant(self, "FreezeAs")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_FreezeAs_stamped_betree(self) -> StampedBetree {
                    ::builtin::get_variant_field(self, "FreezeAs",
                        "stamped_betree")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_Internal(&self) -> bool {
                    ::builtin::is_variant(self, "Internal")
                }
            }
            pub mod show {
                use super::*;
                use bool as query;
                use bool as put;
                use bool as freeze_as;
                use bool as internal_flush_memtable;
                use bool as internal_grow;
                use bool as internal_split;
                use bool as internal_flush;
                use bool as internal_compact;
                use bool as internal_noop;
                use bool as initialize;
            }
            pub mod take_step {
                use super::*;
            }
            #[verus::internal(verus_macro)]
            impl State {
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn wf(self) -> bool {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
            }
        }
    }
    pub mod FilteredBetreeRefinement_v {
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use vstd::map::*;
        use vstd::seq_lib::*;
        use crate::spec::KeyType_t::*;
        use crate::spec::Messages_t::*;
        use crate::abstract_system::StampedMap_v::*;
        use crate::betree::Domain_v::*;
        use crate::betree::PivotTable_v::*;
        use crate::betree::Buffer_v::*;
        use crate::betree::BufferSeq_v::*;
        use crate::betree::BufferOffsets_v::*;
        use crate::betree::OffsetMap_v::*;
        use crate::betree::PivotBetree_v;
        use crate::betree::PivotBetree_v::PivotBetree;
        use crate::betree::FilteredBetree_v::*;
        use crate::betree::SplitRequest_v::*;
        #[verus::internal(verus_macro)]
        impl BetreeNode {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i_buffer(self) -> Buffer {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn i_children_seq(self, start: int)
                -> Seq<PivotBetree_v::BetreeNode> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i_children(self) -> Seq<PivotBetree_v::BetreeNode> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> PivotBetree_v::BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn i_children_seq_lemma(self, start: int) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn i_children_lemma(self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn i_children_lemma_auto() {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn i_wf(self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn i_wf_auto() {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn i_buffer_domain(self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn query_from_refines(self, key: Key) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn query_from_refines_auto() {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn children_have_matching_domains(self,
                other_children: Seq<BetreeNode>) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn i_preserves_domain(self, other: BetreeNode, k: Key) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn i_preserves_domain_auto(self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn child_domain_implies_key_in_domain(self, child_idx: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn extend_buffer_seq_wf(self, buffers: BufferSeq) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn extend_buffer_seq_refines_merge_buffer(self,
                buffers: BufferSeq) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn promote_commutes_with_i(self, domain: Domain) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split_element(self, request: SplitRequest) -> Element {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn split_leaf_wf(self, split_key: Key) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn split_index_wf(self, pivot_idx: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn split_parent_wf(self, request: SplitRequest) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verifier::spinoff_prover]
            #[verus::internal(proof)]
            pub fn split_leaf_commutes_with_i(self, split_key: Key) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn split_index_commutes_with_i(self, pivot_idx: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn split_parent_buffers_commutes_with_i(self,
                request: SplitRequest) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn split_parent_commutes_with_i(self, request: SplitRequest) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn flush_wf(self, child_idx: nat, buffer_gc: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn flush_commutes_with_i(self, child_idx: nat,
                buffer_gc: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verifier::spinoff_prover]
            #[verus::internal(proof)]
            pub fn compact_wf(self, start: nat, end: nat,
                compacted_buffer: Buffer) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn compact_buffer_property(self, start: nat, end: nat,
                compacted_buffer: Buffer) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verifier::spinoff_prover]
            #[verus::internal(proof)]
            pub fn compact_commutes_with_i(self, start: nat, end: nat,
                compacted_buffer: Buffer) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn i_stamped_betree(stamped: StampedBetree)
            -> PivotBetree_v::StampedBetree {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(verus_macro)]
        impl QueryReceiptLine {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> PivotBetree_v::QueryReceiptLine {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        impl QueryReceipt {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> PivotBetree_v::QueryReceipt {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn i_valid(self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        impl Path {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> PivotBetree_v::Path {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn subpath_commutes_with_i(self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn i_valid(self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn target_wf(self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn target_commutes_with_i(self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn substitute_preserves_wf(self, replacement: BetreeNode) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn replaced_children_matching_domains(self,
                replacement: BetreeNode) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn substitute_commutes_with_i(self, replacement: BetreeNode) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn substitute_noop(self, replacement: BetreeNode) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        impl FilteredBetree::Label {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> PivotBetree::Label {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        impl FilteredBetree::State {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn inv(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> PivotBetree::State {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn init_refines(self, stamped_betree: StampedBetree) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn query_refines(self, post: Self, lbl: FilteredBetree::Label,
                receipt: QueryReceipt) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn put_refines(self, post: Self, lbl: FilteredBetree::Label) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn freeze_as_refines(self, post: Self,
                lbl: FilteredBetree::Label) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn internal_flush_memtable_refines(self, post: Self,
                lbl: FilteredBetree::Label) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn internal_grow_refines(self, post: Self,
                lbl: FilteredBetree::Label) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn internal_split_refines(self, post: Self,
                lbl: FilteredBetree::Label, path: Path,
                request: SplitRequest) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn internal_flush_refines(self, post: Self,
                lbl: FilteredBetree::Label, path: Path, child_idx: nat,
                buffer_gc: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn internal_compact_refines(self, post: Self,
                lbl: FilteredBetree::Label, path: Path, start: nat, end: nat,
                compacted_buffer: Buffer) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn internal_noop_noop(self, post: Self,
                lbl: FilteredBetree::Label) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn next_refines(self, post: Self,
                lbl: FilteredBetree::Label) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
    }
    pub mod LinkedBetree_v {
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        use vstd::prelude::*;
        use crate::spec::KeyType_t::*;
        use crate::spec::Messages_t::*;
        use crate::disk::GenericDisk_v::*;
        use crate::betree::Buffer_v::*;
        use crate::betree::LinkedBufferSeq_v;
        use crate::betree::LinkedBufferSeq_v::BufferSeq;
        use crate::betree::BufferOffsets_v::*;
        use crate::betree::OffsetMap_v::*;
        use crate::betree::Memtable_v::*;
        use crate::betree::Domain_v::*;
        use crate::betree::PivotTable_v::*;
        use crate::betree::SplitRequest_v::*;
        use crate::abstract_system::StampedMap_v::*;
        use crate::abstract_system::MsgHistory_v::*;
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct BetreeNode {
            pub buffers: BufferSeq,
            pub pivots: PivotTable,
            pub children: Seq<Pointer>,
            pub flushed: BufferOffsets,
        }
        pub type BufferDiskView = LinkedBufferSeq_v::DiskView;
        #[verus::internal(verus_macro)]
        impl BetreeNode {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid_child_index(self, child_idx: nat) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn occupied_child_index(self, child_idx: nat) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn my_domain(self) -> Domain {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn child_domain(self, child_idx: nat) -> Domain {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn extend_buffer_seq(self, buffers: BufferSeq) -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verifier::recommends_by]
            #[verus::internal(proof)]
            pub fn flushed_ofs_inline_lemma(self, key: Key) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn flushed_ofs(self, key: Key) -> nat {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_leaf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_index(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_split_leaf(self, split_key: Key) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split_leaf(self, split_key: Key)
                -> (BetreeNode, BetreeNode) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_split_index(self, pivot_idx: nat) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split_index(self, pivot_idx: nat)
                -> (BetreeNode, BetreeNode) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn empty_root(domain: Domain) -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn compact_key_range(self, start: nat, end: nat, k: Key,
                buffer_dv: BufferDiskView) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn compact_key_value(self, start: nat, end: nat, k: Key,
                buffer_dv: BufferDiskView) -> Message {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn key_in_domain(self, key: Key) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn child_ptr(self, key: Key) -> Pointer {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn make_offset_map(self) -> OffsetMap {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct DiskView {
            pub entries: Map<Address, BetreeNode>,
        }
        #[verus::internal(verus_macro)]
        impl DiskView {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn entries_wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_nondangling_ptr(self, ptr: Pointer) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn node_has_nondangling_child_ptrs(self, node: BetreeNode)
                -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn child_linked(self, node: BetreeNode, idx: nat) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn node_has_linked_children(self, node: BetreeNode) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn healthy_child_ptrs(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn get(self, ptr: Pointer) -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn agrees_with_disk(self, other: DiskView) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_subdisk(self, bigger: DiskView) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn node_children_respects_rank(self, ranking: Ranking,
                addr: Address) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid_ranking(self, ranking: Ranking) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_fresh(self, addrs: Set<Address>) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn modify_disk(self, addr: Address, node: BetreeNode)
                -> DiskView {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn no_dangling_buffer_ptr(self, buffer_dv: BufferDiskView)
                -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn empty_disk() -> DiskView {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(verus_macro)]
        pub struct TwoAddrs {
            pub addr1: Address,
            pub addr2: Address,
        }
        #[verus::internal(verus_macro)]
        impl TwoAddrs {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn no_duplicates(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn repr(self) -> Set<Address> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct SplitAddrs {
            pub left: Address,
            pub right: Address,
            pub parent: Address,
        }
        #[verus::internal(verus_macro)]
        impl SplitAddrs {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn no_duplicates(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn repr(self) -> Set<Address> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct LinkedBetree {
            pub root: Pointer,
            pub dv: DiskView,
            pub buffer_dv: BufferDiskView,
        }
        pub type StampedBetree = Stamped<LinkedBetree>;
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn empty_linked_betree() -> LinkedBetree {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn empty_image() -> StampedBetree {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(verus_macro)]
        impl LinkedBetree {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn has_root(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn root(self) -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid_ranking(self, ranking: Ranking) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn acyclic(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn the_ranking(self) -> Ranking {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_fresh(self, addrs: Set<Address>) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn child_at_idx(self, idx: nat) -> LinkedBetree {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn child_for_key(self, k: Key) -> LinkedBetree {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn get_rank(self, ranking: Ranking) -> nat {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn child_count(self) -> nat {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_recurse_for_reachable(self, ranking: Ranking,
                child_idx: nat) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verifier::decreases_by]
            #[verus::internal(proof)]
            pub fn reachable_addrs_using_ranking_recur_proof(self,
                ranking: Ranking, child_idx: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn reachable_addrs_using_ranking_recur(self, ranking: Ranking,
                child_idx: nat) -> Set<Address> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn reachable_addrs_using_ranking(self, ranking: Ranking)
                -> Set<Address> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn reachable_betree_addrs(self) -> Set<Address> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn reachable_buffer(self, addr: Address, buffer_addr: Address)
                -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn reachable_buffer_addrs(self) -> Set<Address> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn build_tight_tree(self) -> LinkedBetree {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn push_memtable(self, memtable: Memtable,
                new_addrs: TwoAddrs) -> LinkedBetree {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn grow(self, new_root_addr: Address) -> LinkedBetree {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_split_parent(self, request: SplitRequest) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split_parent(self, request: SplitRequest,
                new_addrs: SplitAddrs) -> LinkedBetree {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_flush(self, child_idx: nat, buffer_gc: nat) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn flush(self, child_idx: nat, buffer_gc: nat,
                new_addrs: TwoAddrs) -> LinkedBetree {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_compact(self, start: nat, end: nat,
                compacted_buffer: Buffer) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn compact(self, start: nat, end: nat,
                compacted_buffer: Buffer, new_addrs: TwoAddrs)
                -> LinkedBetree {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct QueryReceiptLine {
            pub linked: LinkedBetree,
            pub result: Message,
        }
        #[verus::internal(verus_macro)]
        impl QueryReceiptLine {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct QueryReceipt {
            pub key: Key,
            pub linked: LinkedBetree,
            pub lines: Seq<QueryReceiptLine>,
        }
        #[verus::internal(verus_macro)]
        impl QueryReceipt {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn structure(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn node(self, i: int) -> BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn all_lines_wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn child_linked_at(self, i: int) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn result_at(self, i: int) -> Message {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn result_linked_at(self, i: int) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn result(self) -> Message {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid_for(self, linked: LinkedBetree, key: Key) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        pub type PathAddrs = Seq<Address>;
        #[verus::internal(verus_macro)]
        pub struct Path {
            pub linked: LinkedBetree,
            pub key: Key,
            pub depth: nat,
        }
        #[verus::internal(verus_macro)]
        impl Path {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn subpath(self) -> Path {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn target(self) -> LinkedBetree {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn addrs_on_path(self) -> Set<Address> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn can_substitute(self, replacement: LinkedBetree,
                path_addrs: PathAddrs) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn substitute(self, replacement: LinkedBetree,
                path_addrs: PathAddrs) -> LinkedBetree {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[allow(unused_parens)]
        pub mod LinkedBetreeVars {
            use super::*;
            #[verus::internal(verus_macro)]
            pub struct State {
                pub memtable: Memtable,
                pub linked: LinkedBetree,
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Step {
                query(QueryReceipt),
                put(),
                freeze_as(),
                internal_flush_memtable(TwoAddrs),
                internal_grow(Address),
                internal_split(Path, SplitRequest, SplitAddrs, PathAddrs),
                internal_flush(Path, nat, nat, TwoAddrs, PathAddrs),
                internal_compact(Path, nat, nat, Buffer, TwoAddrs, PathAddrs),
                internal_noop(),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Step {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_query(&self) -> bool {
                    ::builtin::is_variant(self, "query")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_query_0(self) -> QueryReceipt {
                    ::builtin::get_variant_field(self, "query", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_put(&self) -> bool {
                    ::builtin::is_variant(self, "put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_freeze_as(&self) -> bool {
                    ::builtin::is_variant(self, "freeze_as")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_internal_flush_memtable(&self) -> bool {
                    ::builtin::is_variant(self, "internal_flush_memtable")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_flush_memtable_0(self) -> TwoAddrs {
                    ::builtin::get_variant_field(self,
                        "internal_flush_memtable", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_internal_grow(&self) -> bool {
                    ::builtin::is_variant(self, "internal_grow")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_grow_0(self) -> Address {
                    ::builtin::get_variant_field(self, "internal_grow", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_internal_split(&self) -> bool {
                    ::builtin::is_variant(self, "internal_split")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_split_0(self) -> Path {
                    ::builtin::get_variant_field(self, "internal_split", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_split_1(self) -> SplitRequest {
                    ::builtin::get_variant_field(self, "internal_split", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_split_2(self) -> SplitAddrs {
                    ::builtin::get_variant_field(self, "internal_split", "2")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_split_3(self) -> PathAddrs {
                    ::builtin::get_variant_field(self, "internal_split", "3")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_internal_flush(&self) -> bool {
                    ::builtin::is_variant(self, "internal_flush")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_flush_0(self) -> Path {
                    ::builtin::get_variant_field(self, "internal_flush", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_flush_1(self) -> nat {
                    ::builtin::get_variant_field(self, "internal_flush", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_flush_2(self) -> nat {
                    ::builtin::get_variant_field(self, "internal_flush", "2")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_flush_3(self) -> TwoAddrs {
                    ::builtin::get_variant_field(self, "internal_flush", "3")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_flush_4(self) -> PathAddrs {
                    ::builtin::get_variant_field(self, "internal_flush", "4")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_internal_compact(&self) -> bool {
                    ::builtin::is_variant(self, "internal_compact")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_compact_0(self) -> Path {
                    ::builtin::get_variant_field(self, "internal_compact", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_compact_1(self) -> nat {
                    ::builtin::get_variant_field(self, "internal_compact", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_compact_2(self) -> nat {
                    ::builtin::get_variant_field(self, "internal_compact", "2")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_compact_3(self) -> Buffer {
                    ::builtin::get_variant_field(self, "internal_compact", "3")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_compact_4(self) -> TwoAddrs {
                    ::builtin::get_variant_field(self, "internal_compact", "4")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_compact_5(self) -> PathAddrs {
                    ::builtin::get_variant_field(self, "internal_compact", "5")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_internal_noop(&self) -> bool {
                    ::builtin::is_variant(self, "internal_noop")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Config {
                initialize(StampedBetree),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Config {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_initialize(&self) -> bool {
                    ::builtin::is_variant(self, "initialize")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_initialize_0(self) -> StampedBetree {
                    ::builtin::get_variant_field(self, "initialize", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[verus::internal(verus_macro)]
            pub enum Label {
                Query {
                    end_lsn: LSN,
                    key: Key,
                    value: Value,
                },
                Put {
                    puts: MsgHistory,
                },
                FreezeAs {
                    stamped_betree: StampedBetree,
                },
                Internal {},
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Label {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_Query(&self) -> bool {
                    ::builtin::is_variant(self, "Query")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_Query_end_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "Query", "end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_Query_key(self) -> Key {
                    ::builtin::get_variant_field(self, "Query", "key")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_Query_value(self) -> Value {
                    ::builtin::get_variant_field(self, "Query", "value")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_Put(&self) -> bool {
                    ::builtin::is_variant(self, "Put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_Put_puts(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "Put", "puts")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_FreezeAs(&self) -> bool {
                    ::builtin::is_variant(self, "FreezeAs")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_FreezeAs_stamped_betree(self) -> StampedBetree {
                    ::builtin::get_variant_field(self, "FreezeAs",
                        "stamped_betree")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_Internal(&self) -> bool {
                    ::builtin::is_variant(self, "Internal")
                }
            }
            pub mod show {
                use super::*;
                use bool as query;
                use bool as put;
                use bool as freeze_as;
                use bool as internal_flush_memtable;
                use bool as internal_grow;
                use bool as internal_split;
                use bool as internal_flush;
                use bool as internal_compact;
                use bool as internal_noop;
                use bool as initialize;
            }
            pub mod take_step {
                use super::*;
            }
            #[verus::internal(verus_macro)]
            impl State {
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn wf(self) -> bool {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
            }
        }
    }
    pub mod LinkedBufferSeq_v {
        use builtin::*;
        use builtin_macros::*;
        use vstd::{map::*, seq::*, set::*};
        use crate::spec::KeyType_t::*;
        use crate::spec::Messages_t::*;
        use crate::betree::Buffer_v::*;
        use crate::betree::BufferSeq_v;
        use crate::betree::OffsetMap_v::*;
        use crate::disk::GenericDisk_v::*;
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct DiskView {
            pub entries: Map<Address, Buffer>,
        }
        #[verus::internal(verus_macro)]
        impl DiskView {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn repr(self) -> Set<Address> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn get(self, addr: Address) -> Buffer {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn modify_disk(self, addr: Address, buffer: Buffer)
                -> DiskView {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_fresh(self, addrs: Set<Address>) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_subdisk(self, bigger: DiskView) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn merge_disk(self, other: DiskView) -> DiskView {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn empty_disk() -> DiskView {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct BufferSeq {
            pub buffers: Seq<Address>,
        }
        #[verus::internal(verus_macro)]
        impl BufferSeq {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn empty() -> BufferSeq {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn len(self) -> nat {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verifier::inline]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn spec_index(self, i: int) -> Address {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid(self, dv: DiskView) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn repr(self) -> Set<Address> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn slice(self, start: int, end: int) -> BufferSeq {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn extend(self, new_buffers: BufferSeq) -> BufferSeq {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn query_from(self, dv: DiskView, k: Key, start: int)
                -> Message {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn update_subrange(self, start: int, end: int,
                new_buffer_addr: Address) -> BufferSeq {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self, dv: DiskView) -> BufferSeq_v::BufferSeq {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn subdisk_implies_same_i(self, small: DiskView,
                big: DiskView) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn key_in_buffer(self, dv: DiskView, from_idx: int, k: Key,
                buffer_idx: int) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn key_in_buffer_filtered(self, dv: DiskView,
                offset_map: OffsetMap, from_idx: int, k: Key, buffer_idx: int)
                -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn query_from_commutes_with_i(self, dv: DiskView, k: Key,
                start: int) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
    }
    pub mod LinkedBetreeRefinement_v {
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use vstd::map::*;
        use vstd::seq_lib::*;
        use vstd::set_lib::*;
        use crate::spec::KeyType_t::*;
        use crate::spec::Messages_t::*;
        use crate::abstract_system::StampedMap_v::*;
        use crate::disk::GenericDisk_v::*;
        use crate::betree::Domain_v::*;
        use crate::betree::PivotTable_v::*;
        use crate::betree::Buffer_v::*;
        use crate::betree::Memtable_v::*;
        use crate::betree::LinkedBufferSeq_v;
        use crate::betree::BufferOffsets_v::*;
        use crate::betree::OffsetMap_v::*;
        use crate::betree::FilteredBetree_v;
        use crate::betree::FilteredBetree_v::FilteredBetree;
        use crate::betree::LinkedBetree_v::*;
        use crate::betree::SplitRequest_v::*;
        pub type LinkedBufferSeq = LinkedBufferSeq_v::BufferSeq;
        #[verus::internal(verus_macro)]
        impl DiskView {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn fresh_ranking_extension(self, r1: Ranking, r2: Ranking)
                -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn subdisk_implies_ranking_validity(self, big: DiskView,
                ranking: Ranking) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn ranking_is_tight(self, ranking: Ranking) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn tight_ranking_is_finite(self, ranking: Ranking) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(proof)]
        pub fn get_max_rank(ranking: Ranking) -> nat {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(verus_macro)]
        impl LinkedBetree {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn disk_tight_wrt_reachable_betree_addrs(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn disk_tight_wrt_reachable_buffer_addrs(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn i_children_seq(self, ranking: Ranking, start: nat)
                -> Seq<FilteredBetree_v::BetreeNode> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn i_children(self, ranking: Ranking)
                -> Seq<FilteredBetree_v::BetreeNode> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn i_node(self, ranking: Ranking)
                -> FilteredBetree_v::BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> FilteredBetree_v::BetreeNode {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn i_children_seq_lemma(self, ranking: Ranking, start: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn i_children_lemma(self, ranking: Ranking) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn i_node_wf(self, ranking: Ranking) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn i_wf(self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn child_at_idx_acyclic(self, idx: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn child_at_idx_valid_ranking(self, idx: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn child_for_key_valid_index(self, k: Key) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn child_for_key_acyclic(self, k: Key) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn i_children_ignores_ranking(self, r1: Ranking,
                r2: Ranking) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn i_node_ignores_ranking(self, r1: Ranking, r2: Ranking) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn child_at_idx_commutes_with_i(self, idx: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn child_for_key_commutes_with_i(self, k: Key) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn indexiness_commutes_with_i(self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn betree_subdisk_preserves_i_with_ranking(self,
                big: LinkedBetree, ranking: Ranking) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn reachable_addrs_using_ranking_recur_body_lemma(self,
                ranking: Ranking, child_idx: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn child_subtree_contains_addr(self, ranking: Ranking,
                addr: Address, start: nat, i: nat) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn reachable_addrs_using_ranking_recur_closed(self,
                ranking: Ranking, child_idx: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn reachable_addrs_using_ranking_closed(self,
                ranking: Ranking) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn reachable_addrs_are_closed(self, ranking: Ranking,
                addr: Address) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn build_tight_preserves_wf(self, ranking: Ranking) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn build_tight_preserves_i(self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn build_tight_ranking(self, ranking: Ranking) -> Ranking {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn identical_children_commutes_with_i(self, idx: nat,
                other: LinkedBetree, other_idx: nat, ranking: Ranking) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn push_memtable_wf(self, memtable: Memtable,
                new_addrs: TwoAddrs) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verifier::spinoff_prover]
            #[verus::internal(proof)]
            pub fn push_memtable_new_ranking(self, memtable: Memtable,
                new_addrs: TwoAddrs, old_ranking: Ranking) -> Ranking {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn push_memtable_commutes_with_i(self, memtable: Memtable,
                new_addrs: TwoAddrs) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn grow_new_ranking(self, new_root_addr: Address,
                old_ranking: Ranking) -> Ranking {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn fresh_entry_preserves_i(self, other: LinkedBetree,
                ranking: Ranking, new_addr: Address) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn grow_commutes_with_i(self, new_root_addr: Address) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split_element(self, request: SplitRequest) -> Element {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn split_new_ranking(self, request: SplitRequest,
                new_addrs: SplitAddrs, ranking: Ranking) -> Ranking {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verifier::spinoff_prover]
            #[verus::internal(proof)]
            pub fn split_parent_commutes_with_i(self, request: SplitRequest,
                new_addrs: SplitAddrs) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn flush_new_ranking(self, child_idx: nat, buffer_gc: nat,
                new_addrs: TwoAddrs, ranking: Ranking) -> Ranking {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verifier::spinoff_prover]
            #[verus::internal(proof)]
            pub fn flush_commutes_with_i(self, child_idx: nat, buffer_gc: nat,
                new_addrs: TwoAddrs) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verifier::spinoff_prover]
            #[verus::internal(proof)]
            pub fn compact_new_ranking(self, start: nat, end: nat,
                compacted_buffer: Buffer, new_addrs: TwoAddrs,
                ranking: Ranking) -> Ranking {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn can_compact_commutes_with_i(self, start: nat, end: nat,
                compacted_buffer: Buffer, new_addrs: TwoAddrs) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verifier::spinoff_prover]
            #[verus::internal(proof)]
            pub fn compact_commutes_with_i(self, start: nat, end: nat,
                compacted_buffer: Buffer, new_addrs: TwoAddrs) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn i_stamped_betree(stamped: StampedBetree)
            -> FilteredBetree_v::StampedBetree {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(verus_macro)]
        impl QueryReceiptLine {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> FilteredBetree_v::QueryReceiptLine {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        impl QueryReceipt {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> FilteredBetree_v::QueryReceipt {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn i_valid(self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(proof)]
        pub fn path_addrs_to_set_additive(path_addrs: PathAddrs) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(verus_macro)]
        impl Path {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> FilteredBetree_v::Path {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn valid_ranking_throughout(self, ranking: Ranking) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn subpath_commutes_with_i(self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn i_valid(self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn target_commutes_with_i(self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn betree_diskview_diff(self, replacement: LinkedBetree,
                path_addrs: PathAddrs) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verifier::spinoff_prover]
            #[verus::internal(proof)]
            pub fn substitute_preserves_wf(self, replacement: LinkedBetree,
                path_addrs: PathAddrs) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verifier::spinoff_prover]
            #[verus::internal(proof)]
            pub fn ranking_after_substitution(self, replacement: LinkedBetree,
                path_addrs: PathAddrs, ranking: Ranking) -> Ranking {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn substitute_commutes_with_i(self, replacement: LinkedBetree,
                path_addrs: PathAddrs, ranking: Ranking) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn fresh_substitution_implies_subdisk(self,
                replacement: LinkedBetree, path_addrs: PathAddrs) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        impl LinkedBetreeVars::Label {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> FilteredBetree::Label {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        impl LinkedBetreeVars::State {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn inv(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> FilteredBetree::State {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn init_refines(self, stamped_betree: StampedBetree) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn query_refines(self, post: Self,
                lbl: LinkedBetreeVars::Label, receipt: QueryReceipt) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn put_refines(self, post: Self,
                lbl: LinkedBetreeVars::Label) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn freeze_as_refines(self, post: Self,
                lbl: LinkedBetreeVars::Label) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn internal_flush_memtable_refines(self, post: Self,
                lbl: LinkedBetreeVars::Label, new_addrs: TwoAddrs) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn internal_grow_refines(self, post: Self,
                lbl: LinkedBetreeVars::Label, new_root_addr: Address) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn internal_split_refines(self, post: Self,
                lbl: LinkedBetreeVars::Label, path: Path,
                request: SplitRequest, new_addrs: SplitAddrs,
                path_addrs: PathAddrs) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn internal_flush_refines(self, post: Self,
                lbl: LinkedBetreeVars::Label, path: Path, child_idx: nat,
                buffer_gc: nat, new_addrs: TwoAddrs, path_addrs: PathAddrs) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn internal_compact_refines(self, post: Self,
                lbl: LinkedBetreeVars::Label, path: Path, start: nat,
                end: nat, compacted_buffer: Buffer, new_addrs: TwoAddrs,
                path_addrs: PathAddrs) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn internal_noop_noop(self, post: Self,
                lbl: LinkedBetreeVars::Label) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn next_refines(self, post: Self,
                lbl: LinkedBetreeVars::Label) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
    }
    pub mod PivotBranch_v {
        /// This file defines the PivotBranch data structure. Under the `betree/` folder, all "Branch" data structures are
        /// just B+-trees. They are called "Branches" to distinguish them from the Be-tree data structures, and because
        /// Be-tree nodes can point to B+-trees (thus making B+-trees "branches" of a Be-tree).
        /// 
        /// A PivotBranch is a B+-tree defined in its most natural form, where the pivots are Keys, and Index nodes directly
        /// contain sequences of their children (i.e.: in a concrete implementation its one massive nested data structure, instead
        /// of using pointers). AKA it's a "functional" tree (immutable, defined).
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use crate::spec::KeyType_t::*;
        use crate::spec::Messages_t::*;
        #[doc =
        " (x9du): A SplitArg is a value used for determining a pivot value at which to split"]
        #[doc =
        " a B+tree node into two nodes. Its an enum to handle the cases for splitting an index"]
        #[doc = " node vs. a Leaf node separately."]
        #[verus::internal(verus_macro)]
        pub enum SplitArg {
            SplitIndex {
                pivot: Key,
                pivot_index: int,
            },
            SplitLeaf {
                pivot: Key,
            },
        }
        #[verus::internal(verus_macro)]
        #[cfg(verus_keep_ghost)]
        #[automatically_derived]
        impl SplitArg {
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_SplitIndex(&self) -> bool {
                ::builtin::is_variant(self, "SplitIndex")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_SplitIndex_pivot(self) -> Key {
                ::builtin::get_variant_field(self, "SplitIndex", "pivot")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_SplitIndex_pivot_index(self) -> int {
                ::builtin::get_variant_field(self, "SplitIndex",
                    "pivot_index")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_SplitLeaf(&self) -> bool {
                ::builtin::is_variant(self, "SplitLeaf")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_SplitLeaf_pivot(self) -> Key {
                ::builtin::get_variant_field(self, "SplitLeaf", "pivot")
            }
        }
        #[verus::internal(verus_macro)]
        impl SplitArg {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self, split_node: Node) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn get_pivot(self) -> Key {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        pub enum Node {
            Index {
                pivots: Seq<Key>,
                children: Seq<Node>,
            },
            Leaf {
                keys: Seq<Key>,
                msgs: Seq<Message>,
            },
        }
        #[verus::internal(verus_macro)]
        #[cfg(verus_keep_ghost)]
        #[automatically_derived]
        impl Node {
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_Index(&self) -> bool {
                ::builtin::is_variant(self, "Index")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_Index_pivots(self) -> Seq<Key> {
                ::builtin::get_variant_field(self, "Index", "pivots")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_Index_children(self) -> Seq<Node> {
                ::builtin::get_variant_field(self, "Index", "children")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_Leaf(&self) -> bool {
                ::builtin::is_variant(self, "Leaf")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_Leaf_keys(self) -> Seq<Key> {
                ::builtin::get_variant_field(self, "Leaf", "keys")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_Leaf_msgs(self) -> Seq<Message> {
                ::builtin::get_variant_field(self, "Leaf", "msgs")
            }
        }
        #[verus::internal(verus_macro)]
        impl Node {
            #[doc = " Returns a newly constructed empty leaf node."]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn empty_leaf() -> Node {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[doc = " Returns the set of all keys contained under this node."]
            #[doc =
            " - For leaf nodes this is just all keys the leaf node contains."]
            #[doc =
            " - For index nodes, this is the set union of all pivot keys + keys contained"]
            #[doc = "   under all leaf nodes under this index node."]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn all_keys(self) -> Set<Key> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[doc = " Pre: self must be an Index node"]
            #[doc = ""]
            #[doc =
            " Returns true iff all keys under node child[i] are less than pivots[i] "]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn all_keys_below_bound(self, i: int) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[doc = " Pre: self must be an Index node"]
            #[doc = " "]
            #[doc =
            " Returns true iff all keys under node child[i] are >= pivots[i-1]."]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn all_keys_above_bound(self, i: int) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[doc = " Returns true iff self is a well-formed B+ tree node."]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[doc =
            " Returns the index before where the key would be inserted into the given node."]
            #[doc = " Let `r` be the return value."]
            #[doc =
            " If self is Index, then `r + 1` is the index of the child node that `key` belongs"]
            #[doc = " to."]
            #[doc =
            " If self is Node, then `r + 1` is the index `key` would be inserted into. (Note that"]
            #[doc =
            " in practice we don\'t allow duplicate keys, so if `key` is already in the sequence,"]
            #[doc = " we\'d just update the value at `r`)."]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn route(self, key: Key) -> int {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[doc = " Returns the Message mapped to the given key."]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn query(self, key: Key) -> Message {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[doc = " Pre: self is a Leaf node."]
            #[doc =
            " Returns a new Leaf node where the key-message pair {key, msg} is inserted into"]
            #[doc = " self."]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn insert_leaf(self, key: Key, msg: Message) -> Node {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[doc = " Pre: path.node == self && path.target is Leaf"]
            #[doc = " "]
            #[doc =
            " Returns a new tree rooted at self where {key, msg} is inserted at the Leaf node"]
            #[doc = " targeted by `path`."]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn insert(self, key: Key, msg: Message, path: Path) -> Node {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[doc =
            " Returns a new tree formed by creating a new Index node who\'s only child is self."]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn grow(self) -> Node {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[doc =
            " Update the empty Leaf node targeted by the `path` (which starts at self) to have the key-value pairs"]
            #[doc = " specified by `keys` and `msgs`."]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn append(self, keys: Seq<Key>, msgs: Seq<Message>,
                path: Path) -> Node {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[doc = " Pre: self is Leaf"]
            #[doc = " "]
            #[doc =
            " Returns two leaf nodes formed by splitting `self` into two Leaf nodes, where"]
            #[doc =
            " the left node contains all keys < `split_arg`, and right node contains all keys"]
            #[doc = " >= `split_arg`."]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split_leaf(self, split_arg: SplitArg) -> (Node, Node) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[doc = " Pre: self is Index"]
            #[doc = " "]
            #[doc =
            " Returns a new Index node formed by taking self.children[from:to] and all pivots that divide"]
            #[doc = " those children."]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn sub_index(self, from: int, to: int) -> Node {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[doc = " Pre: self is Index"]
            #[doc = " "]
            #[doc =
            " Returns two new index nodes that partition `self.children` such that the left node only contains"]
            #[doc =
            " children with keys < split_arg.key, and right node only contains children with keys >= split_arg.key."]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn split_index(self, split_arg: SplitArg) -> (Node, Node) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[doc =
            " Return two nodes created by splitting self based on the `split_arg`."]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split_node(self, split_arg: SplitArg) -> (Node, Node) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[doc = " "]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn can_split_child_of_index(self, split_arg: SplitArg)
                -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[doc = " Pre: self is Index"]
            #[doc = " "]
            #[doc =
            " Returns a new Index node where the child containing `split_arg.pivot` is split on said pivot."]
            #[doc =
            " The pivot arg can NOT be an existing pivot in the Index (because duh, otherwise you\'d have two"]
            #[doc =
            " pivots with the same value, the bucket between them would be empty which is dumb)."]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn split_child_of_index(self, split_arg: SplitArg) -> Node {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[doc =
            " Returns a new tree formed by splitting the children of `path.target()` on split_arg."]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split(self, path: Path, split_arg: SplitArg) -> Node {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[doc =
        " A `Path` describes a target node from a given starting node (using a key to target as well"]
        #[doc = " as a number of steps to take)."]
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct Path {
            #[doc = " The current node."]
            pub node: Node,
            #[doc =
            " The target key of the path (does change across subpaths)."]
            pub key: Key,
            #[doc =
            " How many steps remain. If 0, then `node` is the target node of the path."]
            pub depth: nat,
        }
        #[verus::internal(verus_macro)]
        impl Path {
            #[doc = " Returns the next `Path`."]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn subpath(self) -> Path {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[doc = " Returns `true` iff self is a valid Path."]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[doc =
            " Returns Node targeted by a path (i.e.: the last path element)."]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn target(self) -> Node {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[doc =
            " Returns the Seq of children for self.node when `self.target` is replaced with `replacement`."]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn replaced_children(self, replacement: Node) -> Seq<Node> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[doc =
            " Returns the tree rooted at self.node, where self.target() is replaced with `replacement`."]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn substitute(self, replacement: Node) -> Node {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[doc =
            " Returns true iff `other_key` leads to the same target node as `self.key`."]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn path_equiv(self, other_key: Key) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
    }
    pub mod PivotBranchRefinement_v {
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use crate::spec::KeyType_t::*;
        use crate::spec::Messages_t::*;
        use crate::betree::Buffer_v::*;
        use crate::betree::PivotBranch_v::*;
        #[verus::internal(verus_macro)]
        impl Node {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> Buffer {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn get_keys_or_pivots(node: Node) -> Seq<Key> {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn le_route(node: Node, key: Key, i: int) -> bool {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn gt_route(node: Node, key: Key, i: int) -> bool {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(proof)]
        pub fn lemma_route_ensures(node: Node, key: Key) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(proof)]
        pub fn lemma_route_auto() {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(proof)]
        pub fn lemma_grow_preserves_wf(node: Node) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(proof)]
        pub fn lemma_grow_preserves_all_keys(node: Node) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(proof)]
        pub fn lemma_interpretation_delegation(node: Node, key: Key) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(proof)]
        pub fn lemma_grow_preserves_i(node: Node) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(proof)]
        pub fn lemma_insert_leaf_is_correct(node: Node, key: Key,
            msg: Message) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(proof)]
        pub fn lemma_split_leaf_preserves_wf(node: Node,
            split_arg: SplitArg) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(proof)]
        pub fn lemma_sub_index_preserves_wf(node: Node, from: int, to: int) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(proof)]
        pub fn lemma_split_index_preserves_wf(node: Node,
            split_arg: SplitArg) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(proof)]
        pub fn lemma_split_node_preserves_wf(node: Node,
            split_arg: SplitArg) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(proof)]
        pub fn lemma_split_leaf_interpretation(old_leaf: Node,
            split_arg: SplitArg) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(proof)]
        pub fn lemma_split_index_interpretation1(old_index: Node,
            split_arg: SplitArg) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(proof)]
        pub fn lemma_split_index_interpretation2(old_index: Node,
            split_arg: SplitArg) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(proof)]
        pub fn lemma_split_index_interpretation(old_index: Node,
            split_arg: SplitArg) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(proof)]
        pub fn lemma_split_node_interpretation(old_node: Node,
            split_arg: SplitArg) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(proof)]
        pub fn lemma_split_leaf_all_keys(old_leaf: Node,
            split_arg: SplitArg) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[doc = " (x9du)"]
        #[verus::internal(proof)]
        pub fn lemma_interpretation(node: Node) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct QueryLabel {
            pub key: Key,
            pub msg: Message,
        }
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct InsertLabel {
            pub key: Key,
            pub msg: Message,
            pub path: Path,
        }
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct AppendLabel {
            pub keys: Seq<Key>,
            pub msgs: Seq<Message>,
        }
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct InternalLabel {}
        #[verus::internal(proof)]
        pub fn query_refines(pre: Node, lbl: QueryLabel) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(proof)]
        pub fn lemma_insert_leaf_preserves_wf(node: Node, key: Key,
            msg: Message) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(proof)]
        pub fn lemma_insert_preserves_wf(node: Node, key: Key, msg: Message,
            path: Path) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(proof)]
        pub fn insert_refines(pre: Node, lbl: InsertLabel) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
    }
    pub mod LinkedBranch_v {
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use crate::spec::KeyType_t::*;
        use crate::spec::Messages_t::*;
        use crate::disk::GenericDisk_v::*;
        #[verus::internal(verus_macro)]
        pub enum SplitArg {
            SplitIndex {
                pivot: Key,
                pivot_index: int,
            },
            SplitLeaf {
                pivot: Key,
            },
        }
        #[verus::internal(verus_macro)]
        #[cfg(verus_keep_ghost)]
        #[automatically_derived]
        impl SplitArg {
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_SplitIndex(&self) -> bool {
                ::builtin::is_variant(self, "SplitIndex")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_SplitIndex_pivot(self) -> Key {
                ::builtin::get_variant_field(self, "SplitIndex", "pivot")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_SplitIndex_pivot_index(self) -> int {
                ::builtin::get_variant_field(self, "SplitIndex",
                    "pivot_index")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_SplitLeaf(&self) -> bool {
                ::builtin::is_variant(self, "SplitLeaf")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_SplitLeaf_pivot(self) -> Key {
                ::builtin::get_variant_field(self, "SplitLeaf", "pivot")
            }
        }
        #[verus::internal(verus_macro)]
        impl SplitArg {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self, split_branch: LinkedBranch) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn get_pivot(self) -> Key {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        pub enum Node {
            Index {
                pivots: Seq<Key>,
                children: Seq<Address>,
            },
            Leaf {
                keys: Seq<Key>,
                msgs: Seq<Message>,
            },
        }
        #[verus::internal(verus_macro)]
        #[cfg(verus_keep_ghost)]
        #[automatically_derived]
        impl Node {
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_Index(&self) -> bool {
                ::builtin::is_variant(self, "Index")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_Index_pivots(self) -> Seq<Key> {
                ::builtin::get_variant_field(self, "Index", "pivots")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_Index_children(self) -> Seq<Address> {
                ::builtin::get_variant_field(self, "Index", "children")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_Leaf(&self) -> bool {
                ::builtin::is_variant(self, "Leaf")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_Leaf_keys(self) -> Seq<Key> {
                ::builtin::get_variant_field(self, "Leaf", "keys")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_Leaf_msgs(self) -> Seq<Message> {
                ::builtin::get_variant_field(self, "Leaf", "msgs")
            }
        }
        #[verus::internal(verus_macro)]
        impl Node {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid_child_index(self, i: nat) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn route(self, key: Key) -> int {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct DiskView {
            pub entries: Map<Address, Node>,
        }
        #[verus::internal(verus_macro)]
        impl DiskView {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn entries_wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid_address(self, addr: Address) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn node_has_valid_child_address(self, node: Node) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn no_dangling_address(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn get(self, addr: Address) -> Node {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn get_keys(self, addr: Address) -> Set<Key> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn representation(self) -> Set<Address> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn agrees_with_disk(self, other: DiskView) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_subset_of(self, other: DiskView) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn node_children_respects_rank(self, ranking: Ranking,
                addr: Address) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid_ranking(self, ranking: Ranking) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_fresh(self, addrs: Set<Address>) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(closed)]
            #[verus::internal(spec(checked))]
            pub fn merge_disk(self, other: DiskView) -> DiskView {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(closed)]
            #[verus::internal(spec(checked))]
            pub fn remove_disk(self, other: DiskView) -> DiskView {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn modify_disk(self, addr: Address, item: Node) -> DiskView {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn same_except(self, other: DiskView, except: Set<Address>)
                -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn empty_disk() -> DiskView {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct LinkedBranch {
            pub root: Address,
            pub disk_view: DiskView,
        }
        #[verus::internal(verus_macro)]
        impl LinkedBranch {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn has_root(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn root(self) -> Node {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn get_rank(self, ranking: Ranking) -> nat {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid_ranking(self, ranking: Ranking) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn the_ranking(self) -> Ranking {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn acyclic(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn all_keys_in_range(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn all_keys_in_range_internal(self, ranking: Ranking)
                -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn child_all_keys_in_range_internal(self, ranking: Ranking,
                i: nat) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn children_keys(self, ranking: Ranking, i: nat) -> Set<Key> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn all_keys(self, ranking: Ranking) -> Set<Key> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn all_keys_below_bound(self, i: int, ranking: Ranking)
                -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn all_keys_above_bound(self, i: int, ranking: Ranking)
                -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn child_at_idx(self, i: nat) -> LinkedBranch {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn representation(self) -> Set<Address> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn reachable_addrs_using_ranking(self, ranking: Ranking)
                -> Set<Address> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn child_reachable_addrs_using_ranking(self, ranking: Ranking,
                i: nat) -> Set<Address> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn tight_disk_view(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn query_internal(self, key: Key, ranking: Ranking)
                -> Message {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn query(self, key: Key) -> Message {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn grow(self, addr: Address) -> LinkedBranch {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn insert_leaf(self, key: Key, msg: Message) -> LinkedBranch {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn insert(self, key: Key, msg: Message, path: Path)
                -> LinkedBranch {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn append_to_new_leaf(self, new_keys: Seq<Key>,
                new_msgs: Seq<Message>) -> LinkedBranch {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn append(self, keys: Seq<Key>, msgs: Seq<Message>,
                path: Path) -> LinkedBranch {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split_leaf(self, split_arg: SplitArg,
                right_root_addr: Address) -> (LinkedBranch, LinkedBranch) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn sub_index(self, from: int, to: int) -> Node {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn split_index(self, split_arg: SplitArg,
                right_root_addr: Address) -> (LinkedBranch, LinkedBranch) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split_node(self, split_arg: SplitArg,
                right_root_addr: Address) -> (LinkedBranch, LinkedBranch) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn can_split_child_of_index(self, split_arg: SplitArg,
                new_child_addr: Address) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn split_child_of_index(self, split_arg: SplitArg,
                new_child_addr: Address) -> LinkedBranch {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn split(self, addr: Address, path: Path, split_arg: SplitArg)
                -> LinkedBranch {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn empty_linked_branch(root: Address) -> LinkedBranch {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn union_seq_of_sets<T>(s: Seq<Set<T>>) -> Set<T> {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct Path {
            pub branch: LinkedBranch,
            pub key: Key,
            pub depth: nat,
        }
        #[verus::internal(verus_macro)]
        impl Path {
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn subpath(self) -> Path {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn target(self) -> LinkedBranch {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn substitute(self, replacement: LinkedBranch)
                -> LinkedBranch {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn path_equiv(self, other_key: Key) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
    }
}
mod journal {
    pub mod PagedJournal_v {
        #[allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        use vstd::prelude::*;
        use crate::abstract_system::StampedMap_v::LSN;
        use crate::abstract_system::MsgHistory_v::*;
        #[verus::internal(verus_macro)]
        pub struct JournalRecord {
            pub message_seq: MsgHistory,
            pub prior_rec: Box<Option<JournalRecord>>,
        }
        #[verus::internal(verus_macro)]
        impl JournalRecord {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid(self, boundary_lsn: LSN) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn new_boundary_valid(self, old_lsn: LSN, new_lsn: LSN) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn cropped_prior(self, boundary_lsn: LSN)
                -> Option<JournalRecord> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_crop_head_records(self, boundary_lsn: LSN, depth: nat)
                -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn opt_rec_can_crop_head_records(ojr: Option<JournalRecord>,
                boundary_lsn: LSN, depth: nat) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn crop_head_records(self, boundary_lsn: LSN, depth: nat)
                -> Option<JournalRecord> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn opt_rec_crop_head_records(ojr: Option<JournalRecord>,
                boundary_lsn: LSN, depth: nat) -> Option<JournalRecord> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn crop_head_records_lemma(self, boundary_lsn: LSN,
                depth: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn opt_rec_crop_head_records_lemma(ojr: Option<JournalRecord>,
                boundary_lsn: LSN, depth: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn opt_rec_crop_head_records_lemma_forall() {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn can_crop_monotonic(self, boundary_lsn: LSN, depth: nat,
                more: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn can_crop_more_yields_some(self, boundary_lsn: LSN,
                depth: nat, more: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn message_seq_after_crop(self, boundary_lsn: LSN, depth: nat)
                -> MsgHistory {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn option_new_boundary_valid(ojr: Option<JournalRecord>,
                old_lsn: LSN, new_lsn: LSN) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn discard_old_journal_rec(ojr: Option<JournalRecord>,
                lsn: LSN) -> Option<JournalRecord> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn discard_old_journal_rec_ensures(ojr: Option<JournalRecord>,
                lsn: LSN) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct TruncatedJournal {
            pub boundary_lsn: LSN,
            pub freshest_rec: Option<JournalRecord>,
        }
        #[verus::internal(verus_macro)]
        impl TruncatedJournal {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn prior(self) -> TruncatedJournal {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_empty(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn seq_end(self) -> LSN {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn seq_start(self) -> LSN {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_discard_to(self, lsn: LSN) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn discard_old_defn(self, lsn: LSN) -> TruncatedJournal {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn has_messages_at_depth(self, msgs: MsgHistory, depth: nat)
                -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn append_record(self, msgs: MsgHistory) -> TruncatedJournal {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_crop(self, depth: nat) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn crop_head_records(self, depth: nat) -> TruncatedJournal {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn crop_head_records_ensures(self, depth: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn freeze_for_commit(self, frozen_journal: TruncatedJournal,
                depth: nat) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn mkfs() -> TruncatedJournal {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[allow(unused_parens)]
        pub mod PagedJournal {
            use super::*;
            #[verus::internal(verus_macro)]
            pub struct State {
                pub truncated_journal: TruncatedJournal,
                pub unmarshalled_tail: MsgHistory,
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Step {
                read_for_recovery(nat),
                freeze_for_commit(nat),
                query_end_lsn(),
                put(),
                discard_old(),
                internal_journal_marshal(LSN),
                internal_no_op(),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Step {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_read_for_recovery(&self) -> bool {
                    ::builtin::is_variant(self, "read_for_recovery")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_read_for_recovery_0(self) -> nat {
                    ::builtin::get_variant_field(self, "read_for_recovery", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_freeze_for_commit(&self) -> bool {
                    ::builtin::is_variant(self, "freeze_for_commit")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_freeze_for_commit_0(self) -> nat {
                    ::builtin::get_variant_field(self, "freeze_for_commit", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_query_end_lsn(&self) -> bool {
                    ::builtin::is_variant(self, "query_end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_put(&self) -> bool {
                    ::builtin::is_variant(self, "put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_discard_old(&self) -> bool {
                    ::builtin::is_variant(self, "discard_old")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_internal_journal_marshal(&self) -> bool {
                    ::builtin::is_variant(self, "internal_journal_marshal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_journal_marshal_0(self) -> LSN {
                    ::builtin::get_variant_field(self,
                        "internal_journal_marshal", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_internal_no_op(&self) -> bool {
                    ::builtin::is_variant(self, "internal_no_op")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Config {
                initialize(TruncatedJournal),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Config {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_initialize(&self) -> bool {
                    ::builtin::is_variant(self, "initialize")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_initialize_0(self) -> TruncatedJournal {
                    ::builtin::get_variant_field(self, "initialize", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[verus::internal(verus_macro)]
            pub enum Label {
                ReadForRecovery {
                    messages: MsgHistory,
                },
                FreezeForCommit {
                    frozen_journal: TruncatedJournal,
                },
                QueryEndLsn {
                    end_lsn: LSN,
                },
                Put {
                    messages: MsgHistory,
                },
                DiscardOld {
                    start_lsn: LSN,
                    require_end: LSN,
                },
                Internal {},
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Label {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_ReadForRecovery(&self) -> bool {
                    ::builtin::is_variant(self, "ReadForRecovery")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_ReadForRecovery_messages(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "ReadForRecovery",
                        "messages")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_FreezeForCommit(&self) -> bool {
                    ::builtin::is_variant(self, "FreezeForCommit")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_FreezeForCommit_frozen_journal(self)
                    -> TruncatedJournal {
                    ::builtin::get_variant_field(self, "FreezeForCommit",
                        "frozen_journal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_QueryEndLsn(&self) -> bool {
                    ::builtin::is_variant(self, "QueryEndLsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_QueryEndLsn_end_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "QueryEndLsn", "end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_Put(&self) -> bool {
                    ::builtin::is_variant(self, "Put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_Put_messages(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "Put", "messages")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_DiscardOld(&self) -> bool {
                    ::builtin::is_variant(self, "DiscardOld")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_DiscardOld_start_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "DiscardOld",
                        "start_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_DiscardOld_require_end(self) -> LSN {
                    ::builtin::get_variant_field(self, "DiscardOld",
                        "require_end")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_Internal(&self) -> bool {
                    ::builtin::is_variant(self, "Internal")
                }
            }
            pub mod show {
                use super::*;
                use bool as read_for_recovery;
                use bool as freeze_for_commit;
                use bool as query_end_lsn;
                use bool as put;
                use bool as discard_old;
                use bool as internal_journal_marshal;
                use bool as internal_no_op;
                use bool as initialize;
            }
            pub mod take_step {
                use super::*;
            }
            #[verus::internal(verus_macro)]
            impl State {
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn wf(self) -> bool {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn seq_start(self) -> LSN {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn seq_end(self) -> LSN {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
            }
        }
    }
    pub mod PagedJournalRefinement_v {
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use vstd::calc_macro::*;
        use vstd::prelude::*;
        use vstd::map::*;
        use vstd::seq_lib::*;
        use crate::abstract_system::StampedMap_v::LSN;
        use crate::abstract_system::MsgHistory_v::*;
        use crate::abstract_system::AbstractJournal_v::*;
        use crate::journal::PagedJournal_v::*;
        #[verus::internal(verus_macro)]
        impl JournalRecord {
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn i(self, boundary_lsn: LSN) -> MsgHistory {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn i_opt(ojr: Option<Self>, boundary_lsn: LSN) -> MsgHistory {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn i_lemma(self, boundary_lsn: LSN) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn i_lemma_forall() {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn cant_crop(self, bdy: LSN, depth: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn crop_head_records_chaining(self, bdy: LSN, depth: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn cropped_subseq_in_interpretation(self, bdy: LSN,
                depth: nat, msgs: MsgHistory) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn can_cut_more(ojr: Option<JournalRecord>, bdy: LSN,
                depth: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn crop_equivalence(ojr: Option<JournalRecord>, bdy: LSN,
                depth: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn discard_old_maintains_subseq(ojr: Option<JournalRecord>,
                old_bdy: LSN, new_bdy: LSN) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn crop_head_maintains_subseq(ojr: Option<JournalRecord>,
                bdy: LSN, depth: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn discard_old_defn_interprets(ojr: Option<JournalRecord>,
                old_lsn: LSN, new_lsn: LSN) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn discard_valid(self, old_lsn: LSN, new_lsn: LSN) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        impl TruncatedJournal {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> MsgHistory {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn crop_head_records_wf_lemma(self, depth: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn tj_freeze_for_commit(self, frozen: TruncatedJournal,
                depth: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn discard_old_defn_wf(self, lsn: LSN) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        impl PagedJournal::Label {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> AbstractJournal::Label {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        impl PagedJournal::State {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> AbstractJournal::State {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn read_for_recovery_refines(self, post: Self,
                lbl: PagedJournal::Label, depth: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn freeze_for_commit_refines(self, post: Self,
                lbl: PagedJournal::Label, depth: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn discard_old_refines(self, post: Self,
                lbl: PagedJournal::Label) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn marshall_refines(self, post: Self,
                lbl: PagedJournal::Label, cut: LSN) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn next_refines(self, post: Self, lbl: PagedJournal::Label,
                step: PagedJournal::Step) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
    }
    pub mod LinkedJournal_v {
        #![allow(unused_imports)]
        use builtin::*;
        use vstd::prelude::*;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        use vstd::prelude::*;
        use vstd::map::*;
        use vstd::math;
        use crate::abstract_system::StampedMap_v::LSN;
        use crate::abstract_system::MsgHistory_v::*;
        use crate::disk::GenericDisk_v::*;
        use crate::journal::PagedJournal_v;
        use crate::journal::PagedJournal_v::PagedJournal;
        #[verus::internal(verus_macro)]
        pub struct JournalRecord {
            pub message_seq: MsgHistory,
            pub prior_rec: Pointer,
        }
        #[verus::internal(verus_macro)]
        impl JournalRecord {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn has_link(self, boundary_lsn: LSN) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn cropped_prior(self, boundary_lsn: LSN) -> Pointer {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn contains_lsn(self, boundary_lsn: LSN, lsn: LSN) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct DiskView {
            pub boundary_lsn: LSN,
            pub entries: Map<Address, JournalRecord>,
        }
        #[verus::internal(verus_macro)]
        impl DiskView {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn entries_wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_nondangling_pointer(self, ptr: Pointer) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn nondangling_pointers(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn this_block_can_concat(self, addr: Address) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn blocks_can_concat(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn blocks_each_have_link(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn block_in_bounds(self, ptr: Pointer) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid_ranking(self, ranking: Ranking) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn acyclic(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn the_ranking(self) -> Ranking {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn decodable(self, ptr: Pointer) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn the_rank_of(self, ptr: Pointer) -> nat {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn seq_start(self) -> LSN {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn seq_end(self, root: Pointer) -> LSN {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn discard_old(self, new_boundary: LSN) -> Self {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_sub_disk(self, bigger: Self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn sub_disk_transitive_auto() {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_sub_disk_with_newer_lsn(self, bigger: Self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn build_tight(self, root: Pointer) -> Self {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn build_tight_ensures(self, root: Pointer) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn build_tight_auto(self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_crop(self, root: Pointer, depth: nat) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn pointer_after_crop(self, root: Pointer, depth: nat)
                -> Pointer {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn pointer_after_crop_ensures(self, root: Pointer,
                depth: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn pointer_after_crop_auto(self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn iptr(self, ptr: Pointer)
                -> Option<PagedJournal_v::JournalRecord> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn iptr_ignores_extra_blocks(self, ptr: Pointer,
                big: DiskView) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn next(self, ptr: Pointer) -> Pointer {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn build_tight_ranks(self, ptr: Pointer) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn build_tight_shape(self, root: Pointer) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_tight(self, root: Pointer) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verifier::spinoff_prover]
            #[verus::internal(proof)]
            pub fn build_tight_builds_sub_disks(self, root: Pointer) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn tight_empty_disk(self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn tight_sub_disk(self, root: Pointer, tight: Self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn tight_interp(big: Self, root: Pointer, tight: Self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn lsn_has_entry_at(self, lsn: LSN, addr: Address) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn lsn_has_entry(self, lsn: LSN) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn lsns_have_entries(self, root: Pointer) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn decodable_implies_lsns_have_entries(self, root: Pointer) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct TruncatedJournal {
            pub freshest_rec: Pointer,
            pub disk_view: DiskView,
        }
        #[verus::internal(verus_macro)]
        impl TruncatedJournal {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn seq_start(self) -> LSN {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn seq_end(self) -> LSN {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_discard_to(self, lsn: LSN) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn discard_old(self, lsn: LSN) -> Self {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid_discard_old(self, lsn: LSN, new: Self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn decodable(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_crop(self, depth: nat) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn crop(self, depth: nat) -> Self {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn crop_ensures(self, depth: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn crop_auto(self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn append_record(self, addr: Address, msgs: MsgHistory)
                -> Self {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn build_tight(self) -> Self {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn mkfs() -> Self {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn mkfs_ensures() {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn lsns_have_entries(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn decodable_implies_lsns_have_entries(self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn marshal_ranking(self, addr: Address) -> Ranking {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        impl MsgHistory {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn bounded_discard(self, new_bdy: LSN) -> Self {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[allow(unused_parens)]
        pub mod LinkedJournal {
            use super::*;
            #[verus::internal(verus_macro)]
            pub struct State {
                pub truncated_journal: TruncatedJournal,
                pub unmarshalled_tail: MsgHistory,
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Step {
                read_for_recovery(nat),
                freeze_for_commit(nat),
                query_end_lsn(),
                put(),
                discard_old(TruncatedJournal),
                internal_journal_marshal(LSN, Address),
                internal_no_op(),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Step {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_read_for_recovery(&self) -> bool {
                    ::builtin::is_variant(self, "read_for_recovery")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_read_for_recovery_0(self) -> nat {
                    ::builtin::get_variant_field(self, "read_for_recovery", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_freeze_for_commit(&self) -> bool {
                    ::builtin::is_variant(self, "freeze_for_commit")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_freeze_for_commit_0(self) -> nat {
                    ::builtin::get_variant_field(self, "freeze_for_commit", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_query_end_lsn(&self) -> bool {
                    ::builtin::is_variant(self, "query_end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_put(&self) -> bool {
                    ::builtin::is_variant(self, "put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_discard_old(&self) -> bool {
                    ::builtin::is_variant(self, "discard_old")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_discard_old_0(self) -> TruncatedJournal {
                    ::builtin::get_variant_field(self, "discard_old", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_internal_journal_marshal(&self) -> bool {
                    ::builtin::is_variant(self, "internal_journal_marshal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_journal_marshal_0(self) -> LSN {
                    ::builtin::get_variant_field(self,
                        "internal_journal_marshal", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_journal_marshal_1(self) -> Address {
                    ::builtin::get_variant_field(self,
                        "internal_journal_marshal", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_internal_no_op(&self) -> bool {
                    ::builtin::is_variant(self, "internal_no_op")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Config {
                initialize(TruncatedJournal),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Config {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_initialize(&self) -> bool {
                    ::builtin::is_variant(self, "initialize")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_initialize_0(self) -> TruncatedJournal {
                    ::builtin::get_variant_field(self, "initialize", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[verus::internal(verus_macro)]
            pub enum Label {
                ReadForRecovery {
                    messages: MsgHistory,
                },
                FreezeForCommit {
                    frozen_journal: TruncatedJournal,
                },
                QueryEndLsn {
                    end_lsn: LSN,
                },
                Put {
                    messages: MsgHistory,
                },
                DiscardOld {
                    start_lsn: LSN,
                    require_end: LSN,
                },
                Internal {},
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Label {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_ReadForRecovery(&self) -> bool {
                    ::builtin::is_variant(self, "ReadForRecovery")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_ReadForRecovery_messages(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "ReadForRecovery",
                        "messages")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_FreezeForCommit(&self) -> bool {
                    ::builtin::is_variant(self, "FreezeForCommit")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_FreezeForCommit_frozen_journal(self)
                    -> TruncatedJournal {
                    ::builtin::get_variant_field(self, "FreezeForCommit",
                        "frozen_journal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_QueryEndLsn(&self) -> bool {
                    ::builtin::is_variant(self, "QueryEndLsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_QueryEndLsn_end_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "QueryEndLsn", "end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_Put(&self) -> bool {
                    ::builtin::is_variant(self, "Put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_Put_messages(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "Put", "messages")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_DiscardOld(&self) -> bool {
                    ::builtin::is_variant(self, "DiscardOld")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_DiscardOld_start_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "DiscardOld",
                        "start_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_DiscardOld_require_end(self) -> LSN {
                    ::builtin::get_variant_field(self, "DiscardOld",
                        "require_end")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_Internal(&self) -> bool {
                    ::builtin::is_variant(self, "Internal")
                }
            }
            pub mod show {
                use super::*;
                use bool as read_for_recovery;
                use bool as freeze_for_commit;
                use bool as query_end_lsn;
                use bool as put;
                use bool as discard_old;
                use bool as internal_journal_marshal;
                use bool as internal_no_op;
                use bool as initialize;
            }
            pub mod take_step {
                use super::*;
            }
            #[verus::internal(verus_macro)]
            impl State {
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn wf(self) -> bool {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn seq_start(self) -> LSN {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn seq_end(self) -> LSN {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn unused_addr(self, addr: Address) -> bool {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn lbl_wf(lbl: Label) -> bool {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
            }
        }
    }
    pub mod LinkedJournalRefinement_v {
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        use vstd::prelude::*;
        use vstd::calc_macro::*;
        use crate::abstract_system::StampedMap_v::LSN;
        use crate::abstract_system::MsgHistory_v::*;
        use crate::disk::GenericDisk_v::*;
        use crate::journal::PagedJournal_v;
        use crate::journal::PagedJournal_v::PagedJournal;
        use crate::journal::LinkedJournal_v;
        use crate::journal::LinkedJournal_v::*;
        #[verus::internal(verus_macro)]
        impl DiskView {
            #[verus::internal(proof)]
            pub fn iptr_output_valid(self, ptr: Pointer) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verifier::spinoff_prover]
            #[verus::internal(proof)]
            pub fn discard_interp(self, lsn: LSN, post: Self, ptr: Pointer) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn sub_disk_ranking(self, big: DiskView) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn sub_disk_interp(self, big: DiskView, ptr: Pointer) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn pointer_after_crop_commutes_with_interpretation(self,
                ptr: Pointer, bdy: LSN, depth: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn pointer_after_crop_commutes_with_interpretation_no_some(self,
                ptr: Pointer, depth: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn discard_old_commutes(self, ptr: Pointer, new_bdy: LSN) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verifier::spinoff_prover]
            #[verus::internal(proof)]
            pub fn iptr_framing(self, dv2: Self, ptr: Pointer) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn build_tight_is_awesome(self, root: Pointer) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn build_tight_maintains_interpretation(self, root: Pointer) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        impl TruncatedJournal {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn next(self) -> Self {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> PagedJournal_v::TruncatedJournal {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn iwf(self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn mkfs_refines() {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn discard_old_decodable(self, new_bdy: LSN) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn discard_interp(self, lsn: LSN, post: Self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn discard_old_commutes(self, new_bdy: LSN) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn commute_transitivity<L,
                H>(I: ::builtin::FnSpec<(L,), H>,
                f: ::builtin::FnSpec<(L,), L>, F: ::builtin::FnSpec<(H,), H>,
                g: ::builtin::FnSpec<(L,), L>,
                G: ::builtin::FnSpec<(H,), H>) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn can_crop_monotonic(self, depth: nat, more: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn crop_decreases_seq_end(self, depth: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn linked_tj_can_crop_implies_paged_tj_can_crop(self,
                depth: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn paged_tj_can_crop_implies_linked_tj_can_crop(self,
                depth: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn crop_head_composed_with_discard_old_commutes(self,
                new_bdy: LSN, depth: nat) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        impl LinkedJournal::Label {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> PagedJournal::Label {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        impl LinkedJournal::State {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> PagedJournal::State {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn iwf(self) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn freeze_for_commit_refines(self, post: Self,
                lbl: LinkedJournal::Label, step: LinkedJournal::Step) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[doc =
            " NOTE(Jialin): temp creation just to expose submodule inv"]
            #[verus::internal(proof)]
            pub fn inv_next(self, post: Self, lbl: LinkedJournal::Label,
                step: LinkedJournal::Step) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn discard_old_refines(self, post: Self,
                lbl: LinkedJournal::Label, step: LinkedJournal::Step) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn next_refines(self, post: Self, lbl: LinkedJournal::Label) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
    }
    pub mod LikesJournal_v {
        #![allow(unused_imports)]
        use builtin::*;
        use vstd::prelude::*;
        use vstd::{map::*, multiset::*};
        use vstd::math;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        use crate::abstract_system::StampedMap_v::LSN;
        use crate::abstract_system::MsgHistory_v::*;
        use crate::journal::LinkedJournal_v;
        use crate::journal::LinkedJournal_v::TruncatedJournal;
        use crate::journal::LinkedJournal_v::DiskView;
        use crate::disk::GenericDisk_v::*;
        use crate::allocation_layer::Likes_v::*;
        #[verus::internal(verus_macro)]
        impl TruncatedJournal { }
        type LsnAddrIndex = Map<LSN, Address>;
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn lsn_disjoint(lsn_index: Set<LSN>, msgs: MsgHistory) -> bool {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn lsn_addr_index_discard_up_to(lsn_addr_index: LsnAddrIndex,
            bdy: LSN) -> LsnAddrIndex {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(proof)]
        pub fn lsn_addr_index_discard_up_to_ensures(lsn_addr_index:
                LsnAddrIndex, bdy: LSN) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn singleton_index(start: LSN, end: LSN, value: Address)
            -> LsnAddrIndex {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn lsn_addr_index_append_record(lsn_addr_index: LsnAddrIndex,
            msgs: MsgHistory, addr: Address) -> LsnAddrIndex {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(proof)]
        pub fn lsn_addr_index_append_record_ensures(lsn_addr_index:
                LsnAddrIndex, msgs: MsgHistory, addr: Address) {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(verus_macro)]
        impl DiskView {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn buildable(self, root: Pointer) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn build_lsn_addr_index(self, root: Pointer) -> LsnAddrIndex {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        impl DiskView {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn addr_supports_lsn(self, addr: Address, lsn: LSN) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn tj_at(self, root: Pointer) -> TruncatedJournal {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn build_lsn_addr_index_domain_valid(self, root: Pointer) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn build_tight_domain_is_build_lsn_addr_index_range(self,
                root: Pointer) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn sub_disk_repr_index(self, big: Self, ptr: Pointer) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn build_lsn_addr_all_decodable(self, root: Pointer) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn build_lsn_addr_honors_rank(self, root: Pointer,
                lsn_addr_index: Map<LSN, Address>) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn index_reflects_disk_view(self,
                lsn_addr_index: LsnAddrIndex) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn build_lsn_addr_index_reflects_disk_view(self,
                root: Pointer) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verifier::opaque]
            #[verus::internal(closed)]
            #[verus::internal(spec(checked))]
            pub fn index_keys_map_to_valid_entries(self,
                lsn_addr_index: LsnAddrIndex) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn instantiate_index_keys_map_to_valid_entries(self,
                lsn_addr_index: LsnAddrIndex, lsn: LSN) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn map_to_likes(lsn_addr_map: LsnAddrIndex) -> Likes {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(verus_macro)]
        impl TruncatedJournal {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn build_lsn_addr_index(self) -> LsnAddrIndex {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn transitive_likes(self) -> Likes {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn discard_old_cond(self, start_lsn: LSN,
                keep_addrs: Set<Address>, new: Self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        impl MsgHistory {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn tight_discard_old(self, new: Self, new_bdy: LSN) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[allow(unused_imports)]
        fn max() { ::core::panicking::panic("not implemented") }
        #[verus::internal(verus_macro)]
        impl TruncatedJournal {
            #[verifier::opaque]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn index_domain_valid(self, lsn_addr_index: LsnAddrIndex)
                -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            pub fn every_lsn_at_addr_indexed_to_addr(self,
                lsn_addr_index: LsnAddrIndex, addr: Address) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            pub fn index_range_valid(self, lsn_addr_index: LsnAddrIndex)
                -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn build_lsn_addr_honors_rank(self,
                lsn_addr_index: Map<LSN, Address>) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[allow(unused_parens)]
        pub mod LikesJournal {
            use super::*;
            #[verus::internal(verus_macro)]
            pub struct State {
                pub journal: LinkedJournal_v::LinkedJournal::State,
                pub lsn_addr_index: LsnAddrIndex,
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Step {
                read_for_recovery(nat),
                freeze_for_commit(nat),
                query_end_lsn(),
                put(LinkedJournal_v::LinkedJournal::State),
                discard_old(LinkedJournal_v::LinkedJournal::State),
                internal_journal_marshal(LSN, Address,
                    LinkedJournal_v::LinkedJournal::State),
                internal_no_op(),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Step {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_read_for_recovery(&self) -> bool {
                    ::builtin::is_variant(self, "read_for_recovery")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_read_for_recovery_0(self) -> nat {
                    ::builtin::get_variant_field(self, "read_for_recovery", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_freeze_for_commit(&self) -> bool {
                    ::builtin::is_variant(self, "freeze_for_commit")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_freeze_for_commit_0(self) -> nat {
                    ::builtin::get_variant_field(self, "freeze_for_commit", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_query_end_lsn(&self) -> bool {
                    ::builtin::is_variant(self, "query_end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_put(&self) -> bool {
                    ::builtin::is_variant(self, "put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_put_0(self)
                    -> LinkedJournal_v::LinkedJournal::State {
                    ::builtin::get_variant_field(self, "put", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_discard_old(&self) -> bool {
                    ::builtin::is_variant(self, "discard_old")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_discard_old_0(self)
                    -> LinkedJournal_v::LinkedJournal::State {
                    ::builtin::get_variant_field(self, "discard_old", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_internal_journal_marshal(&self) -> bool {
                    ::builtin::is_variant(self, "internal_journal_marshal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_journal_marshal_0(self) -> LSN {
                    ::builtin::get_variant_field(self,
                        "internal_journal_marshal", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_journal_marshal_1(self) -> Address {
                    ::builtin::get_variant_field(self,
                        "internal_journal_marshal", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_journal_marshal_2(self)
                    -> LinkedJournal_v::LinkedJournal::State {
                    ::builtin::get_variant_field(self,
                        "internal_journal_marshal", "2")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_internal_no_op(&self) -> bool {
                    ::builtin::is_variant(self, "internal_no_op")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Config {
                initialize(TruncatedJournal),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Config {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_initialize(&self) -> bool {
                    ::builtin::is_variant(self, "initialize")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_initialize_0(self) -> TruncatedJournal {
                    ::builtin::get_variant_field(self, "initialize", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[verus::internal(verus_macro)]
            pub enum Label {
                ReadForRecovery {
                    messages: MsgHistory,
                },
                FreezeForCommit {
                    frozen_journal: TruncatedJournal,
                },
                QueryEndLsn {
                    end_lsn: LSN,
                },
                Put {
                    messages: MsgHistory,
                },
                DiscardOld {
                    start_lsn: LSN,
                    require_end: LSN,
                },
                Internal {},
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Label {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_ReadForRecovery(&self) -> bool {
                    ::builtin::is_variant(self, "ReadForRecovery")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_ReadForRecovery_messages(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "ReadForRecovery",
                        "messages")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_FreezeForCommit(&self) -> bool {
                    ::builtin::is_variant(self, "FreezeForCommit")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_FreezeForCommit_frozen_journal(self)
                    -> TruncatedJournal {
                    ::builtin::get_variant_field(self, "FreezeForCommit",
                        "frozen_journal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_QueryEndLsn(&self) -> bool {
                    ::builtin::is_variant(self, "QueryEndLsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_QueryEndLsn_end_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "QueryEndLsn", "end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_Put(&self) -> bool {
                    ::builtin::is_variant(self, "Put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_Put_messages(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "Put", "messages")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_DiscardOld(&self) -> bool {
                    ::builtin::is_variant(self, "DiscardOld")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_DiscardOld_start_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "DiscardOld",
                        "start_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_DiscardOld_require_end(self) -> LSN {
                    ::builtin::get_variant_field(self, "DiscardOld",
                        "require_end")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_Internal(&self) -> bool {
                    ::builtin::is_variant(self, "Internal")
                }
            }
            pub mod show {
                use super::*;
                use bool as read_for_recovery;
                use bool as freeze_for_commit;
                use bool as query_end_lsn;
                use bool as put;
                use bool as discard_old;
                use bool as internal_journal_marshal;
                use bool as internal_no_op;
                use bool as initialize;
            }
            pub mod take_step {
                use super::*;
            }
            #[verus::internal(verus_macro)]
            impl State {
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn lbl_i(lbl: Label)
                    -> LinkedJournal_v::LinkedJournal::Label {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn wf(self) -> bool {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn transitive_likes(self) -> Likes {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn imperative_likes(self) -> Likes {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(proof)]
                pub fn discard_old_step_preserves_acyclicity(pre: Self,
                    post: Self, lbl: Label) {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(proof)]
                pub fn discard_old_step_preserves_index(pre: Self, post: Self,
                    lbl: Label) {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(proof)]
                pub fn discard_old_maintains_repr_index(pre: Self, post: Self,
                    lbl: Label) {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
            }
        }
    }
    pub mod LikesJournalRefinement_v {
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        use vstd::prelude::*;
        use crate::abstract_system::StampedMap_v::LSN;
        use crate::abstract_system::MsgHistory_v::*;
        use crate::disk::GenericDisk_v::*;
        use crate::journal::LinkedJournal_v;
        use crate::journal::LinkedJournal_v::{
            LinkedJournal, DiskView, TruncatedJournal,
        };
        use crate::journal::LikesJournal_v;
        use crate::journal::LikesJournal_v::*;
        #[verus::internal(verus_macro)]
        impl DiskView { }
        #[verus::internal(verus_macro)]
        impl LikesJournal::State {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn i(self) -> LinkedJournal::State {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn discard_old_refines(self, post: Self,
                lbl: LikesJournal::Label,
                new_journal: LinkedJournal_v::LinkedJournal::State) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn next_refines(self, post: Self, lbl: LikesJournal::Label) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
    }
}
mod disk {
    pub mod GenericDisk_v {
        //! This file contains types relating to generic disk addressing and referencing.
        #[allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        #[doc =
        " The `AU` type is the type for a unique allocation unit identifier (thus we use `nat`s)."]
        #[doc = " "]
        #[doc =
        " An Allocation Unit (AU) is the minimum disk unit the \"external\" (i.e.: top-level) allocator"]
        #[doc =
        " allocates to data structures like the Betree and Journal. Allocation Units"]
        #[doc =
        " are made up of contiguous disk sectors. AUs are specified as part of the"]
        #[doc =
        " Splinter implementation. The goal of having large allocation blocks is to"]
        #[doc =
        " amortize allocation costs efficiently for large amounts of data."]
        pub type AU = nat;
        #[doc =
        " A page index within an AU (disk pages, so for SSDs these are on the order of 4KB)."]
        pub type Page = nat;
        #[doc =
        " Returns the number of a disk pages in an Allocation Unit. Left as an uninterpreted function"]
        #[doc = " since it\'s implementation defined."]
        #[verus::internal(closed)]
        #[verus::internal(spec(checked))]
        pub fn page_count() -> nat {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[doc =
        " An Address specifies a specific disk address (i.e.: an address that identifies a disk sector (or whatever"]
        #[doc = " atomic addressing unit the disk in question uses))."]
        #[doc =
        " It does this by combining an AU index with a page index within the AU."]
        #[verus::internal(verus_macro)]
        pub struct Address {
            #[doc = " The Allocation Unit index this address resides within."]
            pub au: AU,
            #[doc =
            " Page index within AU for this address. In the range [0,page_count)."]
            pub page: Page,
        }
        #[verus::internal(verus_macro)]
        impl Address {
            #[doc = " Returns true iff this Address is well formed."]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[doc = " Returns the Address for the first page of this AU."]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn first_page(self) -> Address {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[doc =
            " Returns the previous Address in this AU (may not be well-formed)."]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn previous(self) -> Address {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[doc =
            " Returns the next Address in this AU (may not be well-formed)."]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn next(self) -> Address {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn first_page(ptr: Pointer) -> Pointer {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[doc =
        " Return the lowest of two addresses. Addresses are first compared by AU,"]
        #[doc = " then by Page index (if AUs match)."]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn min_addr(a: Address, b: Address) -> Address {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[doc =
        " Returns the set of AUs that the provided set of Addresses live in."]
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn to_aus(addrs: Set<Address>) -> Set<AU> {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[doc =
        " A Pointer is either an Address or None. (i.e.: we wrap Address with the semantics for"]
        #[doc =
        " \"NULL\" pointers). Used when certain data structures might have unallocated pointers."]
        pub type Pointer = Option<Address>;
        pub type Ranking = Map<Address, nat>;
    }
}
mod allocation_layer {
    pub mod MiniAllocator_v {
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use crate::disk::GenericDisk_v::*;
        #[verus::internal(verus_macro)]
        pub struct PageAllocator {
            pub observed: Set<Address>,
            pub reserved: Set<Address>,
            pub au: AU,
        }
        #[verus::internal(verus_macro)]
        impl PageAllocator {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn new(au: AU) -> Self {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_free_addr(self, addr: Address) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[doc = " get a stack reference"]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn reserve(self, addrs: Set<Address>) -> Self {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[doc = " done with / returns a stack reference "]
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn unreserve(self, addrs: Set<Address>) -> Self {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn observe(self, addrs: Set<Address>) -> Self {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn unobserve(self, addrs: Set<Address>) -> Self {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn unobserve_all(self) -> Self {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn free(self, addrs: Set<Address>) -> Self {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn has_no_observed_pages(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn has_no_outstanding_refs(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn all_pages_allocated(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn all_pages_free(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct MiniAllocator {
            pub allocs: Map<AU, PageAllocator>,
            pub curr: Option<AU>,
        }
        #[verus::internal(verus_macro)]
        impl MiniAllocator {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn empty() -> Self {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn add_aus(self, aus: Set<AU>) -> Self {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_remove(self, au: AU) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn not_observed_aus(self) -> Set<AU> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn can_allocate(self, addr: Address) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn allocate_and_observe(self, addr: Address) -> Self {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(proof)]
            pub fn allocate_and_observe_wf(self, addr: Address) {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn allocate(self, addr: Address) -> Self {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn prune(self, aus: Set<AU>) -> Self {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
    }
    pub mod Likes_v {
        #![allow(unused_imports)]
        use builtin::*;
        use vstd::prelude::*;
        use vstd::{map::*, multiset::*};
        use crate::disk::GenericDisk_v::*;
        pub type Likes = Multiset<Address>;
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn no_likes() -> Likes {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
        #[verus::internal(open)]
        #[verus::internal(spec(checked))]
        pub fn map_sum<T>(s: Map<T, Likes>) -> Likes {
            { { ::std::rt::begin_panic("explicit panic") } }
        }
    }
    pub mod AllocationJournal_v {
        #![allow(unused_imports)]
        use builtin::*;
        use vstd::prelude::*;
        use vstd::math;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        use vstd::prelude::*;
        use vstd::map::*;
        use crate::abstract_system::StampedMap_v::LSN;
        use crate::abstract_system::MsgHistory_v::*;
        use crate::disk::GenericDisk_v::*;
        use crate::disk::GenericDisk_v::AU;
        use crate::journal::LinkedJournal_v;
        use crate::journal::LinkedJournal_v::{
            DiskView, TruncatedJournal, LinkedJournal,
        };
        use crate::journal::LikesJournal_v;
        use crate::allocation_layer::MiniAllocator_v::*;
        #[verus::internal(verus_macro)]
        pub struct JournalImage {
            pub tj: TruncatedJournal,
            pub first: AU,
        }
        #[verus::internal(verus_macro)]
        impl JournalImage {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn accessible_aus(self) -> Set<AU> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn empty() -> Self {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[allow(unused_parens)]
        pub mod AllocationJournal {
            use super::*;
            #[verus::internal(verus_macro)]
            pub struct State {
                pub journal: LinkedJournal::State,
                pub lsn_au_index: Map<LSN, AU>,
                pub first: AU,
                pub mini_allocator: MiniAllocator,
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Step {
                read_for_recovery(),
                freeze_for_commit(),
                query_end_lsn(),
                put(LinkedJournal_v::LinkedJournal::State),
                discard_old(LinkedJournal::State),
                internal_journal_marshal(LSN, Address, LinkedJournal::State),
                internal_mini_allocator_fill(),
                internal_mini_allocator_prune(),
                internal_no_op(),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Step {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_read_for_recovery(&self) -> bool {
                    ::builtin::is_variant(self, "read_for_recovery")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_freeze_for_commit(&self) -> bool {
                    ::builtin::is_variant(self, "freeze_for_commit")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_query_end_lsn(&self) -> bool {
                    ::builtin::is_variant(self, "query_end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_put(&self) -> bool {
                    ::builtin::is_variant(self, "put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_put_0(self)
                    -> LinkedJournal_v::LinkedJournal::State {
                    ::builtin::get_variant_field(self, "put", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_discard_old(&self) -> bool {
                    ::builtin::is_variant(self, "discard_old")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_discard_old_0(self) -> LinkedJournal::State {
                    ::builtin::get_variant_field(self, "discard_old", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_internal_journal_marshal(&self) -> bool {
                    ::builtin::is_variant(self, "internal_journal_marshal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_journal_marshal_0(self) -> LSN {
                    ::builtin::get_variant_field(self,
                        "internal_journal_marshal", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_journal_marshal_1(self) -> Address {
                    ::builtin::get_variant_field(self,
                        "internal_journal_marshal", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_journal_marshal_2(self)
                    -> LinkedJournal::State {
                    ::builtin::get_variant_field(self,
                        "internal_journal_marshal", "2")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_internal_mini_allocator_fill(&self) -> bool {
                    ::builtin::is_variant(self, "internal_mini_allocator_fill")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_internal_mini_allocator_prune(&self) -> bool {
                    ::builtin::is_variant(self, "internal_mini_allocator_prune")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_internal_no_op(&self) -> bool {
                    ::builtin::is_variant(self, "internal_no_op")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Config {
                initialize(LinkedJournal::State, JournalImage),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Config {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_initialize(&self) -> bool {
                    ::builtin::is_variant(self, "initialize")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_initialize_0(self) -> LinkedJournal::State {
                    ::builtin::get_variant_field(self, "initialize", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_initialize_1(self) -> JournalImage {
                    ::builtin::get_variant_field(self, "initialize", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[verus::internal(verus_macro)]
            pub enum Label {
                ReadForRecovery {
                    messages: MsgHistory,
                },
                FreezeForCommit {
                    frozen_journal: JournalImage,
                },
                QueryEndLsn {
                    end_lsn: LSN,
                },
                Put {
                    messages: MsgHistory,
                },
                DiscardOld {
                    start_lsn: LSN,
                    require_end: LSN,
                    deallocs: Set<AU>,
                },
                InternalAllocations {
                    allocs: Set<AU>,
                    deallocs: Set<AU>,
                },
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Label {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_ReadForRecovery(&self) -> bool {
                    ::builtin::is_variant(self, "ReadForRecovery")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_ReadForRecovery_messages(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "ReadForRecovery",
                        "messages")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_FreezeForCommit(&self) -> bool {
                    ::builtin::is_variant(self, "FreezeForCommit")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_FreezeForCommit_frozen_journal(self)
                    -> JournalImage {
                    ::builtin::get_variant_field(self, "FreezeForCommit",
                        "frozen_journal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_QueryEndLsn(&self) -> bool {
                    ::builtin::is_variant(self, "QueryEndLsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_QueryEndLsn_end_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "QueryEndLsn", "end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_Put(&self) -> bool {
                    ::builtin::is_variant(self, "Put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_Put_messages(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "Put", "messages")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_DiscardOld(&self) -> bool {
                    ::builtin::is_variant(self, "DiscardOld")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_DiscardOld_start_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "DiscardOld",
                        "start_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_DiscardOld_require_end(self) -> LSN {
                    ::builtin::get_variant_field(self, "DiscardOld",
                        "require_end")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_DiscardOld_deallocs(self) -> Set<AU> {
                    ::builtin::get_variant_field(self, "DiscardOld", "deallocs")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_InternalAllocations(&self) -> bool {
                    ::builtin::is_variant(self, "InternalAllocations")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_InternalAllocations_allocs(self) -> Set<AU> {
                    ::builtin::get_variant_field(self, "InternalAllocations",
                        "allocs")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_InternalAllocations_deallocs(self) -> Set<AU> {
                    ::builtin::get_variant_field(self, "InternalAllocations",
                        "deallocs")
                }
            }
            pub mod show {
                use super::*;
                use bool as read_for_recovery;
                use bool as freeze_for_commit;
                use bool as query_end_lsn;
                use bool as put;
                use bool as discard_old;
                use bool as internal_journal_marshal;
                use bool as internal_mini_allocator_fill;
                use bool as internal_mini_allocator_prune;
                use bool as internal_no_op;
                use bool as initialize;
            }
            pub mod take_step {
                use super::*;
            }
            #[verus::internal(verus_macro)]
            impl State {
                #[verus::internal(closed)]
                #[verus::internal(spec(checked))]
                pub fn lbl_wf(lbl: Label) -> bool {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn linked_lbl(lbl: Label) -> LinkedJournal::Label {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn wf(self) -> bool {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn accessible_aus(self) -> Set<AU> {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn new_first(tj: TruncatedJournal,
                    lsn_au_index: Map<LSN, AU>, old_first: AU, new_bdy: LSN)
                    -> AU {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn lsn_au_index_discarding_up_to(lsn_au_index:
                        Map<LSN, AU>, bdy: LSN) -> Map<LSN, AU> {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn singleton_index(start_lsn: LSN, end_lsn: LSN,
                    value: AU) -> Map<LSN, AU> {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn lsn_au_index_append_record(lsn_au_index: Map<LSN, AU>,
                    msgs: MsgHistory, au: AU) -> Map<LSN, AU> {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn valid_next_journal_addr(mini_allocator: MiniAllocator,
                    freshest_rec: Pointer, addr: Address) -> bool {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn build_lsn_au_index_page_walk(dv: DiskView,
                    root: Pointer) -> Map<LSN, AU> {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(proof)]
                pub fn build_lsn_au_index_page_walk_domain(dv: DiskView,
                    root: Pointer) {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(proof)]
                pub fn build_commutes_over_discard_page_walk(dv: DiskView,
                    root: Pointer, new_bdy: LSN) {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(proof)]
                pub fn build_lsn_au_index_page_walk_sub_disk(small: DiskView,
                    big: DiskView, root: Pointer) {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(proof)]
                pub fn build_commutes_over_append_record(dv: DiskView,
                    root: Pointer, msgs: MsgHistory, new_addr: Address) {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(proof)]
                pub fn build_lsn_au_index_equiv_page_walk(dv: DiskView,
                    root: Pointer, first: AU) {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(proof)]
                pub fn build_commutes_over_discard(dv: DiskView,
                    root: Pointer, old_first: AU, new_bdy: LSN) {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn upstream(dv: DiskView, addr: Address) -> bool {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn nonzero_pages_point_backward(dv: DiskView) -> bool {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verifier::opaque]
                #[verus::internal(closed)]
                #[verus::internal(spec(checked))]
                pub fn pages_allocated_in_lsn_order(dv: DiskView) -> bool {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn internal_au_pages_fully_linked(dv: DiskView) -> bool {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(proof)]
                pub fn nonfirst_properties(dv: DiskView, root: Pointer,
                    first: AU) {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(proof)]
                pub fn transitive_ranking(dv: LinkedJournal_v::DiskView,
                    root: Address, later: Address, first: AU) {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn pointer_is_upstream(dv: DiskView, root: Pointer,
                    first: AU) -> bool {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(proof)]
                pub fn bottom_properties(dv: DiskView, root: Pointer,
                    first: AU) {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verifier::decreases_by]
                #[verus::internal(proof)]
                pub fn build_lsn_au_index_au_walk_helper(dv: DiskView,
                    root: Pointer, first: AU) {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn build_lsn_au_index_au_walk(dv: DiskView, root: Pointer,
                    first: AU) -> Map<LSN, AU> {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verifier::recommends_by]
                #[verus::internal(proof)]
                pub fn build_lsn_au_index_helper(tj: TruncatedJournal,
                    first: AU) {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn build_lsn_au_index(tj: TruncatedJournal, first: AU)
                    -> Map<LSN, AU> {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn wf_addrs(dv: DiskView) -> bool {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn valid_first_au(dv: DiskView, first: AU) -> bool {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn valid_journal_image(image: JournalImage) -> bool {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn journal_pages_not_free(addrs: Set<Address>,
                    allocator: MiniAllocator) -> bool {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn mini_allocator_follows_freshest_rec(freshest_rec:
                        Pointer, allocator: MiniAllocator) -> bool {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn tj(self) -> TruncatedJournal {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn contiguous_lsns(lsn_au_index: Map<LSN, AU>, lsn1: LSN,
                    lsn2: LSN, lsn3: LSN) -> bool {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn aus_hold_contiguous_lsns(lsn_au_index: Map<LSN, AU>)
                    -> bool {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(closed)]
                #[verus::internal(spec(checked))]
                pub fn index_honors_rank(dv: DiskView, root: Pointer,
                    first: AU, au_index: Map<LSN, AU>) -> bool {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn au_domain_valid(dv: DiskView, root: Pointer,
                    lsn_au_index: Map<LSN, AU>) -> bool {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(proof)]
                pub fn nonfirst_pages(dv: DiskView, addr: Address,
                    first: AU) {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(proof)]
                pub fn build_lsn_addr_index_returns_upstream_pages(dv:
                        DiskView, root: Pointer, first: AU) {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(proof)]
                pub fn upstream_pages(dv: DiskView, earlier: Address,
                    later: Address, first: AU) {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(proof)]
                pub fn lemma_next_au_doesnt_intersect(dv: DiskView,
                    root: Pointer, first: AU, prior_result: Map<LSN, AU>) {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(proof)]
                pub fn au_index_page_supports_lsn(dv: DiskView, root: Pointer,
                    lsn: LSN) {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(proof)]
                pub fn first_contains_boundary(dv: DiskView, root: Pointer,
                    first: AU) {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(proof)]
                pub fn lemma_aus_hold_contiguous_lsns_first_page(dv: DiskView,
                    root: Pointer, first: AU) {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(proof)]
                pub fn lemma_aus_hold_contiguous_lsns_inner(dv: DiskView,
                    root: Pointer, first: AU) {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(proof)]
                pub fn lemma_aus_hold_contiguous_lsns(image: JournalImage) {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn has_unique_lsns(dv: DiskView) -> bool {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(proof)]
                pub fn invoke_submodule_inv(pre: Self, post: Self) {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verifier::spinoff_prover]
                #[verus::internal(proof)]
                pub fn discard_old_helper4(pre: Self, post: Self, lbl: Label,
                    post_journal: LinkedJournal::State, xaddr: Address,
                    zaddr: Address) {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(proof)]
                pub fn discard_old_accessible_aus(pre: Self, post: Self,
                    lbl: Label) {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
            }
        }
    }
    pub mod AllocationJournalRefinement_v {}
    pub mod AllocationCrashAwareJournal_v {
        #![allow(unused_imports)]
        use builtin::*;
        use vstd::prelude::*;
        use vstd::math;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        use vstd::prelude::*;
        use vstd::map::*;
        use vstd::map_lib::*;
        use crate::abstract_system::StampedMap_v::LSN;
        use crate::abstract_system::MsgHistory_v::*;
        use crate::disk::GenericDisk_v::*;
        use crate::disk::GenericDisk_v::AU;
        use crate::allocation_layer::AllocationJournal_v::*;
        use crate::allocation_layer::MiniAllocator_v::*;
        use crate::journal::LinkedJournal_v;
        use crate::journal::LikesJournal_v::*;
        pub type StoreImage = JournalImage;
        #[verus::internal(verus_macro)]
        pub enum Ephemeral {
            Unknown,
            Known {
                v: AllocationJournal::State,
            },
        }
        #[verus::internal(verus_macro)]
        #[cfg(verus_keep_ghost)]
        #[automatically_derived]
        impl Ephemeral {
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_Unknown(&self) -> bool {
                ::builtin::is_variant(self, "Unknown")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_Known(&self) -> bool {
                ::builtin::is_variant(self, "Known")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_Known_v(self) -> AllocationJournal::State {
                ::builtin::get_variant_field(self, "Known", "v")
            }
        }
        #[verus::internal(verus_macro)]
        impl Ephemeral {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[allow(unused_parens)]
        pub mod AllocationCrashAwareJournal {
            use super::*;
            #[verus::internal(verus_macro)]
            pub struct State {
                pub persistent: StoreImage,
                pub ephemeral: Ephemeral,
                pub inflight: Option<StoreImage>,
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Step {
                load_ephemeral_from_persistent(AllocationJournal::State,
                    AllocationJournal::Config),
                read_for_recovery(),
                query_end_lsn(),
                put(AllocationJournal::State),
                internal(AllocationJournal::State),
                query_lsn_persistence(),
                commit_start(StoreImage),
                commit_complete(AllocationJournal::State),
                crash(),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Step {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_load_ephemeral_from_persistent(&self) -> bool {
                    ::builtin::is_variant(self,
                        "load_ephemeral_from_persistent")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_load_ephemeral_from_persistent_0(self)
                    -> AllocationJournal::State {
                    ::builtin::get_variant_field(self,
                        "load_ephemeral_from_persistent", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_load_ephemeral_from_persistent_1(self)
                    -> AllocationJournal::Config {
                    ::builtin::get_variant_field(self,
                        "load_ephemeral_from_persistent", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_read_for_recovery(&self) -> bool {
                    ::builtin::is_variant(self, "read_for_recovery")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_query_end_lsn(&self) -> bool {
                    ::builtin::is_variant(self, "query_end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_put(&self) -> bool {
                    ::builtin::is_variant(self, "put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_put_0(self) -> AllocationJournal::State {
                    ::builtin::get_variant_field(self, "put", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_internal(&self) -> bool {
                    ::builtin::is_variant(self, "internal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_0(self) -> AllocationJournal::State {
                    ::builtin::get_variant_field(self, "internal", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_query_lsn_persistence(&self) -> bool {
                    ::builtin::is_variant(self, "query_lsn_persistence")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_commit_start(&self) -> bool {
                    ::builtin::is_variant(self, "commit_start")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_commit_start_0(self) -> StoreImage {
                    ::builtin::get_variant_field(self, "commit_start", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_commit_complete(&self) -> bool {
                    ::builtin::is_variant(self, "commit_complete")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_commit_complete_0(self)
                    -> AllocationJournal::State {
                    ::builtin::get_variant_field(self, "commit_complete", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_crash(&self) -> bool {
                    ::builtin::is_variant(self, "crash")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Config { initialize(), dummy_to_use_type_params(State), }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Config {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_initialize(&self) -> bool {
                    ::builtin::is_variant(self, "initialize")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[verus::internal(verus_macro)]
            pub enum Label {
                LoadEphemeralFromPersistent,
                ReadForRecovery {
                    records: MsgHistory,
                },
                QueryEndLsn {
                    end_lsn: LSN,
                },
                Put {
                    records: MsgHistory,
                },
                Internal {
                    allocs: Set<AU>,
                    deallocs: Set<AU>,
                },
                QueryLsnPersistence {
                    sync_lsn: LSN,
                },
                CommitStart {
                    new_boundary_lsn: LSN,
                    max_lsn: LSN,
                },
                CommitComplete {
                    require_end: LSN,
                    discarded: Set<AU>,
                },
                Crash,
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Label {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_LoadEphemeralFromPersistent(&self) -> bool {
                    ::builtin::is_variant(self, "LoadEphemeralFromPersistent")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_ReadForRecovery(&self) -> bool {
                    ::builtin::is_variant(self, "ReadForRecovery")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_ReadForRecovery_records(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "ReadForRecovery",
                        "records")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_QueryEndLsn(&self) -> bool {
                    ::builtin::is_variant(self, "QueryEndLsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_QueryEndLsn_end_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "QueryEndLsn", "end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_Put(&self) -> bool {
                    ::builtin::is_variant(self, "Put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_Put_records(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "Put", "records")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_Internal(&self) -> bool {
                    ::builtin::is_variant(self, "Internal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_Internal_allocs(self) -> Set<AU> {
                    ::builtin::get_variant_field(self, "Internal", "allocs")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_Internal_deallocs(self) -> Set<AU> {
                    ::builtin::get_variant_field(self, "Internal", "deallocs")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_QueryLsnPersistence(&self) -> bool {
                    ::builtin::is_variant(self, "QueryLsnPersistence")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_QueryLsnPersistence_sync_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "QueryLsnPersistence",
                        "sync_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_CommitStart(&self) -> bool {
                    ::builtin::is_variant(self, "CommitStart")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_CommitStart_new_boundary_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "CommitStart",
                        "new_boundary_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_CommitStart_max_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "CommitStart", "max_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_CommitComplete(&self) -> bool {
                    ::builtin::is_variant(self, "CommitComplete")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_CommitComplete_require_end(self) -> LSN {
                    ::builtin::get_variant_field(self, "CommitComplete",
                        "require_end")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_CommitComplete_discarded(self) -> Set<AU> {
                    ::builtin::get_variant_field(self, "CommitComplete",
                        "discarded")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_Crash(&self) -> bool {
                    ::builtin::is_variant(self, "Crash")
                }
            }
            pub mod show {
                use super::*;
                use bool as load_ephemeral_from_persistent;
                use bool as read_for_recovery;
                use bool as query_end_lsn;
                use bool as put;
                use bool as internal;
                use bool as query_lsn_persistence;
                use bool as commit_start;
                use bool as commit_complete;
                use bool as crash;
                use bool as initialize;
            }
            pub mod take_step {
                use super::*;
            }
            #[verus::internal(verus_macro)]
            impl State {
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn fresh_label(self, lbl: Label) -> bool {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn state_relations(self) -> bool {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
                #[verus::internal(open)]
                #[verus::internal(spec(checked))]
                pub fn journal_pages_not_free(self) -> bool {
                    { { ::std::rt::begin_panic("explicit panic") } }
                }
            }
        }
    }
    pub mod UnifiedCrashAwareJournal_v {
        #![allow(unused_imports)]
        use builtin::*;
        use vstd::prelude::*;
        use vstd::math;
        use builtin_macros::*;
        use state_machines_macros::state_machine;
        use vstd::prelude::*;
        use vstd::map::*;
        use vstd::map_lib::*;
        use crate::abstract_system::StampedMap_v::LSN;
        use crate::abstract_system::MsgHistory_v::*;
        use crate::disk::GenericDisk_v::*;
        use crate::disk::GenericDisk_v::AU;
        use crate::journal::LinkedJournal_v;
        use crate::journal::LinkedJournal_v::LinkedJournal;
        use crate::journal::LinkedJournal_v::JournalRecord;
        use crate::allocation_layer::AllocationJournal_v::*;
        use crate::allocation_layer::MiniAllocator_v::*;
        pub type JournalDiskView = LinkedJournal_v::DiskView;
        #[verus::internal(verus_macro)]
        pub struct ImageState {
            pub freshest_rec: Pointer,
            pub boundary_lsn: LSN,
            pub first: AU,
        }
        #[verus::internal(verus_macro)]
        impl ImageState {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn empty() -> Self {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn dom(self, dv: DiskView) -> Set<Address> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self, dv: DiskView) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn valid_image(self, dv: DiskView) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn to_tj(self, dv: DiskView)
                -> LinkedJournal_v::TruncatedJournal {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn seq_start(self) -> LSN {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn seq_end(self, dv: DiskView) -> LSN {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct EphemeralState {
            pub image: ImageState,
            pub unmarshalled_tail: MsgHistory,
            pub lsn_au_index: Map<LSN, AU>,
            pub mini_allocator: MiniAllocator,
        }
        #[verus::internal(verus_macro)]
        impl EphemeralState {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn init_by(self, image: ImageState, dv: DiskView) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn wf(self, dv: DiskView) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn decodable(self, dv: DiskView) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn to_lj(self, dv: DiskView) -> LinkedJournal::State {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn same_except_lj(self, new_state: Self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_marshalled_state(self, dv: DiskView, allocs: Set<AU>,
                deallocs: Set<AU>, cut: LSN, addr: Address, new_state: Self,
                new_dv: DiskView) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_allocator_fill(self, dv: DiskView, allocs: Set<AU>,
                deallocs: Set<AU>, new_state: Self, new_dv: DiskView)
                -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_allocator_prune(self, dv: DiskView, allocs: Set<AU>,
                deallocs: Set<AU>, new_state: Self, new_dv: DiskView)
                -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_no_op(self, dv: DiskView, allocs: Set<AU>,
                deallocs: Set<AU>, new_state: Self, new_dv: DiskView)
                -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_internal_op(self, dv: DiskView, allocs: Set<AU>,
                deallocs: Set<AU>, new_state: Self, new_dv: DiskView)
                -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        pub enum Ephemeral {
            Unknown,
            Known {
                v: EphemeralState,
            },
        }
        #[verus::internal(verus_macro)]
        #[cfg(verus_keep_ghost)]
        #[automatically_derived]
        impl Ephemeral {
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_Unknown(&self) -> bool {
                ::builtin::is_variant(self, "Unknown")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn is_Known(&self) -> bool {
                ::builtin::is_variant(self, "Known")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn get_Known_v(self) -> EphemeralState {
                ::builtin::get_variant_field(self, "Known", "v")
            }
        }
        #[verus::internal(verus_macro)]
        pub struct DiskView {
            pub entries: Map<Address, JournalRecord>,
        }
        #[verus::internal(verus_macro)]
        impl DiskView {
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn to_JournalDiskView(self, boundary_lsn: LSN)
                -> JournalDiskView {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn entries_wf(self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn is_nondangling_pointer(self, ptr: Pointer) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec(checked))]
            pub fn nondangling_pointers(self, boundary_lsn: LSN,
                dom: Set<Address>) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[allow(unused_parens)]
        pub mod UnifiedCrashAwareJournal {
            use super::*;
            #[verus::internal(verus_macro)]
            pub struct State {
                pub ephemeral: Ephemeral,
                pub persistent: ImageState,
                pub inflight: Option<ImageState>,
                pub dv: DiskView,
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Step {
                load_ephemeral_from_persistent(EphemeralState),
                read_for_recovery(),
                query_end_lsn(),
                put(EphemeralState),
                internal(EphemeralState, DiskView),
                query_lsn_persistence(),
                commit_start(ImageState, DiskView),
                commit_complete(EphemeralState, DiskView),
                crash(),
                dummy_to_use_type_params(State),
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Step {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_load_ephemeral_from_persistent(&self) -> bool {
                    ::builtin::is_variant(self,
                        "load_ephemeral_from_persistent")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_load_ephemeral_from_persistent_0(self)
                    -> EphemeralState {
                    ::builtin::get_variant_field(self,
                        "load_ephemeral_from_persistent", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_read_for_recovery(&self) -> bool {
                    ::builtin::is_variant(self, "read_for_recovery")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_query_end_lsn(&self) -> bool {
                    ::builtin::is_variant(self, "query_end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_put(&self) -> bool {
                    ::builtin::is_variant(self, "put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_put_0(self) -> EphemeralState {
                    ::builtin::get_variant_field(self, "put", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_internal(&self) -> bool {
                    ::builtin::is_variant(self, "internal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_0(self) -> EphemeralState {
                    ::builtin::get_variant_field(self, "internal", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_internal_1(self) -> DiskView {
                    ::builtin::get_variant_field(self, "internal", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_query_lsn_persistence(&self) -> bool {
                    ::builtin::is_variant(self, "query_lsn_persistence")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_commit_start(&self) -> bool {
                    ::builtin::is_variant(self, "commit_start")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_commit_start_0(self) -> ImageState {
                    ::builtin::get_variant_field(self, "commit_start", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_commit_start_1(self) -> DiskView {
                    ::builtin::get_variant_field(self, "commit_start", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_commit_complete(&self) -> bool {
                    ::builtin::is_variant(self, "commit_complete")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_commit_complete_0(self) -> EphemeralState {
                    ::builtin::get_variant_field(self, "commit_complete", "0")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_commit_complete_1(self) -> DiskView {
                    ::builtin::get_variant_field(self, "commit_complete", "1")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_crash(&self) -> bool {
                    ::builtin::is_variant(self, "crash")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[allow(non_camel_case_types)]
            #[verus::internal(verus_macro)]
            pub enum Config { initialize(), dummy_to_use_type_params(State), }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Config {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_initialize(&self) -> bool {
                    ::builtin::is_variant(self, "initialize")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_dummy_to_use_type_params(&self) -> bool {
                    ::builtin::is_variant(self, "dummy_to_use_type_params")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_dummy_to_use_type_params_0(self) -> State {
                    ::builtin::get_variant_field(self,
                        "dummy_to_use_type_params", "0")
                }
            }
            #[verus::internal(verus_macro)]
            pub enum Label {
                LoadEphemeralFromPersistent,
                ReadForRecovery {
                    records: MsgHistory,
                },
                QueryEndLsn {
                    end_lsn: LSN,
                },
                Put {
                    records: MsgHistory,
                },
                Internal {
                    allocs: Set<AU>,
                    deallocs: Set<AU>,
                },
                QueryLsnPersistence {
                    sync_lsn: LSN,
                },
                CommitStart {
                    new_boundary_lsn: LSN,
                    max_lsn: LSN,
                },
                CommitComplete {
                    require_end: LSN,
                    discarded: Set<AU>,
                },
                Crash,
            }
            #[verus::internal(verus_macro)]
            #[cfg(verus_keep_ghost)]
            #[automatically_derived]
            impl Label {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_LoadEphemeralFromPersistent(&self) -> bool {
                    ::builtin::is_variant(self, "LoadEphemeralFromPersistent")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_ReadForRecovery(&self) -> bool {
                    ::builtin::is_variant(self, "ReadForRecovery")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_ReadForRecovery_records(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "ReadForRecovery",
                        "records")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_QueryEndLsn(&self) -> bool {
                    ::builtin::is_variant(self, "QueryEndLsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_QueryEndLsn_end_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "QueryEndLsn", "end_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_Put(&self) -> bool {
                    ::builtin::is_variant(self, "Put")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_Put_records(self) -> MsgHistory {
                    ::builtin::get_variant_field(self, "Put", "records")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_Internal(&self) -> bool {
                    ::builtin::is_variant(self, "Internal")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_Internal_allocs(self) -> Set<AU> {
                    ::builtin::get_variant_field(self, "Internal", "allocs")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_Internal_deallocs(self) -> Set<AU> {
                    ::builtin::get_variant_field(self, "Internal", "deallocs")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_QueryLsnPersistence(&self) -> bool {
                    ::builtin::is_variant(self, "QueryLsnPersistence")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_QueryLsnPersistence_sync_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "QueryLsnPersistence",
                        "sync_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_CommitStart(&self) -> bool {
                    ::builtin::is_variant(self, "CommitStart")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_CommitStart_new_boundary_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "CommitStart",
                        "new_boundary_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_CommitStart_max_lsn(self) -> LSN {
                    ::builtin::get_variant_field(self, "CommitStart", "max_lsn")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_CommitComplete(&self) -> bool {
                    ::builtin::is_variant(self, "CommitComplete")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_CommitComplete_require_end(self) -> LSN {
                    ::builtin::get_variant_field(self, "CommitComplete",
                        "require_end")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn get_CommitComplete_discarded(self) -> Set<AU> {
                    ::builtin::get_variant_field(self, "CommitComplete",
                        "discarded")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub fn is_Crash(&self) -> bool {
                    ::builtin::is_variant(self, "Crash")
                }
            }
            pub mod show {
                use super::*;
                use bool as load_ephemeral_from_persistent;
                use bool as read_for_recovery;
                use bool as query_end_lsn;
                use bool as put;
                use bool as internal;
                use bool as query_lsn_persistence;
                use bool as commit_start;
                use bool as commit_complete;
                use bool as crash;
                use bool as initialize;
            }
            pub mod take_step {
                use super::*;
            }
            #[verus::internal(verus_macro)]
            impl State { }
        }
    }
}
mod marshalling {
    pub mod Slice_v {
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        #[verus::internal(verus_macro)]
        pub struct Slice {
            pub start: u64,
            pub end: u64,
        }
        #[verus::internal(verus_macro)]
        impl Slice {
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn valid<T>(&self, data: Seq<T>) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn i<T>(&self, data: Seq<T>) -> Seq<T> {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn all<T>(data: Seq<T>) -> Slice {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
    }
    pub mod MarshalledAccessors_v {
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use vstd::bytes::*;
        use vstd::slice::*;
        use crate::marshalling::Slice_v::*;
        #[verus::internal(verus_macro)]
        trait Config {
            #[verus::internal(spec)]
            fn valid(&self)
            -> bool;
        }
        #[verus::internal(verus_macro)]
        trait Marshalling<C: Config, U> {
            #[verus::internal(spec)]
            fn parsable(cfg: &C, data: Seq<u8>)
            -> bool;
            #[verus::internal(spec)]
            fn parse(cfg: &C, data: Seq<u8>)
            -> U;
            fn try_parse(cfg: &C, data: &Vec<u8>)
            -> Option<U>;
            fn exec_parsable(cfg: &C, data: &Vec<u8>)
            -> bool;
            #[verus::internal(spec)]
            fn marshallable(cfg: &C, value: &U)
            -> bool;
            #[verus::internal(spec)]
            fn size(cfg: &C, value: &U)
            -> u64;
            fn exec_size(cfg: &C, value: &U)
            -> u64;
            fn marshall(cfg: &C, value: &U, data: &mut Vec<u8>, start: u64)
            -> u64;
        }
        #[verus::internal(verus_macro)]
        struct DefaultConfig {}
        #[verus::internal(verus_macro)]
        impl Config for DefaultConfig {
            #[verus::internal(spec)]
            fn valid(&self) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
        }
        #[verus::internal(verus_macro)]
        struct IntegerMarshalling {}
        #[verus::internal(verus_macro)]
        impl Marshalling<DefaultConfig, u64> for IntegerMarshalling {
            #[verus::internal(spec)]
            fn parsable(cfg: &DefaultConfig, data: Seq<u8>) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(spec)]
            fn parse(cfg: &DefaultConfig, data: Seq<u8>) -> u64 {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            fn try_parse(cfg: &DefaultConfig, data: &Vec<u8>) -> Option<u64> {
                if 8 <= data.len() {
                        Some(u64_from_le_bytes(slice_subrange(data.as_slice(), 0,
                                    8)))
                    } else { None }
            }
            fn exec_parsable(cfg: &DefaultConfig, data: &Vec<u8>) -> bool {
                8 <= data.len()
            }
            #[verus::internal(spec)]
            fn marshallable(cfg: &DefaultConfig, value: &u64) -> bool {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            #[verus::internal(spec)]
            fn size(cfg: &DefaultConfig, value: &u64) -> u64 {
                { { ::std::rt::begin_panic("explicit panic") } }
            }
            fn exec_size(cfg: &DefaultConfig, value: &u64) -> u64 { 8 }
            fn marshall(cfg: &DefaultConfig, value: &u64, data: &mut Vec<u8>,
                start: u64) -> u64 {
                let s = u64_to_le_bytes(*value);
                {}
                {};
                let end = start + 8;
                let mut k: usize = 0;
                while k < 8 { data.set(start as usize + k, s[k]); k += 1; }
                {};
                end
            }
        }
        #[verus::internal(verus_macro)]
        trait SeqMarshalling<C: Config, U,
            Elt: Marshalling<C, U>>: Marshalling<DefaultConfig, Vec<U>> {
            #[verus::internal(spec)]
            fn spec_elt_cfg(cfg: &DefaultConfig)
            -> C;
            #[verus::internal(proof)]
            fn spec_elt_cfg_ensures(cfg: &DefaultConfig)
            -> C;
            #[verus::internal(spec)]
            fn lengthable(cfg: &DefaultConfig, data: Seq<u8>)
            -> bool;
            #[verus::internal(spec)]
            fn length(cfg: &DefaultConfig, data: Seq<u8>)
            -> int;
            fn try_length(cfg: &DefaultConfig, data: &Vec<u8>)
            -> Option<u64>;
            #[verus::internal(spec)]
            fn gettable(cfg: &DefaultConfig, data: Seq<u8>, idx: int)
            -> bool;
            #[verus::internal(spec)]
            fn get(cfg: &DefaultConfig, slice: Slice, data: Seq<u8>, idx: int)
            -> Slice;
            #[verus::internal(proof)]
            fn get_ensures(cfg: &DefaultConfig, slice: Slice, data: Seq<u8>,
            idx: int);
            #[verus::internal(spec)]
            fn get_data(cfg: &DefaultConfig, slice: Slice, data: Seq<u8>,
            idx: int)
            -> Seq<u8>;
            #[verus::internal(spec)]
            fn elt_parsable(cfg: &DefaultConfig, data: Seq<u8>, idx: int)
            -> bool;
            #[verus::internal(spec)]
            fn get_elt(cfg: &DefaultConfig, slice: Slice, data: Seq<u8>,
            idx: int)
            -> Elt;
            fn try_get(cfg: &DefaultConfig, slice: Slice, data: Seq<u8>,
            idx: int)
            -> Option<Slice>;
            fn try_get_elt(cfg: &DefaultConfig, slice: Slice, data: Seq<u8>,
            idx: int)
            -> Option<Elt>;
            #[verus::internal(spec)]
            fn settable(cfg: &DefaultConfig, data: Seq<u8>, idx: int,
            value: U);
        }
    }
}
fn main() {}
